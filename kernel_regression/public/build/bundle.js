
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$5() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function empty$3() {
        return text$1('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$5,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$5;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.40.2' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$5) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$5) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$5;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const toString$1 = Object.prototype.toString;

    function isAnyArray(object) {
      return toString$1.call(object).endsWith('Array]');
    }

    function max$4(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isAnyArray(input)) {
        throw new TypeError('input must be an array');
      }

      if (input.length === 0) {
        throw new TypeError('input must not be empty');
      }

      var _options$fromIndex = options.fromIndex,
          fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
          _options$toIndex = options.toIndex,
          toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

      if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error('fromIndex must be a positive integer smaller than length');
      }

      if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
      }

      var maxValue = input[fromIndex];

      for (var i = fromIndex + 1; i < toIndex; i++) {
        if (input[i] > maxValue) maxValue = input[i];
      }

      return maxValue;
    }

    function min$3(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isAnyArray(input)) {
        throw new TypeError('input must be an array');
      }

      if (input.length === 0) {
        throw new TypeError('input must not be empty');
      }

      var _options$fromIndex = options.fromIndex,
          fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
          _options$toIndex = options.toIndex,
          toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

      if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error('fromIndex must be a positive integer smaller than length');
      }

      if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
      }

      var minValue = input[fromIndex];

      for (var i = fromIndex + 1; i < toIndex; i++) {
        if (input[i] < minValue) minValue = input[i];
      }

      return minValue;
    }

    function rescale(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isAnyArray(input)) {
        throw new TypeError('input must be an array');
      } else if (input.length === 0) {
        throw new TypeError('input must not be empty');
      }

      var output;

      if (options.output !== undefined) {
        if (!isAnyArray(options.output)) {
          throw new TypeError('output option must be an array if specified');
        }

        output = options.output;
      } else {
        output = new Array(input.length);
      }

      var currentMin = min$3(input);
      var currentMax = max$4(input);

      if (currentMin === currentMax) {
        throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
      }

      var _options$min = options.min,
          minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,
          _options$max = options.max,
          maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;

      if (minValue >= maxValue) {
        throw new RangeError('min option must be smaller than max option');
      }

      var factor = (maxValue - minValue) / (currentMax - currentMin);

      for (var i = 0; i < input.length; i++) {
        output[i] = (input[i] - currentMin) * factor + minValue;
      }

      return output;
    }

    /**
     * @class LuDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs
     * @param {Matrix} matrix
     */
    class LuDecomposition {
      constructor(matrix) {
        matrix = WrapperMatrix2D.checkMatrix(matrix);

        var lu = matrix.clone();
        var rows = lu.rows;
        var columns = lu.columns;
        var pivotVector = new Array(rows);
        var pivotSign = 1;
        var i, j, k, p, s, t, v;
        var LUcolj, kmax;

        for (i = 0; i < rows; i++) {
          pivotVector[i] = i;
        }

        LUcolj = new Array(rows);

        for (j = 0; j < columns; j++) {
          for (i = 0; i < rows; i++) {
            LUcolj[i] = lu.get(i, j);
          }

          for (i = 0; i < rows; i++) {
            kmax = Math.min(i, j);
            s = 0;
            for (k = 0; k < kmax; k++) {
              s += lu.get(i, k) * LUcolj[k];
            }
            LUcolj[i] -= s;
            lu.set(i, j, LUcolj[i]);
          }

          p = j;
          for (i = j + 1; i < rows; i++) {
            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
              p = i;
            }
          }

          if (p !== j) {
            for (k = 0; k < columns; k++) {
              t = lu.get(p, k);
              lu.set(p, k, lu.get(j, k));
              lu.set(j, k, t);
            }

            v = pivotVector[p];
            pivotVector[p] = pivotVector[j];
            pivotVector[j] = v;

            pivotSign = -pivotSign;
          }

          if (j < rows && lu.get(j, j) !== 0) {
            for (i = j + 1; i < rows; i++) {
              lu.set(i, j, lu.get(i, j) / lu.get(j, j));
            }
          }
        }

        this.LU = lu;
        this.pivotVector = pivotVector;
        this.pivotSign = pivotSign;
      }

      /**
       *
       * @return {boolean}
       */
      isSingular() {
        var data = this.LU;
        var col = data.columns;
        for (var j = 0; j < col; j++) {
          if (data[j][j] === 0) {
            return true;
          }
        }
        return false;
      }

      /**
       *
       * @param {Matrix} value
       * @return {Matrix}
       */
      solve(value) {
        value = Matrix.checkMatrix(value);

        var lu = this.LU;
        var rows = lu.rows;

        if (rows !== value.rows) {
          throw new Error('Invalid matrix dimensions');
        }
        if (this.isSingular()) {
          throw new Error('LU matrix is singular');
        }

        var count = value.columns;
        var X = value.subMatrixRow(this.pivotVector, 0, count - 1);
        var columns = lu.columns;
        var i, j, k;

        for (k = 0; k < columns; k++) {
          for (i = k + 1; i < columns; i++) {
            for (j = 0; j < count; j++) {
              X[i][j] -= X[k][j] * lu[i][k];
            }
          }
        }
        for (k = columns - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            X[k][j] /= lu[k][k];
          }
          for (i = 0; i < k; i++) {
            for (j = 0; j < count; j++) {
              X[i][j] -= X[k][j] * lu[i][k];
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {number}
       */
      get determinant() {
        var data = this.LU;
        if (!data.isSquare()) {
          throw new Error('Matrix must be square');
        }
        var determinant = this.pivotSign;
        var col = data.columns;
        for (var j = 0; j < col; j++) {
          determinant *= data[j][j];
        }
        return determinant;
      }

      /**
       *
       * @return {Matrix}
       */
      get lowerTriangularMatrix() {
        var data = this.LU;
        var rows = data.rows;
        var columns = data.columns;
        var X = new Matrix(rows, columns);
        for (var i = 0; i < rows; i++) {
          for (var j = 0; j < columns; j++) {
            if (i > j) {
              X[i][j] = data[i][j];
            } else if (i === j) {
              X[i][j] = 1;
            } else {
              X[i][j] = 0;
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {Matrix}
       */
      get upperTriangularMatrix() {
        var data = this.LU;
        var rows = data.rows;
        var columns = data.columns;
        var X = new Matrix(rows, columns);
        for (var i = 0; i < rows; i++) {
          for (var j = 0; j < columns; j++) {
            if (i <= j) {
              X[i][j] = data[i][j];
            } else {
              X[i][j] = 0;
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {Array<number>}
       */
      get pivotPermutationVector() {
        return this.pivotVector.slice();
      }
    }

    function hypotenuse(a, b) {
      var r = 0;
      if (Math.abs(a) > Math.abs(b)) {
        r = b / a;
        return Math.abs(a) * Math.sqrt(1 + r * r);
      }
      if (b !== 0) {
        r = a / b;
        return Math.abs(b) * Math.sqrt(1 + r * r);
      }
      return 0;
    }

    function getFilled2DArray(rows, columns, value) {
      var array = new Array(rows);
      for (var i = 0; i < rows; i++) {
        array[i] = new Array(columns);
        for (var j = 0; j < columns; j++) {
          array[i][j] = value;
        }
      }
      return array;
    }

    /**
     * @class SingularValueDecomposition
     * @see https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs
     * @param {Matrix} value
     * @param {object} [options]
     * @param {boolean} [options.computeLeftSingularVectors=true]
     * @param {boolean} [options.computeRightSingularVectors=true]
     * @param {boolean} [options.autoTranspose=false]
     */
    class SingularValueDecomposition {
      constructor(value, options = {}) {
        value = WrapperMatrix2D.checkMatrix(value);

        var m = value.rows;
        var n = value.columns;

        const {
          computeLeftSingularVectors = true,
          computeRightSingularVectors = true,
          autoTranspose = false
        } = options;

        var wantu = Boolean(computeLeftSingularVectors);
        var wantv = Boolean(computeRightSingularVectors);

        var swapped = false;
        var a;
        if (m < n) {
          if (!autoTranspose) {
            a = value.clone();
            // eslint-disable-next-line no-console
            console.warn(
              'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose'
            );
          } else {
            a = value.transpose();
            m = a.rows;
            n = a.columns;
            swapped = true;
            var aux = wantu;
            wantu = wantv;
            wantv = aux;
          }
        } else {
          a = value.clone();
        }

        var nu = Math.min(m, n);
        var ni = Math.min(m + 1, n);
        var s = new Array(ni);
        var U = getFilled2DArray(m, nu, 0);
        var V = getFilled2DArray(n, n, 0);

        var e = new Array(n);
        var work = new Array(m);

        var si = new Array(ni);
        for (let i = 0; i < ni; i++) si[i] = i;

        var nct = Math.min(m - 1, n);
        var nrt = Math.max(0, Math.min(n - 2, m));
        var mrc = Math.max(nct, nrt);

        for (let k = 0; k < mrc; k++) {
          if (k < nct) {
            s[k] = 0;
            for (let i = k; i < m; i++) {
              s[k] = hypotenuse(s[k], a[i][k]);
            }
            if (s[k] !== 0) {
              if (a[k][k] < 0) {
                s[k] = -s[k];
              }
              for (let i = k; i < m; i++) {
                a[i][k] /= s[k];
              }
              a[k][k] += 1;
            }
            s[k] = -s[k];
          }

          for (let j = k + 1; j < n; j++) {
            if (k < nct && s[k] !== 0) {
              let t = 0;
              for (let i = k; i < m; i++) {
                t += a[i][k] * a[i][j];
              }
              t = -t / a[k][k];
              for (let i = k; i < m; i++) {
                a[i][j] += t * a[i][k];
              }
            }
            e[j] = a[k][j];
          }

          if (wantu && k < nct) {
            for (let i = k; i < m; i++) {
              U[i][k] = a[i][k];
            }
          }

          if (k < nrt) {
            e[k] = 0;
            for (let i = k + 1; i < n; i++) {
              e[k] = hypotenuse(e[k], e[i]);
            }
            if (e[k] !== 0) {
              if (e[k + 1] < 0) {
                e[k] = 0 - e[k];
              }
              for (let i = k + 1; i < n; i++) {
                e[i] /= e[k];
              }
              e[k + 1] += 1;
            }
            e[k] = -e[k];
            if (k + 1 < m && e[k] !== 0) {
              for (let i = k + 1; i < m; i++) {
                work[i] = 0;
              }
              for (let i = k + 1; i < m; i++) {
                for (let j = k + 1; j < n; j++) {
                  work[i] += e[j] * a[i][j];
                }
              }
              for (let j = k + 1; j < n; j++) {
                let t = -e[j] / e[k + 1];
                for (let i = k + 1; i < m; i++) {
                  a[i][j] += t * work[i];
                }
              }
            }
            if (wantv) {
              for (let i = k + 1; i < n; i++) {
                V[i][k] = e[i];
              }
            }
          }
        }

        let p = Math.min(n, m + 1);
        if (nct < n) {
          s[nct] = a[nct][nct];
        }
        if (m < p) {
          s[p - 1] = 0;
        }
        if (nrt + 1 < p) {
          e[nrt] = a[nrt][p - 1];
        }
        e[p - 1] = 0;

        if (wantu) {
          for (let j = nct; j < nu; j++) {
            for (let i = 0; i < m; i++) {
              U[i][j] = 0;
            }
            U[j][j] = 1;
          }
          for (let k = nct - 1; k >= 0; k--) {
            if (s[k] !== 0) {
              for (let j = k + 1; j < nu; j++) {
                let t = 0;
                for (let i = k; i < m; i++) {
                  t += U[i][k] * U[i][j];
                }
                t = -t / U[k][k];
                for (let i = k; i < m; i++) {
                  U[i][j] += t * U[i][k];
                }
              }
              for (let i = k; i < m; i++) {
                U[i][k] = -U[i][k];
              }
              U[k][k] = 1 + U[k][k];
              for (let i = 0; i < k - 1; i++) {
                U[i][k] = 0;
              }
            } else {
              for (let i = 0; i < m; i++) {
                U[i][k] = 0;
              }
              U[k][k] = 1;
            }
          }
        }

        if (wantv) {
          for (let k = n - 1; k >= 0; k--) {
            if (k < nrt && e[k] !== 0) {
              for (let j = k + 1; j < n; j++) {
                let t = 0;
                for (let i = k + 1; i < n; i++) {
                  t += V[i][k] * V[i][j];
                }
                t = -t / V[k + 1][k];
                for (let i = k + 1; i < n; i++) {
                  V[i][j] += t * V[i][k];
                }
              }
            }
            for (let i = 0; i < n; i++) {
              V[i][k] = 0;
            }
            V[k][k] = 1;
          }
        }

        var pp = p - 1;
        var eps = Number.EPSILON;
        while (p > 0) {
          let k, kase;
          for (k = p - 2; k >= -1; k--) {
            if (k === -1) {
              break;
            }
            const alpha =
              Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
            if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
              e[k] = 0;
              break;
            }
          }
          if (k === p - 2) {
            kase = 4;
          } else {
            let ks;
            for (ks = p - 1; ks >= k; ks--) {
              if (ks === k) {
                break;
              }
              let t =
                (ks !== p ? Math.abs(e[ks]) : 0) +
                (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
              if (Math.abs(s[ks]) <= eps * t) {
                s[ks] = 0;
                break;
              }
            }
            if (ks === k) {
              kase = 3;
            } else if (ks === p - 1) {
              kase = 1;
            } else {
              kase = 2;
              k = ks;
            }
          }

          k++;

          switch (kase) {
            case 1: {
              let f = e[p - 2];
              e[p - 2] = 0;
              for (let j = p - 2; j >= k; j--) {
                let t = hypotenuse(s[j], f);
                let cs = s[j] / t;
                let sn = f / t;
                s[j] = t;
                if (j !== k) {
                  f = -sn * e[j - 1];
                  e[j - 1] = cs * e[j - 1];
                }
                if (wantv) {
                  for (let i = 0; i < n; i++) {
                    t = cs * V[i][j] + sn * V[i][p - 1];
                    V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
                    V[i][j] = t;
                  }
                }
              }
              break;
            }
            case 2: {
              let f = e[k - 1];
              e[k - 1] = 0;
              for (let j = k; j < p; j++) {
                let t = hypotenuse(s[j], f);
                let cs = s[j] / t;
                let sn = f / t;
                s[j] = t;
                f = -sn * e[j];
                e[j] = cs * e[j];
                if (wantu) {
                  for (let i = 0; i < m; i++) {
                    t = cs * U[i][j] + sn * U[i][k - 1];
                    U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
                    U[i][j] = t;
                  }
                }
              }
              break;
            }
            case 3: {
              const scale = Math.max(
                Math.abs(s[p - 1]),
                Math.abs(s[p - 2]),
                Math.abs(e[p - 2]),
                Math.abs(s[k]),
                Math.abs(e[k])
              );
              const sp = s[p - 1] / scale;
              const spm1 = s[p - 2] / scale;
              const epm1 = e[p - 2] / scale;
              const sk = s[k] / scale;
              const ek = e[k] / scale;
              const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
              const c = sp * epm1 * (sp * epm1);
              let shift = 0;
              if (b !== 0 || c !== 0) {
                if (b < 0) {
                  shift = 0 - Math.sqrt(b * b + c);
                } else {
                  shift = Math.sqrt(b * b + c);
                }
                shift = c / (b + shift);
              }
              let f = (sk + sp) * (sk - sp) + shift;
              let g = sk * ek;
              for (let j = k; j < p - 1; j++) {
                let t = hypotenuse(f, g);
                if (t === 0) t = Number.MIN_VALUE;
                let cs = f / t;
                let sn = g / t;
                if (j !== k) {
                  e[j - 1] = t;
                }
                f = cs * s[j] + sn * e[j];
                e[j] = cs * e[j] - sn * s[j];
                g = sn * s[j + 1];
                s[j + 1] = cs * s[j + 1];
                if (wantv) {
                  for (let i = 0; i < n; i++) {
                    t = cs * V[i][j] + sn * V[i][j + 1];
                    V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
                    V[i][j] = t;
                  }
                }
                t = hypotenuse(f, g);
                if (t === 0) t = Number.MIN_VALUE;
                cs = f / t;
                sn = g / t;
                s[j] = t;
                f = cs * e[j] + sn * s[j + 1];
                s[j + 1] = -sn * e[j] + cs * s[j + 1];
                g = sn * e[j + 1];
                e[j + 1] = cs * e[j + 1];
                if (wantu && j < m - 1) {
                  for (let i = 0; i < m; i++) {
                    t = cs * U[i][j] + sn * U[i][j + 1];
                    U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
                    U[i][j] = t;
                  }
                }
              }
              e[p - 2] = f;
              break;
            }
            case 4: {
              if (s[k] <= 0) {
                s[k] = s[k] < 0 ? -s[k] : 0;
                if (wantv) {
                  for (let i = 0; i <= pp; i++) {
                    V[i][k] = -V[i][k];
                  }
                }
              }
              while (k < pp) {
                if (s[k] >= s[k + 1]) {
                  break;
                }
                let t = s[k];
                s[k] = s[k + 1];
                s[k + 1] = t;
                if (wantv && k < n - 1) {
                  for (let i = 0; i < n; i++) {
                    t = V[i][k + 1];
                    V[i][k + 1] = V[i][k];
                    V[i][k] = t;
                  }
                }
                if (wantu && k < m - 1) {
                  for (let i = 0; i < m; i++) {
                    t = U[i][k + 1];
                    U[i][k + 1] = U[i][k];
                    U[i][k] = t;
                  }
                }
                k++;
              }
              p--;
              break;
            }
            // no default
          }
        }

        if (swapped) {
          var tmp = V;
          V = U;
          U = tmp;
        }

        this.m = m;
        this.n = n;
        this.s = s;
        this.U = U;
        this.V = V;
      }

      /**
       * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).
       * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
       * var svd = SingularValueDecomposition(A);
       * var x = svd.solve(b);
       * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
       * @return {Matrix} - The vector x
       */
      solve(value) {
        var Y = value;
        var e = this.threshold;
        var scols = this.s.length;
        var Ls = Matrix.zeros(scols, scols);

        for (let i = 0; i < scols; i++) {
          if (Math.abs(this.s[i]) <= e) {
            Ls[i][i] = 0;
          } else {
            Ls[i][i] = 1 / this.s[i];
          }
        }

        var U = this.U;
        var V = this.rightSingularVectors;

        var VL = V.mmul(Ls);
        var vrows = V.rows;
        var urows = U.length;
        var VLU = Matrix.zeros(vrows, urows);

        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < urows; j++) {
            let sum = 0;
            for (let k = 0; k < scols; k++) {
              sum += VL[i][k] * U[j][k];
            }
            VLU[i][j] = sum;
          }
        }

        return VLU.mmul(Y);
      }

      /**
       *
       * @param {Array<number>} value
       * @return {Matrix}
       */
      solveForDiagonal(value) {
        return this.solve(Matrix.diag(value));
      }

      /**
       * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :
       * var svd = SingularValueDecomposition(A);
       * var inverseA = svd.inverse();
       * @return {Matrix} - The approximation of the inverse of the matrix
       */
      inverse() {
        var V = this.V;
        var e = this.threshold;
        var vrows = V.length;
        var vcols = V[0].length;
        var X = new Matrix(vrows, this.s.length);

        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < vcols; j++) {
            if (Math.abs(this.s[j]) > e) {
              X[i][j] = V[i][j] / this.s[j];
            } else {
              X[i][j] = 0;
            }
          }
        }

        var U = this.U;

        var urows = U.length;
        var ucols = U[0].length;
        var Y = new Matrix(vrows, urows);

        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < urows; j++) {
            let sum = 0;
            for (let k = 0; k < ucols; k++) {
              sum += X[i][k] * U[j][k];
            }
            Y[i][j] = sum;
          }
        }

        return Y;
      }

      /**
       *
       * @return {number}
       */
      get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
      }

      /**
       *
       * @return {number}
       */
      get norm2() {
        return this.s[0];
      }

      /**
       *
       * @return {number}
       */
      get rank() {
        var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
        var r = 0;
        var s = this.s;
        for (var i = 0, ii = s.length; i < ii; i++) {
          if (s[i] > tol) {
            r++;
          }
        }
        return r;
      }

      /**
       *
       * @return {Array<number>}
       */
      get diagonal() {
        return this.s;
      }

      /**
       *
       * @return {number}
       */
      get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
      }

      /**
       *
       * @return {Matrix}
       */
      get leftSingularVectors() {
        if (!Matrix.isMatrix(this.U)) {
          this.U = new Matrix(this.U);
        }
        return this.U;
      }

      /**
       *
       * @return {Matrix}
       */
      get rightSingularVectors() {
        if (!Matrix.isMatrix(this.V)) {
          this.V = new Matrix(this.V);
        }
        return this.V;
      }

      /**
       *
       * @return {Matrix}
       */
      get diagonalMatrix() {
        return Matrix.diag(this.s);
      }
    }

    /**
     * @private
     * Check that a row index is not out of bounds
     * @param {Matrix} matrix
     * @param {number} index
     * @param {boolean} [outer]
     */
    function checkRowIndex(matrix, index, outer) {
      var max = outer ? matrix.rows : matrix.rows - 1;
      if (index < 0 || index > max) {
        throw new RangeError('Row index out of range');
      }
    }

    /**
     * @private
     * Check that a column index is not out of bounds
     * @param {Matrix} matrix
     * @param {number} index
     * @param {boolean} [outer]
     */
    function checkColumnIndex(matrix, index, outer) {
      var max = outer ? matrix.columns : matrix.columns - 1;
      if (index < 0 || index > max) {
        throw new RangeError('Column index out of range');
      }
    }

    /**
     * @private
     * Check that the provided vector is an array with the right length
     * @param {Matrix} matrix
     * @param {Array|Matrix} vector
     * @return {Array}
     * @throws {RangeError}
     */
    function checkRowVector(matrix, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix.columns) {
        throw new RangeError(
          'vector size must be the same as the number of columns'
        );
      }
      return vector;
    }

    /**
     * @private
     * Check that the provided vector is an array with the right length
     * @param {Matrix} matrix
     * @param {Array|Matrix} vector
     * @return {Array}
     * @throws {RangeError}
     */
    function checkColumnVector(matrix, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix.rows) {
        throw new RangeError('vector size must be the same as the number of rows');
      }
      return vector;
    }

    function checkIndices(matrix, rowIndices, columnIndices) {
      return {
        row: checkRowIndices(matrix, rowIndices),
        column: checkColumnIndices(matrix, columnIndices)
      };
    }

    function checkRowIndices(matrix, rowIndices) {
      if (typeof rowIndices !== 'object') {
        throw new TypeError('unexpected type for row indices');
      }

      var rowOut = rowIndices.some((r) => {
        return r < 0 || r >= matrix.rows;
      });

      if (rowOut) {
        throw new RangeError('row indices are out of range');
      }

      if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

      return rowIndices;
    }

    function checkColumnIndices(matrix, columnIndices) {
      if (typeof columnIndices !== 'object') {
        throw new TypeError('unexpected type for column indices');
      }

      var columnOut = columnIndices.some((c) => {
        return c < 0 || c >= matrix.columns;
      });

      if (columnOut) {
        throw new RangeError('column indices are out of range');
      }
      if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

      return columnIndices;
    }

    function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
      if (arguments.length !== 5) {
        throw new RangeError('expected 4 arguments');
      }
      checkNumber('startRow', startRow);
      checkNumber('endRow', endRow);
      checkNumber('startColumn', startColumn);
      checkNumber('endColumn', endColumn);
      if (
        startRow > endRow ||
        startColumn > endColumn ||
        startRow < 0 ||
        startRow >= matrix.rows ||
        endRow < 0 ||
        endRow >= matrix.rows ||
        startColumn < 0 ||
        startColumn >= matrix.columns ||
        endColumn < 0 ||
        endColumn >= matrix.columns
      ) {
        throw new RangeError('Submatrix indices are out of range');
      }
    }

    function sumByRow(matrix) {
      var sum = Matrix.zeros(matrix.rows, 1);
      for (var i = 0; i < matrix.rows; ++i) {
        for (var j = 0; j < matrix.columns; ++j) {
          sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));
        }
      }
      return sum;
    }

    function sumByColumn(matrix) {
      var sum = Matrix.zeros(1, matrix.columns);
      for (var i = 0; i < matrix.rows; ++i) {
        for (var j = 0; j < matrix.columns; ++j) {
          sum.set(0, j, sum.get(0, j) + matrix.get(i, j));
        }
      }
      return sum;
    }

    function sumAll(matrix) {
      var v = 0;
      for (var i = 0; i < matrix.rows; i++) {
        for (var j = 0; j < matrix.columns; j++) {
          v += matrix.get(i, j);
        }
      }
      return v;
    }

    function checkNumber(name, value) {
      if (typeof value !== 'number') {
        throw new TypeError(`${name} must be a number`);
      }
    }

    class BaseView extends AbstractMatrix() {
      constructor(matrix, rows, columns) {
        super();
        this.matrix = matrix;
        this.rows = rows;
        this.columns = columns;
      }

      static get [Symbol.species]() {
        return Matrix;
      }
    }

    class MatrixTransposeView extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.columns, matrix.rows);
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(columnIndex, rowIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(columnIndex, rowIndex);
      }
    }

    class MatrixRowView extends BaseView {
      constructor(matrix, row) {
        super(matrix, 1, matrix.columns);
        this.row = row;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.row, columnIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(this.row, columnIndex);
      }
    }

    class MatrixSubView extends BaseView {
      constructor(matrix, startRow, endRow, startColumn, endColumn) {
        checkRange(matrix, startRow, endRow, startColumn, endColumn);
        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
        this.startRow = startRow;
        this.startColumn = startColumn;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.startRow + rowIndex,
          this.startColumn + columnIndex,
          value
        );
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.startRow + rowIndex,
          this.startColumn + columnIndex
        );
      }
    }

    class MatrixSelectionView extends BaseView {
      constructor(matrix, rowIndices, columnIndices) {
        var indices = checkIndices(matrix, rowIndices, columnIndices);
        super(matrix, indices.row.length, indices.column.length);
        this.rowIndices = indices.row;
        this.columnIndices = indices.column;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex],
          value
        );
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex]
        );
      }
    }

    class MatrixRowSelectionView extends BaseView {
      constructor(matrix, rowIndices) {
        rowIndices = checkRowIndices(matrix, rowIndices);
        super(matrix, rowIndices.length, matrix.columns);
        this.rowIndices = rowIndices;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
      }
    }

    class MatrixColumnSelectionView extends BaseView {
      constructor(matrix, columnIndices) {
        columnIndices = checkColumnIndices(matrix, columnIndices);
        super(matrix, matrix.rows, columnIndices.length);
        this.columnIndices = columnIndices;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
      }
    }

    class MatrixColumnView extends BaseView {
      constructor(matrix, column) {
        super(matrix, matrix.rows, 1);
        this.column = column;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.column, value);
        return this;
      }

      get(rowIndex) {
        return this.matrix.get(rowIndex, this.column);
      }
    }

    class MatrixFlipRowView extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
      }
    }

    class MatrixFlipColumnView extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
      }
    }

    function AbstractMatrix(superCtor) {
      if (superCtor === undefined) superCtor = Object;

      /**
       * Real matrix
       * @class Matrix
       * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,
       * 2D array containing the data or Matrix instance to clone
       * @param {number} [nColumns] - Number of columns of the new matrix
       */
      class Matrix extends superCtor {
        static get [Symbol.species]() {
          return this;
        }

        /**
         * Constructs a Matrix with the chosen dimensions from a 1D array
         * @param {number} newRows - Number of rows
         * @param {number} newColumns - Number of columns
         * @param {Array} newData - A 1D array containing data for the matrix
         * @return {Matrix} - The new matrix
         */
        static from1DArray(newRows, newColumns, newData) {
          var length = newRows * newColumns;
          if (length !== newData.length) {
            throw new RangeError('Data length does not match given dimensions');
          }
          var newMatrix = new this(newRows, newColumns);
          for (var row = 0; row < newRows; row++) {
            for (var column = 0; column < newColumns; column++) {
              newMatrix.set(row, column, newData[row * newColumns + column]);
            }
          }
          return newMatrix;
        }

        /**
             * Creates a row vector, a matrix with only one row.
             * @param {Array} newData - A 1D array containing data for the vector
             * @return {Matrix} - The new matrix
             */
        static rowVector(newData) {
          var vector = new this(1, newData.length);
          for (var i = 0; i < newData.length; i++) {
            vector.set(0, i, newData[i]);
          }
          return vector;
        }

        /**
             * Creates a column vector, a matrix with only one column.
             * @param {Array} newData - A 1D array containing data for the vector
             * @return {Matrix} - The new matrix
             */
        static columnVector(newData) {
          var vector = new this(newData.length, 1);
          for (var i = 0; i < newData.length; i++) {
            vector.set(i, 0, newData[i]);
          }
          return vector;
        }

        /**
             * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @return {Matrix} - The new matrix
             */
        static empty(rows, columns) {
          return new this(rows, columns);
        }

        /**
             * Creates a matrix with the given dimensions. Values will be set to zero.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @return {Matrix} - The new matrix
             */
        static zeros(rows, columns) {
          return this.empty(rows, columns).fill(0);
        }

        /**
             * Creates a matrix with the given dimensions. Values will be set to one.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @return {Matrix} - The new matrix
             */
        static ones(rows, columns) {
          return this.empty(rows, columns).fill(1);
        }

        /**
             * Creates a matrix with the given dimensions. Values will be randomly set.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @param {function} [rng=Math.random] - Random number generator
             * @return {Matrix} The new matrix
             */
        static rand(rows, columns, rng) {
          if (rng === undefined) rng = Math.random;
          var matrix = this.empty(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              matrix.set(i, j, rng());
            }
          }
          return matrix;
        }

        /**
             * Creates a matrix with the given dimensions. Values will be random integers.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @param {number} [maxValue=1000] - Maximum value
             * @param {function} [rng=Math.random] - Random number generator
             * @return {Matrix} The new matrix
             */
        static randInt(rows, columns, maxValue, rng) {
          if (maxValue === undefined) maxValue = 1000;
          if (rng === undefined) rng = Math.random;
          var matrix = this.empty(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              var value = Math.floor(rng() * maxValue);
              matrix.set(i, j, value);
            }
          }
          return matrix;
        }

        /**
             * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.
             * @param {number} rows - Number of rows
             * @param {number} [columns=rows] - Number of columns
             * @param {number} [value=1] - Value to fill the diagonal with
             * @return {Matrix} - The new identity matrix
             */
        static eye(rows, columns, value) {
          if (columns === undefined) columns = rows;
          if (value === undefined) value = 1;
          var min = Math.min(rows, columns);
          var matrix = this.zeros(rows, columns);
          for (var i = 0; i < min; i++) {
            matrix.set(i, i, value);
          }
          return matrix;
        }

        /**
             * Creates a diagonal matrix based on the given array.
             * @param {Array} data - Array containing the data for the diagonal
             * @param {number} [rows] - Number of rows (Default: data.length)
             * @param {number} [columns] - Number of columns (Default: rows)
             * @return {Matrix} - The new diagonal matrix
             */
        static diag(data, rows, columns) {
          var l = data.length;
          if (rows === undefined) rows = l;
          if (columns === undefined) columns = rows;
          var min = Math.min(l, rows, columns);
          var matrix = this.zeros(rows, columns);
          for (var i = 0; i < min; i++) {
            matrix.set(i, i, data[i]);
          }
          return matrix;
        }

        /**
             * Returns a matrix whose elements are the minimum between matrix1 and matrix2
             * @param {Matrix} matrix1
             * @param {Matrix} matrix2
             * @return {Matrix}
             */
        static min(matrix1, matrix2) {
          matrix1 = this.checkMatrix(matrix1);
          matrix2 = this.checkMatrix(matrix2);
          var rows = matrix1.rows;
          var columns = matrix1.columns;
          var result = new this(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
            }
          }
          return result;
        }

        /**
             * Returns a matrix whose elements are the maximum between matrix1 and matrix2
             * @param {Matrix} matrix1
             * @param {Matrix} matrix2
             * @return {Matrix}
             */
        static max(matrix1, matrix2) {
          matrix1 = this.checkMatrix(matrix1);
          matrix2 = this.checkMatrix(matrix2);
          var rows = matrix1.rows;
          var columns = matrix1.columns;
          var result = new this(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
            }
          }
          return result;
        }

        /**
             * Check that the provided value is a Matrix and tries to instantiate one if not
             * @param {*} value - The value to check
             * @return {Matrix}
             */
        static checkMatrix(value) {
          return Matrix.isMatrix(value) ? value : new this(value);
        }

        /**
             * Returns true if the argument is a Matrix, false otherwise
             * @param {*} value - The value to check
             * @return {boolean}
             */
        static isMatrix(value) {
          return (value != null) && (value.klass === 'Matrix');
        }

        /**
             * @prop {number} size - The number of elements in the matrix.
             */
        get size() {
          return this.rows * this.columns;
        }

        /**
             * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.
             * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)
             * @return {Matrix} this
             */
        apply(callback) {
          if (typeof callback !== 'function') {
            throw new TypeError('callback must be a function');
          }
          var ii = this.rows;
          var jj = this.columns;
          for (var i = 0; i < ii; i++) {
            for (var j = 0; j < jj; j++) {
              callback.call(this, i, j);
            }
          }
          return this;
        }

        /**
             * Returns a new 1D array filled row by row with the matrix values
             * @return {Array}
             */
        to1DArray() {
          var array = new Array(this.size);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              array[i * this.columns + j] = this.get(i, j);
            }
          }
          return array;
        }

        /**
             * Returns a 2D array containing a copy of the data
             * @return {Array}
             */
        to2DArray() {
          var copy = new Array(this.rows);
          for (var i = 0; i < this.rows; i++) {
            copy[i] = new Array(this.columns);
            for (var j = 0; j < this.columns; j++) {
              copy[i][j] = this.get(i, j);
            }
          }
          return copy;
        }

        /**
             * @return {boolean} true if the matrix has one row
             */
        isRowVector() {
          return this.rows === 1;
        }

        /**
             * @return {boolean} true if the matrix has one column
             */
        isColumnVector() {
          return this.columns === 1;
        }

        /**
             * @return {boolean} true if the matrix has one row or one column
             */
        isVector() {
          return (this.rows === 1) || (this.columns === 1);
        }

        /**
             * @return {boolean} true if the matrix has the same number of rows and columns
             */
        isSquare() {
          return this.rows === this.columns;
        }

        /**
             * @return {boolean} true if the matrix is square and has the same values on both sides of the diagonal
             */
        isSymmetric() {
          if (this.isSquare()) {
            for (var i = 0; i < this.rows; i++) {
              for (var j = 0; j <= i; j++) {
                if (this.get(i, j) !== this.get(j, i)) {
                  return false;
                }
              }
            }
            return true;
          }
          return false;
        }

        /**
              * @return true if the matrix is in echelon form
              */
        isEchelonForm() {
          let i = 0;
          let j = 0;
          let previousColumn = -1;
          let isEchelonForm = true;
          let checked = false;
          while ((i < this.rows) && (isEchelonForm)) {
            j = 0;
            checked = false;
            while ((j < this.columns) && (checked === false)) {
              if (this.get(i, j) === 0) {
                j++;
              } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
                checked = true;
                previousColumn = j;
              } else {
                isEchelonForm = false;
                checked = true;
              }
            }
            i++;
          }
          return isEchelonForm;
        }

        /**
                 * @return true if the matrix is in reduced echelon form
                 */
        isReducedEchelonForm() {
          let i = 0;
          let j = 0;
          let previousColumn = -1;
          let isReducedEchelonForm = true;
          let checked = false;
          while ((i < this.rows) && (isReducedEchelonForm)) {
            j = 0;
            checked = false;
            while ((j < this.columns) && (checked === false)) {
              if (this.get(i, j) === 0) {
                j++;
              } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
                checked = true;
                previousColumn = j;
              } else {
                isReducedEchelonForm = false;
                checked = true;
              }
            }
            for (let k = j + 1; k < this.rows; k++) {
              if (this.get(i, k) !== 0) {
                isReducedEchelonForm = false;
              }
            }
            i++;
          }
          return isReducedEchelonForm;
        }

        /**
             * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1
             * @abstract
             * @param {number} rowIndex - Index of the row
             * @param {number} columnIndex - Index of the column
             * @param {number} value - The new value for the element
             * @return {Matrix} this
             */
        set(rowIndex, columnIndex, value) { // eslint-disable-line no-unused-vars
          throw new Error('set method is unimplemented');
        }

        /**
             * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]
             * @abstract
             * @param {number} rowIndex - Index of the row
             * @param {number} columnIndex - Index of the column
             * @return {number}
             */
        get(rowIndex, columnIndex) { // eslint-disable-line no-unused-vars
          throw new Error('get method is unimplemented');
        }

        /**
             * Creates a new matrix that is a repetition of the current matrix. New matrix has rowRep times the number of
             * rows of the matrix, and colRep times the number of columns of the matrix
             * @param {number} rowRep - Number of times the rows should be repeated
             * @param {number} colRep - Number of times the columns should be re
             * @return {Matrix}
             * @example
             * var matrix = new Matrix([[1,2]]);
             * matrix.repeat(2); // [[1,2],[1,2]]
             */
        repeat(rowRep, colRep) {
          rowRep = rowRep || 1;
          colRep = colRep || 1;
          var matrix = new this.constructor[Symbol.species](this.rows * rowRep, this.columns * colRep);
          for (var i = 0; i < rowRep; i++) {
            for (var j = 0; j < colRep; j++) {
              matrix.setSubMatrix(this, this.rows * i, this.columns * j);
            }
          }
          return matrix;
        }

        /**
             * Fills the matrix with a given value. All elements will be set to this value.
             * @param {number} value - New value
             * @return {Matrix} this
             */
        fill(value) {
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, value);
            }
          }
          return this;
        }

        /**
             * Negates the matrix. All elements will be multiplied by (-1)
             * @return {Matrix} this
             */
        neg() {
          return this.mulS(-1);
        }

        /**
             * Returns a new array from the given row index
             * @param {number} index - Row index
             * @return {Array}
             */
        getRow(index) {
          checkRowIndex(this, index);
          var row = new Array(this.columns);
          for (var i = 0; i < this.columns; i++) {
            row[i] = this.get(index, i);
          }
          return row;
        }

        /**
             * Returns a new row vector from the given row index
             * @param {number} index - Row index
             * @return {Matrix}
             */
        getRowVector(index) {
          return this.constructor.rowVector(this.getRow(index));
        }

        /**
             * Sets a row at the given index
             * @param {number} index - Row index
             * @param {Array|Matrix} array - Array or vector
             * @return {Matrix} this
             */
        setRow(index, array) {
          checkRowIndex(this, index);
          array = checkRowVector(this, array);
          for (var i = 0; i < this.columns; i++) {
            this.set(index, i, array[i]);
          }
          return this;
        }

        /**
             * Swaps two rows
             * @param {number} row1 - First row index
             * @param {number} row2 - Second row index
             * @return {Matrix} this
             */
        swapRows(row1, row2) {
          checkRowIndex(this, row1);
          checkRowIndex(this, row2);
          for (var i = 0; i < this.columns; i++) {
            var temp = this.get(row1, i);
            this.set(row1, i, this.get(row2, i));
            this.set(row2, i, temp);
          }
          return this;
        }

        /**
             * Returns a new array from the given column index
             * @param {number} index - Column index
             * @return {Array}
             */
        getColumn(index) {
          checkColumnIndex(this, index);
          var column = new Array(this.rows);
          for (var i = 0; i < this.rows; i++) {
            column[i] = this.get(i, index);
          }
          return column;
        }

        /**
             * Returns a new column vector from the given column index
             * @param {number} index - Column index
             * @return {Matrix}
             */
        getColumnVector(index) {
          return this.constructor.columnVector(this.getColumn(index));
        }

        /**
             * Sets a column at the given index
             * @param {number} index - Column index
             * @param {Array|Matrix} array - Array or vector
             * @return {Matrix} this
             */
        setColumn(index, array) {
          checkColumnIndex(this, index);
          array = checkColumnVector(this, array);
          for (var i = 0; i < this.rows; i++) {
            this.set(i, index, array[i]);
          }
          return this;
        }

        /**
             * Swaps two columns
             * @param {number} column1 - First column index
             * @param {number} column2 - Second column index
             * @return {Matrix} this
             */
        swapColumns(column1, column2) {
          checkColumnIndex(this, column1);
          checkColumnIndex(this, column2);
          for (var i = 0; i < this.rows; i++) {
            var temp = this.get(i, column1);
            this.set(i, column1, this.get(i, column2));
            this.set(i, column2, temp);
          }
          return this;
        }

        /**
             * Adds the values of a vector to each row
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        addRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) + vector[j]);
            }
          }
          return this;
        }

        /**
             * Subtracts the values of a vector from each row
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        subRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) - vector[j]);
            }
          }
          return this;
        }

        /**
             * Multiplies the values of a vector with each row
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        mulRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) * vector[j]);
            }
          }
          return this;
        }

        /**
             * Divides the values of each row by those of a vector
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        divRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) / vector[j]);
            }
          }
          return this;
        }

        /**
             * Adds the values of a vector to each column
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        addColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) + vector[i]);
            }
          }
          return this;
        }

        /**
             * Subtracts the values of a vector from each column
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        subColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) - vector[i]);
            }
          }
          return this;
        }

        /**
             * Multiplies the values of a vector with each column
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        mulColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) * vector[i]);
            }
          }
          return this;
        }

        /**
             * Divides the values of each column by those of a vector
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        divColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) / vector[i]);
            }
          }
          return this;
        }

        /**
             * Multiplies the values of a row with a scalar
             * @param {number} index - Row index
             * @param {number} value
             * @return {Matrix} this
             */
        mulRow(index, value) {
          checkRowIndex(this, index);
          for (var i = 0; i < this.columns; i++) {
            this.set(index, i, this.get(index, i) * value);
          }
          return this;
        }

        /**
             * Multiplies the values of a column with a scalar
             * @param {number} index - Column index
             * @param {number} value
             * @return {Matrix} this
             */
        mulColumn(index, value) {
          checkColumnIndex(this, index);
          for (var i = 0; i < this.rows; i++) {
            this.set(i, index, this.get(i, index) * value);
          }
          return this;
        }

        /**
             * Returns the maximum value of the matrix
             * @return {number}
             */
        max() {
          var v = this.get(0, 0);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) > v) {
                v = this.get(i, j);
              }
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value
             * @return {Array}
             */
        maxIndex() {
          var v = this.get(0, 0);
          var idx = [0, 0];
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) > v) {
                v = this.get(i, j);
                idx[0] = i;
                idx[1] = j;
              }
            }
          }
          return idx;
        }

        /**
             * Returns the minimum value of the matrix
             * @return {number}
             */
        min() {
          var v = this.get(0, 0);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) < v) {
                v = this.get(i, j);
              }
            }
          }
          return v;
        }

        /**
             * Returns the index of the minimum value
             * @return {Array}
             */
        minIndex() {
          var v = this.get(0, 0);
          var idx = [0, 0];
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) < v) {
                v = this.get(i, j);
                idx[0] = i;
                idx[1] = j;
              }
            }
          }
          return idx;
        }

        /**
             * Returns the maximum value of one row
             * @param {number} row - Row index
             * @return {number}
             */
        maxRow(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) > v) {
              v = this.get(row, i);
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value of one row
             * @param {number} row - Row index
             * @return {Array}
             */
        maxRowIndex(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          var idx = [row, 0];
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) > v) {
              v = this.get(row, i);
              idx[1] = i;
            }
          }
          return idx;
        }

        /**
             * Returns the minimum value of one row
             * @param {number} row - Row index
             * @return {number}
             */
        minRow(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) < v) {
              v = this.get(row, i);
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value of one row
             * @param {number} row - Row index
             * @return {Array}
             */
        minRowIndex(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          var idx = [row, 0];
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) < v) {
              v = this.get(row, i);
              idx[1] = i;
            }
          }
          return idx;
        }

        /**
             * Returns the maximum value of one column
             * @param {number} column - Column index
             * @return {number}
             */
        maxColumn(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) > v) {
              v = this.get(i, column);
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value of one column
             * @param {number} column - Column index
             * @return {Array}
             */
        maxColumnIndex(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          var idx = [0, column];
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) > v) {
              v = this.get(i, column);
              idx[0] = i;
            }
          }
          return idx;
        }

        /**
             * Returns the minimum value of one column
             * @param {number} column - Column index
             * @return {number}
             */
        minColumn(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) < v) {
              v = this.get(i, column);
            }
          }
          return v;
        }

        /**
             * Returns the index of the minimum value of one column
             * @param {number} column - Column index
             * @return {Array}
             */
        minColumnIndex(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          var idx = [0, column];
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) < v) {
              v = this.get(i, column);
              idx[0] = i;
            }
          }
          return idx;
        }

        /**
             * Returns an array containing the diagonal values of the matrix
             * @return {Array}
             */
        diag() {
          var min = Math.min(this.rows, this.columns);
          var diag = new Array(min);
          for (var i = 0; i < min; i++) {
            diag[i] = this.get(i, i);
          }
          return diag;
        }

        /**
             * Returns the sum by the argument given, if no argument given,
             * it returns the sum of all elements of the matrix.
             * @param {string} by - sum by 'row' or 'column'.
             * @return {Matrix|number}
             */
        sum(by) {
          switch (by) {
            case 'row':
              return sumByRow(this);
            case 'column':
              return sumByColumn(this);
            default:
              return sumAll(this);
          }
        }

        /**
             * Returns the mean of all elements of the matrix
             * @return {number}
             */
        mean() {
          return this.sum() / this.size;
        }

        /**
             * Returns the product of all elements of the matrix
             * @return {number}
             */
        prod() {
          var prod = 1;
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              prod *= this.get(i, j);
            }
          }
          return prod;
        }

        /**
             * Returns the norm of a matrix.
             * @param {string} type - "frobenius" (default) or "max" return resp. the Frobenius norm and the max norm.
             * @return {number}
             */
        norm(type = 'frobenius') {
          var result = 0;
          if (type === 'max') {
            return this.max();
          } else if (type === 'frobenius') {
            for (var i = 0; i < this.rows; i++) {
              for (var j = 0; j < this.columns; j++) {
                result = result + this.get(i, j) * this.get(i, j);
              }
            }
            return Math.sqrt(result);
          } else {
            throw new RangeError(`unknown norm type: ${type}`);
          }
        }

        /**
             * Computes the cumulative sum of the matrix elements (in place, row by row)
             * @return {Matrix} this
             */
        cumulativeSum() {
          var sum = 0;
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              sum += this.get(i, j);
              this.set(i, j, sum);
            }
          }
          return this;
        }

        /**
             * Computes the dot (scalar) product between the matrix and another
             * @param {Matrix} vector2 vector
             * @return {number}
             */
        dot(vector2) {
          if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
          var vector1 = this.to1DArray();
          if (vector1.length !== vector2.length) {
            throw new RangeError('vectors do not have the same size');
          }
          var dot = 0;
          for (var i = 0; i < vector1.length; i++) {
            dot += vector1[i] * vector2[i];
          }
          return dot;
        }

        /**
             * Returns the matrix product between this and other
             * @param {Matrix} other
             * @return {Matrix}
             */
        mmul(other) {
          other = this.constructor.checkMatrix(other);
          if (this.columns !== other.rows) {
            // eslint-disable-next-line no-console
            console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
          }

          var m = this.rows;
          var n = this.columns;
          var p = other.columns;

          var result = new this.constructor[Symbol.species](m, p);

          var Bcolj = new Array(n);
          for (var j = 0; j < p; j++) {
            for (var k = 0; k < n; k++) {
              Bcolj[k] = other.get(k, j);
            }

            for (var i = 0; i < m; i++) {
              var s = 0;
              for (k = 0; k < n; k++) {
                s += this.get(i, k) * Bcolj[k];
              }

              result.set(i, j, s);
            }
          }
          return result;
        }

        strassen2x2(other) {
          var result = new this.constructor[Symbol.species](2, 2);
          const a11 = this.get(0, 0);
          const b11 = other.get(0, 0);
          const a12 = this.get(0, 1);
          const b12 = other.get(0, 1);
          const a21 = this.get(1, 0);
          const b21 = other.get(1, 0);
          const a22 = this.get(1, 1);
          const b22 = other.get(1, 1);

          // Compute intermediate values.
          const m1 = (a11 + a22) * (b11 + b22);
          const m2 = (a21 + a22) * b11;
          const m3 = a11 * (b12 - b22);
          const m4 = a22 * (b21 - b11);
          const m5 = (a11 + a12) * b22;
          const m6 = (a21 - a11) * (b11 + b12);
          const m7 = (a12 - a22) * (b21 + b22);

          // Combine intermediate values into the output.
          const c00 = m1 + m4 - m5 + m7;
          const c01 = m3 + m5;
          const c10 = m2 + m4;
          const c11 = m1 - m2 + m3 + m6;

          result.set(0, 0, c00);
          result.set(0, 1, c01);
          result.set(1, 0, c10);
          result.set(1, 1, c11);
          return result;
        }

        strassen3x3(other) {
          var result = new this.constructor[Symbol.species](3, 3);

          const a00 = this.get(0, 0);
          const a01 = this.get(0, 1);
          const a02 = this.get(0, 2);
          const a10 = this.get(1, 0);
          const a11 = this.get(1, 1);
          const a12 = this.get(1, 2);
          const a20 = this.get(2, 0);
          const a21 = this.get(2, 1);
          const a22 = this.get(2, 2);

          const b00 = other.get(0, 0);
          const b01 = other.get(0, 1);
          const b02 = other.get(0, 2);
          const b10 = other.get(1, 0);
          const b11 = other.get(1, 1);
          const b12 = other.get(1, 2);
          const b20 = other.get(2, 0);
          const b21 = other.get(2, 1);
          const b22 = other.get(2, 2);

          const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
          const m2 = (a00 - a10) * (-b01 + b11);
          const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
          const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
          const m5 = (a10 + a11) * (-b00 + b01);
          const m6 = a00 * b00;
          const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
          const m8 = (-a00 + a20) * (b02 - b12);
          const m9 = (a20 + a21) * (-b00 + b02);
          const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
          const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
          const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
          const m13 = (a02 - a22) * (b11 - b21);
          const m14 = a02 * b20;
          const m15 = (a21 + a22) * (-b20 + b21);
          const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
          const m17 = (a02 - a12) * (b12 - b22);
          const m18 = (a11 + a12) * (-b20 + b22);
          const m19 = a01 * b10;
          const m20 = a12 * b21;
          const m21 = a10 * b02;
          const m22 = a20 * b01;
          const m23 = a22 * b22;

          const c00 = m6 + m14 + m19;
          const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
          const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
          const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
          const c11 = m2 + m4 + m5 + m6 + m20;
          const c12 = m14 + m16 + m17 + m18 + m21;
          const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
          const c21 = m12 + m13 + m14 + m15 + m22;
          const c22 = m6 + m7 + m8 + m9 + m23;

          result.set(0, 0, c00);
          result.set(0, 1, c01);
          result.set(0, 2, c02);
          result.set(1, 0, c10);
          result.set(1, 1, c11);
          result.set(1, 2, c12);
          result.set(2, 0, c20);
          result.set(2, 1, c21);
          result.set(2, 2, c22);
          return result;
        }

        /**
             * Returns the matrix product between x and y. More efficient than mmul(other) only when we multiply squared matrix and when the size of the matrix is > 1000.
             * @param {Matrix} y
             * @return {Matrix}
             */
        mmulStrassen(y) {
          var x = this.clone();
          var r1 = x.rows;
          var c1 = x.columns;
          var r2 = y.rows;
          var c2 = y.columns;
          if (c1 !== r2) {
            // eslint-disable-next-line no-console
            console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);
          }

          // Put a matrix into the top left of a matrix of zeros.
          // `rows` and `cols` are the dimensions of the output matrix.
          function embed(mat, rows, cols) {
            var r = mat.rows;
            var c = mat.columns;
            if ((r === rows) && (c === cols)) {
              return mat;
            } else {
              var resultat = Matrix.zeros(rows, cols);
              resultat = resultat.setSubMatrix(mat, 0, 0);
              return resultat;
            }
          }


          // Make sure both matrices are the same size.
          // This is exclusively for simplicity:
          // this algorithm can be implemented with matrices of different sizes.

          var r = Math.max(r1, r2);
          var c = Math.max(c1, c2);
          x = embed(x, r, c);
          y = embed(y, r, c);

          // Our recursive multiplication function.
          function blockMult(a, b, rows, cols) {
            // For small matrices, resort to naive multiplication.
            if (rows <= 512 || cols <= 512) {
              return a.mmul(b); // a is equivalent to this
            }

            // Apply dynamic padding.
            if ((rows % 2 === 1) && (cols % 2 === 1)) {
              a = embed(a, rows + 1, cols + 1);
              b = embed(b, rows + 1, cols + 1);
            } else if (rows % 2 === 1) {
              a = embed(a, rows + 1, cols);
              b = embed(b, rows + 1, cols);
            } else if (cols % 2 === 1) {
              a = embed(a, rows, cols + 1);
              b = embed(b, rows, cols + 1);
            }

            var halfRows = parseInt(a.rows / 2, 10);
            var halfCols = parseInt(a.columns / 2, 10);
            // Subdivide input matrices.
            var a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
            var b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);

            var a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
            var b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);

            var a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
            var b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);

            var a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
            var b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);

            // Compute intermediate values.
            var m1 = blockMult(Matrix.add(a11, a22), Matrix.add(b11, b22), halfRows, halfCols);
            var m2 = blockMult(Matrix.add(a21, a22), b11, halfRows, halfCols);
            var m3 = blockMult(a11, Matrix.sub(b12, b22), halfRows, halfCols);
            var m4 = blockMult(a22, Matrix.sub(b21, b11), halfRows, halfCols);
            var m5 = blockMult(Matrix.add(a11, a12), b22, halfRows, halfCols);
            var m6 = blockMult(Matrix.sub(a21, a11), Matrix.add(b11, b12), halfRows, halfCols);
            var m7 = blockMult(Matrix.sub(a12, a22), Matrix.add(b21, b22), halfRows, halfCols);

            // Combine intermediate values into the output.
            var c11 = Matrix.add(m1, m4);
            c11.sub(m5);
            c11.add(m7);
            var c12 = Matrix.add(m3, m5);
            var c21 = Matrix.add(m2, m4);
            var c22 = Matrix.sub(m1, m2);
            c22.add(m3);
            c22.add(m6);

            // Crop output to the desired size (undo dynamic padding).
            var resultat = Matrix.zeros(2 * c11.rows, 2 * c11.columns);
            resultat = resultat.setSubMatrix(c11, 0, 0);
            resultat = resultat.setSubMatrix(c12, c11.rows, 0);
            resultat = resultat.setSubMatrix(c21, 0, c11.columns);
            resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);
            return resultat.subMatrix(0, rows - 1, 0, cols - 1);
          }
          return blockMult(x, y, r, c);
        }

        /**
             * Returns a row-by-row scaled matrix
             * @param {number} [min=0] - Minimum scaled value
             * @param {number} [max=1] - Maximum scaled value
             * @return {Matrix} - The scaled matrix
             */
        scaleRows(min, max) {
          min = min === undefined ? 0 : min;
          max = max === undefined ? 1 : max;
          if (min >= max) {
            throw new RangeError('min should be strictly smaller than max');
          }
          var newMatrix = this.constructor.empty(this.rows, this.columns);
          for (var i = 0; i < this.rows; i++) {
            var scaled = rescale(this.getRow(i), { min, max });
            newMatrix.setRow(i, scaled);
          }
          return newMatrix;
        }

        /**
             * Returns a new column-by-column scaled matrix
             * @param {number} [min=0] - Minimum scaled value
             * @param {number} [max=1] - Maximum scaled value
             * @return {Matrix} - The new scaled matrix
             * @example
             * var matrix = new Matrix([[1,2],[-1,0]]);
             * var scaledMatrix = matrix.scaleColumns(); // [[1,1],[0,0]]
             */
        scaleColumns(min, max) {
          min = min === undefined ? 0 : min;
          max = max === undefined ? 1 : max;
          if (min >= max) {
            throw new RangeError('min should be strictly smaller than max');
          }
          var newMatrix = this.constructor.empty(this.rows, this.columns);
          for (var i = 0; i < this.columns; i++) {
            var scaled = rescale(this.getColumn(i), {
              min: min,
              max: max
            });
            newMatrix.setColumn(i, scaled);
          }
          return newMatrix;
        }


        /**
             * Returns the Kronecker product (also known as tensor product) between this and other
             * See https://en.wikipedia.org/wiki/Kronecker_product
             * @param {Matrix} other
             * @return {Matrix}
             */
        kroneckerProduct(other) {
          other = this.constructor.checkMatrix(other);

          var m = this.rows;
          var n = this.columns;
          var p = other.rows;
          var q = other.columns;

          var result = new this.constructor[Symbol.species](m * p, n * q);
          for (var i = 0; i < m; i++) {
            for (var j = 0; j < n; j++) {
              for (var k = 0; k < p; k++) {
                for (var l = 0; l < q; l++) {
                  result[p * i + k][q * j + l] = this.get(i, j) * other.get(k, l);
                }
              }
            }
          }
          return result;
        }

        /**
             * Transposes the matrix and returns a new one containing the result
             * @return {Matrix}
             */
        transpose() {
          var result = new this.constructor[Symbol.species](this.columns, this.rows);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              result.set(j, i, this.get(i, j));
            }
          }
          return result;
        }

        /**
             * Sorts the rows (in place)
             * @param {function} compareFunction - usual Array.prototype.sort comparison function
             * @return {Matrix} this
             */
        sortRows(compareFunction) {
          if (compareFunction === undefined) compareFunction = compareNumbers;
          for (var i = 0; i < this.rows; i++) {
            this.setRow(i, this.getRow(i).sort(compareFunction));
          }
          return this;
        }

        /**
             * Sorts the columns (in place)
             * @param {function} compareFunction - usual Array.prototype.sort comparison function
             * @return {Matrix} this
             */
        sortColumns(compareFunction) {
          if (compareFunction === undefined) compareFunction = compareNumbers;
          for (var i = 0; i < this.columns; i++) {
            this.setColumn(i, this.getColumn(i).sort(compareFunction));
          }
          return this;
        }

        /**
             * Returns a subset of the matrix
             * @param {number} startRow - First row index
             * @param {number} endRow - Last row index
             * @param {number} startColumn - First column index
             * @param {number} endColumn - Last column index
             * @return {Matrix}
             */
        subMatrix(startRow, endRow, startColumn, endColumn) {
          checkRange(this, startRow, endRow, startColumn, endColumn);
          var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, endColumn - startColumn + 1);
          for (var i = startRow; i <= endRow; i++) {
            for (var j = startColumn; j <= endColumn; j++) {
              newMatrix[i - startRow][j - startColumn] = this.get(i, j);
            }
          }
          return newMatrix;
        }

        /**
             * Returns a subset of the matrix based on an array of row indices
             * @param {Array} indices - Array containing the row indices
             * @param {number} [startColumn = 0] - First column index
             * @param {number} [endColumn = this.columns-1] - Last column index
             * @return {Matrix}
             */
        subMatrixRow(indices, startColumn, endColumn) {
          if (startColumn === undefined) startColumn = 0;
          if (endColumn === undefined) endColumn = this.columns - 1;
          if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
            throw new RangeError('Argument out of range');
          }

          var newMatrix = new this.constructor[Symbol.species](indices.length, endColumn - startColumn + 1);
          for (var i = 0; i < indices.length; i++) {
            for (var j = startColumn; j <= endColumn; j++) {
              if (indices[i] < 0 || indices[i] >= this.rows) {
                throw new RangeError(`Row index out of range: ${indices[i]}`);
              }
              newMatrix.set(i, j - startColumn, this.get(indices[i], j));
            }
          }
          return newMatrix;
        }

        /**
             * Returns a subset of the matrix based on an array of column indices
             * @param {Array} indices - Array containing the column indices
             * @param {number} [startRow = 0] - First row index
             * @param {number} [endRow = this.rows-1] - Last row index
             * @return {Matrix}
             */
        subMatrixColumn(indices, startRow, endRow) {
          if (startRow === undefined) startRow = 0;
          if (endRow === undefined) endRow = this.rows - 1;
          if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {
            throw new RangeError('Argument out of range');
          }

          var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, indices.length);
          for (var i = 0; i < indices.length; i++) {
            for (var j = startRow; j <= endRow; j++) {
              if (indices[i] < 0 || indices[i] >= this.columns) {
                throw new RangeError(`Column index out of range: ${indices[i]}`);
              }
              newMatrix.set(j - startRow, i, this.get(j, indices[i]));
            }
          }
          return newMatrix;
        }

        /**
             * Set a part of the matrix to the given sub-matrix
             * @param {Matrix|Array< Array >} matrix - The source matrix from which to extract values.
             * @param {number} startRow - The index of the first row to set
             * @param {number} startColumn - The index of the first column to set
             * @return {Matrix}
             */
        setSubMatrix(matrix, startRow, startColumn) {
          matrix = this.constructor.checkMatrix(matrix);
          var endRow = startRow + matrix.rows - 1;
          var endColumn = startColumn + matrix.columns - 1;
          checkRange(this, startRow, endRow, startColumn, endColumn);
          for (var i = 0; i < matrix.rows; i++) {
            for (var j = 0; j < matrix.columns; j++) {
              this[startRow + i][startColumn + j] = matrix.get(i, j);
            }
          }
          return this;
        }

        /**
             * Return a new matrix based on a selection of rows and columns
             * @param {Array<number>} rowIndices - The row indices to select. Order matters and an index can be more than once.
             * @param {Array<number>} columnIndices - The column indices to select. Order matters and an index can be use more than once.
             * @return {Matrix} The new matrix
             */
        selection(rowIndices, columnIndices) {
          var indices = checkIndices(this, rowIndices, columnIndices);
          var newMatrix = new this.constructor[Symbol.species](rowIndices.length, columnIndices.length);
          for (var i = 0; i < indices.row.length; i++) {
            var rowIndex = indices.row[i];
            for (var j = 0; j < indices.column.length; j++) {
              var columnIndex = indices.column[j];
              newMatrix[i][j] = this.get(rowIndex, columnIndex);
            }
          }
          return newMatrix;
        }

        /**
             * Returns the trace of the matrix (sum of the diagonal elements)
             * @return {number}
             */
        trace() {
          var min = Math.min(this.rows, this.columns);
          var trace = 0;
          for (var i = 0; i < min; i++) {
            trace += this.get(i, i);
          }
          return trace;
        }

        /*
             Matrix views
             */

        /**
             * Returns a view of the transposition of the matrix
             * @return {MatrixTransposeView}
             */
        transposeView() {
          return new MatrixTransposeView(this);
        }

        /**
             * Returns a view of the row vector with the given index
             * @param {number} row - row index of the vector
             * @return {MatrixRowView}
             */
        rowView(row) {
          checkRowIndex(this, row);
          return new MatrixRowView(this, row);
        }

        /**
             * Returns a view of the column vector with the given index
             * @param {number} column - column index of the vector
             * @return {MatrixColumnView}
             */
        columnView(column) {
          checkColumnIndex(this, column);
          return new MatrixColumnView(this, column);
        }

        /**
             * Returns a view of the matrix flipped in the row axis
             * @return {MatrixFlipRowView}
             */
        flipRowView() {
          return new MatrixFlipRowView(this);
        }

        /**
             * Returns a view of the matrix flipped in the column axis
             * @return {MatrixFlipColumnView}
             */
        flipColumnView() {
          return new MatrixFlipColumnView(this);
        }

        /**
             * Returns a view of a submatrix giving the index boundaries
             * @param {number} startRow - first row index of the submatrix
             * @param {number} endRow - last row index of the submatrix
             * @param {number} startColumn - first column index of the submatrix
             * @param {number} endColumn - last column index of the submatrix
             * @return {MatrixSubView}
             */
        subMatrixView(startRow, endRow, startColumn, endColumn) {
          return new MatrixSubView(this, startRow, endRow, startColumn, endColumn);
        }

        /**
             * Returns a view of the cross of the row indices and the column indices
             * @example
             * // resulting vector is [[2], [2]]
             * var matrix = new Matrix([[1,2,3], [4,5,6]]).selectionView([0, 0], [1])
             * @param {Array<number>} rowIndices
             * @param {Array<number>} columnIndices
             * @return {MatrixSelectionView}
             */
        selectionView(rowIndices, columnIndices) {
          return new MatrixSelectionView(this, rowIndices, columnIndices);
        }

        /**
             * Returns a view of the row indices
             * @example
             * // resulting vector is [[1,2,3], [1,2,3]]
             * var matrix = new Matrix([[1,2,3], [4,5,6]]).rowSelectionView([0, 0])
             * @param {Array<number>} rowIndices
             * @return {MatrixRowSelectionView}
             */
        rowSelectionView(rowIndices) {
          return new MatrixRowSelectionView(this, rowIndices);
        }

        /**
             * Returns a view of the column indices
             * @example
             * // resulting vector is [[2, 2], [5, 5]]
             * var matrix = new Matrix([[1,2,3], [4,5,6]]).columnSelectionView([1, 1])
             * @param {Array<number>} columnIndices
             * @return {MatrixColumnSelectionView}
             */
        columnSelectionView(columnIndices) {
          return new MatrixColumnSelectionView(this, columnIndices);
        }


        /**
            * Calculates and returns the determinant of a matrix as a Number
            * @example
            *   new Matrix([[1,2,3], [4,5,6]]).det()
            * @return {number}
            */
        det() {
          if (this.isSquare()) {
            var a, b, c, d;
            if (this.columns === 2) {
              // 2 x 2 matrix
              a = this.get(0, 0);
              b = this.get(0, 1);
              c = this.get(1, 0);
              d = this.get(1, 1);

              return a * d - (b * c);
            } else if (this.columns === 3) {
              // 3 x 3 matrix
              var subMatrix0, subMatrix1, subMatrix2;
              subMatrix0 = this.selectionView([1, 2], [1, 2]);
              subMatrix1 = this.selectionView([1, 2], [0, 2]);
              subMatrix2 = this.selectionView([1, 2], [0, 1]);
              a = this.get(0, 0);
              b = this.get(0, 1);
              c = this.get(0, 2);

              return a * subMatrix0.det() - b * subMatrix1.det() + c * subMatrix2.det();
            } else {
              // general purpose determinant using the LU decomposition
              return new LuDecomposition(this).determinant;
            }
          } else {
            throw Error('Determinant can only be calculated for a square matrix.');
          }
        }

        /**
             * Returns inverse of a matrix if it exists or the pseudoinverse
             * @param {number} threshold - threshold for taking inverse of singular values (default = 1e-15)
             * @return {Matrix} the (pseudo)inverted matrix.
             */
        pseudoInverse(threshold) {
          if (threshold === undefined) threshold = Number.EPSILON;
          var svdSolution = new SingularValueDecomposition(this, { autoTranspose: true });

          var U = svdSolution.leftSingularVectors;
          var V = svdSolution.rightSingularVectors;
          var s = svdSolution.diagonal;

          for (var i = 0; i < s.length; i++) {
            if (Math.abs(s[i]) > threshold) {
              s[i] = 1.0 / s[i];
            } else {
              s[i] = 0.0;
            }
          }

          // convert list to diagonal
          s = this.constructor[Symbol.species].diag(s);
          return V.mmul(s.mmul(U.transposeView()));
        }

        /**
             * Creates an exact and independent copy of the matrix
             * @return {Matrix}
             */
        clone() {
          var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);
          for (var row = 0; row < this.rows; row++) {
            for (var column = 0; column < this.columns; column++) {
              newMatrix.set(row, column, this.get(row, column));
            }
          }
          return newMatrix;
        }
      }

      Matrix.prototype.klass = 'Matrix';

      function compareNumbers(a, b) {
        return a - b;
      }

      /*
         Synonyms
         */

      Matrix.random = Matrix.rand;
      Matrix.diagonal = Matrix.diag;
      Matrix.prototype.diagonal = Matrix.prototype.diag;
      Matrix.identity = Matrix.eye;
      Matrix.prototype.negate = Matrix.prototype.neg;
      Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;
      Matrix.prototype.determinant = Matrix.prototype.det;

      /*
         Add dynamically instance and static methods for mathematical operations
         */

      var inplaceOperator = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;

      var inplaceOperatorScalar = `
(function %name%S(value) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) %op% value);
        }
    }
    return this;
})
`;

      var inplaceOperatorMatrix = `
(function %name%M(matrix) {
    matrix = this.constructor.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
        this.columns !== matrix.columns) {
        throw new RangeError('Matrices dimensions must be equal');
    }
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));
        }
    }
    return this;
})
`;

      var staticOperator = `
(function %name%(matrix, value) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%(value);
})
`;

      var inplaceMethod = `
(function %name%() {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j)));
        }
    }
    return this;
})
`;

      var staticMethod = `
(function %name%(matrix) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%();
})
`;

      var inplaceMethodWithArgs = `
(function %name%(%args%) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), %args%));
        }
    }
    return this;
})
`;

      var staticMethodWithArgs = `
(function %name%(matrix, %args%) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%(%args%);
})
`;


      var inplaceMethodWithOneArgScalar = `
(function %name%S(value) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), value));
        }
    }
    return this;
})
`;
      var inplaceMethodWithOneArgMatrix = `
(function %name%M(matrix) {
    matrix = this.constructor.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
        this.columns !== matrix.columns) {
        throw new RangeError('Matrices dimensions must be equal');
    }
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));
        }
    }
    return this;
})
`;

      var inplaceMethodWithOneArg = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;

      var staticMethodWithOneArg = staticMethodWithArgs;

      var operators = [
        // Arithmetic operators
        ['+', 'add'],
        ['-', 'sub', 'subtract'],
        ['*', 'mul', 'multiply'],
        ['/', 'div', 'divide'],
        ['%', 'mod', 'modulus'],
        // Bitwise operators
        ['&', 'and'],
        ['|', 'or'],
        ['^', 'xor'],
        ['<<', 'leftShift'],
        ['>>', 'signPropagatingRightShift'],
        ['>>>', 'rightShift', 'zeroFillRightShift']
      ];

      var i;
      var eval2 = eval; // eslint-disable-line no-eval
      for (var operator of operators) {
        var inplaceOp = eval2(fillTemplateFunction(inplaceOperator, { name: operator[1], op: operator[0] }));
        var inplaceOpS = eval2(fillTemplateFunction(inplaceOperatorScalar, { name: `${operator[1]}S`, op: operator[0] }));
        var inplaceOpM = eval2(fillTemplateFunction(inplaceOperatorMatrix, { name: `${operator[1]}M`, op: operator[0] }));
        var staticOp = eval2(fillTemplateFunction(staticOperator, { name: operator[1] }));
        for (i = 1; i < operator.length; i++) {
          Matrix.prototype[operator[i]] = inplaceOp;
          Matrix.prototype[`${operator[i]}S`] = inplaceOpS;
          Matrix.prototype[`${operator[i]}M`] = inplaceOpM;
          Matrix[operator[i]] = staticOp;
        }
      }

      var methods = [['~', 'not']];

      [
        'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil',
        'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p',
        'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'
      ].forEach(function (mathMethod) {
        methods.push([`Math.${mathMethod}`, mathMethod]);
      });

      for (var method of methods) {
        var inplaceMeth = eval2(fillTemplateFunction(inplaceMethod, { name: method[1], method: method[0] }));
        var staticMeth = eval2(fillTemplateFunction(staticMethod, { name: method[1] }));
        for (i = 1; i < method.length; i++) {
          Matrix.prototype[method[i]] = inplaceMeth;
          Matrix[method[i]] = staticMeth;
        }
      }

      var methodsWithArgs = [['Math.pow', 1, 'pow']];

      for (var methodWithArg of methodsWithArgs) {
        var args = 'arg0';
        for (i = 1; i < methodWithArg[1]; i++) {
          args += `, arg${i}`;
        }
        if (methodWithArg[1] !== 1) {
          var inplaceMethWithArgs = eval2(fillTemplateFunction(inplaceMethodWithArgs, {
            name: methodWithArg[2],
            method: methodWithArg[0],
            args: args
          }));
          var staticMethWithArgs = eval2(fillTemplateFunction(staticMethodWithArgs, { name: methodWithArg[2], args: args }));
          for (i = 2; i < methodWithArg.length; i++) {
            Matrix.prototype[methodWithArg[i]] = inplaceMethWithArgs;
            Matrix[methodWithArg[i]] = staticMethWithArgs;
          }
        } else {
          var tmplVar = {
            name: methodWithArg[2],
            args: args,
            method: methodWithArg[0]
          };
          var inplaceMethod2 = eval2(fillTemplateFunction(inplaceMethodWithOneArg, tmplVar));
          var inplaceMethodS = eval2(fillTemplateFunction(inplaceMethodWithOneArgScalar, tmplVar));
          var inplaceMethodM = eval2(fillTemplateFunction(inplaceMethodWithOneArgMatrix, tmplVar));
          var staticMethod2 = eval2(fillTemplateFunction(staticMethodWithOneArg, tmplVar));
          for (i = 2; i < methodWithArg.length; i++) {
            Matrix.prototype[methodWithArg[i]] = inplaceMethod2;
            Matrix.prototype[`${methodWithArg[i]}M`] = inplaceMethodM;
            Matrix.prototype[`${methodWithArg[i]}S`] = inplaceMethodS;
            Matrix[methodWithArg[i]] = staticMethod2;
          }
        }
      }

      function fillTemplateFunction(template, values) {
        for (var value in values) {
          template = template.replace(new RegExp(`%${value}%`, 'g'), values[value]);
        }
        return template;
      }

      return Matrix;
    }

    class Matrix extends AbstractMatrix(Array) {
      constructor(nRows, nColumns) {
        var i;
        if (arguments.length === 1 && typeof nRows === 'number') {
          return new Array(nRows);
        }
        if (Matrix.isMatrix(nRows)) {
          return nRows.clone();
        } else if (Number.isInteger(nRows) && nRows > 0) {
          // Create an empty matrix
          super(nRows);
          if (Number.isInteger(nColumns) && nColumns > 0) {
            for (i = 0; i < nRows; i++) {
              this[i] = new Array(nColumns);
            }
          } else {
            throw new TypeError('nColumns must be a positive integer');
          }
        } else if (Array.isArray(nRows)) {
          // Copy the values from the 2D array
          const matrix = nRows;
          nRows = matrix.length;
          nColumns = matrix[0].length;
          if (typeof nColumns !== 'number' || nColumns === 0) {
            throw new TypeError(
              'Data must be a 2D array with at least one element'
            );
          }
          super(nRows);
          for (i = 0; i < nRows; i++) {
            if (matrix[i].length !== nColumns) {
              throw new RangeError('Inconsistent array dimensions');
            }
            this[i] = [].concat(matrix[i]);
          }
        } else {
          throw new TypeError(
            'First argument must be a positive number or an array'
          );
        }
        this.rows = nRows;
        this.columns = nColumns;
        return this;
      }

      set(rowIndex, columnIndex, value) {
        this[rowIndex][columnIndex] = value;
        return this;
      }

      get(rowIndex, columnIndex) {
        return this[rowIndex][columnIndex];
      }

      /**
       * Removes a row from the given index
       * @param {number} index - Row index
       * @return {Matrix} this
       */
      removeRow(index) {
        checkRowIndex(this, index);
        if (this.rows === 1) {
          throw new RangeError('A matrix cannot have less than one row');
        }
        this.splice(index, 1);
        this.rows -= 1;
        return this;
      }

      /**
       * Adds a row at the given index
       * @param {number} [index = this.rows] - Row index
       * @param {Array|Matrix} array - Array or vector
       * @return {Matrix} this
       */
      addRow(index, array) {
        if (array === undefined) {
          array = index;
          index = this.rows;
        }
        checkRowIndex(this, index, true);
        array = checkRowVector(this, array);
        this.splice(index, 0, array);
        this.rows += 1;
        return this;
      }

      /**
       * Removes a column from the given index
       * @param {number} index - Column index
       * @return {Matrix} this
       */
      removeColumn(index) {
        checkColumnIndex(this, index);
        if (this.columns === 1) {
          throw new RangeError('A matrix cannot have less than one column');
        }
        for (var i = 0; i < this.rows; i++) {
          this[i].splice(index, 1);
        }
        this.columns -= 1;
        return this;
      }

      /**
       * Adds a column at the given index
       * @param {number} [index = this.columns] - Column index
       * @param {Array|Matrix} array - Array or vector
       * @return {Matrix} this
       */
      addColumn(index, array) {
        if (typeof array === 'undefined') {
          array = index;
          index = this.columns;
        }
        checkColumnIndex(this, index, true);
        array = checkColumnVector(this, array);
        for (var i = 0; i < this.rows; i++) {
          this[i].splice(index, 0, array[i]);
        }
        this.columns += 1;
        return this;
      }
    }

    class WrapperMatrix1D extends AbstractMatrix() {
      /**
       * @class WrapperMatrix1D
       * @param {Array<number>} data
       * @param {object} [options]
       * @param {object} [options.rows = 1]
       */
      constructor(data, options = {}) {
        const { rows = 1 } = options;

        if (data.length % rows !== 0) {
          throw new Error('the data length is not divisible by the number of rows');
        }
        super();
        this.rows = rows;
        this.columns = data.length / rows;
        this.data = data;
      }

      set(rowIndex, columnIndex, value) {
        var index = this._calculateIndex(rowIndex, columnIndex);
        this.data[index] = value;
        return this;
      }

      get(rowIndex, columnIndex) {
        var index = this._calculateIndex(rowIndex, columnIndex);
        return this.data[index];
      }

      _calculateIndex(row, column) {
        return row * this.columns + column;
      }

      static get [Symbol.species]() {
        return Matrix;
      }
    }

    class WrapperMatrix2D extends AbstractMatrix() {
      /**
       * @class WrapperMatrix2D
       * @param {Array<Array<number>>} data
       */
      constructor(data) {
        super();
        this.data = data;
        this.rows = data.length;
        this.columns = data[0].length;
      }

      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }

      static get [Symbol.species]() {
        return Matrix;
      }
    }

    /**
     * @class QrDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs
     * @param {Matrix} value
     */
    class QrDecomposition {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);

        var qr = value.clone();
        var m = value.rows;
        var n = value.columns;
        var rdiag = new Array(n);
        var i, j, k, s;

        for (k = 0; k < n; k++) {
          var nrm = 0;
          for (i = k; i < m; i++) {
            nrm = hypotenuse(nrm, qr.get(i, k));
          }
          if (nrm !== 0) {
            if (qr.get(k, k) < 0) {
              nrm = -nrm;
            }
            for (i = k; i < m; i++) {
              qr.set(i, k, qr.get(i, k) / nrm);
            }
            qr.set(k, k, qr.get(k, k) + 1);
            for (j = k + 1; j < n; j++) {
              s = 0;
              for (i = k; i < m; i++) {
                s += qr.get(i, k) * qr.get(i, j);
              }
              s = -s / qr.get(k, k);
              for (i = k; i < m; i++) {
                qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
              }
            }
          }
          rdiag[k] = -nrm;
        }

        this.QR = qr;
        this.Rdiag = rdiag;
      }

      /**
       * Solve a problem of least square (Ax=b) by using the QR decomposition. Useful when A is rectangular, but not working when A is singular.
       * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
       * var qr = QrDecomposition(A);
       * var x = qr.solve(b);
       * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
       * @return {Matrix} - The vector x
       */
      solve(value) {
        value = Matrix.checkMatrix(value);

        var qr = this.QR;
        var m = qr.rows;

        if (value.rows !== m) {
          throw new Error('Matrix row dimensions must agree');
        }
        if (!this.isFullRank()) {
          throw new Error('Matrix is rank deficient');
        }

        var count = value.columns;
        var X = value.clone();
        var n = qr.columns;
        var i, j, k, s;

        for (k = 0; k < n; k++) {
          for (j = 0; j < count; j++) {
            s = 0;
            for (i = k; i < m; i++) {
              s += qr[i][k] * X[i][j];
            }
            s = -s / qr[k][k];
            for (i = k; i < m; i++) {
              X[i][j] += s * qr[i][k];
            }
          }
        }
        for (k = n - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            X[k][j] /= this.Rdiag[k];
          }
          for (i = 0; i < k; i++) {
            for (j = 0; j < count; j++) {
              X[i][j] -= X[k][j] * qr[i][k];
            }
          }
        }

        return X.subMatrix(0, n - 1, 0, count - 1);
      }

      /**
       *
       * @return {boolean}
       */
      isFullRank() {
        var columns = this.QR.columns;
        for (var i = 0; i < columns; i++) {
          if (this.Rdiag[i] === 0) {
            return false;
          }
        }
        return true;
      }

      /**
       *
       * @return {Matrix}
       */
      get upperTriangularMatrix() {
        var qr = this.QR;
        var n = qr.columns;
        var X = new Matrix(n, n);
        var i, j;
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            if (i < j) {
              X[i][j] = qr[i][j];
            } else if (i === j) {
              X[i][j] = this.Rdiag[i];
            } else {
              X[i][j] = 0;
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {Matrix}
       */
      get orthogonalMatrix() {
        var qr = this.QR;
        var rows = qr.rows;
        var columns = qr.columns;
        var X = new Matrix(rows, columns);
        var i, j, k, s;

        for (k = columns - 1; k >= 0; k--) {
          for (i = 0; i < rows; i++) {
            X[i][k] = 0;
          }
          X[k][k] = 1;
          for (j = k; j < columns; j++) {
            if (qr[k][k] !== 0) {
              s = 0;
              for (i = k; i < rows; i++) {
                s += qr[i][k] * X[i][j];
              }

              s = -s / qr[k][k];

              for (i = k; i < rows; i++) {
                X[i][j] += s * qr[i][k];
              }
            }
          }
        }
        return X;
      }
    }

    /**
     * Computes the inverse of a Matrix
     * @param {Matrix} matrix
     * @param {boolean} [useSVD=false]
     * @return {Matrix}
     */
    function inverse(matrix, useSVD = false) {
      matrix = WrapperMatrix2D.checkMatrix(matrix);
      if (useSVD) {
        return new SingularValueDecomposition(matrix).inverse();
      } else {
        return solve(matrix, Matrix.eye(matrix.rows));
      }
    }

    /**
     *
     * @param {Matrix} leftHandSide
     * @param {Matrix} rightHandSide
     * @param {boolean} [useSVD = false]
     * @return {Matrix}
     */
    function solve(leftHandSide, rightHandSide, useSVD = false) {
      leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
      rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
      if (useSVD) {
        return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);
      } else {
        return leftHandSide.isSquare()
          ? new LuDecomposition(leftHandSide).solve(rightHandSide)
          : new QrDecomposition(leftHandSide).solve(rightHandSide);
      }
    }

    /**
     * @class EigenvalueDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs
     * @param {Matrix} matrix
     * @param {object} [options]
     * @param {boolean} [options.assumeSymmetric=false]
     */
    class EigenvalueDecomposition {
      constructor(matrix, options = {}) {
        const { assumeSymmetric = false } = options;

        matrix = WrapperMatrix2D.checkMatrix(matrix);
        if (!matrix.isSquare()) {
          throw new Error('Matrix is not a square matrix');
        }

        var n = matrix.columns;
        var V = getFilled2DArray(n, n, 0);
        var d = new Array(n);
        var e = new Array(n);
        var value = matrix;
        var i, j;

        var isSymmetric = false;
        if (assumeSymmetric) {
          isSymmetric = true;
        } else {
          isSymmetric = matrix.isSymmetric();
        }

        if (isSymmetric) {
          for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
              V[i][j] = value.get(i, j);
            }
          }
          tred2(n, e, d, V);
          tql2(n, e, d, V);
        } else {
          var H = getFilled2DArray(n, n, 0);
          var ort = new Array(n);
          for (j = 0; j < n; j++) {
            for (i = 0; i < n; i++) {
              H[i][j] = value.get(i, j);
            }
          }
          orthes(n, H, ort, V);
          hqr2(n, e, d, V, H);
        }

        this.n = n;
        this.e = e;
        this.d = d;
        this.V = V;
      }

      /**
       *
       * @return {Array<number>}
       */
      get realEigenvalues() {
        return this.d;
      }

      /**
       *
       * @return {Array<number>}
       */
      get imaginaryEigenvalues() {
        return this.e;
      }

      /**
       *
       * @return {Matrix}
       */
      get eigenvectorMatrix() {
        if (!Matrix.isMatrix(this.V)) {
          this.V = new Matrix(this.V);
        }
        return this.V;
      }

      /**
       *
       * @return {Matrix}
       */
      get diagonalMatrix() {
        var n = this.n;
        var e = this.e;
        var d = this.d;
        var X = new Matrix(n, n);
        var i, j;
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            X[i][j] = 0;
          }
          X[i][i] = d[i];
          if (e[i] > 0) {
            X[i][i + 1] = e[i];
          } else if (e[i] < 0) {
            X[i][i - 1] = e[i];
          }
        }
        return X;
      }
    }

    function tred2(n, e, d, V) {
      var f, g, h, i, j, k, hh, scale;

      for (j = 0; j < n; j++) {
        d[j] = V[n - 1][j];
      }

      for (i = n - 1; i > 0; i--) {
        scale = 0;
        h = 0;
        for (k = 0; k < i; k++) {
          scale = scale + Math.abs(d[k]);
        }

        if (scale === 0) {
          e[i] = d[i - 1];
          for (j = 0; j < i; j++) {
            d[j] = V[i - 1][j];
            V[i][j] = 0;
            V[j][i] = 0;
          }
        } else {
          for (k = 0; k < i; k++) {
            d[k] /= scale;
            h += d[k] * d[k];
          }

          f = d[i - 1];
          g = Math.sqrt(h);
          if (f > 0) {
            g = -g;
          }

          e[i] = scale * g;
          h = h - f * g;
          d[i - 1] = f - g;
          for (j = 0; j < i; j++) {
            e[j] = 0;
          }

          for (j = 0; j < i; j++) {
            f = d[j];
            V[j][i] = f;
            g = e[j] + V[j][j] * f;
            for (k = j + 1; k <= i - 1; k++) {
              g += V[k][j] * d[k];
              e[k] += V[k][j] * f;
            }
            e[j] = g;
          }

          f = 0;
          for (j = 0; j < i; j++) {
            e[j] /= h;
            f += e[j] * d[j];
          }

          hh = f / (h + h);
          for (j = 0; j < i; j++) {
            e[j] -= hh * d[j];
          }

          for (j = 0; j < i; j++) {
            f = d[j];
            g = e[j];
            for (k = j; k <= i - 1; k++) {
              V[k][j] -= f * e[k] + g * d[k];
            }
            d[j] = V[i - 1][j];
            V[i][j] = 0;
          }
        }
        d[i] = h;
      }

      for (i = 0; i < n - 1; i++) {
        V[n - 1][i] = V[i][i];
        V[i][i] = 1;
        h = d[i + 1];
        if (h !== 0) {
          for (k = 0; k <= i; k++) {
            d[k] = V[k][i + 1] / h;
          }

          for (j = 0; j <= i; j++) {
            g = 0;
            for (k = 0; k <= i; k++) {
              g += V[k][i + 1] * V[k][j];
            }
            for (k = 0; k <= i; k++) {
              V[k][j] -= g * d[k];
            }
          }
        }

        for (k = 0; k <= i; k++) {
          V[k][i + 1] = 0;
        }
      }

      for (j = 0; j < n; j++) {
        d[j] = V[n - 1][j];
        V[n - 1][j] = 0;
      }

      V[n - 1][n - 1] = 1;
      e[0] = 0;
    }

    function tql2(n, e, d, V) {
      var g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2;

      for (i = 1; i < n; i++) {
        e[i - 1] = e[i];
      }

      e[n - 1] = 0;

      var f = 0;
      var tst1 = 0;
      var eps = Number.EPSILON;

      for (l = 0; l < n; l++) {
        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
        m = l;
        while (m < n) {
          if (Math.abs(e[m]) <= eps * tst1) {
            break;
          }
          m++;
        }

        if (m > l) {
          do {

            g = d[l];
            p = (d[l + 1] - g) / (2 * e[l]);
            r = hypotenuse(p, 1);
            if (p < 0) {
              r = -r;
            }

            d[l] = e[l] / (p + r);
            d[l + 1] = e[l] * (p + r);
            dl1 = d[l + 1];
            h = g - d[l];
            for (i = l + 2; i < n; i++) {
              d[i] -= h;
            }

            f = f + h;

            p = d[m];
            c = 1;
            c2 = c;
            c3 = c;
            el1 = e[l + 1];
            s = 0;
            s2 = 0;
            for (i = m - 1; i >= l; i--) {
              c3 = c2;
              c2 = c;
              s2 = s;
              g = c * e[i];
              h = c * p;
              r = hypotenuse(p, e[i]);
              e[i + 1] = s * r;
              s = e[i] / r;
              c = p / r;
              p = c * d[i] - s * g;
              d[i + 1] = h + s * (c * g + s * d[i]);

              for (k = 0; k < n; k++) {
                h = V[k][i + 1];
                V[k][i + 1] = s * V[k][i] + c * h;
                V[k][i] = c * V[k][i] - s * h;
              }
            }

            p = -s * s2 * c3 * el1 * e[l] / dl1;
            e[l] = s * p;
            d[l] = c * p;
          } while (Math.abs(e[l]) > eps * tst1);
        }
        d[l] = d[l] + f;
        e[l] = 0;
      }

      for (i = 0; i < n - 1; i++) {
        k = i;
        p = d[i];
        for (j = i + 1; j < n; j++) {
          if (d[j] < p) {
            k = j;
            p = d[j];
          }
        }

        if (k !== i) {
          d[k] = d[i];
          d[i] = p;
          for (j = 0; j < n; j++) {
            p = V[j][i];
            V[j][i] = V[j][k];
            V[j][k] = p;
          }
        }
      }
    }

    function orthes(n, H, ort, V) {
      var low = 0;
      var high = n - 1;
      var f, g, h, i, j, m;
      var scale;

      for (m = low + 1; m <= high - 1; m++) {
        scale = 0;
        for (i = m; i <= high; i++) {
          scale = scale + Math.abs(H[i][m - 1]);
        }

        if (scale !== 0) {
          h = 0;
          for (i = high; i >= m; i--) {
            ort[i] = H[i][m - 1] / scale;
            h += ort[i] * ort[i];
          }

          g = Math.sqrt(h);
          if (ort[m] > 0) {
            g = -g;
          }

          h = h - ort[m] * g;
          ort[m] = ort[m] - g;

          for (j = m; j < n; j++) {
            f = 0;
            for (i = high; i >= m; i--) {
              f += ort[i] * H[i][j];
            }

            f = f / h;
            for (i = m; i <= high; i++) {
              H[i][j] -= f * ort[i];
            }
          }

          for (i = 0; i <= high; i++) {
            f = 0;
            for (j = high; j >= m; j--) {
              f += ort[j] * H[i][j];
            }

            f = f / h;
            for (j = m; j <= high; j++) {
              H[i][j] -= f * ort[j];
            }
          }

          ort[m] = scale * ort[m];
          H[m][m - 1] = scale * g;
        }
      }

      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          V[i][j] = i === j ? 1 : 0;
        }
      }

      for (m = high - 1; m >= low + 1; m--) {
        if (H[m][m - 1] !== 0) {
          for (i = m + 1; i <= high; i++) {
            ort[i] = H[i][m - 1];
          }

          for (j = m; j <= high; j++) {
            g = 0;
            for (i = m; i <= high; i++) {
              g += ort[i] * V[i][j];
            }

            g = g / ort[m] / H[m][m - 1];
            for (i = m; i <= high; i++) {
              V[i][j] += g * ort[i];
            }
          }
        }
      }
    }

    function hqr2(nn, e, d, V, H) {
      var n = nn - 1;
      var low = 0;
      var high = nn - 1;
      var eps = Number.EPSILON;
      var exshift = 0;
      var norm = 0;
      var p = 0;
      var q = 0;
      var r = 0;
      var s = 0;
      var z = 0;
      var iter = 0;
      var i, j, k, l, m, t, w, x, y;
      var ra, sa, vr, vi;
      var notlast, cdivres;

      for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
          d[i] = H[i][i];
          e[i] = 0;
        }

        for (j = Math.max(i - 1, 0); j < nn; j++) {
          norm = norm + Math.abs(H[i][j]);
        }
      }

      while (n >= low) {
        l = n;
        while (l > low) {
          s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);
          if (s === 0) {
            s = norm;
          }
          if (Math.abs(H[l][l - 1]) < eps * s) {
            break;
          }
          l--;
        }

        if (l === n) {
          H[n][n] = H[n][n] + exshift;
          d[n] = H[n][n];
          e[n] = 0;
          n--;
          iter = 0;
        } else if (l === n - 1) {
          w = H[n][n - 1] * H[n - 1][n];
          p = (H[n - 1][n - 1] - H[n][n]) / 2;
          q = p * p + w;
          z = Math.sqrt(Math.abs(q));
          H[n][n] = H[n][n] + exshift;
          H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;
          x = H[n][n];

          if (q >= 0) {
            z = p >= 0 ? p + z : p - z;
            d[n - 1] = x + z;
            d[n] = d[n - 1];
            if (z !== 0) {
              d[n] = x - w / z;
            }
            e[n - 1] = 0;
            e[n] = 0;
            x = H[n][n - 1];
            s = Math.abs(x) + Math.abs(z);
            p = x / s;
            q = z / s;
            r = Math.sqrt(p * p + q * q);
            p = p / r;
            q = q / r;

            for (j = n - 1; j < nn; j++) {
              z = H[n - 1][j];
              H[n - 1][j] = q * z + p * H[n][j];
              H[n][j] = q * H[n][j] - p * z;
            }

            for (i = 0; i <= n; i++) {
              z = H[i][n - 1];
              H[i][n - 1] = q * z + p * H[i][n];
              H[i][n] = q * H[i][n] - p * z;
            }

            for (i = low; i <= high; i++) {
              z = V[i][n - 1];
              V[i][n - 1] = q * z + p * V[i][n];
              V[i][n] = q * V[i][n] - p * z;
            }
          } else {
            d[n - 1] = x + p;
            d[n] = x + p;
            e[n - 1] = z;
            e[n] = -z;
          }

          n = n - 2;
          iter = 0;
        } else {
          x = H[n][n];
          y = 0;
          w = 0;
          if (l < n) {
            y = H[n - 1][n - 1];
            w = H[n][n - 1] * H[n - 1][n];
          }

          if (iter === 10) {
            exshift += x;
            for (i = low; i <= n; i++) {
              H[i][i] -= x;
            }
            s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);
            x = y = 0.75 * s;
            w = -0.4375 * s * s;
          }

          if (iter === 30) {
            s = (y - x) / 2;
            s = s * s + w;
            if (s > 0) {
              s = Math.sqrt(s);
              if (y < x) {
                s = -s;
              }
              s = x - w / ((y - x) / 2 + s);
              for (i = low; i <= n; i++) {
                H[i][i] -= s;
              }
              exshift += s;
              x = y = w = 0.964;
            }
          }

          iter = iter + 1;

          m = n - 2;
          while (m >= l) {
            z = H[m][m];
            r = x - z;
            s = y - z;
            p = (r * s - w) / H[m + 1][m] + H[m][m + 1];
            q = H[m + 1][m + 1] - z - r - s;
            r = H[m + 2][m + 1];
            s = Math.abs(p) + Math.abs(q) + Math.abs(r);
            p = p / s;
            q = q / s;
            r = r / s;
            if (m === l) {
              break;
            }
            if (
              Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) <
              eps *
                (Math.abs(p) *
                  (Math.abs(H[m - 1][m - 1]) +
                    Math.abs(z) +
                    Math.abs(H[m + 1][m + 1])))
            ) {
              break;
            }
            m--;
          }

          for (i = m + 2; i <= n; i++) {
            H[i][i - 2] = 0;
            if (i > m + 2) {
              H[i][i - 3] = 0;
            }
          }

          for (k = m; k <= n - 1; k++) {
            notlast = k !== n - 1;
            if (k !== m) {
              p = H[k][k - 1];
              q = H[k + 1][k - 1];
              r = notlast ? H[k + 2][k - 1] : 0;
              x = Math.abs(p) + Math.abs(q) + Math.abs(r);
              if (x !== 0) {
                p = p / x;
                q = q / x;
                r = r / x;
              }
            }

            if (x === 0) {
              break;
            }

            s = Math.sqrt(p * p + q * q + r * r);
            if (p < 0) {
              s = -s;
            }

            if (s !== 0) {
              if (k !== m) {
                H[k][k - 1] = -s * x;
              } else if (l !== m) {
                H[k][k - 1] = -H[k][k - 1];
              }

              p = p + s;
              x = p / s;
              y = q / s;
              z = r / s;
              q = q / p;
              r = r / p;

              for (j = k; j < nn; j++) {
                p = H[k][j] + q * H[k + 1][j];
                if (notlast) {
                  p = p + r * H[k + 2][j];
                  H[k + 2][j] = H[k + 2][j] - p * z;
                }

                H[k][j] = H[k][j] - p * x;
                H[k + 1][j] = H[k + 1][j] - p * y;
              }

              for (i = 0; i <= Math.min(n, k + 3); i++) {
                p = x * H[i][k] + y * H[i][k + 1];
                if (notlast) {
                  p = p + z * H[i][k + 2];
                  H[i][k + 2] = H[i][k + 2] - p * r;
                }

                H[i][k] = H[i][k] - p;
                H[i][k + 1] = H[i][k + 1] - p * q;
              }

              for (i = low; i <= high; i++) {
                p = x * V[i][k] + y * V[i][k + 1];
                if (notlast) {
                  p = p + z * V[i][k + 2];
                  V[i][k + 2] = V[i][k + 2] - p * r;
                }

                V[i][k] = V[i][k] - p;
                V[i][k + 1] = V[i][k + 1] - p * q;
              }
            }
          }
        }
      }

      if (norm === 0) {
        return;
      }

      for (n = nn - 1; n >= 0; n--) {
        p = d[n];
        q = e[n];

        if (q === 0) {
          l = n;
          H[n][n] = 1;
          for (i = n - 1; i >= 0; i--) {
            w = H[i][i] - p;
            r = 0;
            for (j = l; j <= n; j++) {
              r = r + H[i][j] * H[j][n];
            }

            if (e[i] < 0) {
              z = w;
              s = r;
            } else {
              l = i;
              if (e[i] === 0) {
                H[i][n] = w !== 0 ? -r / w : -r / (eps * norm);
              } else {
                x = H[i][i + 1];
                y = H[i + 1][i];
                q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
                t = (x * s - z * r) / q;
                H[i][n] = t;
                H[i + 1][n] =
                  Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z;
              }

              t = Math.abs(H[i][n]);
              if (eps * t * t > 1) {
                for (j = i; j <= n; j++) {
                  H[j][n] = H[j][n] / t;
                }
              }
            }
          }
        } else if (q < 0) {
          l = n - 1;

          if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {
            H[n - 1][n - 1] = q / H[n][n - 1];
            H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];
          } else {
            cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);
            H[n - 1][n - 1] = cdivres[0];
            H[n - 1][n] = cdivres[1];
          }

          H[n][n - 1] = 0;
          H[n][n] = 1;
          for (i = n - 2; i >= 0; i--) {
            ra = 0;
            sa = 0;
            for (j = l; j <= n; j++) {
              ra = ra + H[i][j] * H[j][n - 1];
              sa = sa + H[i][j] * H[j][n];
            }

            w = H[i][i] - p;

            if (e[i] < 0) {
              z = w;
              r = ra;
              s = sa;
            } else {
              l = i;
              if (e[i] === 0) {
                cdivres = cdiv(-ra, -sa, w, q);
                H[i][n - 1] = cdivres[0];
                H[i][n] = cdivres[1];
              } else {
                x = H[i][i + 1];
                y = H[i + 1][i];
                vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
                vi = (d[i] - p) * 2 * q;
                if (vr === 0 && vi === 0) {
                  vr =
                    eps *
                    norm *
                    (Math.abs(w) +
                      Math.abs(q) +
                      Math.abs(x) +
                      Math.abs(y) +
                      Math.abs(z));
                }
                cdivres = cdiv(
                  x * r - z * ra + q * sa,
                  x * s - z * sa - q * ra,
                  vr,
                  vi
                );
                H[i][n - 1] = cdivres[0];
                H[i][n] = cdivres[1];
                if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
                  H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;
                  H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;
                } else {
                  cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);
                  H[i + 1][n - 1] = cdivres[0];
                  H[i + 1][n] = cdivres[1];
                }
              }

              t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));
              if (eps * t * t > 1) {
                for (j = i; j <= n; j++) {
                  H[j][n - 1] = H[j][n - 1] / t;
                  H[j][n] = H[j][n] / t;
                }
              }
            }
          }
        }
      }

      for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
          for (j = i; j < nn; j++) {
            V[i][j] = H[i][j];
          }
        }
      }

      for (j = nn - 1; j >= low; j--) {
        for (i = low; i <= high; i++) {
          z = 0;
          for (k = low; k <= Math.min(j, high); k++) {
            z = z + V[i][k] * H[k][j];
          }
          V[i][j] = z;
        }
      }
    }

    function cdiv(xr, xi, yr, yi) {
      var r, d;
      if (Math.abs(yr) > Math.abs(yi)) {
        r = yi / yr;
        d = yr + r * yi;
        return [(xr + r * xi) / d, (xi - r * xr) / d];
      } else {
        r = yr / yi;
        d = yi + r * yr;
        return [(r * xr + xi) / d, (r * xi - xr) / d];
      }
    }

    /**
     * @class CholeskyDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs
     * @param {Matrix} value
     */
    class CholeskyDecomposition {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        if (!value.isSymmetric()) {
          throw new Error('Matrix is not symmetric');
        }

        var a = value;
        var dimension = a.rows;
        var l = new Matrix(dimension, dimension);
        var positiveDefinite = true;
        var i, j, k;

        for (j = 0; j < dimension; j++) {
          var Lrowj = l[j];
          var d = 0;
          for (k = 0; k < j; k++) {
            var Lrowk = l[k];
            var s = 0;
            for (i = 0; i < k; i++) {
              s += Lrowk[i] * Lrowj[i];
            }
            Lrowj[k] = s = (a.get(j, k) - s) / l[k][k];
            d = d + s * s;
          }

          d = a.get(j, j) - d;

          positiveDefinite &= d > 0;
          l[j][j] = Math.sqrt(Math.max(d, 0));
          for (k = j + 1; k < dimension; k++) {
            l[j][k] = 0;
          }
        }

        if (!positiveDefinite) {
          throw new Error('Matrix is not positive definite');
        }

        this.L = l;
      }

      /**
       *
       * @param {Matrix} value
       * @return {Matrix}
       */
      solve(value) {
        value = WrapperMatrix2D.checkMatrix(value);

        var l = this.L;
        var dimension = l.rows;

        if (value.rows !== dimension) {
          throw new Error('Matrix dimensions do not match');
        }

        var count = value.columns;
        var B = value.clone();
        var i, j, k;

        for (k = 0; k < dimension; k++) {
          for (j = 0; j < count; j++) {
            for (i = 0; i < k; i++) {
              B[k][j] -= B[i][j] * l[k][i];
            }
            B[k][j] /= l[k][k];
          }
        }

        for (k = dimension - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            for (i = k + 1; i < dimension; i++) {
              B[k][j] -= B[i][j] * l[i][k];
            }
            B[k][j] /= l[k][k];
          }
        }

        return B;
      }

      /**
       *
       * @return {Matrix}
       */
      get lowerTriangularMatrix() {
        return this.L;
      }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var func$3 = Symbol('func');
    var validate = Symbol('validate');

    var symbols$1 = {
    	func: func$3,
    	validate: validate
    };

    const { func: func$2 } = symbols$1;

    const numberPredicates = {
      positive: (value) => (value > 0),
      negative: (value) => (value < 0),
      nonNegative: (value) => (value >= 0),
      integer: (value) => (value === (value | 0)),

      [func$2]: {
        is: (fn) => fn,
        eq: (v) => (value) => (value === v),
        gt: (v) => (value) => (value > v),
        gte: (v) => (value) => (value >= v),
        lt: (v) => (value) => (value < v),
        lte: (v) => (value) => (value <= v)
      }
    };

    var number$4 = {
      predicates: numberPredicates,
      validator: (value) => {
        return typeof value === 'number'
      }
    };

    const { func: func$1 } = symbols$1;

    const stringPredicates = {
      empty: (value) => (value === ''),
      nonEmpty: (value) => (value !== ''),

      [func$1]: {
        is: (fn) => fn,
        eq: (v) => (value) => (value === v),
        length: (v) => (value) => (value.length === v),
        minLength: (v) => (value) => (value.length >= v),
        maxLength: (v) => (value) => (value.length <= v),
        matches: (v) => (value) => v.test(value),
        startsWith: (v) => (value) => value.startsWith(v),
        endsWith: (v) => (value) => value.endsWith(v)
      }
    };

    var string = {
      predicates: stringPredicates,
      validator: (value) => {
        return typeof value === 'string'
      }
    };

    const { func } = symbols$1;

    const objectPredicates = {
      plain: (value) => {
        if (typeof value !== 'object') return false

        const proto = Object.getPrototypeOf(value);
        return proto === null || proto === Object.getPrototypeOf({})
      },
      empty: (value) => Object.keys(value).length === 0,
      nonEmpty: (value) => Object.keys(value).length > 0,

      [func]: {
        is: (fn) => fn,
        instanceOf: (v) => (value) => (value instanceof v)
      }
    };

    var object$2 = {
      predicates: objectPredicates,
      validator: (value) => {
        return typeof value === 'object'
      }
    };

    const typePredicates = {
      number: number$4,
      string,
      object: object$2
    };

    const createOw = ({
      validators = [],
      predicates = typePredicates,
      type = null
    } = { }) => {
      const ow = new Proxy(function () { }, {
        get: (obj, key) => {
          if (key === symbols$1.validate) {
            return (value, label = 'argument') => {
              if (!type) {
                return new Error('missing required type specifier')
              }

              for (let i = 0; i < validators.length; ++i) {
                const validator = validators[i];
                const result = validator.fn(value);

                if (!result) {
                  if (i === 0) {
                    throw new Error(`Expected ${label} \`${value}\` to be of type \`${type}\`, but received type \`${typeof value}\``)
                  } else {
                    throw new Error(`Expected ${type} \`${label}\` \`${value}\` failed predicate \`${validator.key}\``)
                  }
                }
              }
            }
          }

          const predicate = predicates[key];

          if (predicate) {
            if (typeof predicate === 'function') {
              validators.push({
                key,
                fn: predicate
              });

              return ow
            } else {
              return createOw({
                type: key,
                validators: [
                  {
                    key,
                    fn: predicate.validator
                  }
                ],
                predicates: predicate.predicates
              })
            }
          } else {
            const fn = predicates[symbols$1.func] && predicates[symbols$1.func][key];

            if (fn) {
              return new Proxy(function () { }, {
                get: () => {
                  throw new Error(`invalid use of functional predicate "${key}"`)
                },

                apply: (obj, thisArg, args) => {
                  validators.push({
                    key,
                    fn: fn(...args)
                  });

                  return ow
                }
              })
            } else {
              if (key === 'default' || key === '__esModule') {
                return ow
              }

              return ow
              // throw new Error(`unrecognized predicate "${key}"`)
            }
          }
        },

        apply: (obj, thisArg, args) => {
          if (args.length !== 2 && args.length !== 3) {
            throw new Error('invalid number of arguments to "ow"')
          } else {
            args[1][symbols$1.validate](args[0], args[2]);
          }
        }
      });

      return ow
    };

    var owLite = createOw();

    var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var RNG = function () {
      function RNG() {
        _classCallCheck$1(this, RNG);
      }

      _createClass$1(RNG, [{
        key: 'next',
        value: function next() {
          throw new Error('RNG.next must be overridden');
        }
      }, {
        key: 'seed',
        value: function seed(_seed, opts) {
          throw new Error('RNG.seed must be overridden');
        }
      }, {
        key: 'clone',
        value: function clone(seed, opts) {
          throw new Error('RNG.clone must be overridden');
        }
      }, {
        key: '_seed',
        value: function _seed(seed, opts) {
          // TODO: add entropy and stuff

          if (seed === (seed | 0)) {
            return seed;
          } else {
            var strSeed = '' + seed;
            var s = 0;

            for (var k = 0; k < strSeed.length; ++k) {
              s ^= strSeed.charCodeAt(k) | 0;
            }

            return s;
          }
        }
      }, {
        key: 'name',
        get: function get() {
          throw new Error('RNG.name must be overridden');
        }
      }]);

      return RNG;
    }();

    var _default$g = RNG;


    var rng = /*#__PURE__*/Object.defineProperty({
    	default: _default$g
    }, '__esModule', {value: true});

    var alea = createCommonjsModule(function (module) {
    // A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
    // http://baagoe.com/en/RandomMusings/javascript/
    // https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
    // Original work is under MIT license -

    // Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.



    (function(global, module, define) {

    function Alea(seed) {
      var me = this, mash = Mash();

      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };

      // Apply the seeding algorithm from Baagoe.
      me.c = 1;
      me.s0 = mash(' ');
      me.s1 = mash(' ');
      me.s2 = mash(' ');
      me.s0 -= mash(seed);
      if (me.s0 < 0) { me.s0 += 1; }
      me.s1 -= mash(seed);
      if (me.s1 < 0) { me.s1 += 1; }
      me.s2 -= mash(seed);
      if (me.s2 < 0) { me.s2 += 1; }
      mash = null;
    }

    function copy(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }

    function impl(seed, opts) {
      var xg = new Alea(seed),
          state = opts && opts.state,
          prng = xg.next;
      prng.int32 = function() { return (xg.next() * 0x100000000) | 0; };
      prng.double = function() {
        return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
      };
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    function Mash() {
      var n = 0xefc8249d;

      var mash = function(data) {
        data = String(data);
        for (var i = 0; i < data.length; i++) {
          n += data.charCodeAt(i);
          var h = 0.02519603282416938 * n;
          n = h >>> 0;
          h -= n;
          h *= n;
          n = h >>> 0;
          h -= n;
          n += h * 0x100000000; // 2^32
        }
        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
      };

      return mash;
    }


    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.alea = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xor128 = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xor128" prng algorithm by
    // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;

      // Set up generator function.
      me.next = function() {
        var t = me.x ^ (me.x << 11);
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
      };

      if (seed === (seed | 0)) {
        // Integer seed.
        me.x = seed;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }

    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }

    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xor128 = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xorwow = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xorwow" prng algorithm by
    // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      // Set up generator function.
      me.next = function() {
        var t = (me.x ^ (me.x >>> 2));
        me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
        return (me.d = (me.d + 362437 | 0)) +
           (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
      };

      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;

      if (seed === (seed | 0)) {
        // Integer seed.
        me.x = seed;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }

    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }

    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xorwow = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xorshift7 = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xorshift7" algorithm by
    // Franois Panneton and Pierre L'ecuyer:
    // "On the Xorgshift Random Number Generators"
    // http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this;

      // Set up generator function.
      me.next = function() {
        // Update xor generator.
        var X = me.x, i = me.i, t, v;
        t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
        t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
        t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
        t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
        t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
        X[i] = v;
        me.i = (i + 1) & 7;
        return v;
      };

      function init(me, seed) {
        var j, X = [];

        if (seed === (seed | 0)) {
          // Seed state array using a 32-bit integer.
          X[0] = seed;
        } else {
          // Seed state using a string.
          seed = '' + seed;
          for (j = 0; j < seed.length; ++j) {
            X[j & 7] = (X[j & 7] << 15) ^
                (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
          }
        }
        // Enforce an array length of 8, not all zeroes.
        while (X.length < 8) X.push(0);
        for (j = 0; j < 8 && X[j] === 0; ++j);
        if (j == 8) X[7] = -1;

        me.x = X;
        me.i = 0;

        // Discard an initial 256 values.
        for (j = 256; j > 0; --j) {
          me.next();
        }
      }

      init(me, seed);
    }

    function copy(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }

    function impl(seed, opts) {
      if (seed == null) seed = +(new Date);
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.x) copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xorshift7 = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xor4096 = createCommonjsModule(function (module) {
    // A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
    //
    // This fast non-cryptographic random number generator is designed for
    // use in Monte-Carlo algorithms. It combines a long-period xorshift
    // generator with a Weyl generator, and it passes all common batteries
    // of stasticial tests for randomness while consuming only a few nanoseconds
    // for each prng generated.  For background on the generator, see Brent's
    // paper: "Some long-period random number generators using shifts and xors."
    // http://arxiv.org/pdf/1004.3115v1.pdf
    //
    // Usage:
    //
    // var xor4096 = require('xor4096');
    // random = xor4096(1);                        // Seed with int32 or string.
    // assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
    // assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
    //
    // For nonzero numeric keys, this impelementation provides a sequence
    // identical to that by Brent's xorgens 3 implementaion in C.  This
    // implementation also provides for initalizing the generator with
    // string seeds, or for saving and restoring the state of the generator.
    //
    // On Chrome, this prng benchmarks about 2.1 times slower than
    // Javascript's built-in Math.random().

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this;

      // Set up generator function.
      me.next = function() {
        var w = me.w,
            X = me.X, i = me.i, t, v;
        // Update Weyl generator.
        me.w = w = (w + 0x61c88647) | 0;
        // Update xor generator.
        v = X[(i + 34) & 127];
        t = X[i = ((i + 1) & 127)];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        // Update Xor generator array state.
        v = X[i] = v ^ t;
        me.i = i;
        // Result is the combination.
        return (v + (w ^ (w >>> 16))) | 0;
      };

      function init(me, seed) {
        var t, v, i, j, w, X = [], limit = 128;
        if (seed === (seed | 0)) {
          // Numeric seeds initialize v, which is used to generates X.
          v = seed;
          seed = null;
        } else {
          // String seeds are mixed into v and X one character at a time.
          seed = seed + '\0';
          v = 0;
          limit = Math.max(limit, seed.length);
        }
        // Initialize circular array and weyl value.
        for (i = 0, j = -32; j < limit; ++j) {
          // Put the unicode characters into the array, and shuffle them.
          if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
          // After 32 shuffles, take v as the starting w value.
          if (j === 0) w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = (w + 0x61c88647) | 0;     // Weyl.
            t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
            i = (0 == t) ? i + 1 : 0;     // Count zeroes.
          }
        }
        // We have detected all zeroes; make the key nonzero.
        if (i >= 128) {
          X[(seed && seed.length || 0) & 127] = -1;
        }
        // Run the generator 512 times to further mix the state before using it.
        // Factoring this as a function slows the main generator, so it is just
        // unrolled here.  The weyl generator is not advanced while warming up.
        i = 127;
        for (j = 4 * 128; j > 0; --j) {
          v = X[(i + 34) & 127];
          t = X[i = ((i + 1) & 127)];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i] = v ^ t;
        }
        // Storing state as object members is faster than using closure variables.
        me.w = w;
        me.X = X;
        me.i = i;
      }

      init(me, seed);
    }

    function copy(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null) seed = +(new Date);
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.X) copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xor4096 = impl;
    }

    })(
      commonjsGlobal,                                     // window object or global
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var tychei = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "Tyche-i" prng algorithm by
    // Samuel Neves and Filipe Araujo.
    // See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      // Set up generator function.
      me.next = function() {
        var b = me.b, c = me.c, d = me.d, a = me.a;
        b = (b << 25) ^ (b >>> 7) ^ c;
        c = (c - d) | 0;
        d = (d << 24) ^ (d >>> 8) ^ a;
        a = (a - b) | 0;
        me.b = b = (b << 20) ^ (b >>> 12) ^ c;
        me.c = c = (c - d) | 0;
        me.d = (d << 16) ^ (c >>> 16) ^ a;
        return me.a = (a - b) | 0;
      };

      /* The following is non-inverted tyche, which has better internal
       * bit diffusion, but which is about 25% slower than tyche-i in JS.
      me.next = function() {
        var a = me.a, b = me.b, c = me.c, d = me.d;
        a = (me.a + me.b | 0) >>> 0;
        d = me.d ^ a; d = d << 16 ^ d >>> 16;
        c = me.c + d | 0;
        b = me.b ^ c; b = b << 12 ^ d >>> 20;
        me.a = a = a + b | 0;
        d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
        me.c = c = c + d | 0;
        b = b ^ c;
        return me.b = (b << 7 ^ b >>> 25);
      }
      */

      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;

      if (seed === Math.floor(seed)) {
        // Integer seed.
        me.a = (seed / 0x100000000) | 0;
        me.b = seed | 0;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }

    function copy(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.tychei = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

    /*
    Copyright 2019 David Bau.

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    */

    var seedrandom$1 = createCommonjsModule(function (module) {
    (function (global, pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //

    var width = 256,        // each RC4 output is 0 <= x < 256
        chunks = 6,         // at least six RC4 outputs for each double
        digits = 52,        // there are 52 significant digits in a double
        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks),
        significance = math.pow(2, digits),
        overflow = significance * 2,
        mask = width - 1,
        nodecrypto;         // node.js crypto module, initialized at the bottom.

    //
    // seedrandom()
    // This is the seedrandom function described above.
    //
    function seedrandom(seed, options, callback) {
      var key = [];
      options = (options == true) ? { entropy: true } : (options || {});

      // Flatten the seed string or build one from local entropy if needed.
      var shortseed = mixkey(flatten(
        options.entropy ? [seed, tostring(pool)] :
        (seed == null) ? autoseed() : seed, 3), key);

      // Use the seed to initialize an ARC4 generator.
      var arc4 = new ARC4(key);

      // This function returns a random double in [0, 1) that contains
      // randomness in every bit of the mantissa of the IEEE 754 value.
      var prng = function() {
        var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
            d = startdenom,                 //   and denominator d = 2 ^ 48.
            x = 0;                          //   and no 'extra last byte'.
        while (n < significance) {          // Fill up all significant digits by
          n = (n + x) * width;              //   shifting numerator and
          d *= width;                       //   denominator and generating a
          x = arc4.g(1);                    //   new least-significant-byte.
        }
        while (n >= overflow) {             // To avoid rounding up, before adding
          n /= 2;                           //   last byte, shift everything
          d /= 2;                           //   right using integer math until
          x >>>= 1;                         //   we have exactly the desired bits.
        }
        return (n + x) / d;                 // Form the number within [0, 1).
      };

      prng.int32 = function() { return arc4.g(4) | 0; };
      prng.quick = function() { return arc4.g(4) / 0x100000000; };
      prng.double = prng;

      // Mix the randomness into accumulated entropy.
      mixkey(tostring(arc4.S), pool);

      // Calling convention: what to return as a function of prng, seed, is_math.
      return (options.pass || callback ||
          function(prng, seed, is_math_call, state) {
            if (state) {
              // Load the arc4 state from the given state if it has an S array.
              if (state.S) { copy(state, arc4); }
              // Only provide the .state method if requested via options.state.
              prng.state = function() { return copy(arc4, {}); };
            }

            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) { math[rngname] = prng; return seed; }

            // Otherwise, it is a newer calling convention, so return the
            // prng directly.
            else return prng;
          })(
      prng,
      shortseed,
      'global' in options ? options.global : (this == math),
      options.state);
    }

    //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
    function ARC4(key) {
      var t, keylen = key.length,
          me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

      // The empty key [] is treated as [0].
      if (!keylen) { key = [keylen++]; }

      // Set up S using the standard key scheduling algorithm.
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0; i < width; i++) {
        s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
        s[j] = t;
      }

      // The "g" method returns the next (count) outputs as one number.
      (me.g = function(count) {
        // Using instance members instead of closure state nearly doubles speed.
        var t, r = 0,
            i = me.i, j = me.j, s = me.S;
        while (count--) {
          t = s[i = mask & (i + 1)];
          r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
        }
        me.i = i; me.j = j;
        return r;
        // For robust unpredictability, the function call below automatically
        // discards an initial batch of values.  This is called RC4-drop[256].
        // See http://google.com/search?q=rsa+fluhrer+response&btnI
      })(width);
    }

    //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //
    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //
    function flatten(obj, depth) {
      var result = [], typ = (typeof obj), prop;
      if (depth && typ == 'object') {
        for (prop in obj) {
          try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
        }
      }
      return (result.length ? result : typ == 'string' ? obj : obj + '\0');
    }

    //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //
    function mixkey(seed, key) {
      var stringseed = seed + '', smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] =
          mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
      }
      return tostring(key);
    }

    //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          // The use of 'out' to remember randomBytes makes tight minified code.
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global.crypto || global.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e) {
        var browser = global.navigator,
            plugins = browser && browser.plugins;
        return [+new Date, global, plugins, global.screen, tostring(pool)];
      }
    }

    //
    // tostring()
    // Converts an array of charcodes to a string
    //
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }

    //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //
    mixkey(math.random(), pool);

    //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //
    if (module.exports) {
      module.exports = seedrandom;
      // When in node.js, try using crypto package for autoseeding.
      try {
        nodecrypto = require$$0;
      } catch (ex) {}
    } else {
      // When included as a plain script, set up Math.seedrandom global.
      math['seed' + rngname] = seedrandom;
    }


    // End anonymous scope, and pass initial values.
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      (typeof self !== 'undefined') ? self : commonjsGlobal,
      [],     // pool: entropy pool starts empty
      Math    // math: package containing random, pow, and seedrandom
    );
    });

    // A library of seedable RNGs implemented in Javascript.
    //
    // Usage:
    //
    // var seedrandom = require('seedrandom');
    // var random = seedrandom(1); // or any seed.
    // var x = random();       // 0 <= x < 1.  Every bit is random.
    // var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

    // alea, a 53-bit multiply-with-carry generator by Johannes Baage.
    // Period: ~2^116
    // Reported to pass all BigCrush tests.


    // xor128, a pure xor-shift generator by George Marsaglia.
    // Period: 2^128-1.
    // Reported to fail: MatrixRank and LinearComp.


    // xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
    // Period: 2^192-2^32
    // Reported to fail: CollisionOver, SimpPoker, and LinearComp.


    // xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
    // a different approach: it adds robustness by allowing more shifts
    // than Marsaglia's original three.  It is a 7-shift generator
    // with 256 bits, that passes BigCrush with no systmatic failures.
    // Period 2^256-1.
    // No systematic BigCrush failures reported.


    // xor4096, by Richard Brent, is a 4096-bit xor-shift with a
    // very long period that also adds a Weyl generator. It also passes
    // BigCrush with no systematic failures.  Its long period may
    // be useful if you have many generators and need to avoid
    // collisions.
    // Period: 2^4128-2^32.
    // No systematic BigCrush failures reported.


    // Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
    // number generator derived from ChaCha, a modern stream cipher.
    // https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
    // Period: ~2^127
    // No systematic BigCrush failures reported.


    // The original ARC4-based prng included in this library.
    // Period: ~2^1600


    seedrandom$1.alea = alea;
    seedrandom$1.xor128 = xor128;
    seedrandom$1.xorwow = xorwow;
    seedrandom$1.xorshift7 = xorshift7;
    seedrandom$1.xor4096 = xor4096;
    seedrandom$1.tychei = tychei;

    var seedrandom = seedrandom$1;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



    var _owLite2$b = _interopRequireDefault$c(owLite);



    var _rng2$1 = _interopRequireDefault$c(rng);

    function _interopRequireDefault$c(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var RNGFunction = function (_RNG) {
      _inherits(RNGFunction, _RNG);

      function RNGFunction(thunk, opts) {
        _classCallCheck(this, RNGFunction);

        var _this = _possibleConstructorReturn(this, (RNGFunction.__proto__ || Object.getPrototypeOf(RNGFunction)).call(this));

        _this.seed(thunk, opts);
        return _this;
      }

      _createClass(RNGFunction, [{
        key: 'next',
        value: function next() {
          return this._rng();
        }
      }, {
        key: 'seed',
        value: function seed(thunk) {
          (0, _owLite2$b.default)(thunk, _owLite2$b.default.function);
          this._rng = thunk;
        }
      }, {
        key: 'clone',
        value: function clone() {
          for (var _len = arguments.length, opts = Array(_len), _key = 0; _key < _len; _key++) {
            opts[_key] = arguments[_key];
          }

          return new (Function.prototype.bind.apply(RNGFunction, [null].concat([this._rng], opts)))();
        }
      }, {
        key: 'name',
        get: function get() {
          return 'function';
        }
      }]);

      return RNGFunction;
    }(_rng2$1.default);

    var _default$f = RNGFunction;


    var _function = /*#__PURE__*/Object.defineProperty({
    	default: _default$f
    }, '__esModule', {value: true});

    var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



    var _seedrandom2 = _interopRequireDefault$b(seedrandom);



    var _rng2 = _interopRequireDefault$b(rng);



    var _function2 = _interopRequireDefault$b(_function);

    function _interopRequireDefault$b(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    var _default$e = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _args$ = args[0],
          arg0 = _args$ === undefined ? 'default' : _args$,
          rest = args.slice(1);


      switch (typeof arg0 === 'undefined' ? 'undefined' : _typeof$1(arg0)) {
        case 'object':
          if (arg0 instanceof _rng2.default) {
            return arg0;
          }
          break;

        case 'function':
          return new _function2.default(arg0);

        case 'string':
        case 'number':
          return new _function2.default(_seedrandom2.default.apply(undefined, _toConsumableArray(rest)));
      }

      throw new Error('invalid RNG "' + arg0 + '"');
    };


    var rngFactory = /*#__PURE__*/Object.defineProperty({
    	default: _default$e
    }, '__esModule', {value: true});

    var _owLite2$a = _interopRequireDefault$a(owLite);

    function _interopRequireDefault$a(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$d = function (random, min, max) {
      if (max === undefined) {
        max = min === undefined ? 1 : min;
        min = 0;
      }

      (0, _owLite2$a.default)(min, _owLite2$a.default.number);
      (0, _owLite2$a.default)(max, _owLite2$a.default.number);

      return function () {
        return random.next() * (max - min) + min;
      };
    };


    var uniform$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$d
    }, '__esModule', {value: true});

    var _owLite2$9 = _interopRequireDefault$9(owLite);

    function _interopRequireDefault$9(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$c = function (random, min, max) {
      if (max === undefined) {
        max = min === undefined ? 1 : min;
        min = 0;
      }

      (0, _owLite2$9.default)(min, _owLite2$9.default.number.integer);
      (0, _owLite2$9.default)(max, _owLite2$9.default.number.integer);

      return function () {
        return random.next() * (max - min + 1) + min | 0;
      };
    };


    var uniformInt = /*#__PURE__*/Object.defineProperty({
    	default: _default$c
    }, '__esModule', {value: true});

    var _default$b = function (random) {
      return function () {
        return random.next() >= 0.5;
      };
    };


    var uniformBoolean = /*#__PURE__*/Object.defineProperty({
    	default: _default$b
    }, '__esModule', {value: true});

    var _owLite2$8 = _interopRequireDefault$8(owLite);

    function _interopRequireDefault$8(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$a = function (random) {
      var mu = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var sigma = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      (0, _owLite2$8.default)(mu, _owLite2$8.default.number);
      (0, _owLite2$8.default)(sigma, _owLite2$8.default.number);

      return function () {
        var x = void 0,
            y = void 0,
            r = void 0;

        do {
          x = random.next() * 2 - 1;
          y = random.next() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);

        return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
      };
    };


    var normal$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$a
    }, '__esModule', {value: true});

    var _default$9 = function (random) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var normal = random.normal.apply(random, args);

      return function () {
        return Math.exp(normal());
      };
    };


    var logNormal$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$9
    }, '__esModule', {value: true});

    var _owLite2$7 = _interopRequireDefault$7(owLite);

    function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$8 = function (random) {
      var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

      (0, _owLite2$7.default)(p, _owLite2$7.default.number.gte(0).lt(1));

      return function () {
        return random.next() + p | 0;
      };
    };


    var bernoulli$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$8
    }, '__esModule', {value: true});

    var _owLite2$6 = _interopRequireDefault$6(owLite);

    function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$7 = function (random) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;

      (0, _owLite2$6.default)(n, _owLite2$6.default.number.positive.integer);
      (0, _owLite2$6.default)(p, _owLite2$6.default.number.gte(0).lte(1));

      return function () {
        var i = 0;
        var x = 0;

        while (i++ < n) {
          x += random.next() < p;
        }

        return x;
      };
    };


    var binomial$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$7
    }, '__esModule', {value: true});

    var _owLite2$5 = _interopRequireDefault$5(owLite);

    function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$6 = function (random) {
      var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

      (0, _owLite2$5.default)(p, _owLite2$5.default.number.gt(0).lte(1));
      var invLogP = 1.0 / Math.log(1.0 - p);

      return function () {
        return 1 + Math.log(random.next()) * invLogP | 0;
      };
    };


    var geometric$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$6
    }, '__esModule', {value: true});

    var _owLite2$4 = _interopRequireDefault$4(owLite);

    function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var logFactorialTable = [0.0, 0.0, 0.69314718055994529, 1.7917594692280550, 3.1780538303479458, 4.7874917427820458, 6.5792512120101012, 8.5251613610654147, 10.604602902745251, 12.801827480081469];

    var logFactorial = function logFactorial(k) {
      return logFactorialTable[k];
    };

    var logSqrt2PI = 0.91893853320467267;

    var _default$5 = function (random) {
      var lambda = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$4.default)(lambda, _owLite2$4.default.number.positive);

      if (lambda < 10) {
        // inversion method
        var expMean = Math.exp(-lambda);

        return function () {
          var p = expMean;
          var x = 0;
          var u = random.next();

          while (u > p) {
            u = u - p;
            p = lambda * p / ++x;
          }

          return x;
        };
      } else {
        // generative method
        var smu = Math.sqrt(lambda);
        var b = 0.931 + 2.53 * smu;
        var a = -0.059 + 0.02483 * b;
        var invAlpha = 1.1239 + 1.1328 / (b - 3.4);
        var vR = 0.9277 - 3.6224 / (b - 2);

        return function () {
          while (true) {
            var u = void 0;
            var v = random.next();

            if (v <= 0.86 * vR) {
              u = v / vR - 0.43;
              return Math.floor((2 * a / (0.5 - Math.abs(u)) + b) * u + lambda + 0.445);
            }

            if (v >= vR) {
              u = random.next() - 0.5;
            } else {
              u = v / vR - 0.93;
              u = (u < 0 ? -0.5 : 0.5) - u;
              v = random.next() * vR;
            }

            var us = 0.5 - Math.abs(u);
            if (us < 0.013 && v > us) {
              continue;
            }

            var k = Math.floor((2 * a / us + b) * u + lambda + 0.445) | 0;
            v = v * invAlpha / (a / (us * us) + b);

            if (k >= 10) {
              var t = (k + 0.5) * Math.log(lambda / k) - lambda - logSqrt2PI + k - (1 / 12.0 - (1 / 360.0 - 1 / (1260.0 * k * k)) / (k * k)) / k;

              if (Math.log(v * smu) <= t) {
                return k;
              }
            } else if (k >= 0) {
              if (Math.log(v) <= k * Math.log(lambda) - lambda - logFactorial(k)) {
                return k;
              }
            }
          }
        };
      }
    };


    var poisson$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$5
    }, '__esModule', {value: true});

    var _owLite2$3 = _interopRequireDefault$3(owLite);

    function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$4 = function (random) {
      var lambda = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$3.default)(lambda, _owLite2$3.default.number.positive);

      return function () {
        return -Math.log(1 - random.next()) / lambda;
      };
    };


    var exponential$2 = /*#__PURE__*/Object.defineProperty({
    	default: _default$4
    }, '__esModule', {value: true});

    var _owLite2$2 = _interopRequireDefault$2(owLite);

    function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$3 = function (random) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$2.default)(n, _owLite2$2.default.number.integer.gte(0));

      return function () {
        var sum = 0;
        for (var i = 0; i < n; ++i) {
          sum += random.next();
        }

        return sum;
      };
    };


    var irwinHall$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$3
    }, '__esModule', {value: true});

    var _owLite2$1 = _interopRequireDefault$1(owLite);

    function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$2 = function (random) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$1.default)(n, _owLite2$1.default.number.integer.positive);
      var irwinHall = random.irwinHall(n);

      return function () {
        return irwinHall() / n;
      };
    };


    var bates$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$2
    }, '__esModule', {value: true});

    var _owLite2 = _interopRequireDefault(owLite);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$1 = function (random) {
      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2.default)(alpha, _owLite2.default.number.gte(0));
      var invAlpha = 1.0 / alpha;

      return function () {
        return 1.0 / Math.pow(1.0 - random.next(), invAlpha);
      };
    };


    var pareto$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$1
    }, '__esModule', {value: true});

    var random$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RNGFactory = exports.RNG = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



    var _owLite2 = _interopRequireDefault(owLite);



    var _rng2 = _interopRequireDefault(rng);



    var _rngFactory2 = _interopRequireDefault(rngFactory);



    var _uniform3 = _interopRequireDefault(uniform$1);



    var _uniformInt3 = _interopRequireDefault(uniformInt);



    var _uniformBoolean3 = _interopRequireDefault(uniformBoolean);



    var _normal3 = _interopRequireDefault(normal$1);



    var _logNormal3 = _interopRequireDefault(logNormal$1);



    var _bernoulli3 = _interopRequireDefault(bernoulli$1);



    var _binomial3 = _interopRequireDefault(binomial$1);



    var _geometric3 = _interopRequireDefault(geometric$1);



    var _poisson3 = _interopRequireDefault(poisson$1);



    var _exponential3 = _interopRequireDefault(exponential$2);



    var _irwinHall3 = _interopRequireDefault(irwinHall$1);



    var _bates3 = _interopRequireDefault(bates$1);



    var _pareto3 = _interopRequireDefault(pareto$1);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    exports.RNG = _rng2.default;
    exports.RNGFactory = _rngFactory2.default;

    /**
     * Seedable random number generator supporting many common distributions.
     *
     * Defaults to Math.random as its underlying pseudorandom number generator.
     *
     * @name Random
     * @class
     *
     * @param {RNG|function} [rng=Math.random] - Underlying pseudorandom number generator.
     */

    var Random = function () {
      function Random(rng) {
        _classCallCheck(this, Random);

        if (rng) (0, _owLite2.default)(rng, _owLite2.default.object.instanceOf(_rng2.default));

        this._cache = {};
        this.use(rng);
      }

      /**
       * @member {RNG} Underlying pseudo-random number generator
       */


      _createClass(Random, [{
        key: 'clone',


        /**
         * Creates a new `Random` instance, optionally specifying parameters to
         * set a new seed.
         *
         * @see RNG.clone
         *
         * @param {string} [seed] - Optional seed for new RNG.
         * @param {object} [opts] - Optional config for new RNG options.
         * @return {Random}
         */
        value: function clone() {
          if (arguments.length) {
            return new Random(_rngFactory2.default.apply(undefined, arguments));
          } else {
            return new Random(this.rng.clone());
          }
        }

        /**
         * Sets the underlying pseudorandom number generator used via
         * either an instance of `seedrandom`, a custom instance of RNG
         * (for PRNG plugins), or a string specifying the PRNG to use
         * along with an optional `seed` and `opts` to initialize the
         * RNG.
         *
         * @example
         * const random = require('random')
         *
         * random.use('example_seedrandom_string')
         * // or
         * random.use(seedrandom('kittens'))
         * // or
         * random.use(Math.random)
         *
         * @param {...*} args
         */

      }, {
        key: 'use',
        value: function use() {
          this._rng = _rngFactory2.default.apply(undefined, arguments);
        }

        /**
         * Patches `Math.random` with this Random instance's PRNG.
         */

      }, {
        key: 'patch',
        value: function patch() {
          if (this._patch) {
            throw new Error('Math.random already patched');
          }

          this._patch = Math.random;
          Math.random = this.uniform();
        }

        /**
         * Restores a previously patched `Math.random` to its original value.
         */

      }, {
        key: 'unpatch',
        value: function unpatch() {
          if (this._patch) {
            Math.random = this._patch;
            delete this._patch;
          }
        }

        // --------------------------------------------------------------------------
        // Uniform utility functions
        // --------------------------------------------------------------------------

        /**
         * Convenience wrapper around `this.rng.next()`
         *
         * Returns a floating point number in [0, 1).
         *
         * @return {number}
         */

      }, {
        key: 'next',
        value: function next() {
          return this._rng.next();
        }

        /**
         * Samples a uniform random floating point number, optionally specifying
         * lower and upper bounds.
         *
         * Convence wrapper around `random.uniform()`
         *
         * @param {number} [min=0] - Lower bound (float, inclusive)
         * @param {number} [max=1] - Upper bound (float, exclusive)
         * @return {number}
         */

      }, {
        key: 'float',
        value: function float(min, max) {
          return this.uniform(min, max)();
        }

        /**
         * Samples a uniform random integer, optionally specifying lower and upper
         * bounds.
         *
         * Convence wrapper around `random.uniformInt()`
         *
         * @param {number} [min=0] - Lower bound (integer, inclusive)
         * @param {number} [max=1] - Upper bound (integer, inclusive)
         * @return {number}
         */

      }, {
        key: 'int',
        value: function int(min, max) {
          return this.uniformInt(min, max)();
        }

        /**
         * Samples a uniform random integer, optionally specifying lower and upper
         * bounds.
         *
         * Convence wrapper around `random.uniformInt()`
         *
         * @alias `random.int`
         *
         * @param {number} [min=0] - Lower bound (integer, inclusive)
         * @param {number} [max=1] - Upper bound (integer, inclusive)
         * @return {number}
         */

      }, {
        key: 'integer',
        value: function integer(min, max) {
          return this.uniformInt(min, max)();
        }

        /**
         * Samples a uniform random boolean value.
         *
         * Convence wrapper around `random.uniformBoolean()`
         *
         * @alias `random.boolean`
         *
         * @return {boolean}
         */

      }, {
        key: 'bool',
        value: function bool() {
          return this.uniformBoolean()();
        }

        /**
         * Samples a uniform random boolean value.
         *
         * Convence wrapper around `random.uniformBoolean()`
         *
         * @return {boolean}
         */

      }, {
        key: 'boolean',
        value: function boolean() {
          return this.uniformBoolean()();
        }

        // --------------------------------------------------------------------------
        // Uniform distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Continuous uniform distribution](https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)).
         *
         * @param {number} [min=0] - Lower bound (float, inclusive)
         * @param {number} [max=1] - Upper bound (float, exclusive)
         * @return {function}
         */

      }, {
        key: 'uniform',
        value: function uniform(min, max) {
          return this._memoize('uniform', _uniform3.default, min, max);
        }

        /**
         * Generates a [Discrete uniform distribution](https://en.wikipedia.org/wiki/Discrete_uniform_distribution).
         *
         * @param {number} [min=0] - Lower bound (integer, inclusive)
         * @param {number} [max=1] - Upper bound (integer, inclusive)
         * @return {function}
         */

      }, {
        key: 'uniformInt',
        value: function uniformInt(min, max) {
          return this._memoize('uniformInt', _uniformInt3.default, min, max);
        }

        /**
         * Generates a [Discrete uniform distribution](https://en.wikipedia.org/wiki/Discrete_uniform_distribution),
         * with two possible outcomes, `true` or `false.
         *
         * This method is analogous to flipping a coin.
         *
         * @return {function}
         */

      }, {
        key: 'uniformBoolean',
        value: function uniformBoolean() {
          return this._memoize('uniformBoolean', _uniformBoolean3.default);
        }

        // --------------------------------------------------------------------------
        // Normal distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Normal distribution](https://en.wikipedia.org/wiki/Normal_distribution).
         *
         * @param {number} [mu=0] - Mean
         * @param {number} [sigma=1] - Standard deviation
         * @return {function}
         */

      }, {
        key: 'normal',
        value: function normal(mu, sigma) {
          return (0, _normal3.default)(this, mu, sigma);
        }

        /**
         * Generates a [Log-normal distribution](https://en.wikipedia.org/wiki/Log-normal_distribution).
         *
         * @param {number} [mu=0] - Mean of underlying normal distribution
         * @param {number} [sigma=1] - Standard deviation of underlying normal distribution
         * @return {function}
         */

      }, {
        key: 'logNormal',
        value: function logNormal(mu, sigma) {
          return (0, _logNormal3.default)(this, mu, sigma);
        }

        // --------------------------------------------------------------------------
        // Bernoulli distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution).
         *
         * @param {number} [p=0.5] - Success probability of each trial.
         * @return {function}
         */

      }, {
        key: 'bernoulli',
        value: function bernoulli(p) {
          return (0, _bernoulli3.default)(this, p);
        }

        /**
         * Generates a [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution).
         *
         * @param {number} [n=1] - Number of trials.
         * @param {number} [p=0.5] - Success probability of each trial.
         * @return {function}
         */

      }, {
        key: 'binomial',
        value: function binomial(n, p) {
          return (0, _binomial3.default)(this, n, p);
        }

        /**
         * Generates a [Geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution).
         *
         * @param {number} [p=0.5] - Success probability of each trial.
         * @return {function}
         */

      }, {
        key: 'geometric',
        value: function geometric(p) {
          return (0, _geometric3.default)(this, p);
        }

        // --------------------------------------------------------------------------
        // Poisson distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution).
         *
         * @param {number} [lambda=1] - Mean (lambda > 0)
         * @return {function}
         */

      }, {
        key: 'poisson',
        value: function poisson(lambda) {
          return (0, _poisson3.default)(this, lambda);
        }

        /**
         * Generates an [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution).
         *
         * @param {number} [lambda=1] - Inverse mean (lambda > 0)
         * @return {function}
         */

      }, {
        key: 'exponential',
        value: function exponential(lambda) {
          return (0, _exponential3.default)(this, lambda);
        }

        // --------------------------------------------------------------------------
        // Misc distributions
        // --------------------------------------------------------------------------

        /**
         * Generates an [Irwin Hall distribution](https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution).
         *
         * @param {number} [n=1] - Number of uniform samples to sum (n >= 0)
         * @return {function}
         */

      }, {
        key: 'irwinHall',
        value: function irwinHall(n) {
          return (0, _irwinHall3.default)(this, n);
        }

        /**
         * Generates a [Bates distribution](https://en.wikipedia.org/wiki/Bates_distribution).
         *
         * @param {number} [n=1] - Number of uniform samples to average (n >= 1)
         * @return {function}
         */

      }, {
        key: 'bates',
        value: function bates(n) {
          return (0, _bates3.default)(this, n);
        }

        /**
         * Generates a [Pareto distribution](https://en.wikipedia.org/wiki/Pareto_distribution).
         *
         * @param {number} [alpha=1] - Alpha
         * @return {function}
         */

      }, {
        key: 'pareto',
        value: function pareto(alpha) {
          return (0, _pareto3.default)(this, alpha);
        }

        // --------------------------------------------------------------------------
        // Internal
        // --------------------------------------------------------------------------

        /**
         * Memoizes distributions to ensure they're only created when necessary.
         *
         * Returns a thunk which that returns independent, identically distributed
         * samples from the specified distribution.
         *
         * @private
         *
         * @param {string} label - Name of distribution
         * @param {function} getter - Function which generates a new distribution
         * @param {...*} args - Distribution-specific arguments
         *
         * @return {function}
         */

      }, {
        key: '_memoize',
        value: function _memoize(label, getter) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          var key = '' + args.join(';');
          var value = this._cache[label];

          if (value === undefined || value.key !== key) {
            value = { key: key, distribution: getter.apply(undefined, [this].concat(args)) };
            this._cache[label] = value;
          }

          return value.distribution;
        }
      }, {
        key: 'rng',
        get: function get() {
          return this._rng;
        }
      }]);

      return Random;
    }();

    // defaults to Math.random as its RNG


    exports.default = new Random();

    });

    var random = random$1.default;

    class Gaussian {
      constructor(mean, cov) {
        // TODO: Consider saving the dimension
        if ((mean instanceof Matrix) && (cov instanceof Matrix)) {
          this.mean = mean;
          this.cov = cov;
        } else {
          this.mean = new Matrix([mean]).transpose();
          this.cov = new Matrix(cov);
        }
      }

      at(x) {
        const diff = (new Matrix([x])).transpose().sub(this.mean);
        const n = diff.transpose().mmul(inverse(this.cov)).mmul(diff).mul(-0.5).exp();
        const d = Math.sqrt(Math.pow(2*Math.PI, this.mean.rows)*this.cov.det());
        return (n * (1 / d));
      }

      // idx is the first row of b
      marginalize(idx) {
        // FIXME: Rewrite with Array.slice() for speed
        const aMean = sliceMat(this.mean,0,0,idx,1);
        const bMean = sliceMat(this.mean,idx,0,this.mean.rows,1);
        const aCov = sliceMat(this.cov,0,0,idx,idx);
        const bCov = sliceMat(this.cov,idx,idx,this.mean.rows,this.mean.rows);
        return [new Gaussian(aMean, aCov), new Gaussian(bMean, bCov)];
      }

      // Also refer to: https://stats.stackexchange.com/questions/232959/simulating-the-posterior-of-a-gaussian-process
      // FIXME: Currently only works with \mu_e = 0
      condition(X) {
        const idx = X.length;
        const x0 = new Matrix([X]).transpose();
        const Exx = sliceMat(this.cov,0,0,idx,idx);
        const Exy = sliceMat(this.cov,0,idx,idx,this.mean.rows);
        const Eyx = Exy.transpose();
        const Eyy = sliceMat(this.cov,idx,idx,this.mean.rows,this.mean.rows);

        // Compute new zero
        const Lxx = new CholeskyDecomposition(Exx).lowerTriangularMatrix;
        const mLy = solve(Lxx, x0);
        const Lk = solve(Lxx, Exy);
        const condMean = Lk.transpose().mmul(mLy); // Hack

        // FIXME: Make this more performant (use cholesky and slove instead of inverse)
        const condCov = Eyy.sub(Eyx.mmul(inverse(Exx)).mmul(Exy));
        return new Gaussian(condMean, condCov);
      }

      // Uses Eigenvalue decomposition to compute t from Cov = tt^T
      transformationMatrix() {
        const e = new EigenvalueDecomposition(this.cov);
        const r = e.eigenvectorMatrix;
        const d = Matrix.zeros(r.rows, r.columns);
        for(let i = 0; i < d.rows; ++i) {
          d.set(i,i, Math.sqrt(e.realEigenvalues[i]));
        }
        return r.mmul(d);
      }

      sample() {
        const z = Matrix.zeros(this.mean.rows, 1);
        const normal = random.normal();
        for(let i = 0; i < this.mean.rows; ++i)
          z.set(i,0,normal());

        const samples = Matrix.add(this.mean, this.transformationMatrix().mmul(z));
        return samples;
      }

      getMean() {
        return this.mean.transpose()[0];
      }

      getSd() {
        return this.cov.diag().map(s2 => Math.sqrt(s2));
      }
    }

    // ranges from [i1,i2) & [j1,j2)
    function sliceMat(mat,i1,j1,i2,j2) {
      const result = new Matrix(i2-i1,j2-j1);
      for(let i = i1; i < i2; ++i) 
        for(let j = j1; j < j2; ++j) {
          result.set(i-i1, j-j1, mat.get(i,j)); 
        }
      return result;
    }

    class RBFKernel {
      constructor() {
        this.g = new Gaussian([0], [[1]]);
        this.scale = 1.0 / this.g.at([0]);
      }

      call(x1, x2) {
        return this.g.at([x1 - x2]) * this.scale;
      }

      // find +x solving call(0, x) = y
      inv0(y) {
        var sigma2 = this.get_sigma2();
        var ys = y / this.scale;
        const sspi = Math.sqrt(sigma2 * 2.0 * Math.PI);
        const dssq = -2.0 * sigma2; 
        var x = Math.sqrt(dssq * Math.log(ys * sspi));
        return x;
      }

      set_sigma(sigma) {
        this.g = new Gaussian([0], [[sigma * sigma]]);
        this.scale = 1.0 / this.g.at([0]);
      }

      get_sigma2() {
        return this.g.cov[0][0];
      }

      cuts(x, beg, end) {
        return [];
      }
    }

    class RBFShuffleKernel {
      constructor(cut_size) {
        this.g = new Gaussian([0], [[1]]);
        this.scale = 1.0 / this.g.at([0]);
        this.cut_size = cut_size;
      }

      call(x1, x2) {
        var c = this.cut_size;
        var d = Math.floor(x2 / c);
        var r = x2 - d * c;
        if (Math.abs(d % 2) == 1) 
          x2 += c - 2 * r;

        return this.g.at([x2 - x1]) * this.scale;
      }

      set_sigma(sigma) {
        this.g = new Gaussian([0], [[sigma * sigma]]);
        this.scale = 1.0 / this.g.at([0]);
      }

      get_sigma2() {
        return this.g.cov[0][0];
      }

      // return a list of points of discontinuity in [beg, end] for the
      // representer function of x
      cuts(x, beg, end) {
        var s = beg; 
        var p = [];
        while (s < end) {
          p.push(s);
          s += this.cut_size;
        }
        return p;
      }
    }

    function ascending$3(a, b) {
      return a == null || b == null ? NaN
        : a < b ? -1
        : a > b ? 1
        : a >= b ? 0
        : NaN;
    }

    function bisector(f) {
      let delta = f;
      let compare = f;

      if (f.length === 1) {
        delta = (d, x) => f(d) - x;
        compare = ascendingComparator(f);
      }

      function left(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          const mid = (lo + hi) >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      }

      function right(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          const mid = (lo + hi) >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }

      function center(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {left, center, right};
    }

    function ascendingComparator(f) {
      return (d, x) => ascending$3(f(d), x);
    }

    function number$3(x) {
      return x === null ? NaN : +x;
    }

    function* numbers(values, valueof) {
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            yield value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            yield value;
          }
        }
      }
    }

    const ascendingBisect = bisector(ascending$3);
    const bisectRight = ascendingBisect.right;
    const bisectLeft = ascendingBisect.left;
    const bisectCenter = bisector(number$3).center;

    function count$1(values, valueof) {
      let count = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count;
          }
        }
      }
      return count;
    }

    function length$3(array) {
      return array.length | 0;
    }

    function empty$2(length) {
      return !(length > 0);
    }

    function arrayify(values) {
      return typeof values !== "object" || "length" in values ? values : Array.from(values);
    }

    function reducer(reduce) {
      return values => reduce(...values);
    }

    function cross$2(...values) {
      const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
      values = values.map(arrayify);
      const lengths = values.map(length$3);
      const j = values.length - 1;
      const index = new Array(j + 1).fill(0);
      const product = [];
      if (j < 0 || lengths.some(empty$2)) return product;
      while (true) {
        product.push(index.map((j, i) => values[i][j]));
        let i = j;
        while (++index[i] === lengths[i]) {
          if (i === 0) return reduce ? product.map(reduce) : product;
          index[i--] = 0;
        }
      }
    }

    function cumsum(values, valueof) {
      var sum = 0, index = 0;
      return Float64Array.from(values, valueof === undefined
        ? v => (sum += +v || 0)
        : v => (sum += +valueof(v, index++, values) || 0));
    }

    function descending$2(a, b) {
      return a == null || b == null ? NaN
        : b < a ? -1
        : b > a ? 1
        : b >= a ? 0
        : NaN;
    }

    function variance(values, valueof) {
      let count = 0;
      let delta;
      let mean = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      }
      if (count > 1) return sum / (count - 1);
    }

    function deviation(values, valueof) {
      const v = variance(values, valueof);
      return v ? Math.sqrt(v) : v;
    }

    function extent$1(values, valueof) {
      let min;
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
      return [min, max];
    }

    // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
    class Adder {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
          if (lo) p[i++] = lo;
          x = hi;
        }
        p[i] = x;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x, y, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x = hi;
            y = p[--n];
            hi = x + y;
            lo = y - (hi - x);
            if (lo) break;
          }
          if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
            y = lo * 2;
            x = hi + y;
            if (y == x - hi) hi = x;
          }
        }
        return hi;
      }
    }

    function fsum(values, valueof) {
      const adder = new Adder();
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            adder.add(value);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            adder.add(value);
          }
        }
      }
      return +adder;
    }

    function fcumsum(values, valueof) {
      const adder = new Adder();
      let index = -1;
      return Float64Array.from(values, valueof === undefined
          ? v => adder.add(+v || 0)
          : v => adder.add(+valueof(v, ++index, values) || 0)
      );
    }

    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (entries != null) for (const [key, value] of entries) this.set(key, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }

    class InternSet extends Set {
      constructor(values, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (values != null) for (const value of values) this.add(value);
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    }

    function intern_get({_intern, _key}, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }

    function intern_set({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }

    function intern_delete({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(value);
        _intern.delete(key);
      }
      return value;
    }

    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function identity$9(x) {
      return x;
    }

    function group(values, ...keys) {
      return nest(values, identity$9, identity$9, keys);
    }

    function groups(values, ...keys) {
      return nest(values, Array.from, identity$9, keys);
    }

    function flatten$1(groups, keys) {
      for (let i = 1, n = keys.length; i < n; ++i) {
        groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));
      }
      return groups;
    }

    function flatGroup(values, ...keys) {
      return flatten$1(groups(values, ...keys), keys);
    }

    function flatRollup(values, reduce, ...keys) {
      return flatten$1(rollups(values, reduce, ...keys), keys);
    }

    function rollup(values, reduce, ...keys) {
      return nest(values, identity$9, reduce, keys);
    }

    function rollups(values, reduce, ...keys) {
      return nest(values, Array.from, reduce, keys);
    }

    function index$4(values, ...keys) {
      return nest(values, identity$9, unique, keys);
    }

    function indexes(values, ...keys) {
      return nest(values, Array.from, unique, keys);
    }

    function unique(values) {
      if (values.length !== 1) throw new Error("duplicate key");
      return values[0];
    }

    function nest(values, map, reduce, keys) {
      return (function regroup(values, i) {
        if (i >= keys.length) return reduce(values);
        const groups = new InternMap();
        const keyof = keys[i++];
        let index = -1;
        for (const value of values) {
          const key = keyof(value, ++index, values);
          const group = groups.get(key);
          if (group) group.push(value);
          else groups.set(key, [value]);
        }
        for (const [key, values] of groups) {
          groups.set(key, regroup(values, i));
        }
        return map(groups);
      })(values, 0);
    }

    function permute(source, keys) {
      return Array.from(keys, key => source[key]);
    }

    function sort(values, ...F) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      values = Array.from(values);
      let [f = ascending$3] = F;
      if (f.length === 1 || F.length > 1) {
        const index = Uint32Array.from(values, (d, i) => i);
        if (F.length > 1) {
          F = F.map(f => values.map(f));
          index.sort((i, j) => {
            for (const f of F) {
              const c = ascending$3(f[i], f[j]);
              if (c) return c;
            }
          });
        } else {
          f = values.map(f);
          index.sort((i, j) => ascending$3(f[i], f[j]));
        }
        return permute(values, index);
      }
      return values.sort(f);
    }

    function groupSort(values, reduce, key) {
      return (reduce.length === 1
        ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending$3(av, bv) || ascending$3(ak, bk)))
        : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending$3(ak, bk))))
        .map(([key]) => key);
    }

    var array$5 = Array.prototype;

    var slice$3 = array$5.slice;

    function constant$b(x) {
      return function() {
        return x;
      };
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        let r0 = Math.round(start / step), r1 = Math.round(stop / step);
        if (r0 * step < start) ++r0;
        if (r1 * step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.round(start * step), r1 = Math.round(stop * step);
        if (r0 / step < start) ++r0;
        if (r1 / step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function nice$1(start, stop, count) {
      let prestep;
      while (true) {
        const step = tickIncrement(start, stop, count);
        if (step === prestep || step === 0 || !isFinite(step)) {
          return [start, stop];
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        }
        prestep = step;
      }
    }

    function thresholdSturges(values) {
      return Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1;
    }

    function bin() {
      var value = identity$9,
          domain = extent$1,
          threshold = thresholdSturges;

      function histogram(data) {
        if (!Array.isArray(data)) data = Array.from(data);

        var i,
            n = data.length,
            x,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds, and nice the
        // default domain accordingly.
        if (!Array.isArray(tz)) {
          const max = x1, tn = +tz;
          if (domain === extent$1) [x0, x1] = nice$1(x0, x1, tn);
          tz = ticks(x0, x1, tn);

          // If the last threshold is coincident with the domains upper bound, the
          // last bin will be zero-width. If the default domain is used, and this
          // last threshold is coincident with the maximum input value, we can
          // extend the niced upper bound by one tick to ensure uniform bin widths;
          // otherwise, we simply remove the last threshold. Note that we dont
          // coerce values or the domain to numbers, and thus must be careful to
          // compare order (>=) rather than strict equality (===)!
          if (tz[tz.length - 1] >= x1) {
            if (max >= x1 && domain === extent$1) {
              const step = tickIncrement(x0, x1, tn);
              if (isFinite(step)) {
                if (step > 0) {
                  x1 = (Math.floor(x1 / step) + 1) * step;
                } else if (step < 0) {
                  x1 = (Math.ceil(x1 * -step) + 1) / -step;
                }
              }
            } else {
              tz.pop();
            }
          }
        }

        // Remove any thresholds outside the domain.
        var m = tz.length;
        while (tz[0] <= x0) tz.shift(), --m;
        while (tz[m - 1] > x1) tz.pop(), --m;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        for (i = 0; i < n; ++i) {
          x = values[i];
          if (x != null && x0 <= x && x <= x1) {
            bins[bisectRight(tz, x, 0, m)].push(data[i]);
          }
        }

        return bins;
      }

      histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$b(_), histogram) : value;
      };

      histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant$b([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$b(slice$3.call(_)) : constant$b(_), histogram) : threshold;
      };

      return histogram;
    }

    function max$3(values, valueof) {
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      }
      return max;
    }

    function min$2(values, valueof) {
      let min;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      }
      return min;
    }

    // Based on https://github.com/mourner/quickselect
    // ISC license, Copyright 2018 Vladimir Agafonkin.
    function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending$3) {
      while (right > left) {
        if (right - left > 600) {
          const n = right - left + 1;
          const m = k - left + 1;
          const z = Math.log(n);
          const s = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
          const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
          quickselect(array, k, newLeft, newRight, compare);
        }

        const t = array[k];
        let i = left;
        let j = right;

        swap$1(array, left, k);
        if (compare(array[right], t) > 0) swap$1(array, left, right);

        while (i < j) {
          swap$1(array, i, j), ++i, --j;
          while (compare(array[i], t) < 0) ++i;
          while (compare(array[j], t) > 0) --j;
        }

        if (compare(array[left], t) === 0) swap$1(array, left, j);
        else ++j, swap$1(array, j, right);

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
      }
      return array;
    }

    function swap$1(array, i, j) {
      const t = array[i];
      array[i] = array[j];
      array[j] = t;
    }

    function quantile$1(values, p, valueof) {
      values = Float64Array.from(numbers(values, valueof));
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return min$2(values);
      if (p >= 1) return max$3(values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = max$3(quickselect(values, i0).subarray(0, i0 + 1)),
          value1 = min$2(values.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileSorted(values, p, valueof = number$3) {
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
      if (p >= 1) return +valueof(values[n - 1], n - 1, values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    }

    function freedmanDiaconis(values, min, max) {
      return Math.ceil((max - min) / (2 * (quantile$1(values, 0.75) - quantile$1(values, 0.25)) * Math.pow(count$1(values), -1 / 3)));
    }

    function scott(values, min, max) {
      return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(count$1(values), -1 / 3)));
    }

    function maxIndex(values, valueof) {
      let max;
      let maxIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      }
      return maxIndex;
    }

    function mean(values, valueof) {
      let count = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      }
      if (count) return sum / count;
    }

    function median(values, valueof) {
      return quantile$1(values, 0.5, valueof);
    }

    function* flatten(arrays) {
      for (const array of arrays) {
        yield* array;
      }
    }

    function merge(arrays) {
      return Array.from(flatten(arrays));
    }

    function minIndex(values, valueof) {
      let min;
      let minIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      }
      return minIndex;
    }

    function mode(values, valueof) {
      const counts = new InternMap();
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      }
      let modeValue;
      let modeCount = 0;
      for (const [value, count] of counts) {
        if (count > modeCount) {
          modeCount = count;
          modeValue = value;
        }
      }
      return modeValue;
    }

    function pairs(values, pairof = pair) {
      const pairs = [];
      let previous;
      let first = false;
      for (const value of values) {
        if (first) pairs.push(pairof(previous, value));
        previous = value;
        first = true;
      }
      return pairs;
    }

    function pair(a, b) {
      return [a, b];
    }

    function range$2(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    function least(values, compare = ascending$3) {
      let min;
      let defined = false;
      if (compare.length === 1) {
        let minValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, minValue) < 0
              : ascending$3(value, value) === 0) {
            min = element;
            minValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, min) < 0
              : compare(value, value) === 0) {
            min = value;
            defined = true;
          }
        }
      }
      return min;
    }

    function leastIndex(values, compare = ascending$3) {
      if (compare.length === 1) return minIndex(values, compare);
      let minValue;
      let min = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (min < 0
            ? compare(value, value) === 0
            : compare(value, minValue) < 0) {
          minValue = value;
          min = index;
        }
      }
      return min;
    }

    function greatest(values, compare = ascending$3) {
      let max;
      let defined = false;
      if (compare.length === 1) {
        let maxValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, maxValue) > 0
              : ascending$3(value, value) === 0) {
            max = element;
            maxValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, max) > 0
              : compare(value, value) === 0) {
            max = value;
            defined = true;
          }
        }
      }
      return max;
    }

    function greatestIndex(values, compare = ascending$3) {
      if (compare.length === 1) return maxIndex(values, compare);
      let maxValue;
      let max = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (max < 0
            ? compare(value, value) === 0
            : compare(value, maxValue) > 0) {
          maxValue = value;
          max = index;
        }
      }
      return max;
    }

    function scan(values, compare) {
      const index = leastIndex(values, compare);
      return index < 0 ? undefined : index;
    }

    var shuffle$1 = shuffler(Math.random);

    function shuffler(random) {
      return function shuffle(array, i0 = 0, i1 = array.length) {
        let m = i1 - (i0 = +i0);
        while (m) {
          const i = random() * m-- | 0, t = array[m + i0];
          array[m + i0] = array[i + i0];
          array[i + i0] = t;
        }
        return array;
      };
    }

    function sum$2(values, valueof) {
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            sum += value;
          }
        }
      }
      return sum;
    }

    function transpose(matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min$2(matrix, length$2), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    }

    function length$2(d) {
      return d.length;
    }

    function zip() {
      return transpose(arguments);
    }

    function every(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (!test(value, ++index, values)) {
          return false;
        }
      }
      return true;
    }

    function some(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          return true;
        }
      }
      return false;
    }

    function filter$1(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      const array = [];
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          array.push(value);
        }
      }
      return array;
    }

    function map$1(values, mapper) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
      return Array.from(values, (value, index) => mapper(value, index, values));
    }

    function reduce(values, reducer, value) {
      if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
      const iterator = values[Symbol.iterator]();
      let done, next, index = -1;
      if (arguments.length < 3) {
        ({done, value} = iterator.next());
        if (done) return;
        ++index;
      }
      while (({done, value: next} = iterator.next()), !done) {
        value = reducer(value, next, ++index, values);
      }
      return value;
    }

    function reverse$1(values) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      return Array.from(values).reverse();
    }

    function difference(values, ...others) {
      values = new Set(values);
      for (const other of others) {
        for (const value of other) {
          values.delete(value);
        }
      }
      return values;
    }

    function disjoint(values, other) {
      const iterator = other[Symbol.iterator](), set = new Set();
      for (const v of values) {
        if (set.has(v)) return false;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) break;
          if (Object.is(v, value)) return false;
          set.add(value);
        }
      }
      return true;
    }

    function set$2(values) {
      return values instanceof Set ? values : new Set(values);
    }

    function intersection(values, ...others) {
      values = new Set(values);
      others = others.map(set$2);
      out: for (const value of values) {
        for (const other of others) {
          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      }
      return values;
    }

    function superset(values, other) {
      const iterator = values[Symbol.iterator](), set = new Set();
      for (const o of other) {
        if (set.has(o)) continue;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) return false;
          set.add(value);
          if (Object.is(o, value)) break;
        }
      }
      return true;
    }

    function subset(values, other) {
      return superset(other, values);
    }

    function union(...others) {
      const set = new Set();
      for (const other of others) {
        for (const o of other) {
          set.add(o);
        }
      }
      return set;
    }

    function identity$8(x) {
      return x;
    }

    var top = 1,
        right = 2,
        bottom = 3,
        left = 4,
        epsilon$6 = 1e-6;

    function translateX(x) {
      return "translate(" + x + ",0)";
    }

    function translateY(y) {
      return "translate(0," + y + ")";
    }

    function number$2(scale) {
      return d => +scale(d);
    }

    function center$1(scale, offset) {
      offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
      if (scale.round()) offset = Math.round(offset);
      return d => +scale(d) + offset;
    }

    function entering() {
      return !this.__axis;
    }

    function axis(orient, scale) {
      var tickArguments = [],
          tickValues = null,
          tickFormat = null,
          tickSizeInner = 6,
          tickSizeOuter = 6,
          tickPadding = 3,
          offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
          k = orient === top || orient === left ? -1 : 1,
          x = orient === left || orient === right ? "x" : "y",
          transform = orient === top || orient === bottom ? translateX : translateY;

      function axis(context) {
        var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
            format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8) : tickFormat,
            spacing = Math.max(tickSizeInner, 0) + tickPadding,
            range = scale.range(),
            range0 = +range[0] + offset,
            range1 = +range[range.length - 1] + offset,
            position = (scale.bandwidth ? center$1 : number$2)(scale.copy(), offset),
            selection = context.selection ? context.selection() : context,
            path = selection.selectAll(".domain").data([null]),
            tick = selection.selectAll(".tick").data(values, scale).order(),
            tickExit = tick.exit(),
            tickEnter = tick.enter().append("g").attr("class", "tick"),
            line = tick.select("line"),
            text = tick.select("text");

        path = path.merge(path.enter().insert("path", ".tick")
            .attr("class", "domain")
            .attr("stroke", "currentColor"));

        tick = tick.merge(tickEnter);

        line = line.merge(tickEnter.append("line")
            .attr("stroke", "currentColor")
            .attr(x + "2", k * tickSizeInner));

        text = text.merge(tickEnter.append("text")
            .attr("fill", "currentColor")
            .attr(x, k * spacing)
            .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

        if (context !== selection) {
          path = path.transition(context);
          tick = tick.transition(context);
          line = line.transition(context);
          text = text.transition(context);

          tickExit = tickExit.transition(context)
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

          tickEnter
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
        }

        tickExit.remove();

        path
            .attr("d", orient === left || orient === right
                ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
                : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

        tick
            .attr("opacity", 1)
            .attr("transform", function(d) { return transform(position(d) + offset); });

        line
            .attr(x + "2", k * tickSizeInner);

        text
            .attr(x, k * spacing)
            .text(format);

        selection.filter(entering)
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

        selection
            .each(function() { this.__axis = position; });
      }

      axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
      };

      axis.ticks = function() {
        return tickArguments = Array.from(arguments), axis;
      };

      axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
      };

      axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
      };

      axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
      };

      axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
      };

      axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
      };

      axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
      };

      axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
      };

      axis.offset = function(_) {
        return arguments.length ? (offset = +_, axis) : offset;
      };

      return axis;
    }

    function axisTop(scale) {
      return axis(top, scale);
    }

    function axisRight(scale) {
      return axis(right, scale);
    }

    function axisBottom(scale) {
      return axis(bottom, scale);
    }

    function axisLeft(scale) {
      return axis(left, scale);
    }

    var noop$4 = {value: () => {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames$1(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$1(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$4, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none$2() {}

    function selector(selector) {
      return selector == null ? none$2 : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we dont ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array$4(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty$1() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty$1 : function() {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function() {
        return array$4(select.apply(this, arguments));
      };
    }

    function selection_selectAll(select) {
      if (typeof select === "function") select = arrayAll(select);
      else select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function childMatcher(selector) {
      return function(node) {
        return node.matches(selector);
      };
    }

    var find$1 = Array.prototype.find;

    function childFind(match) {
      return function() {
        return find$1.call(this.children, match);
      };
    }

    function childFirst() {
      return this.firstElementChild;
    }

    function selection_selectChild(match) {
      return this.select(match == null ? childFirst
          : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter = Array.prototype.filter;

    function children() {
      return Array.from(this.children);
    }

    function childrenFilter(match) {
      return function() {
        return filter.call(this.children, match);
      };
    }

    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children
          : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$a(x) {
      return function() {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that dont fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = new Map,
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
          exit[i] = node;
        }
      }
    }

    function datum(node) {
      return node.__data__;
    }

    function selection_data(value, key) {
      if (!arguments.length) return Array.from(this, datum);

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$a(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isnt worried about live collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // dont; wed rather avoid a gratuitous copy.)
    function arraylike(data) {
      return typeof data === "object" && "length" in data
        ? data // Array, TypedArray, NodeList, array-like
        : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(context) {
      var selection = context.selection ? context.selection() : context;

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending$2;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending$2(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      return Array.from(this);
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      let size = 0;
      for (const node of this) ++size; // eslint-disable-line no-unused-vars
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }

    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, options) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root$1 = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root$1);
    }

    function selection_selection() {
      return this;
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root$1);
    }

    function create$1(name) {
      return select(creator(name).call(document.documentElement));
    }

    var nextId = 0;

    function local$1() {
      return new Local;
    }

    function Local() {
      this._ = "@" + (++nextId).toString(36);
    }

    Local.prototype = local$1.prototype = {
      constructor: Local,
      get: function(node) {
        var id = this._;
        while (!(id in node)) if (!(node = node.parentNode)) return;
        return node[id];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };

    function sourceEvent(event) {
      let sourceEvent;
      while (sourceEvent = event.sourceEvent) event = sourceEvent;
      return event;
    }

    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }

    function pointers(events, node) {
      if (events.target) { // i.e., instanceof Event, not TouchList or iterable
        events = sourceEvent(events);
        if (node === undefined) node = events.currentTarget;
        events = events.touches || [events];
      }
      return Array.from(events, event => pointer(event, node));
    }

    function selectAll(selector) {
      return typeof selector === "string"
          ? new Selection$1([document.querySelectorAll(selector)], [document.documentElement])
          : new Selection$1([array$4(selector)], root$1);
    }

    // These are typically used in conjunction with noevent to ensure that we can
    // preventDefault on the event.
    const nonpassive = {passive: false};
    const nonpassivecapture = {capture: true, passive: false};

    function nopropagation$2(event) {
      event.stopImmediatePropagation();
    }

    function noevent$2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable(view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent$2, nonpassivecapture);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$2, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent$2, nonpassivecapture);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var constant$9 = x => () => x;

    function DragEvent(type, {
      sourceEvent,
      subject,
      target,
      identifier,
      active,
      x, y, dx, dy,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        subject: {value: subject, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        identifier: {value: identifier, enumerable: true, configurable: true},
        active: {value: active, enumerable: true, configurable: true},
        x: {value: x, enumerable: true, configurable: true},
        y: {value: y, enumerable: true, configurable: true},
        dx: {value: dx, enumerable: true, configurable: true},
        dy: {value: dy, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$2(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(event, d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable$2() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
      var filter = defaultFilter$2,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable$2,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved, nonpassive)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned(event, d) {
        if (touchending || !filter.call(this, event, d)) return;
        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
        if (!gesture) return;
        select(event.view)
          .on("mousemove.drag", mousemoved, nonpassivecapture)
          .on("mouseup.drag", mouseupped, nonpassivecapture);
        dragDisable(event.view);
        nopropagation$2(event);
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start", event);
      }

      function mousemoved(event) {
        noevent$2(event);
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag", event);
      }

      function mouseupped(event) {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent$2(event);
        gestures.mouse("end", event);
      }

      function touchstarted(event, d) {
        if (!filter.call(this, event, d)) return;
        var touches = event.changedTouches,
            c = container.call(this, event, d),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
            nopropagation$2(event);
            gesture("start", event, touches[i]);
          }
        }
      }

      function touchmoved(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent$2(event);
            gesture("drag", event, touches[i]);
          }
        }
      }

      function touchended(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation$2(event);
            gesture("end", event, touches[i]);
          }
        }
      }

      function beforestart(that, container, event, d, identifier, touch) {
        var dispatch = listeners.copy(),
            p = pointer(touch || event, container), dx, dy,
            s;

        if ((s = subject.call(that, new DragEvent("beforestart", {
            sourceEvent: event,
            target: drag,
            identifier,
            active,
            x: p[0],
            y: p[1],
            dx: 0,
            dy: 0,
            dispatch
          }), d)) == null) return;

        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;

        return function gesture(type, event, touch) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[identifier] = gesture, n = active++; break;
            case "end": delete gestures[identifier], --active; // falls through
            case "drag": p = pointer(touch || event, container), n = active; break;
          }
          dispatch.call(
            type,
            that,
            new DragEvent(type, {
              sourceEvent: event,
              subject: s,
              target: drag,
              identifier,
              active: n,
              x: p[0] + dx,
              y: p[1] + dy,
              dx: p[0] - p0[0],
              dy: p[1] - p0[1],
              dispatch
            }),
            d
          );
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$9(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$9(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$9(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$9(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend$1(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color$1, {
      copy: function(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color$1(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color$1(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend$1(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color$1(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl$2(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl$2, extend$1(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    const radians$1 = Math.PI / 180;
    const degrees$2 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    const K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0$1 = 4 / 29,
        t1$1 = 6 / 29,
        t2 = 3 * t1$1 * t1$1,
        t3 = t1$1 * t1$1 * t1$1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function gray(l, opacity) {
      return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
    }

    function lab$1(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab$1, extend$1(Color, {
      brighter: function(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker: function(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb: function() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
    }

    function lab2xyz(t) {
      return t > t1$1 ? t * t * t : t2 * (t - t0$1);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * degrees$2;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function lch(l, c, h, opacity) {
      return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function hcl$2(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * radians$1;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl$2, extend$1(Color, {
      brighter: function(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker: function(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb: function() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B$1 = +1.78277,
        C = -0.29227,
        D$1 = -0.90649,
        E = +1.97294,
        ED = E * D$1,
        EB = E * B$1,
        BC_DA = B$1 * C - D$1 * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D$1,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * degrees$2 - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix$3(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix$3, extend$1(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians$1,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B$1 * sinh)),
          255 * (l + a * (C * cosh + D$1 * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function basis$1(t1, v0, v1, v2, v3) {
      var t2 = t1 * t1, t3 = t2 * t1;
      return ((1 - 3 * t1 + 3 * t2 - t3) * v0
          + (4 - 6 * t2 + 3 * t3) * v1
          + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
          + t3 * v3) / 6;
    }

    function basis$2(values) {
      var n = values.length - 1;
      return function(t) {
        var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function basisClosed$1(values) {
      var n = values.length;
      return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
            v0 = values[(i + n - 1) % n],
            v1 = values[i % n],
            v2 = values[(i + 1) % n],
            v3 = values[(i + 2) % n];
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    var constant$8 = x => () => x;

    function linear$2(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential$1(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue$1(a, b) {
      var d = b - a;
      return d ? linear$2(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$8(isNaN(a) ? b : a);
    }

    function gamma$1(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential$1(a, b, y) : constant$8(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$2(a, d) : constant$8(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma$1(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function rgbSpline(spline) {
      return function(colors) {
        var n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n),
            i, color;
        for (i = 0; i < n; ++i) {
          color = rgb(colors[i]);
          r[i] = color.r || 0;
          g[i] = color.g || 0;
          b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
          color.r = r(t);
          color.g = g(t);
          color.b = b(t);
          return color + "";
        };
      };
    }

    var rgbBasis = rgbSpline(basis$2);
    var rgbBasisClosed = rgbSpline(basisClosed$1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function array$3(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate$2(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date$1(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object$1(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate$2(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate$2(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$8(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color$1(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color$1 ? interpolateRgb
          : b instanceof Date ? date$1
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1
          : interpolateNumber)(a, b);
    }

    function discrete(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    function hue(a, b) {
      var i = hue$1(+a, +b);
      return function(t) {
        var x = i(t);
        return x - 360 * Math.floor(x / 360);
      };
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees$1 = 180 / Math.PI;

    var identity$7 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees$1,
        skewX: Math.atan(skewX) * degrees$1,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;

    /* eslint-disable no-undef */
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$7 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }

    function parseSvg(value) {
      if (value == null) return identity$7;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$7;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var epsilon2$1 = 1e-12;

    function cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }

    function sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }

    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }

    var interpolateZoom = (function zoomRho(rho, rho2, rho4) {

      // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]
      function zoom(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
            ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;

        // Special case for u0  u1.
        if (d2 < epsilon2$1) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        }

        // General case.
        else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
              b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s = t * S,
                coshr0 = cosh(r0),
                u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh(rho * s + r0)
            ];
          };
        }

        i.duration = S * 1000 * rho / Math.SQRT2;

        return i;
      }

      zoom.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };

      return zoom;
    })(Math.SQRT2, 2, 4);

    function hsl(hue) {
      return function(start, end) {
        var h = hue((start = hsl$2(start)).h, (end = hsl$2(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hsl$1 = hsl(hue$1);
    var hslLong = hsl(nogamma);

    function lab(start, end) {
      var l = nogamma((start = lab$1(start)).l, (end = lab$1(end)).l),
          a = nogamma(start.a, end.a),
          b = nogamma(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.l = l(t);
        start.a = a(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    function hcl(hue) {
      return function(start, end) {
        var h = hue((start = hcl$2(start)).h, (end = hcl$2(end)).h),
            c = nogamma(start.c, end.c),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.c = c(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hcl$1 = hcl(hue$1);
    var hclLong = hcl(nogamma);

    function cubehelix$1(hue) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix(start, end) {
          var h = hue((start = cubehelix$3(start)).h, (end = cubehelix$3(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix.gamma = cubehelixGamma;

        return cubehelix;
      })(1);
    }

    var cubehelix$2 = cubehelix$1(hue$1);
    var cubehelixLong = cubehelix$1(nogamma);

    function piecewise(interpolate, values) {
      if (values === undefined) values = interpolate, interpolate = interpolate$2;
      var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
      while (i < n) I[i] = interpolate(v, v = values[++i]);
      return function(t) {
        var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i](t - i);
      };
    }

    function quantize$1(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
      return samples;
    }

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval$1 = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend weve set an alarm, if we havent already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval$1) interval$1 = clearInterval(interval$1);
      } else {
        if (!interval$1) clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    function interval(callback, delay, time) {
      var t = new Timer, total = delay;
      if (delay == null) return t.restart(callback, delay, time), t;
      t._restart = t.restart;
      t.restart = function(callback, delay, time) {
        delay = +delay, time = time == null ? now() : +time;
        t._restart(function tick(elapsed) {
          elapsed += total;
          t._restart(tick, total += delay, time);
          callback(elapsed);
        }, delay, time);
      };
      t.restart(callback, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get(node, id).value[name];
      };
    }

    function interpolate$1(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color$1 ? interpolateRgb
          : (c = color$1(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error;
        set(this, id).ease = v;
      };
    }

    function transition_easeVarying(value) {
      if (typeof value !== "function") throw new Error;
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and were done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });

        // The selection was empty, resolve end immediately
        if (size === 0) resolve();
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    const linear$1 = t => +t;

    function quadIn(t) {
      return t * t;
    }

    function quadOut(t) {
      return t * (2 - t);
    }

    function quadInOut(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
      return t * t * t;
    }

    function cubicOut(t) {
      return --t * t * t + 1;
    }

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent$1 = 3;

    var polyIn = (function custom(e) {
      e = +e;

      function polyIn(t) {
        return Math.pow(t, e);
      }

      polyIn.exponent = custom;

      return polyIn;
    })(exponent$1);

    var polyOut = (function custom(e) {
      e = +e;

      function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
      }

      polyOut.exponent = custom;

      return polyOut;
    })(exponent$1);

    var polyInOut = (function custom(e) {
      e = +e;

      function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      polyInOut.exponent = custom;

      return polyInOut;
    })(exponent$1);

    var pi$4 = Math.PI,
        halfPi$3 = pi$4 / 2;

    function sinIn(t) {
      return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi$3);
    }

    function sinOut(t) {
      return Math.sin(t * halfPi$3);
    }

    function sinInOut(t) {
      return (1 - Math.cos(pi$4 * t)) / 2;
    }

    // tpmt is two power minus ten times t scaled to [0,1]
    function tpmt(x) {
      return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
    }

    function expIn(t) {
      return tpmt(1 - +t);
    }

    function expOut(t) {
      return 1 - tpmt(t);
    }

    function expInOut(t) {
      return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
    }

    function circleIn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function circleOut(t) {
      return Math.sqrt(1 - --t * t);
    }

    function circleInOut(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1 = 4 / 11,
        b2 = 6 / 11,
        b3 = 8 / 11,
        b4 = 3 / 4,
        b5 = 9 / 11,
        b6 = 10 / 11,
        b7 = 15 / 16,
        b8 = 21 / 22,
        b9 = 63 / 64,
        b0 = 1 / b1 / b1;

    function bounceIn(t) {
      return 1 - bounceOut(1 - t);
    }

    function bounceOut(t) {
      return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }

    function bounceInOut(t) {
      return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;

    var backIn = (function custom(s) {
      s = +s;

      function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
      }

      backIn.overshoot = custom;

      return backIn;
    })(overshoot);

    var backOut = (function custom(s) {
      s = +s;

      function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
      }

      backOut.overshoot = custom;

      return backOut;
    })(overshoot);

    var backInOut = (function custom(s) {
      s = +s;

      function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
      }

      backInOut.overshoot = custom;

      return backInOut;
    })(overshoot);

    var tau$5 = 2 * Math.PI,
        amplitude = 1,
        period = 0.3;

    var elasticIn = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticIn(t) {
        return a * tpmt(-(--t)) * Math.sin((s - t) / p);
      }

      elasticIn.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticIn.period = function(p) { return custom(a, p); };

      return elasticIn;
    })(amplitude, period);

    var elasticOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticOut(t) {
        return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
      }

      elasticOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticOut.period = function(p) { return custom(a, p); };

      return elasticOut;
    })(amplitude, period);

    var elasticInOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0
            ? a * tpmt(-t) * Math.sin((s - t) / p)
            : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
      }

      elasticInOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticInOut.period = function(p) { return custom(a, p); };

      return elasticInOut;
    })(amplitude, period);

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var root = [null];

    function active(node, name) {
      var schedules = node.__transition,
          schedule,
          i;

      if (schedules) {
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
            return new Transition([[node]], root, name, +i);
          }
        }
      }

      return null;
    }

    var constant$7 = x => () => x;

    function BrushEvent(type, {
      sourceEvent,
      target,
      selection,
      mode,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        selection: {value: selection, enumerable: true, configurable: true},
        mode: {value: mode, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function nopropagation$1(event) {
      event.stopImmediatePropagation();
    }

    function noevent$1(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    var MODE_DRAG = {name: "drag"},
        MODE_SPACE = {name: "space"},
        MODE_HANDLE = {name: "handle"},
        MODE_CENTER = {name: "center"};

    const {abs: abs$3, max: max$2, min: min$1} = Math;

    function number1(e) {
      return [+e[0], +e[1]];
    }

    function number2(e) {
      return [number1(e[0]), number1(e[1])];
    }

    var X = {
      name: "x",
      handles: ["w", "e"].map(type),
      input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
      output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
    };

    var Y = {
      name: "y",
      handles: ["n", "s"].map(type),
      input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
      output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
    };

    var XY = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
      input: function(xy) { return xy == null ? null : number2(xy); },
      output: function(xy) { return xy; }
    };

    var cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };

    var flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };

    var flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };

    var signsX = {
      overlay: +1,
      selection: +1,
      n: null,
      e: +1,
      s: null,
      w: -1,
      nw: -1,
      ne: +1,
      se: +1,
      sw: -1
    };

    var signsY = {
      overlay: +1,
      selection: +1,
      n: -1,
      e: null,
      s: +1,
      w: null,
      nw: -1,
      ne: -1,
      se: +1,
      sw: +1
    };

    function type(t) {
      return {type: t};
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$1(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultExtent$1() {
      var svg = this.ownerSVGElement || this;
      if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
      }
      return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }

    function defaultTouchable$1() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    // Like d3.local, but with the name __brush rather than auto-generated.
    function local(node) {
      while (!node.__brush) if (!(node = node.parentNode)) return;
      return node.__brush;
    }

    function empty(extent) {
      return extent[0][0] === extent[1][0]
          || extent[0][1] === extent[1][1];
    }

    function brushSelection(node) {
      var state = node.__brush;
      return state ? state.dim.output(state.selection) : null;
    }

    function brushX() {
      return brush$1(X);
    }

    function brushY() {
      return brush$1(Y);
    }

    function brush() {
      return brush$1(XY);
    }

    function brush$1(dim) {
      var extent = defaultExtent$1,
          filter = defaultFilter$1,
          touchable = defaultTouchable$1,
          keys = true,
          listeners = dispatch("start", "brush", "end"),
          handleSize = 6,
          touchending;

      function brush(group) {
        var overlay = group
            .property("__brush", initialize)
          .selectAll(".overlay")
          .data([type("overlay")]);

        overlay.enter().append("rect")
            .attr("class", "overlay")
            .attr("pointer-events", "all")
            .attr("cursor", cursors.overlay)
          .merge(overlay)
            .each(function() {
              var extent = local(this).extent;
              select(this)
                  .attr("x", extent[0][0])
                  .attr("y", extent[0][1])
                  .attr("width", extent[1][0] - extent[0][0])
                  .attr("height", extent[1][1] - extent[0][1]);
            });

        group.selectAll(".selection")
          .data([type("selection")])
          .enter().append("rect")
            .attr("class", "selection")
            .attr("cursor", cursors.selection)
            .attr("fill", "#777")
            .attr("fill-opacity", 0.3)
            .attr("stroke", "#fff")
            .attr("shape-rendering", "crispEdges");

        var handle = group.selectAll(".handle")
          .data(dim.handles, function(d) { return d.type; });

        handle.exit().remove();

        handle.enter().append("rect")
            .attr("class", function(d) { return "handle handle--" + d.type; })
            .attr("cursor", function(d) { return cursors[d.type]; });

        group
            .each(redraw)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousedown.brush", started)
          .filter(touchable)
            .on("touchstart.brush", started)
            .on("touchmove.brush", touchmoved)
            .on("touchend.brush touchcancel.brush", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      brush.move = function(group, selection, event) {
        if (group.tween) {
          group
              .on("start.brush", function(event) { emitter(this, arguments).beforestart().start(event); })
              .on("interrupt.brush end.brush", function(event) { emitter(this, arguments).end(event); })
              .tween("brush", function() {
                var that = this,
                    state = that.__brush,
                    emit = emitter(that, arguments),
                    selection0 = state.selection,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                    i = interpolate$2(selection0, selection1);

                function tween(t) {
                  state.selection = t === 1 && selection1 === null ? null : i(t);
                  redraw.call(that);
                  emit.brush();
                }

                return selection0 !== null && selection1 !== null ? tween : tween(1);
              });
        } else {
          group
              .each(function() {
                var that = this,
                    args = arguments,
                    state = that.__brush,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                    emit = emitter(that, args).beforestart();

                interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start(event).brush(event).end(event);
              });
        }
      };

      brush.clear = function(group, event) {
        brush.move(group, null, event);
      };

      function redraw() {
        var group = select(this),
            selection = local(this).selection;

        if (selection) {
          group.selectAll(".selection")
              .style("display", null)
              .attr("x", selection[0][0])
              .attr("y", selection[0][1])
              .attr("width", selection[1][0] - selection[0][0])
              .attr("height", selection[1][1] - selection[0][1]);

          group.selectAll(".handle")
              .style("display", null)
              .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
              .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
              .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
              .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
        }

        else {
          group.selectAll(".selection,.handle")
              .style("display", "none")
              .attr("x", null)
              .attr("y", null)
              .attr("width", null)
              .attr("height", null);
        }
      }

      function emitter(that, args, clean) {
        var emit = that.__brush.emitter;
        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
      }

      function Emitter(that, args, clean) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
        this.clean = clean;
      }

      Emitter.prototype = {
        beforestart: function() {
          if (++this.active === 1) this.state.emitter = this, this.starting = true;
          return this;
        },
        start: function(event, mode) {
          if (this.starting) this.starting = false, this.emit("start", event, mode);
          else this.emit("brush", event);
          return this;
        },
        brush: function(event, mode) {
          this.emit("brush", event, mode);
          return this;
        },
        end: function(event, mode) {
          if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
          return this;
        },
        emit: function(type, event, mode) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new BrushEvent(type, {
              sourceEvent: event,
              target: brush,
              selection: dim.output(this.state.selection),
              mode,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function started(event) {
        if (touchending && !event.touches) return;
        if (!filter.apply(this, arguments)) return;

        var that = this,
            type = event.target.__data__.type,
            mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
            signX = dim === Y ? null : signsX[type],
            signY = dim === X ? null : signsY[type],
            state = local(that),
            extent = state.extent,
            selection = state.selection,
            W = extent[0][0], w0, w1,
            N = extent[0][1], n0, n1,
            E = extent[1][0], e0, e1,
            S = extent[1][1], s0, s1,
            dx = 0,
            dy = 0,
            moving,
            shifting = signX && signY && keys && event.shiftKey,
            lockX,
            lockY,
            points = Array.from(event.touches || [event], t => {
              const i = t.identifier;
              t = pointer(t, that);
              t.point0 = t.slice();
              t.identifier = i;
              return t;
            });

        interrupt(that);
        var emit = emitter(that, arguments, true).beforestart();

        if (type === "overlay") {
          if (selection) moving = true;
          const pts = [points[0], points[1] || points[0]];
          state.selection = selection = [[
              w0 = dim === Y ? W : min$1(pts[0][0], pts[1][0]),
              n0 = dim === X ? N : min$1(pts[0][1], pts[1][1])
            ], [
              e0 = dim === Y ? E : max$2(pts[0][0], pts[1][0]),
              s0 = dim === X ? S : max$2(pts[0][1], pts[1][1])
            ]];
          if (points.length > 1) move(event);
        } else {
          w0 = selection[0][0];
          n0 = selection[0][1];
          e0 = selection[1][0];
          s0 = selection[1][1];
        }

        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;

        var group = select(that)
            .attr("pointer-events", "none");

        var overlay = group.selectAll(".overlay")
            .attr("cursor", cursors[type]);

        if (event.touches) {
          emit.moved = moved;
          emit.ended = ended;
        } else {
          var view = select(event.view)
              .on("mousemove.brush", moved, true)
              .on("mouseup.brush", ended, true);
          if (keys) view
              .on("keydown.brush", keydowned, true)
              .on("keyup.brush", keyupped, true);

          dragDisable(event.view);
        }

        redraw.call(that);
        emit.start(event, mode.name);

        function moved(event) {
          for (const p of event.changedTouches || [event]) {
            for (const d of points)
              if (d.identifier === p.identifier) d.cur = pointer(p, that);
          }
          if (shifting && !lockX && !lockY && points.length === 1) {
            const point = points[0];
            if (abs$3(point.cur[0] - point[0]) > abs$3(point.cur[1] - point[1]))
              lockY = true;
            else
              lockX = true;
          }
          for (const point of points)
            if (point.cur) point[0] = point.cur[0], point[1] = point.cur[1];
          moving = true;
          noevent$1(event);
          move(event);
        }

        function move(event) {
          const point = points[0], point0 = point.point0;
          var t;

          dx = point[0] - point0[0];
          dy = point[1] - point0[1];

          switch (mode) {
            case MODE_SPACE:
            case MODE_DRAG: {
              if (signX) dx = max$2(W - w0, min$1(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
              if (signY) dy = max$2(N - n0, min$1(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
              break;
            }
            case MODE_HANDLE: {
              if (points[1]) {
                if (signX) w1 = max$2(W, min$1(E, points[0][0])), e1 = max$2(W, min$1(E, points[1][0])), signX = 1;
                if (signY) n1 = max$2(N, min$1(S, points[0][1])), s1 = max$2(N, min$1(S, points[1][1])), signY = 1;
              } else {
                if (signX < 0) dx = max$2(W - w0, min$1(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                else if (signX > 0) dx = max$2(W - e0, min$1(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                if (signY < 0) dy = max$2(N - n0, min$1(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                else if (signY > 0) dy = max$2(N - s0, min$1(S - s0, dy)), n1 = n0, s1 = s0 + dy;
              }
              break;
            }
            case MODE_CENTER: {
              if (signX) w1 = max$2(W, min$1(E, w0 - dx * signX)), e1 = max$2(W, min$1(E, e0 + dx * signX));
              if (signY) n1 = max$2(N, min$1(S, n0 - dy * signY)), s1 = max$2(N, min$1(S, s0 + dy * signY));
              break;
            }
          }

          if (e1 < w1) {
            signX *= -1;
            t = w0, w0 = e0, e0 = t;
            t = w1, w1 = e1, e1 = t;
            if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
          }

          if (s1 < n1) {
            signY *= -1;
            t = n0, n0 = s0, s0 = t;
            t = n1, n1 = s1, s1 = t;
            if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
          }

          if (state.selection) selection = state.selection; // May be set by brush.move!
          if (lockX) w1 = selection[0][0], e1 = selection[1][0];
          if (lockY) n1 = selection[0][1], s1 = selection[1][1];

          if (selection[0][0] !== w1
              || selection[0][1] !== n1
              || selection[1][0] !== e1
              || selection[1][1] !== s1) {
            state.selection = [[w1, n1], [e1, s1]];
            redraw.call(that);
            emit.brush(event, mode.name);
          }
        }

        function ended(event) {
          nopropagation$1(event);
          if (event.touches) {
            if (event.touches.length) return;
            if (touchending) clearTimeout(touchending);
            touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
          } else {
            yesdrag(event.view, moving);
            view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
          }
          group.attr("pointer-events", "all");
          overlay.attr("cursor", cursors.overlay);
          if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
          if (empty(selection)) state.selection = null, redraw.call(that);
          emit.end(event, mode.name);
        }

        function keydowned(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              shifting = signX && signY;
              break;
            }
            case 18: { // ALT
              if (mode === MODE_HANDLE) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
                move(event);
              }
              break;
            }
            case 32: { // SPACE; takes priority over ALT
              if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
                if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
                mode = MODE_SPACE;
                overlay.attr("cursor", cursors.selection);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }

        function keyupped(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              if (shifting) {
                lockX = lockY = shifting = false;
                move(event);
              }
              break;
            }
            case 18: { // ALT
              if (mode === MODE_CENTER) {
                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
                move(event);
              }
              break;
            }
            case 32: { // SPACE
              if (mode === MODE_SPACE) {
                if (event.altKey) {
                  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                  mode = MODE_CENTER;
                } else {
                  if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                  if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                  mode = MODE_HANDLE;
                }
                overlay.attr("cursor", cursors[type]);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }
      }

      function touchmoved(event) {
        emitter(this, arguments).moved(event);
      }

      function touchended(event) {
        emitter(this, arguments).ended(event);
      }

      function initialize() {
        var state = this.__brush || {selection: null};
        state.extent = number2(extent.apply(this, arguments));
        state.dim = dim;
        return state;
      }

      brush.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$7(number2(_)), brush) : extent;
      };

      brush.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$7(!!_), brush) : filter;
      };

      brush.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$7(!!_), brush) : touchable;
      };

      brush.handleSize = function(_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
      };

      brush.keyModifiers = function(_) {
        return arguments.length ? (keys = !!_, brush) : keys;
      };

      brush.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
      };

      return brush;
    }

    var abs$2 = Math.abs;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var pi$3 = Math.PI;
    var halfPi$2 = pi$3 / 2;
    var tau$4 = pi$3 * 2;
    var max$1 = Math.max;
    var epsilon$5 = 1e-12;

    function range$1(i, j) {
      return Array.from({length: j - i}, (_, k) => i + k);
    }

    function compareValue(compare) {
      return function(a, b) {
        return compare(
          a.source.value + a.target.value,
          b.source.value + b.target.value
        );
      };
    }

    function chord() {
      return chord$1(false, false);
    }

    function chordTranspose() {
      return chord$1(false, true);
    }

    function chordDirected() {
      return chord$1(true, false);
    }

    function chord$1(directed, transpose) {
      var padAngle = 0,
          sortGroups = null,
          sortSubgroups = null,
          sortChords = null;

      function chord(matrix) {
        var n = matrix.length,
            groupSums = new Array(n),
            groupIndex = range$1(0, n),
            chords = new Array(n * n),
            groups = new Array(n),
            k = 0, dx;

        matrix = Float64Array.from({length: n * n}, transpose
            ? (_, i) => matrix[i % n][i / n | 0]
            : (_, i) => matrix[i / n | 0][i % n]);

        // Compute the scaling factor from value to angle in [0, 2pi].
        for (let i = 0; i < n; ++i) {
          let x = 0;
          for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];
          k += groupSums[i] = x;
        }
        k = max$1(0, tau$4 - padAngle * n) / k;
        dx = k ? padAngle : tau$4 / n;

        // Compute the angles for each group and constituent chord.
        {
          let x = 0;
          if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));
          for (const i of groupIndex) {
            const x0 = x;
            if (directed) {
              const subgroupIndex = range$1(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
              for (const j of subgroupIndex) {
                if (j < 0) {
                  const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};
                } else {
                  const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            } else {
              const subgroupIndex = range$1(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));
              for (const j of subgroupIndex) {
                let chord;
                if (i < j) {
                  chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                } else {
                  chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                  if (i === j) chord.source = chord.target;
                }
                if (chord.source && chord.target && chord.source.value < chord.target.value) {
                  const source = chord.source;
                  chord.source = chord.target;
                  chord.target = source;
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            }
            x += dx;
          }
        }

        // Remove empty chords.
        chords = Object.values(chords);
        chords.groups = groups;
        return sortChords ? chords.sort(sortChords) : chords;
      }

      chord.padAngle = function(_) {
        return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
      };

      chord.sortGroups = function(_) {
        return arguments.length ? (sortGroups = _, chord) : sortGroups;
      };

      chord.sortSubgroups = function(_) {
        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
      };

      chord.sortChords = function(_) {
        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
      };

      return chord;
    }

    const pi$2 = Math.PI,
        tau$3 = 2 * pi$2,
        epsilon$4 = 1e-6,
        tauEpsilon = tau$3 - epsilon$4;

    function Path$1() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }

    function path() {
      return new Path$1;
    }

    Path$1.prototype = path.prototype = {
      constructor: Path$1,
      moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$4));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$4) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$4) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$4 || Math.abs(this._y1 - y0) > epsilon$4) {
          this._ += "L" + x0 + "," + y0;
        }

        // Is this arc empty? Were done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$3 + tau$3;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$4) {
          this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
      },
      toString: function() {
        return this._;
      }
    };

    var slice$2 = Array.prototype.slice;

    function constant$6(x) {
      return function() {
        return x;
      };
    }

    function defaultSource$1(d) {
      return d.source;
    }

    function defaultTarget(d) {
      return d.target;
    }

    function defaultRadius$1(d) {
      return d.radius;
    }

    function defaultStartAngle(d) {
      return d.startAngle;
    }

    function defaultEndAngle(d) {
      return d.endAngle;
    }

    function defaultPadAngle() {
      return 0;
    }

    function defaultArrowheadRadius() {
      return 10;
    }

    function ribbon(headRadius) {
      var source = defaultSource$1,
          target = defaultTarget,
          sourceRadius = defaultRadius$1,
          targetRadius = defaultRadius$1,
          startAngle = defaultStartAngle,
          endAngle = defaultEndAngle,
          padAngle = defaultPadAngle,
          context = null;

      function ribbon() {
        var buffer,
            s = source.apply(this, arguments),
            t = target.apply(this, arguments),
            ap = padAngle.apply(this, arguments) / 2,
            argv = slice$2.call(arguments),
            sr = +sourceRadius.apply(this, (argv[0] = s, argv)),
            sa0 = startAngle.apply(this, argv) - halfPi$2,
            sa1 = endAngle.apply(this, argv) - halfPi$2,
            tr = +targetRadius.apply(this, (argv[0] = t, argv)),
            ta0 = startAngle.apply(this, argv) - halfPi$2,
            ta1 = endAngle.apply(this, argv) - halfPi$2;

        if (!context) context = buffer = path();

        if (ap > epsilon$5) {
          if (abs$2(sa1 - sa0) > ap * 2 + epsilon$5) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
          else sa0 = sa1 = (sa0 + sa1) / 2;
          if (abs$2(ta1 - ta0) > ap * 2 + epsilon$5) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
          else ta0 = ta1 = (ta0 + ta1) / 2;
        }

        context.moveTo(sr * cos$2(sa0), sr * sin$2(sa0));
        context.arc(0, 0, sr, sa0, sa1);
        if (sa0 !== ta0 || sa1 !== ta1) {
          if (headRadius) {
            var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
            context.quadraticCurveTo(0, 0, tr2 * cos$2(ta0), tr2 * sin$2(ta0));
            context.lineTo(tr * cos$2(ta2), tr * sin$2(ta2));
            context.lineTo(tr2 * cos$2(ta1), tr2 * sin$2(ta1));
          } else {
            context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
            context.arc(0, 0, tr, ta0, ta1);
          }
        }
        context.quadraticCurveTo(0, 0, sr * cos$2(sa0), sr * sin$2(sa0));
        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      if (headRadius) ribbon.headRadius = function(_) {
        return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : headRadius;
      };

      ribbon.radius = function(_) {
        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.sourceRadius = function(_) {
        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.targetRadius = function(_) {
        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : targetRadius;
      };

      ribbon.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : startAngle;
      };

      ribbon.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : endAngle;
      };

      ribbon.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : padAngle;
      };

      ribbon.source = function(_) {
        return arguments.length ? (source = _, ribbon) : source;
      };

      ribbon.target = function(_) {
        return arguments.length ? (target = _, ribbon) : target;
      };

      ribbon.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
      };

      return ribbon;
    }

    function ribbon$1() {
      return ribbon();
    }

    function ribbonArrow() {
      return ribbon(defaultArrowheadRadius);
    }

    var array$2 = Array.prototype;

    var slice$1 = array$2.slice;

    function ascending$1(a, b) {
      return a - b;
    }

    function area$3(ring) {
      var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area;
    }

    var constant$5 = x => () => x;

    function contains$2(ring, hole) {
      var i = -1, n = hole.length, c;
      while (++i < n) if (c = ringContains(ring, hole[i])) return c;
      return 0;
    }

    function ringContains(ring, point) {
      var x = point[0], y = point[1], contains = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) return 0;
        if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
      }
      return contains;
    }

    function segmentContains(a, b, c) {
      var i; return collinear$1(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
    }

    function collinear$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
    }

    function within(p, q, r) {
      return p <= q && q <= r || r <= q && q <= p;
    }

    function noop$3() {}

    var cases = [
      [],
      [[[1.0, 1.5], [0.5, 1.0]]],
      [[[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [0.5, 1.0]]],
      [[[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 0.5], [1.0, 1.5]]],
      [[[1.0, 0.5], [0.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 0.5]]],
      [[[1.0, 1.5], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.5, 1.0]]],
      [[[1.0, 1.5], [1.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 1.5]]],
      []
    ];

    function contours() {
      var dx = 1,
          dy = 1,
          threshold = thresholdSturges,
          smooth = smoothLinear;

      function contours(values) {
        var tz = threshold(values);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          const e = extent$1(values), ts = tickStep(e[0], e[1], tz);
          tz = ticks(Math.floor(e[0] / ts) * ts, Math.floor(e[1] / ts - 1) * ts, tz);
        } else {
          tz = tz.slice().sort(ascending$1);
        }

        return tz.map(value => contour(values, value));
      }

      // Accumulate, smooth contour rings, assign holes to exterior rings.
      // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
      function contour(values, value) {
        var polygons = [],
            holes = [];

        isorings(values, value, function(ring) {
          smooth(ring, values, value);
          if (area$3(ring) > 0) polygons.push([ring]);
          else holes.push(ring);
        });

        holes.forEach(function(hole) {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            if (contains$2((polygon = polygons[i])[0], hole) !== -1) {
              polygon.push(hole);
              return;
            }
          }
        });

        return {
          type: "MultiPolygon",
          value: value,
          coordinates: polygons
        };
      }

      // Marching squares with isolines stitched into rings.
      // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
      function isorings(values, value, callback) {
        var fragmentByStart = new Array,
            fragmentByEnd = new Array,
            x, y, t0, t1, t2, t3;

        // Special case for the first row (y = -1, t2 = t3 = 0).
        x = y = -1;
        t1 = values[0] >= value;
        cases[t1 << 1].forEach(stitch);
        while (++x < dx - 1) {
          t0 = t1, t1 = values[x + 1] >= value;
          cases[t0 | t1 << 1].forEach(stitch);
        }
        cases[t1 << 0].forEach(stitch);

        // General case for the intermediate rows.
        while (++y < dy - 1) {
          x = -1;
          t1 = values[y * dx + dx] >= value;
          t2 = values[y * dx] >= value;
          cases[t1 << 1 | t2 << 2].forEach(stitch);
          while (++x < dx - 1) {
            t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
            t3 = t2, t2 = values[y * dx + x + 1] >= value;
            cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
          }
          cases[t1 | t2 << 3].forEach(stitch);
        }

        // Special case for the last row (y = dy - 1, t0 = t1 = 0).
        x = -1;
        t2 = values[y * dx] >= value;
        cases[t2 << 2].forEach(stitch);
        while (++x < dx - 1) {
          t3 = t2, t2 = values[y * dx + x + 1] >= value;
          cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);

        function stitch(line) {
          var start = [line[0][0] + x, line[0][1] + y],
              end = [line[1][0] + x, line[1][1] + y],
              startIndex = index(start),
              endIndex = index(end),
              f, g;
          if (f = fragmentByEnd[startIndex]) {
            if (g = fragmentByStart[endIndex]) {
              delete fragmentByEnd[f.end];
              delete fragmentByStart[g.start];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
              }
            } else {
              delete fragmentByEnd[f.end];
              f.ring.push(end);
              fragmentByEnd[f.end = endIndex] = f;
            }
          } else if (f = fragmentByStart[endIndex]) {
            if (g = fragmentByEnd[startIndex]) {
              delete fragmentByStart[f.start];
              delete fragmentByEnd[g.end];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
              }
            } else {
              delete fragmentByStart[f.start];
              f.ring.unshift(start);
              fragmentByStart[f.start = startIndex] = f;
            }
          } else {
            fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
          }
        }
      }

      function index(point) {
        return point[0] * 2 + point[1] * (dx + 1) * 4;
      }

      function smoothLinear(ring, values, value) {
        ring.forEach(function(point) {
          var x = point[0],
              y = point[1],
              xt = x | 0,
              yt = y | 0,
              v0,
              v1 = values[yt * dx + xt];
          if (x > 0 && x < dx && xt === x) {
            v0 = values[yt * dx + xt - 1];
            point[0] = x + (value - v0) / (v1 - v0) - 0.5;
          }
          if (y > 0 && y < dy && yt === y) {
            v0 = values[(yt - 1) * dx + xt];
            point[1] = y + (value - v0) / (v1 - v0) - 0.5;
          }
        });
      }

      contours.contour = contour;

      contours.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, contours;
      };

      contours.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), contours) : threshold;
      };

      contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop$3, contours) : smooth === smoothLinear;
      };

      return contours;
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurX(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var j = 0; j < m; ++j) {
        for (var i = 0, sr = 0; i < n + r; ++i) {
          if (i < n) {
            sr += source.data[i + j * n];
          }
          if (i >= r) {
            if (i >= w) {
              sr -= source.data[i - w + j * n];
            }
            target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
          }
        }
      }
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurY(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var i = 0; i < n; ++i) {
        for (var j = 0, sr = 0; j < m + r; ++j) {
          if (j < m) {
            sr += source.data[i + j * n];
          }
          if (j >= r) {
            if (j >= w) {
              sr -= source.data[i + (j - w) * n];
            }
            target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
          }
        }
      }
    }

    function defaultX$1(d) {
      return d[0];
    }

    function defaultY$1(d) {
      return d[1];
    }

    function defaultWeight() {
      return 1;
    }

    function density() {
      var x = defaultX$1,
          y = defaultY$1,
          weight = defaultWeight,
          dx = 960,
          dy = 500,
          r = 20, // blur radius
          k = 2, // log2(grid cell size)
          o = r * 3, // grid offset, to pad for blur
          n = (dx + o * 2) >> k, // grid width
          m = (dy + o * 2) >> k, // grid height
          threshold = constant$5(20);

      function density(data) {
        var values0 = new Float32Array(n * m),
            values1 = new Float32Array(n * m),
            pow2k = Math.pow(2, -k);

        data.forEach(function(d, i, data) {
          var xi = (x(d, i, data) + o) * pow2k,
              yi = (y(d, i, data) + o) * pow2k,
              wi = +weight(d, i, data);
          if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
            var x0 = Math.floor(xi),
                y0 = Math.floor(yi),
                xt = xi - x0 - 0.5,
                yt = yi - y0 - 0.5;
            values0[x0 + y0 * n] += (1 - xt) * (1 - yt) * wi;
            values0[x0 + 1 + y0 * n] += xt * (1 - yt) * wi;
            values0[x0 + 1 + (y0 + 1) * n] += xt * yt * wi;
            values0[x0 + (y0 + 1) * n] += (1 - xt) * yt * wi;
          }
        });

        // TODO Optimize.
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

        var tz = threshold(values0);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          var stop = max$3(values0);
          tz = tickStep(0, stop, tz);
          tz = range$2(0, Math.floor(stop / tz) * tz, tz);
          tz.shift();
        }

        return contours()
            .thresholds(tz)
            .size([n, m])
          (values0)
            .map(transform);
      }

      function transform(geometry) {
        geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      }

      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }

      function transformRing(coordinates) {
        coordinates.forEach(transformPoint);
      }

      // TODO Optimize.
      function transformPoint(coordinates) {
        coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
        coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
      }

      function resize() {
        o = r * 3;
        n = (dx + o * 2) >> k;
        m = (dy + o * 2) >> k;
        return density;
      }

      density.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$5(+_), density) : x;
      };

      density.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$5(+_), density) : y;
      };

      density.weight = function(_) {
        return arguments.length ? (weight = typeof _ === "function" ? _ : constant$5(+_), density) : weight;
      };

      density.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = +_[0], _1 = +_[1];
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, resize();
      };

      density.cellSize = function(_) {
        if (!arguments.length) return 1 << k;
        if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
        return k = Math.floor(Math.log(_) / Math.LN2), resize();
      };

      density.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), density) : threshold;
      };

      density.bandwidth = function(_) {
        if (!arguments.length) return Math.sqrt(r * (r + 1));
        if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
        return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
      };

      return density;
    }

    const epsilon$3 = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon$3) * epsilon$3;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum$1(elen, e, flen, f, h) {
        let Q, Qnew, hh, bvirt;
        let enow = e[0];
        let fnow = f[0];
        let eindex = 0;
        let findex = 0;
        if ((fnow > enow) === (fnow > -enow)) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        let hindex = 0;
        if (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
                if ((fnow > enow) === (fnow > -enow)) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) {
                    h[hindex++] = hh;
                }
            }
        }
        while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
        }
        return hindex;
    }

    function estimate(elen, e) {
        let Q = e[0];
        for (let i = 1; i < elen; i++) Q += e[i];
        return Q;
    }

    function vec(n) {
        return new Float64Array(n);
    }

    const ccwerrboundA = (3 + 16 * epsilon$3) * epsilon$3;
    const ccwerrboundB = (2 + 12 * epsilon$3) * epsilon$3;
    const ccwerrboundC = (9 + 64 * epsilon$3) * epsilon$3 * epsilon$3;

    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);

    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        let acxtail, acytail, bcxtail, bcytail;
        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

        const acx = ax - cx;
        const bcx = bx - cx;
        const acy = ay - cy;
        const bcy = by - cy;

        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B[3] = u3;

        let det = estimate(4, B);
        let errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) {
            return det;
        }

        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);

        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
        }

        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) return det;

        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C1len = sum$1(4, B, 4, u, C1);

        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C2len = sum$1(C1len, C1, 4, u, C2);

        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const Dlen = sum$1(C2len, C2, 4, u, D);

        return D[Dlen - 1];
    }

    function orient2d(ax, ay, bx, by, cx, cy) {
        const detleft = (ay - cy) * (bx - cx);
        const detright = (ax - cx) * (by - cy);
        const det = detleft - detright;

        if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;

        const detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) return det;

        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    const EPSILON = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);

    class Delaunator {

        static from(points, getX = defaultGetX, getY = defaultGetY) {
            const n = points.length;
            const coords = new Float64Array(n * 2);

            for (let i = 0; i < n; i++) {
                const p = points[i];
                coords[2 * i] = getX(p);
                coords[2 * i + 1] = getY(p);
            }

            return new Delaunator(coords);
        }

        constructor(coords) {
            const n = coords.length >> 1;
            if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

            this.coords = coords;

            // arrays that will store the triangulation graph
            const maxTriangles = Math.max(2 * n - 5, 0);
            this._triangles = new Uint32Array(maxTriangles * 3);
            this._halfedges = new Int32Array(maxTriangles * 3);

            // temporary arrays for tracking the edges of the advancing convex hull
            this._hashSize = Math.ceil(Math.sqrt(n));
            this._hullPrev = new Uint32Array(n); // edge to prev edge
            this._hullNext = new Uint32Array(n); // edge to next edge
            this._hullTri = new Uint32Array(n); // edge to adjacent triangle
            this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

            // temporary arrays for sorting points
            this._ids = new Uint32Array(n);
            this._dists = new Float64Array(n);

            this.update();
        }

        update() {
            const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
            const n = coords.length >> 1;

            // populate an array of point indices; calculate input data bbox
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            for (let i = 0; i < n; i++) {
                const x = coords[2 * i];
                const y = coords[2 * i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                this._ids[i] = i;
            }
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            let minDist = Infinity;
            let i0, i1, i2;

            // pick a seed point close to the center
            for (let i = 0; i < n; i++) {
                const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist) {
                    i0 = i;
                    minDist = d;
                }
            }
            const i0x = coords[2 * i0];
            const i0y = coords[2 * i0 + 1];

            minDist = Infinity;

            // find the point closest to the seed
            for (let i = 0; i < n; i++) {
                if (i === i0) continue;
                const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist && d > 0) {
                    i1 = i;
                    minDist = d;
                }
            }
            let i1x = coords[2 * i1];
            let i1y = coords[2 * i1 + 1];

            let minRadius = Infinity;

            // find the third point which forms the smallest circumcircle with the first two
            for (let i = 0; i < n; i++) {
                if (i === i0 || i === i1) continue;
                const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
                if (r < minRadius) {
                    i2 = i;
                    minRadius = r;
                }
            }
            let i2x = coords[2 * i2];
            let i2y = coords[2 * i2 + 1];

            if (minRadius === Infinity) {
                // order collinear points by dx (or dy if all x are identical)
                // and return the list as a hull
                for (let i = 0; i < n; i++) {
                    this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
                }
                quicksort(this._ids, this._dists, 0, n - 1);
                const hull = new Uint32Array(n);
                let j = 0;
                for (let i = 0, d0 = -Infinity; i < n; i++) {
                    const id = this._ids[i];
                    if (this._dists[id] > d0) {
                        hull[j++] = id;
                        d0 = this._dists[id];
                    }
                }
                this.hull = hull.subarray(0, j);
                this.triangles = new Uint32Array(0);
                this.halfedges = new Uint32Array(0);
                return;
            }

            // swap the order of the seed points for counter-clockwise orientation
            if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
                const i = i1;
                const x = i1x;
                const y = i1y;
                i1 = i2;
                i1x = i2x;
                i1y = i2y;
                i2 = i;
                i2x = x;
                i2y = y;
            }

            const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
            this._cx = center.x;
            this._cy = center.y;

            for (let i = 0; i < n; i++) {
                this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
            }

            // sort the points by distance from the seed triangle circumcenter
            quicksort(this._ids, this._dists, 0, n - 1);

            // set up the seed triangle as the starting hull
            this._hullStart = i0;
            let hullSize = 3;

            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;

            hullTri[i0] = 0;
            hullTri[i1] = 1;
            hullTri[i2] = 2;

            hullHash.fill(-1);
            hullHash[this._hashKey(i0x, i0y)] = i0;
            hullHash[this._hashKey(i1x, i1y)] = i1;
            hullHash[this._hashKey(i2x, i2y)] = i2;

            this.trianglesLen = 0;
            this._addTriangle(i0, i1, i2, -1, -1, -1);

            for (let k = 0, xp, yp; k < this._ids.length; k++) {
                const i = this._ids[k];
                const x = coords[2 * i];
                const y = coords[2 * i + 1];

                // skip near-duplicate points
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
                xp = x;
                yp = y;

                // skip seed triangle points
                if (i === i0 || i === i1 || i === i2) continue;

                // find a visible edge on the convex hull using edge hash
                let start = 0;
                for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                    start = hullHash[(key + j) % this._hashSize];
                    if (start !== -1 && start !== hullNext[start]) break;
                }

                start = hullPrev[start];
                let e = start, q;
                while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                    e = q;
                    if (e === start) {
                        e = -1;
                        break;
                    }
                }
                if (e === -1) continue; // likely a near-duplicate point; skip it

                // add the first triangle from the point
                let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

                // recursively flip triangles from the point until they satisfy the Delaunay condition
                hullTri[i] = this._legalize(t + 2);
                hullTri[e] = t; // keep track of boundary triangles on the hull
                hullSize++;

                // walk forward through the hull, adding more triangles and flipping recursively
                let n = hullNext[e];
                while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                    t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this._legalize(t + 2);
                    hullNext[n] = n; // mark as removed
                    hullSize--;
                    n = q;
                }

                // walk backward from the other side, adding more triangles and flipping
                if (e === start) {
                    while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                        t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this._legalize(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e; // mark as removed
                        hullSize--;
                        e = q;
                    }
                }

                // update the hull indices
                this._hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;

                // save the two new edges in the hash table
                hullHash[this._hashKey(x, y)] = i;
                hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
            }

            this.hull = new Uint32Array(hullSize);
            for (let i = 0, e = this._hullStart; i < hullSize; i++) {
                this.hull[i] = e;
                e = hullNext[e];
            }

            // trim typed triangle mesh arrays
            this.triangles = this._triangles.subarray(0, this.trianglesLen);
            this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }

        _hashKey(x, y) {
            return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
        }

        _legalize(a) {
            const {_triangles: triangles, _halfedges: halfedges, coords} = this;

            let i = 0;
            let ar = 0;

            // recursion eliminated with a fixed-size stack
            while (true) {
                const b = halfedges[a];

                /* if the pair of triangles doesn't satisfy the Delaunay condition
                 * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
                 * then do the same check/flip recursively for the new pair of triangles
                 *
                 *           pl                    pl
                 *          /||\                  /  \
                 *       al/ || \bl            al/    \a
                 *        /  ||  \              /      \
                 *       /  a||b  \    flip    /___ar___\
                 *     p0\   ||   /p1   =>   p0\---bl---/p1
                 *        \  ||  /              \      /
                 *       ar\ || /br             b\    /br
                 *          \||/                  \  /
                 *           pr                    pr
                 */
                const a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;

                if (b === -1) { // convex hull edge
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                    continue;
                }

                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;

                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];

                const illegal = inCircle(
                    coords[2 * p0], coords[2 * p0 + 1],
                    coords[2 * pr], coords[2 * pr + 1],
                    coords[2 * pl], coords[2 * pl + 1],
                    coords[2 * p1], coords[2 * p1 + 1]);

                if (illegal) {
                    triangles[a] = p1;
                    triangles[b] = p0;

                    const hbl = halfedges[bl];

                    // edge swapped on the other side of the hull (rare); fix the halfedge reference
                    if (hbl === -1) {
                        let e = this._hullStart;
                        do {
                            if (this._hullTri[e] === bl) {
                                this._hullTri[e] = a;
                                break;
                            }
                            e = this._hullPrev[e];
                        } while (e !== this._hullStart);
                    }
                    this._link(a, hbl);
                    this._link(b, halfedges[ar]);
                    this._link(ar, bl);

                    const br = b0 + (b + 1) % 3;

                    // don't worry about hitting the cap: it can only happen on extremely degenerate input
                    if (i < EDGE_STACK.length) {
                        EDGE_STACK[i++] = br;
                    }
                } else {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                }
            }

            return ar;
        }

        _link(a, b) {
            this._halfedges[a] = b;
            if (b !== -1) this._halfedges[b] = a;
        }

        // add a new triangle given vertex indices and adjacent half-edge ids
        _addTriangle(i0, i1, i2, a, b, c) {
            const t = this.trianglesLen;

            this._triangles[t] = i0;
            this._triangles[t + 1] = i1;
            this._triangles[t + 2] = i2;

            this._link(t, a);
            this._link(t + 1, b);
            this._link(t + 2, c);

            this.trianglesLen += 3;

            return t;
        }
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    function pseudoAngle(dx, dy) {
        const p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
    }

    function dist(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return dx * dx + dy * dy;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        const dx = ax - px;
        const dy = ay - py;
        const ex = bx - px;
        const ey = by - py;
        const fx = cx - px;
        const fy = cy - py;

        const ap = dx * dx + dy * dy;
        const bp = ex * ex + ey * ey;
        const cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) -
               dy * (ex * cp - bp * fx) +
               ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = (ey * bl - dy * cl) * d;
        const y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = ax + (ey * bl - dy * cl) * d;
        const y = ay + (dx * cl - ex * bl) * d;

        return {x, y};
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (let i = left + 1; i <= right; i++) {
                const temp = ids[i];
                const tempDist = dists[temp];
                let j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
                ids[j + 1] = temp;
            }
        } else {
            const median = (left + right) >> 1;
            let i = left + 1;
            let j = right;
            swap(ids, median, i);
            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

            const temp = ids[i];
            const tempDist = dists[temp];
            while (true) {
                do i++; while (dists[ids[i]] < tempDist);
                do j--; while (dists[ids[j]] > tempDist);
                if (j < i) break;
                swap(ids, i, j);
            }
            ids[left + 1] = ids[j];
            ids[j] = temp;

            if (right - i + 1 >= j - left) {
                quicksort(ids, dists, i, right);
                quicksort(ids, dists, left, j - 1);
            } else {
                quicksort(ids, dists, left, j - 1);
                quicksort(ids, dists, i, right);
            }
        }
    }

    function swap(arr, i, j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultGetX(p) {
        return p[0];
    }
    function defaultGetY(p) {
        return p[1];
    }

    const epsilon$2 = 1e-6;

    class Path {
      constructor() {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
      }
      moveTo(x, y) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x, y) {
        this._ += `L${this._x1 = +x},${this._y1 = +y}`;
      }
      arc(x, y, r) {
        x = +x, y = +y, r = +r;
        const x0 = x + r;
        const y0 = y;
        if (r < 0) throw new Error("negative radius");
        if (this._x1 === null) this._ += `M${x0},${y0}`;
        else if (Math.abs(this._x1 - x0) > epsilon$2 || Math.abs(this._y1 - y0) > epsilon$2) this._ += "L" + x0 + "," + y0;
        if (!r) return;
        this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
      }
      rect(x, y, w, h) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
      }
      value() {
        return this._ || null;
      }
    }

    class Polygon {
      constructor() {
        this._ = [];
      }
      moveTo(x, y) {
        this._.push([x, y]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x, y) {
        this._.push([x, y]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    }

    class Voronoi {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const {delaunay: {points, hull, triangles}, vectors} = this;

        // Compute circumcenters.
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
          const t1 = triangles[i] * 2;
          const t2 = triangles[i + 1] * 2;
          const t3 = triangles[i + 2] * 2;
          const x1 = points[t1];
          const y1 = points[t1 + 1];
          const x2 = points[t2];
          const y2 = points[t2 + 1];
          const x3 = points[t3];
          const y3 = points[t3 + 1];

          const dx = x2 - x1;
          const dy = y2 - y1;
          const ex = x3 - x1;
          const ey = y3 - y1;
          const ab = (dx * ey - dy * ex) * 2;

          if (Math.abs(ab) < 1e-9) {
            // degenerate case (collinear diagram)
            // almost equal points (degenerate triangle)
            // the circumcenter is at the infinity, in a
            // direction that is:
            // 1. orthogonal to the halfedge.
            let a = 1e9;
            // 2. points away from the center; since the list of triangles starts
            // in the center, the first point of the first triangle
            // will be our reference
            const r = triangles[0] * 2;
            a *= Math.sign((points[r] - x1) * ey - (points[r + 1] - y1) * ex);
            x = (x1 + x3) / 2 - a * ey;
            y = (y1 + y3) / 2 + a * ex;
          } else {
            const d = 1 / ab;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x = x1 + (ey * bl - dy * cl) * d;
            y = y1 + (dx * cl - ex * bl) * d;
          }
          circumcenters[j] = x;
          circumcenters[j + 1] = y;
        }

        // Compute exterior cell rays.
        let h = hull[hull.length - 1];
        let p0, p1 = h * 4;
        let x0, x1 = points[2 * h];
        let y0, y1 = points[2 * h + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h = hull[i];
          p0 = p1, x0 = x1, y0 = y1;
          p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
          vectors[p0 + 2] = vectors[p1] = y0 - y1;
          vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
        }
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
        if (hull.length <= 1) return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t = Math.floor(inedges[h1] / 3) * 2;
          const x = circumcenters[t];
          const y = circumcenters[t + 1];
          const v = h0 * 4;
          const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
          if (p) this._renderSegment(x, y, p[0], p[1], context);
        }
        return buffer && buffer.value();
      }
      renderBounds(context) {
        const buffer = context == null ? context = new Path : undefined;
        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const points = this._clip(i);
        if (points === null || !points.length) return;
        context.moveTo(points[0], points[1]);
        let n = points.length;
        while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
        for (let i = 2; i < n; i += 2) {
          if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
            context.lineTo(points[i], points[i + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const {delaunay: {points}} = this;
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const cell = this.cellPolygon(i);
          if (cell) cell.index = i, yield cell;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon;
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x0, y0, x1, y1, context) {
        let S;
        const c0 = this._regioncode(x0, y0);
        const c1 = this._regioncode(x1, y1);
        if (c0 === 0 && c1 === 0) {
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
        } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
          context.moveTo(S[0], S[1]);
          context.lineTo(S[2], S[3]);
        }
      }
      contains(i, x, y) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
        return this.delaunay._step(i, x, y) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci) for (const j of this.delaunay.neighbors(i)) {
          const cj = this._clip(j);
          // find the common edge
          if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
            for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
              if (ci[ai] == cj[aj]
              && ci[ai + 1] == cj[aj + 1]
              && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
              && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
              ) {
                yield j;
                break loop;
              }
            }
          }
        }
      }
      _cell(i) {
        const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
        const e0 = inedges[i];
        if (e0 === -1) return null; // coincident point
        const points = [];
        let e = e0;
        do {
          const t = Math.floor(e / 3);
          points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
        } while (e !== e0 && e !== -1);
        return points;
      }
      _clip(i) {
        // degenerate case (1 valid point: return the box)
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points = this._cell(i);
        if (points === null) return null;
        const {vectors: V} = this;
        const v = i * 4;
        return V[v] || V[v + 1]
            ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
            : this._clipFinite(i, points);
      }
      _clipFinite(i, points) {
        const n = points.length;
        let P = null;
        let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
        let c0, c1 = this._regioncode(x1, y1);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
          c0 = c1, c1 = this._regioncode(x1, y1);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P) P.push(x1, y1);
            else P = [x1, y1];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1) this._edge(i, e0, e1, P, P.length);
              if (P) P.push(sx0, sy0);
              else P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1) this._edge(i, e0, e1, P, P.length);
            if (P) P.push(sx1, sy1);
            else P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x0, y0, x1, y1, c0, c1) {
        while (true) {
          if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
          if (c0 & c1) return null;
          let x, y, c = c0 || c1;
          if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
          else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
          else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
          else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
          if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
          else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
        }
      }
      _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
        let P = Array.from(points), p;
        if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x, y;
          switch (e0) {
            case 0b0101: e0 = 0b0100; continue; // top-left
            case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
            case 0b0110: e0 = 0b0010; continue; // top-right
            case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
            case 0b1010: e0 = 0b1000; continue; // bottom-right
            case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
            case 0b1001: e0 = 0b0001; continue; // bottom-left
            case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
          }
          // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are
          // undefined, the conditional statement will be executed.
          if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
            P.splice(j, 0, x, y), j += 2;
          }
        }
        if (P.length > 4) {
          for (let i = 0; i < P.length; i+= 2) {
            const j = (i + 2) % P.length, k = (i + 4) % P.length;
            if (P[i] === P[j] && P[j] === P[k]
            || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
              P.splice(j, 2), i -= 2;
          }
        }
        return j;
      }
      _project(x0, y0, vx, vy) {
        let t = Infinity, c, x, y;
        if (vy < 0) { // top
          if (y0 <= this.ymin) return null;
          if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
        } else if (vy > 0) { // bottom
          if (y0 >= this.ymax) return null;
          if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
        }
        if (vx > 0) { // right
          if (x0 >= this.xmax) return null;
          if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
        } else if (vx < 0) { // left
          if (x0 <= this.xmin) return null;
          if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
        }
        return [x, y];
      }
      _edgecode(x, y) {
        return (x === this.xmin ? 0b0001
            : x === this.xmax ? 0b0010 : 0b0000)
            | (y === this.ymin ? 0b0100
            : y === this.ymax ? 0b1000 : 0b0000);
      }
      _regioncode(x, y) {
        return (x < this.xmin ? 0b0001
            : x > this.xmax ? 0b0010 : 0b0000)
            | (y < this.ymin ? 0b0100
            : y > this.ymax ? 0b1000 : 0b0000);
      }
    }

    const tau$2 = 2 * Math.PI, pow$2 = Math.pow;

    function pointX(p) {
      return p[0];
    }

    function pointY(p) {
      return p[1];
    }

    // A triangulation is collinear if all its triangles have a non-null area
    function collinear(d) {
      const {triangles, coords} = d;
      for (let i = 0; i < triangles.length; i += 3) {
        const a = 2 * triangles[i],
              b = 2 * triangles[i + 1],
              c = 2 * triangles[i + 2],
              cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                    - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
        if (cross > 1e-10) return false;
      }
      return true;
    }

    function jitter(x, y, r) {
      return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
    }

    class Delaunay {
      static from(points, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points
            ? flatArray(points, fx, fy, that)
            : Float64Array.from(flatIterable(points, fx, fy, that)));
      }
      constructor(points) {
        this._delaunator = new Delaunator(points);
        this.inedges = new Int32Array(points.length / 2);
        this._hullIndex = new Int32Array(points.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points = this.points;

        // check for collinear
        if (d.hull && d.hull.length > 2 && collinear(d)) {
          this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
            .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
          const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
            bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
          for (let i = 0, n = points.length / 2; i < n; ++i) {
            const p = jitter(points[2 * i], points[2 * i + 1], r);
            points[2 * i] = p[0];
            points[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points);
        } else {
          delete this.collinear;
        }

        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);

        // Compute an index from each point to an (arbitrary) incoming halfedge
        // Used to give the first neighbor of each point; for this reason,
        // on the hull we give priority to exterior halfedges
        for (let e = 0, n = halfedges.length; e < n; ++e) {
          const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
          if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }

        // degenerate case: 1 or 2 (distinct) points
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds) {
        return new Voronoi(this, bounds);
      }
      *neighbors(i) {
        const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

        // degenerate case with several collinear points
        if (collinear) {
          const l = collinear.indexOf(i);
          if (l > 0) yield collinear[l - 1];
          if (l < collinear.length - 1) yield collinear[l + 1];
          return;
        }

        const e0 = inedges[i];
        if (e0 === -1) return; // coincident point
        let e = e0, p0 = -1;
        do {
          yield p0 = triangles[e];
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) return; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p0) yield p;
            return;
          }
        } while (e !== e0);
      }
      find(x, y, i = 0) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
        const i0 = i;
        let c;
        while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
        return c;
      }
      _step(i, x, y) {
        const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
        if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
        let c = i;
        let dc = pow$2(x - points[i * 2], 2) + pow$2(y - points[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e = e0;
        do {
          let t = triangles[e];
          const dt = pow$2(x - points[t * 2], 2) + pow$2(y - points[t * 2 + 1], 2);
          if (dt < dc) dc = dt, c = t;
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            e = hull[(_hullIndex[i] + 1) % hull.length];
            if (e !== t) {
              if (pow$2(x - points[e * 2], 2) + pow$2(y - points[e * 2 + 1], 2) < dc) return e;
            }
            break;
          }
        } while (e !== e0);
        return c;
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, halfedges, triangles} = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context.moveTo(points[ti], points[ti + 1]);
          context.lineTo(points[tj], points[tj + 1]);
        }
        this.renderHull(context);
        return buffer && buffer.value();
      }
      renderPoints(context, r) {
        if (r === undefined && (!context || typeof context.moveTo !== "function")) r = context, context = null;
        r = r == undefined ? 2 : +r;
        const buffer = context == null ? context = new Path : undefined;
        const {points} = this;
        for (let i = 0, n = points.length; i < n; i += 2) {
          const x = points[i], y = points[i + 1];
          context.moveTo(x + r, y);
          context.arc(x, y, r, 0, tau$2);
        }
        return buffer && buffer.value();
      }
      renderHull(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {hull, points} = this;
        const h = hull[0] * 2, n = hull.length;
        context.moveTo(points[h], points[h + 1]);
        for (let i = 1; i < n; ++i) {
          const h = 2 * hull[i];
          context.lineTo(points[h], points[h + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon;
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, triangles} = this;
        const t0 = triangles[i *= 3] * 2;
        const t1 = triangles[i + 1] * 2;
        const t2 = triangles[i + 2] * 2;
        context.moveTo(points[t0], points[t0 + 1]);
        context.lineTo(points[t1], points[t1 + 1]);
        context.lineTo(points[t2], points[t2 + 1]);
        context.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const {triangles} = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon;
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    }

    function flatArray(points, fx, fy, that) {
      const n = points.length;
      const array = new Float64Array(n * 2);
      for (let i = 0; i < n; ++i) {
        const p = points[i];
        array[i * 2] = fx.call(that, p, i, points);
        array[i * 2 + 1] = fy.call(that, p, i, points);
      }
      return array;
    }

    function* flatIterable(points, fx, fy, that) {
      let i = 0;
      for (const p of points) {
        yield fx.call(that, p, i, points);
        yield fy.call(that, p, i, points);
        ++i;
      }
    }

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad$1(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear$1(year) {
      return year < 0 ? "-" + pad$1(-year, 6)
        : year > 9999 ? "+" + pad$1(year, 6)
        : pad$1(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
          : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv$1 = dsvFormat(",");

    var csvParse = csv$1.parse;
    var csvParseRows = csv$1.parseRows;
    var csvFormat = csv$1.format;
    var csvFormatBody = csv$1.formatBody;
    var csvFormatRows = csv$1.formatRows;
    var csvFormatRow = csv$1.formatRow;
    var csvFormatValue = csv$1.formatValue;

    var tsv$1 = dsvFormat("\t");

    var tsvParse = tsv$1.parse;
    var tsvParseRows = tsv$1.parseRows;
    var tsvFormat = tsv$1.format;
    var tsvFormatBody = tsv$1.formatBody;
    var tsvFormatRows = tsv$1.formatRows;
    var tsvFormatRow = tsv$1.formatRow;
    var tsvFormatValue = tsv$1.formatValue;

    function autoType(object) {
      for (var key in object) {
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
          if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
          value = new Date(value);
        }
        else continue;
        object[key] = value;
      }
      return object;
    }

    // https://github.com/d3/d3-dsv/issues/45
    const fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function responseBlob(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.blob();
    }

    function blob(input, init) {
      return fetch(input, init).then(responseBlob);
    }

    function responseArrayBuffer(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.arrayBuffer();
    }

    function buffer(input, init) {
      return fetch(input, init).then(responseArrayBuffer);
    }

    function responseText(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.text();
    }

    function text(input, init) {
      return fetch(input, init).then(responseText);
    }

    function dsvParse(parse) {
      return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return text(input, init).then(function(response) {
          return parse(response, row);
        });
      };
    }

    function dsv(delimiter, input, init, row) {
      if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
      var format = dsvFormat(delimiter);
      return text(input, init).then(function(response) {
        return format.parse(response, row);
      });
    }

    var csv = dsvParse(csvParse);
    var tsv = dsvParse(tsvParse);

    function image(input, init) {
      return new Promise(function(resolve, reject) {
        var image = new Image;
        for (var key in init) image[key] = init[key];
        image.onerror = reject;
        image.onload = function() { resolve(image); };
        image.src = input;
      });
    }

    function responseJson(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      if (response.status === 204 || response.status === 205) return;
      return response.json();
    }

    function json(input, init) {
      return fetch(input, init).then(responseJson);
    }

    function parser(type) {
      return (input, init) => text(input, init)
        .then(text => (new DOMParser).parseFromString(text, type));
    }

    var xml = parser("application/xml");

    var html = parser("text/html");

    var svg = parser("image/svg+xml");

    function center(x, y) {
      var nodes, strength = 1;

      if (x == null) x = 0;
      if (y == null) y = 0;

      function force() {
        var i,
            n = nodes.length,
            node,
            sx = 0,
            sy = 0;

        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }

        for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }

      force.initialize = function(_) {
        nodes = _;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      return force;
    }

    function tree_add(d) {
      const x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add(this.cover(x, y), x, y, d);
    }

    function add(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries dont change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0 || 1,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant cant contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isnt necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function constant$4(x) {
      return function() {
        return x;
      };
    }

    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }

    function x$3(d) {
      return d.x + d.vx;
    }

    function y$3(d) {
      return d.y + d.vy;
    }

    function collide(radius) {
      var nodes,
          radii,
          random,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant$4(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$3, y$3).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(random), l += x * x;
                if (y === 0) y = jiggle(random), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index$3(d) {
      return d.index;
    }

    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("node not found: " + nodeId);
      return node;
    }

    function link$2(links) {
      var id = index$3,
          strength = defaultStrength,
          strengths,
          distance = constant$4(30),
          distances,
          nodes,
          count,
          bias,
          random,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle(random);
            y = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$4(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$1 = 1664525;
    const c$3 = 1013904223;
    const m = 4294967296; // 2^32

    function lcg$1() {
      let s = 1;
      return () => (s = (a$1 * s + c$3) % m) / m;
    }

    function x$2(d) {
      return d.x;
    }

    function y$2(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function simulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = new Map(),
          stepper = timer(step),
          event = dispatch("tick", "end"),
          random = lcg$1();

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.forEach(function(force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes, random);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function manyBody() {
      var nodes,
          node,
          random,
          alpha,
          strength = constant$4(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x$2, y$2).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function radial$1(radius, x, y) {
      var nodes,
          strength = constant$4(0.1),
          strengths,
          radiuses;

      if (typeof radius !== "function") radius = constant$4(+radius);
      if (x == null) x = 0;
      if (y == null) y = 0;

      function force(alpha) {
        for (var i = 0, n = nodes.length; i < n; ++i) {
          var node = nodes[i],
              dx = node.x - x || 1e-6,
              dy = node.y - y || 1e-6,
              r = Math.sqrt(dx * dx + dy * dy),
              k = (radiuses[i] - r) * strengths[i] * alpha / r;
          node.vx += dx * k;
          node.vy += dy * k;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for (i = 0; i < n; ++i) {
          radiuses[i] = +radius(nodes[i], i, nodes);
          strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _, initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function x$1(x) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant$4(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : x;
      };

      return force;
    }

    function y$1(y) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant$4(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : y;
      };

      return force;
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };

    function identity$6(x) {
      return x;
    }

    var map = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale$1(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$6 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$6 : formatNumerals(map.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer value part that can be
            // grouped, and fractional or exponential suffix part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format;
    var formatPrefix;

    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    var epsilon$1 = 1e-6;
    var epsilon2 = 1e-12;
    var pi$1 = Math.PI;
    var halfPi$1 = pi$1 / 2;
    var quarterPi = pi$1 / 4;
    var tau$1 = pi$1 * 2;

    var degrees = 180 / pi$1;
    var radians = pi$1 / 180;

    var abs$1 = Math.abs;
    var atan = Math.atan;
    var atan2$1 = Math.atan2;
    var cos$1 = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;
    var hypot = Math.hypot;
    var log$1 = Math.log;
    var pow$1 = Math.pow;
    var sin$1 = Math.sin;
    var sign$1 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$2 = Math.sqrt;
    var tan = Math.tan;

    function acos$1(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin$1(x) {
      return x > 1 ? halfPi$1 : x < -1 ? -halfPi$1 : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin$1(x / 2)) * x;
    }

    function noop$2() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    var areaRingSum$1 = new Adder();

    // hello?

    var areaSum$1 = new Adder(),
        lambda00$2,
        phi00$2,
        lambda0$2,
        cosPhi0$1,
        sinPhi0$1;

    var areaStream$1 = {
      point: noop$2,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: function() {
        areaRingSum$1 = new Adder();
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum$1;
        areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$2;
      },
      sphere: function() {
        areaSum$1.add(tau$1);
      }
    };

    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }

    function areaRingEnd$1() {
      areaPoint$1(lambda00$2, phi00$2);
    }

    function areaPointFirst$1(lambda, phi) {
      areaStream$1.point = areaPoint$1;
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians, phi *= radians;
      lambda0$2 = lambda, cosPhi0$1 = cos$1(phi = phi / 2 + quarterPi), sinPhi0$1 = sin$1(phi);
    }

    function areaPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      phi = phi / 2 + quarterPi; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnolis
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0$2,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos$1(phi),
          sinPhi = sin$1(phi),
          k = sinPhi0$1 * sinPhi,
          u = cosPhi0$1 * cosPhi + k * cos$1(adLambda),
          v = k * sdLambda * sin$1(adLambda);
      areaRingSum$1.add(atan2$1(v, u));

      // Advance the previous points.
      lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
    }

    function area$2(object) {
      areaSum$1 = new Adder();
      geoStream(object, areaStream$1);
      return areaSum$1 * 2;
    }

    function spherical(cartesian) {
      return [atan2$1(cartesian[1], cartesian[0]), asin$1(cartesian[2])];
    }

    function cartesian(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
      return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0, // previous 3D point
        deltaSum,
        ranges,
        range;

    var boundsStream$1 = {
      point: boundsPoint$1,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$1.point = boundsRingPoint;
        boundsStream$1.lineStart = boundsRingStart;
        boundsStream$1.lineEnd = boundsRingEnd;
        deltaSum = new Adder();
        areaStream$1.polygonStart();
      },
      polygonEnd: function() {
        areaStream$1.polygonEnd();
        boundsStream$1.point = boundsPoint$1;
        boundsStream$1.lineStart = boundsLineStart;
        boundsStream$1.lineEnd = boundsLineEnd;
        if (areaRingSum$1 < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$1) phi1 = 90;
        else if (deltaSum < -epsilon$1) phi0 = -90;
        range[0] = lambda0$1, range[1] = lambda1;
      },
      sphere: function() {
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };

    function boundsPoint$1(lambda, phi) {
      ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian([lambda * radians, phi * radians]);
      if (p0) {
        var normal = cartesianCross(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical(inflection);
        var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees * sign,
            phii,
            antimeridian = abs$1(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = inflection[1] * degrees;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = -inflection[1] * degrees;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream$1.point = linePoint;
    }

    function boundsLineEnd() {
      range[0] = lambda0$1, range[1] = lambda1;
      boundsStream$1.point = boundsPoint$1;
      p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream$1.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream$1.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream$1.lineEnd();
      if (abs$1(deltaSum) > epsilon$1) lambda0$1 = -(lambda1 = 180);
      range[0] = lambda0$1, range[1] = lambda1;
      p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
    // the distance between 180 to be 360.
    function angle(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range, x) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function bounds(feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream(feature, boundsStream$1);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range = null;

      return lambda0$1 === Infinity || phi0 === Infinity
          ? [[NaN, NaN], [NaN, NaN]]
          : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1,
        X0$1, Y0$1, Z0$1,
        X1$1, Y1$1, Z1$1,
        X2$1, Y2$1, Z2$1,
        lambda00, phi00, // first point
        x0$4, y0$4, z0; // previous point

    var centroidStream$1 = {
      sphere: noop$2,
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function() {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function() {
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0$1 += (x - X0$1) / W0;
      Y0$1 += (y - Y0$1) / W0;
      Z0$1 += (z - Z0$1) / W0;
    }

    function centroidLineStart$1() {
      centroidStream$1.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidStream$1.point = centroidLinePoint;
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          w = atan2$1(sqrt$2((w = y0$4 * z - z0 * y) * w + (w = z0 * x - x0$4 * z) * w + (w = x0$4 * y - y0$4 * x) * w), x0$4 * x + y0$4 * y + z0 * z);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart$1() {
      centroidStream$1.point = centroidRingPointFirst;
    }

    function centroidRingEnd$1() {
      centroidRingPoint(lambda00, phi00);
      centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00 = lambda, phi00 = phi;
      lambda *= radians, phi *= radians;
      centroidStream$1.point = centroidRingPoint;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          cx = y0$4 * z - z0 * y,
          cy = z0 * x - x0$4 * z,
          cz = x0$4 * y - y0$4 * x,
          m = hypot(cx, cy, cz),
          w = asin$1(m), // line weight = angle
          v = m && -w / m; // area weight multiplier
      X2$1.add(v * cx);
      Y2$1.add(v * cy);
      Z2$1.add(v * cz);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroid$1(object) {
      W0 = W1 =
      X0$1 = Y0$1 = Z0$1 =
      X1$1 = Y1$1 = Z1$1 = 0;
      X2$1 = new Adder();
      Y2$1 = new Adder();
      Z2$1 = new Adder();
      geoStream(object, centroidStream$1);

      var x = +X2$1,
          y = +Y2$1,
          z = +Z2$1,
          m = hypot(x, y, z);

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2) {
        x = X1$1, y = Y1$1, z = Z1$1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon$1) x = X0$1, y = Y0$1, z = Z0$1;
        m = hypot(x, y, z);
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2) return [NaN, NaN];
      }

      return [atan2$1(y, x) * degrees, asin$1(z / m) * degrees];
    }

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    function compose(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity(lambda, phi) {
      return [abs$1(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$1) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
        : rotationLambda(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
        : rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$1(deltaPhi),
          sinDeltaPhi = sin$1(deltaPhi),
          cosDeltaGamma = cos$1(deltaGamma),
          sinDeltaGamma = sin$1(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2$1(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin$1(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2$1(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin$1(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    function rotation(rotate) {
      rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }

      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };

      return forward;
    }

    // Generates a circle centered at [0, 0], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos$1(radius),
          sinRadius = sin$1(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau$1;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$1;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos$1(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau$1 - epsilon$1) % tau$1;
    }

    function circle$2() {
      var center = constant$3([0, 0]),
          radius = constant$3(90),
          precision = constant$3(6),
          ring,
          rotate,
          stream = {point: point};

      function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= degrees, x[1] *= degrees;
      }

      function circle() {
        var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * radians,
            p = precision.apply(this, arguments) * radians;
        ring = [];
        rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
        circleStream(stream, r, p, 1);
        c = {type: "Polygon", coordinates: [ring]};
        ring = rotate = null;
        return c;
      }

      circle.center = function(_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : constant$3([+_[0], +_[1]]), circle) : center;
      };

      circle.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$3(+_), circle) : radius;
      };

      circle.precision = function(_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : constant$3(+_), circle) : precision;
      };

      return circle;
    }

    function clipBuffer() {
      var lines = [],
          line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$2,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function pointEqual(a, b) {
      return abs$1(a[0] - b[0]) < epsilon$1 && abs$1(a[1] - b[1]) < epsilon$1;
    }

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        if (pointEqual(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          // handle degenerate cases by moving the point
          p1[0] += 2 * epsilon$1;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link$1(subject);
      link$1(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link$1(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    function longitude(point) {
      return abs$1(point[0]) <= pi$1 ? point[0] : sign$1(point[0]) * ((abs$1(point[0]) + pi$1) % tau$1 - pi$1);
    }

    function polygonContains(polygon, point) {
      var lambda = longitude(point),
          phi = point[1],
          sinPhi = sin$1(phi),
          normal = [sin$1(lambda), -cos$1(lambda), 0],
          angle = 0,
          winding = 0;

      var sum = new Adder();

      if (sinPhi === 1) phi = halfPi$1 + epsilon$1;
      else if (sinPhi === -1) phi = -halfPi$1 - epsilon$1;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = longitude(point0),
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin$1(phi0),
            cosPhi0 = cos$1(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = longitude(point1),
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin$1(phi1),
              cosPhi1 = cos$1(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi$1,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2$1(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
          angle += antimeridian ? delta + sign * tau$1 : delta;

          // Are the longitudes either side of the points meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon$1 || angle < epsilon$1 && sum < -epsilon2) ^ (winding & 1);
    }

    function clip(pointVisible, clipLine, interpolate, start) {
      return function(sink) {
        var line = clipLine(sink),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge(segments);
            var startInside = polygonContains(polygon, start);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    }

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi$1 - epsilon$1 : halfPi$1 - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$1 : halfPi$1 - b[1]);
    }

    var clipAntimeridian = clip(
      function() { return true; },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$1, -halfPi$1]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$1 : -pi$1,
              delta = abs$1(lambda1 - lambda0);
          if (abs$1(delta - pi$1) < epsilon$1) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$1 : -halfPi$1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$1) { // line crosses antimeridian
            if (abs$1(lambda0 - sign0) < epsilon$1) lambda0 -= sign0 * epsilon$1; // handle degeneracies
            if (abs$1(lambda1 - sign1) < epsilon$1) lambda1 -= sign1 * epsilon$1;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
      return abs$1(sinLambda0Lambda1) > epsilon$1
          ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
              - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi$1;
        stream.point(-pi$1, phi);
        stream.point(0, phi);
        stream.point(pi$1, phi);
        stream.point(pi$1, 0);
        stream.point(pi$1, -phi);
        stream.point(0, -phi);
        stream.point(-pi$1, -phi);
        stream.point(-pi$1, 0);
        stream.point(-pi$1, phi);
      } else if (abs$1(from[0] - to[0]) > epsilon$1) {
        var lambda = from[0] < to[0] ? pi$1 : -pi$1;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle(radius) {
      var cr = cos$1(radius),
          delta = 6 * radians,
          smallRadius = cr > 0,
          notHemisphere = abs$1(cr) > epsilon$1; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos$1(lambda) * cos$1(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian(a),
            pb = cartesian(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross(pa, pb),
            n2n2 = cartesianDot(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot(A, u),
            uu = cartesianDot(u, u),
            t2 = w * w - uu * (cartesianDot(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt$2(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs$1(delta - pi$1) < epsilon$1,
            meridian = polar || delta < epsilon$1;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon$1 ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi$1 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi$1 - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
    }

    function clipLine(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    var clipMax = 1e9, clipMin = -clipMax;

    // TODO Use d3-polygons polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs$1(p[0] - x0) < epsilon$1 ? direction > 0 ? 0 : 3
            : abs$1(p[0] - x1) < epsilon$1 ? direction > 0 ? 2 : 1
            : abs$1(p[1] - y0) < epsilon$1 ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    function extent() {
      var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip;

      return clip = {
        stream: function(stream) {
          return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function(_) {
          return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
        }
      };
    }

    var lengthSum$1,
        lambda0,
        sinPhi0,
        cosPhi0;

    var lengthStream$1 = {
      sphere: noop$2,
      point: noop$2,
      lineStart: lengthLineStart,
      lineEnd: noop$2,
      polygonStart: noop$2,
      polygonEnd: noop$2
    };

    function lengthLineStart() {
      lengthStream$1.point = lengthPointFirst$1;
      lengthStream$1.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream$1.point = lengthStream$1.lineEnd = noop$2;
    }

    function lengthPointFirst$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      lambda0 = lambda, sinPhi0 = sin$1(phi), cosPhi0 = cos$1(phi);
      lengthStream$1.point = lengthPoint$1;
    }

    function lengthPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var sinPhi = sin$1(phi),
          cosPhi = cos$1(phi),
          delta = abs$1(lambda - lambda0),
          cosDelta = cos$1(delta),
          sinDelta = sin$1(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
      lengthSum$1.add(atan2$1(sqrt$2(x * x + y * y), z));
      lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
    }

    function length$1(object) {
      lengthSum$1 = new Adder();
      geoStream(object, lengthStream$1);
      return +lengthSum$1;
    }

    var coordinates = [null, null],
        object = {type: "LineString", coordinates: coordinates};

    function distance(a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length$1(object);
    }

    var containsObjectType = {
      Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function(object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type)
          ? containsGeometryType[geometry.type](geometry, point)
          : false;
    }

    function containsPoint(coordinates, point) {
      return distance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ao, bo, ab;
      for (var i = 0, n = coordinates.length; i < n; i++) {
        bo = distance(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
          ab = distance(coordinates[i], coordinates[i - 1]);
          if (
            ab > 0 &&
            ao <= ab &&
            bo <= ab &&
            (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
          )
            return true;
        }
        ao = bo;
      }
      return false;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }

    function contains$1(object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type)
          ? containsObjectType[object.type]
          : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
      var y = range$2(y0, y1 - epsilon$1, dy).concat(y1);
      return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
      var x = range$2(x0, x1 - epsilon$1, dx).concat(x1);
      return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
      var x1, x0, X1, X0,
          y1, y0, Y1, Y0,
          dx = 10, dy = dx, DX = 90, DY = 360,
          x, y, X, Y,
          precision = 2.5;

      function graticule() {
        return {type: "MultiLineString", coordinates: lines()};
      }

      function lines() {
        return range$2(ceil(X0 / DX) * DX, X1, DX).map(X)
            .concat(range$2(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
            .concat(range$2(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$1(x % DX) > epsilon$1; }).map(x))
            .concat(range$2(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$1(y % DY) > epsilon$1; }).map(y));
      }

      graticule.lines = function() {
        return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
      };

      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X(X0).concat(
            Y(Y1).slice(1),
            X(X1).reverse().slice(1),
            Y(Y0).reverse().slice(1))
          ]
        };
      };

      graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function(_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function(_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function(_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function(_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule
          .extentMajor([[-180, -90 + epsilon$1], [180, 90 - epsilon$1]])
          .extentMinor([[-180, -80 - epsilon$1], [180, 80 + epsilon$1]]);
    }

    function graticule10() {
      return graticule()();
    }

    function interpolate(a, b) {
      var x0 = a[0] * radians,
          y0 = a[1] * radians,
          x1 = b[0] * radians,
          y1 = b[1] * radians,
          cy0 = cos$1(y0),
          sy0 = sin$1(y0),
          cy1 = cos$1(y1),
          sy1 = sin$1(y1),
          kx0 = cy0 * cos$1(x0),
          ky0 = cy0 * sin$1(x0),
          kx1 = cy1 * cos$1(x1),
          ky1 = cy1 * sin$1(x1),
          d = 2 * asin$1(sqrt$2(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin$1(d);

      var interpolate = d ? function(t) {
        var B = sin$1(t *= d) / k,
            A = sin$1(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [
          atan2$1(y, x) * degrees,
          atan2$1(z, sqrt$2(x * x + y * y)) * degrees
        ];
      } : function() {
        return [x0 * degrees, y0 * degrees];
      };

      interpolate.distance = d;

      return interpolate;
    }

    var identity$5 = x => x;

    var areaSum = new Adder(),
        areaRingSum = new Adder(),
        x00$2,
        y00$2,
        x0$3,
        y0$3;

    var areaStream = {
      point: noop$2,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$2;
        areaSum.add(abs$1(areaRingSum));
        areaRingSum = new Adder();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum = new Adder();
        return area;
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00$2 = x0$3 = x, y00$2 = y0$3 = y;
    }

    function areaPoint(x, y) {
      areaRingSum.add(y0$3 * x - x0$3 * y);
      x0$3 = x, y0$3 = y;
    }

    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }

    var x0$2 = Infinity,
        y0$2 = x0$2,
        x1 = -x0$2,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: noop$2,
      polygonEnd: noop$2,
      result: function() {
        var bounds = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0$2) x0$2 = x;
      if (x > x1) x1 = x;
      if (y < y0$2) y0$2 = y;
      if (y > y1) y1 = y;
    }

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00$1,
        y00$1,
        x0$1,
        y0$1;

    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
            : Z1 ? [X1 / Z1, Y1 / Z1]
            : Z0 ? [X0 / Z0, Y0 / Z0]
            : [NaN, NaN];
        X0 = Y0 = Z0 =
        X1 = Y1 = Z1 =
        X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };

    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$1, dy = y - y0$1, z = sqrt$2(dx * dx + dy * dy);
      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }

    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$1 = x, y00$1 = y0$1 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$1,
          dy = y - y0$1,
          z = sqrt$2(dx * dx + dy * dy);

      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;

      z = y0$1 * x - x0$1 * y;
      X2 += z * (x0$1 + x);
      Y2 += z * (y0$1 + y);
      Z2 += z * 3;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$1);
            break;
          }
        }
      },
      result: noop$2
    };

    var lengthSum = new Adder(),
        lengthRing,
        x00,
        y00,
        x0,
        y0;

    var lengthStream = {
      point: noop$2,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing) lengthPoint(x00, y00);
        lengthStream.point = noop$2;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length = +lengthSum;
        lengthSum = new Adder();
        return length;
      }
    };

    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00 = x0 = x, y00 = y0 = y;
    }

    function lengthPoint(x, y) {
      x0 -= x, y0 -= y;
      lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
      x0 = x, y0 = y;
    }

    function PathString() {
      this._string = [];
    }

    PathString.prototype = {
      _radius: 4.5,
      _circle: circle$1(4.5),
      pointRadius: function(_) {
        if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._string.push("Z");
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x, ",", y);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x, ",", y);
            break;
          }
          default: {
            if (this._circle == null) this._circle = circle$1(this._radius);
            this._string.push("M", x, ",", y, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };

    function circle$1(radius) {
      return "m0," + radius
          + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
          + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
          + "z";
    }

    function index$2(projection, context) {
      var pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function(object) {
        geoStream(object, projectionStream(areaStream));
        return areaStream.result();
      };

      path.measure = function(object) {
        geoStream(object, projectionStream(lengthStream));
        return lengthStream.result();
      };

      path.bounds = function(object) {
        geoStream(object, projectionStream(boundsStream));
        return boundsStream.result();
      };

      path.centroid = function(object) {
        geoStream(object, projectionStream(centroidStream));
        return centroidStream.result();
      };

      path.projection = function(_) {
        return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$5) : (projection = _).stream, path) : projection;
      };

      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      return path.projection(projection).context(context);
    }

    function transform$1(methods) {
      return {
        stream: transformer$3(methods)
      };
    }

    function transformer$3(methods) {
      return function(stream) {
        var s = new TransformStream;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
      var clip = projection.clipExtent && projection.clipExtent();
      projection.scale(150).translate([0, 0]);
      if (clip != null) projection.clipExtent(null);
      geoStream(object, projection.stream(boundsStream));
      fitBounds(boundsStream.result());
      if (clip != null) projection.clipExtent(clip);
      return projection;
    }

    function fitExtent(projection, extent, object) {
      return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    function fitWidth(projection, width, object) {
      return fit(projection, function(b) {
        var w = +width,
            k = w / (b[1][0] - b[0][0]),
            x = (w - k * (b[1][0] + b[0][0])) / 2,
            y = -k * b[0][1];
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitHeight(projection, height, object) {
      return fit(projection, function(b) {
        var h = +height,
            k = h / (b[1][1] - b[0][1]),
            x = -k * b[0][0],
            y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
      return transformer$3({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt$2(a * a + b * b + c * c),
              phi2 = asin$1(c /= m),
              lambda2 = abs$1(abs$1(c) - 1) < epsilon$1 || abs$1(lambda0 - lambda1) < epsilon$1 ? (lambda0 + lambda1) / 2 : atan2$1(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer$3({
      point: function(x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });

    function transformRotate(rotate) {
      return transformer$3({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx; y *= sy;
        return [dx + k * x, dy - k * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k * sx, (dy - y) / k * sy];
      };
      return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
      var cosAlpha = cos$1(alpha),
          sinAlpha = sin$1(alpha),
          a = cosAlpha * k,
          b = sinAlpha * k,
          ai = cosAlpha / k,
          bi = sinAlpha / k,
          ci = (sinAlpha * dy - cosAlpha * dx) / k,
          fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform(x, y) {
        x *= sx; y *= sy;
        return [a * x - b * y + dx, dy - b * x - a * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }

    function projection(project) {
      return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
          alpha = 0, // post-rotate angle
          sx = 1, // reflectX
          sy = 1, // reflectX
          theta = null, preclip = clipAntimeridian, // pre-clip angle
          x0 = null, y0, x1, y1, postclip = identity$5, // post-clip extent
          delta2 = 0.5, // precision
          projectResample,
          projectTransform,
          projectRotateTransform,
          cache,
          cacheStream;

      function projection(point) {
        return projectRotateTransform(point[0] * radians, point[1] * radians);
      }

      function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [point[0] * degrees, point[1] * degrees];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };

      projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
      };

      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };

      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
      };

      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };

      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$2(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };

      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };

      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
            transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project, transform);
        projectRotateTransform = compose(rotate, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function conicProjection(projectAt) {
      var phi0 = 0,
          phi1 = pi$1 / 3,
          m = projectionMutator(projectAt),
          p = m(phi0, phi1);

      p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
      };

      return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos$1(phi0);

      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
      }

      forward.invert = function(x, y) {
        return [x / cosPhi0, asin$1(y * cosPhi0)];
      };

      return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
      var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

      // Are the parallels symmetrical around the Equator?
      if (abs$1(n) < epsilon$1) return cylindricalEqualAreaRaw(y0);

      var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c) / n;

      function project(x, y) {
        var r = sqrt$2(c - 2 * n * sin$1(y)) / n;
        return [r * sin$1(x *= n), r0 - r * cos$1(x)];
      }

      project.invert = function(x, y) {
        var r0y = r0 - y,
            l = atan2$1(x, abs$1(r0y)) * sign$1(r0y);
        if (r0y * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(r0y);
        return [l / n, asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };

      return project;
    }

    function conicEqualArea() {
      return conicProjection(conicEqualAreaRaw)
          .scale(155.424)
          .center([0, 33.6442]);
    }

    function albers() {
      return conicEqualArea()
          .parallels([29.5, 45.5])
          .scale(1070)
          .translate([480, 250])
          .rotate([96, 0])
          .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
        sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
        lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
        lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
        polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
        polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
      };
    }

    // A composite projection for the United States, configured by default for
    // 960500. The projection also works quite well at 960600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa() {
      var cache,
          cacheStream,
          lower48 = albers(), lower48Point,
          alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
          hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
          point, pointStream = {point: function(x, y) { point = [x, y]; }};

      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point = null,
            (lower48Point.point(x, y), point)
            || (alaskaPoint.point(x, y), point)
            || (hawaiiPoint.point(x, y), point);
      }

      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k;
        return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
            : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
            : lower48).invert(coordinates);
      };

      albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };

      albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };

      albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };

      albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];

        lower48Point = lower48
            .translate(_)
            .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
            .stream(pointStream);

        alaskaPoint = alaska
            .translate([x - 0.307 * k, y + 0.201 * k])
            .clipExtent([[x - 0.425 * k + epsilon$1, y + 0.120 * k + epsilon$1], [x - 0.214 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        hawaiiPoint = hawaii
            .translate([x - 0.205 * k, y + 0.212 * k])
            .clipExtent([[x - 0.214 * k + epsilon$1, y + 0.166 * k + epsilon$1], [x - 0.115 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        return reset();
      };

      albersUsa.fitExtent = function(extent, object) {
        return fitExtent(albersUsa, extent, object);
      };

      albersUsa.fitSize = function(size, object) {
        return fitSize(albersUsa, size, object);
      };

      albersUsa.fitWidth = function(width, object) {
        return fitWidth(albersUsa, width, object);
      };

      albersUsa.fitHeight = function(height, object) {
        return fitHeight(albersUsa, height, object);
      };

      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }

      return albersUsa.scale(1070);
    }

    function azimuthalRaw(scale) {
      return function(x, y) {
        var cx = cos$1(x),
            cy = cos$1(y),
            k = scale(cx * cy);
            if (k === Infinity) return [2, 0];
        return [
          k * cy * sin$1(x),
          k * sin$1(y)
        ];
      }
    }

    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt$2(x * x + y * y),
            c = angle(z),
            sc = sin$1(c),
            cc = cos$1(c);
        return [
          atan2$1(x * sc, z * cc),
          asin$1(z && y * sc / z)
        ];
      }
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt$2(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin$1(z / 2);
    });

    function azimuthalEqualArea() {
      return projection(azimuthalEqualAreaRaw)
          .scale(124.75)
          .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
      return (c = acos$1(c)) && c / sin$1(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });

    function azimuthalEquidistant() {
      return projection(azimuthalEquidistantRaw)
          .scale(79.4188)
          .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
      return [lambda, log$1(tan((halfPi$1 + phi) / 2))];
    }

    mercatorRaw.invert = function(x, y) {
      return [x, 2 * atan(exp(y)) - halfPi$1];
    };

    function mercator() {
      return mercatorProjection(mercatorRaw)
          .scale(961 / tau$1);
    }

    function mercatorProjection(project) {
      var m = projection(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null, y0, x1, y1; // clip extent

      m.scale = function(_) {
        return arguments.length ? (scale(_), reclip()) : scale();
      };

      m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };

      m.center = function(_) {
        return arguments.length ? (center(_), reclip()) : center();
      };

      m.clipExtent = function(_) {
        return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      function reclip() {
        var k = pi$1 * scale(),
            t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x0 == null
            ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
            ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
            : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
      }

      return reclip();
    }

    function tany(y) {
      return tan((halfPi$1 + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : log$1(cy0 / cos$1(y1)) / log$1(tany(y1) / tany(y0)),
          f = cy0 * pow$1(tany(y0), n) / n;

      if (!n) return mercatorRaw;

      function project(x, y) {
        if (f > 0) { if (y < -halfPi$1 + epsilon$1) y = -halfPi$1 + epsilon$1; }
        else { if (y > halfPi$1 - epsilon$1) y = halfPi$1 - epsilon$1; }
        var r = f / pow$1(tany(y), n);
        return [r * sin$1(n * x), f - r * cos$1(n * x)];
      }

      project.invert = function(x, y) {
        var fy = f - y, r = sign$1(n) * sqrt$2(x * x + fy * fy),
          l = atan2$1(x, abs$1(fy)) * sign$1(fy);
        if (fy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(fy);
        return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi$1];
      };

      return project;
    }

    function conicConformal() {
      return conicProjection(conicConformalRaw)
          .scale(109.5)
          .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    function equirectangular() {
      return projection(equirectangularRaw)
          .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
          g = cy0 / n + y0;

      if (abs$1(n) < epsilon$1) return equirectangularRaw;

      function project(x, y) {
        var gy = g - y, nx = n * x;
        return [gy * sin$1(nx), g - gy * cos$1(nx)];
      }

      project.invert = function(x, y) {
        var gy = g - y,
            l = atan2$1(x, abs$1(gy)) * sign$1(gy);
        if (gy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(gy);
        return [l / n, g - sign$1(n) * sqrt$2(x * x + gy * gy)];
      };

      return project;
    }

    function conicEquidistant() {
      return conicProjection(conicEquidistantRaw)
          .scale(131.154)
          .center([0, 13.9389]);
    }

    var A1 = 1.340264,
        A2 = -0.081106,
        A3 = 0.000893,
        A4 = 0.003796,
        M = sqrt$2(3) / 2,
        iterations = 12;

    function equalEarthRaw(lambda, phi) {
      var l = asin$1(M * sin$1(phi)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
      ];
    }

    equalEarthRaw.invert = function(x, y) {
      var l = y, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs$1(delta) < epsilon2) break;
      }
      return [
        M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
        asin$1(sin$1(l) / M)
      ];
    };

    function equalEarth() {
      return projection(equalEarthRaw)
          .scale(177.158);
    }

    function gnomonicRaw(x, y) {
      var cy = cos$1(y), k = cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert(atan);

    function gnomonic() {
      return projection(gnomonicRaw)
          .scale(144.049)
          .clipAngle(60);
    }

    function identity$4() {
      var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
          alpha = 0, ca, sa, // angle
          x0 = null, y0, x1, y1, // clip extent
          kx = 1, ky = 1,
          transform = transformer$3({
            point: function(x, y) {
              var p = projection([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }),
          postclip = identity$5,
          cache,
          cacheStream;

      function reset() {
        kx = k * sx;
        ky = k * sy;
        cache = cacheStream = null;
        return projection;
      }

      function projection (p) {
        var x = p[0] * kx, y = p[1] * ky;
        if (alpha) {
          var t = y * ca - x * sa;
          x = x * ca + y * sa;
          y = t;
        }    
        return [x + tx, y + ty];
      }
      projection.invert = function(p) {
        var x = p[0] - tx, y = p[1] - ty;
        if (alpha) {
          var t = y * ca + x * sa;
          x = x * ca - y * sa;
          y = t;
        }
        return [x / kx, y / ky];
      };
      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
      };
      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };
      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };
      projection.scale = function(_) {
        return arguments.length ? (k = +_, reset()) : k;
      };
      projection.translate = function(_) {
        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
      };
      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, sa = sin$1(alpha), ca = cos$1(alpha), reset()) : alpha * degrees;
      };
      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
      };
      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
      };
      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };
      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };
      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };
      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      return projection;
    }

    function naturalEarth1Raw(lambda, phi) {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      return [
        lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
        phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
      ];
    }

    naturalEarth1Raw.invert = function(x, y) {
      var phi = y, i = 25, delta;
      do {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
            (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
      } while (abs$1(delta) > epsilon$1 && --i > 0);
      return [
        x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
        phi
      ];
    };

    function naturalEarth1() {
      return projection(naturalEarth1Raw)
          .scale(175.295);
    }

    function orthographicRaw(x, y) {
      return [cos$1(y) * sin$1(x), sin$1(y)];
    }

    orthographicRaw.invert = azimuthalInvert(asin$1);

    function orthographic() {
      return projection(orthographicRaw)
          .scale(249.5)
          .clipAngle(90 + epsilon$1);
    }

    function stereographicRaw(x, y) {
      var cy = cos$1(y), k = 1 + cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });

    function stereographic() {
      return projection(stereographicRaw)
          .scale(250)
          .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
      return [log$1(tan((halfPi$1 + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function(x, y) {
      return [-y, 2 * atan(exp(x)) - halfPi$1];
    };

    function transverseMercator() {
      var m = mercatorProjection(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate;

      m.center = function(_) {
        return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
      };

      m.rotate = function(_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };

      return rotate([0, 0, 90])
          .scale(159.155);
    }

    function defaultSeparation$1(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    function meanX(children) {
      return children.reduce(meanXReduce, 0) / children.length;
    }

    function meanXReduce(x, c) {
      return x + c.x;
    }

    function maxY(children) {
      return 1 + children.reduce(maxYReduce, 0);
    }

    function maxYReduce(y, c) {
      return Math.max(y, c.y);
    }

    function leafLeft(node) {
      var children;
      while (children = node.children) node = children[0];
      return node;
    }

    function leafRight(node) {
      var children;
      while (children = node.children) node = children[children.length - 1];
      return node;
    }

    function cluster() {
      var separation = defaultSeparation$1,
          dx = 1,
          dy = 1,
          nodeSize = false;

      function cluster(root) {
        var previousNode,
            x = 0;

        // First walk, computing the initial x & y values.
        root.eachAfter(function(node) {
          var children = node.children;
          if (children) {
            node.x = meanX(children);
            node.y = maxY(children);
          } else {
            node.x = previousNode ? x += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });

        var left = leafLeft(root),
            right = leafRight(root),
            x0 = left.x - separation(left, right) / 2,
            x1 = right.x + separation(right, left) / 2;

        // Second walk, normalizing x & y to the desired size.
        return root.eachAfter(nodeSize ? function(node) {
          node.x = (node.x - root.x) * dx;
          node.y = (root.y - node.y) * dy;
        } : function(node) {
          node.x = (node.x - x0) / (x1 - x0) * dx;
          node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
        });
      }

      cluster.separation = function(x) {
        return arguments.length ? (separation = x, cluster) : separation;
      };

      cluster.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
      };

      cluster.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
      };

      return cluster;
    }

    function count(node) {
      var sum = 0,
          children = node.children,
          i = children && children.length;
      if (!i) sum = 1;
      else while (--i >= 0) sum += children[i].value;
      node.value = sum;
    }

    function node_count() {
      return this.eachAfter(count);
    }

    function node_each(callback, that) {
      let index = -1;
      for (const node of this) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_eachBefore(callback, that) {
      var node = this, nodes = [node], children, i, index = -1;
      while (node = nodes.pop()) {
        callback.call(that, node, ++index, this);
        if (children = node.children) {
          for (i = children.length - 1; i >= 0; --i) {
            nodes.push(children[i]);
          }
        }
      }
      return this;
    }

    function node_eachAfter(callback, that) {
      var node = this, nodes = [node], next = [], children, i, n, index = -1;
      while (node = nodes.pop()) {
        next.push(node);
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            nodes.push(children[i]);
          }
        }
      }
      while (node = next.pop()) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_find(callback, that) {
      let index = -1;
      for (const node of this) {
        if (callback.call(that, node, ++index, this)) {
          return node;
        }
      }
    }

    function node_sum(value) {
      return this.eachAfter(function(node) {
        var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length;
        while (--i >= 0) sum += children[i].value;
        node.value = sum;
      });
    }

    function node_sort(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }

    function node_path(end) {
      var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start];
      while (start !== ancestor) {
        start = start.parent;
        nodes.push(start);
      }
      var k = nodes.length;
      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }
      return nodes;
    }

    function leastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }

    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }

    function node_descendants() {
      return Array.from(this);
    }

    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }

    function node_links() {
      var root = this, links = [];
      root.each(function(node) {
        if (node !== root) { // Dont include the roots parent, if any.
          links.push({source: node.parent, target: node});
        }
      });
      return links;
    }

    function* node_iterator() {
      var node = this, current, next = [node], children, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          yield node;
          if (children = node.children) {
            for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }
        }
      } while (next.length);
    }

    function hierarchy(data, children) {
      if (data instanceof Map) {
        data = [undefined, data];
        if (children === undefined) children = mapChildren;
      } else if (children === undefined) {
        children = objectChildren;
      }

      var root = new Node$1(data),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n;

      while (node = nodes.pop()) {
        if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
          node.children = childs;
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = childs[i] = new Node$1(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }

      return root.eachBefore(computeHeight);
    }

    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }

    function objectChildren(d) {
      return d.children;
    }

    function mapChildren(d) {
      return Array.isArray(d) ? d[1] : null;
    }

    function copyData(node) {
      if (node.data.value !== undefined) node.value = node.data.value;
      node.data = node.data.data;
    }

    function computeHeight(node) {
      var height = 0;
      do node.height = height;
      while ((node = node.parent) && (node.height < ++height));
    }

    function Node$1(data) {
      this.data = data;
      this.depth =
      this.height = 0;
      this.parent = null;
    }

    Node$1.prototype = hierarchy.prototype = {
      constructor: Node$1,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      find: node_find,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy,
      [Symbol.iterator]: node_iterator
    };

    function array$1(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function shuffle(array) {
      var m = array.length,
          t,
          i;

      while (m) {
        i = Math.random() * m-- | 0;
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }

      return array;
    }

    function enclose(circles) {
      var i = 0, n = (circles = shuffle(Array.from(circles))).length, B = [], p, e;

      while (i < n) {
        p = circles[i];
        if (e && enclosesWeak(e, p)) ++i;
        else e = encloseBasis(B = extendBasis(B, p)), i = 0;
      }

      return e;
    }

    function extendBasis(B, p) {
      var i, j;

      if (enclosesWeakAll(p, B)) return [p];

      // If we get here then B must have at least one element.
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i])
            && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }

      // If we get here then B must have at least two elements.
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p)
              && enclosesNot(encloseBasis2(B[i], p), B[j])
              && enclosesNot(encloseBasis2(B[j], p), B[i])
              && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }

      // If we get here then something is very wrong.
      throw new Error;
    }

    function enclosesNot(a, b) {
      var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }

    function enclosesWeak(a, b) {
      var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }

    function encloseBasis(B) {
      switch (B.length) {
        case 1: return encloseBasis1(B[0]);
        case 2: return encloseBasis2(B[0], B[1]);
        case 3: return encloseBasis3(B[0], B[1], B[2]);
      }
    }

    function encloseBasis1(a) {
      return {
        x: a.x,
        y: a.y,
        r: a.r
      };
    }

    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
          l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
        x: (x1 + x2 + x21 / l * r21) / 2,
        y: (y1 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
      };
    }

    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x3 = c.x, y3 = c.y, r3 = c.r,
          a2 = x1 - x2,
          a3 = x1 - x3,
          b2 = y1 - y2,
          b3 = y1 - y3,
          c2 = r2 - r1,
          c3 = r3 - r1,
          d1 = x1 * x1 + y1 * y1 - r1 * r1,
          d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
          d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
          ab = a3 * b2 - a2 * b3,
          xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
          xb = (b3 * c2 - b2 * c3) / ab,
          ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
          yb = (a2 * c3 - a3 * c2) / ab,
          A = xb * xb + yb * yb - 1,
          B = 2 * (r1 + xa * xb + ya * yb),
          C = xa * xa + ya * ya - r1 * r1,
          r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return {
        x: x1 + xa + xb * r,
        y: y1 + ya + yb * r,
        r: r
      };
    }

    function place(b, a, c) {
      var dx = b.x - a.x, x, a2,
          dy = b.y - a.y, y, b2,
          d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r, a2 *= a2;
        b2 = b.r + c.r, b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }

    function intersects(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function score(node) {
      var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab,
          dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }

    function Node(circle) {
      this._ = circle;
      this.next = null;
      this.previous = null;
    }

    function packEnclose(circles) {
      if (!(n = (circles = array$1(circles)).length)) return 0;

      var a, b, c, n, aa, ca, i, j, k, sj, sk;

      // Place the first circle.
      a = circles[0], a.x = 0, a.y = 0;
      if (!(n > 1)) return a.r;

      // Place the second circle.
      b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
      if (!(n > 2)) return a.r + b.r;

      // Place the third circle.
      place(b, a, c = circles[2]);

      // Initialize the front-chain using the first three circles a, b and c.
      a = new Node(a), b = new Node(b), c = new Node(c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;

      // Attempt to place each remaining circle
      pack: for (i = 3; i < n; ++i) {
        place(a._, b._, c = circles[i]), c = new Node(c);

        // Find the closest intersecting circle on the front-chain, if any.
        // Closeness is determined by linear distance along the front-chain.
        // Ahead or behind is likewise determined by linear distance.
        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
        do {
          if (sj <= sk) {
            if (intersects(j._, c._)) {
              b = j, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sj += j._.r, j = j.next;
          } else {
            if (intersects(k._, c._)) {
              a = k, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sk += k._.r, k = k.previous;
          }
        } while (j !== k.next);

        // Success! Insert the new circle c between a and b.
        c.previous = a, c.next = b, a.next = b.previous = b = c;

        // Compute the new closest circle pair to the centroid.
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c, aa = ca;
          }
        }
        b = a.next;
      }

      // Compute the enclosing circle of the front chain.
      a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

      // Translate the circles to put the enclosing circle around the origin.
      for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

      return c.r;
    }

    function siblings(circles) {
      packEnclose(circles);
      return circles;
    }

    function optional(f) {
      return f == null ? null : required(f);
    }

    function required(f) {
      if (typeof f !== "function") throw new Error;
      return f;
    }

    function constantZero() {
      return 0;
    }

    function constant$2(x) {
      return function() {
        return x;
      };
    }

    function defaultRadius(d) {
      return Math.sqrt(d.value);
    }

    function index$1() {
      var radius = null,
          dx = 1,
          dy = 1,
          padding = constantZero;

      function pack(root) {
        root.x = dx / 2, root.y = dy / 2;
        if (radius) {
          root.eachBefore(radiusLeaf(radius))
              .eachAfter(packChildren(padding, 0.5))
              .eachBefore(translateChild(1));
        } else {
          root.eachBefore(radiusLeaf(defaultRadius))
              .eachAfter(packChildren(constantZero, 1))
              .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
              .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
        }
        return root;
      }

      pack.radius = function(x) {
        return arguments.length ? (radius = optional(x), pack) : radius;
      };

      pack.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
      };

      pack.padding = function(x) {
        return arguments.length ? (padding = typeof x === "function" ? x : constant$2(+x), pack) : padding;
      };

      return pack;
    }

    function radiusLeaf(radius) {
      return function(node) {
        if (!node.children) {
          node.r = Math.max(0, +radius(node) || 0);
        }
      };
    }

    function packChildren(padding, k) {
      return function(node) {
        if (children = node.children) {
          var children,
              i,
              n = children.length,
              r = padding(node) * k || 0,
              e;

          if (r) for (i = 0; i < n; ++i) children[i].r += r;
          e = packEnclose(children);
          if (r) for (i = 0; i < n; ++i) children[i].r -= r;
          node.r = e + r;
        }
      };
    }

    function translateChild(k) {
      return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
          node.x = parent.x + k * node.x;
          node.y = parent.y + k * node.y;
        }
      };
    }

    function roundNode(node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }

    function treemapDice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
      }
    }

    function partition() {
      var dx = 1,
          dy = 1,
          padding = 0,
          round = false;

      function partition(root) {
        var n = root.height + 1;
        root.x0 =
        root.y0 = padding;
        root.x1 = dx;
        root.y1 = dy / n;
        root.eachBefore(positionNode(dy, n));
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(dy, n) {
        return function(node) {
          if (node.children) {
            treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
          }
          var x0 = node.x0,
              y0 = node.y0,
              x1 = node.x1 - padding,
              y1 = node.y1 - padding;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
        };
      }

      partition.round = function(x) {
        return arguments.length ? (round = !!x, partition) : round;
      };

      partition.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
      };

      partition.padding = function(x) {
        return arguments.length ? (padding = +x, partition) : padding;
      };

      return partition;
    }

    var preroot = {depth: -1},
        ambiguous = {};

    function defaultId(d) {
      return d.id;
    }

    function defaultParentId(d) {
      return d.parentId;
    }

    function stratify() {
      var id = defaultId,
          parentId = defaultParentId;

      function stratify(data) {
        var nodes = Array.from(data),
            n = nodes.length,
            d,
            i,
            root,
            parent,
            node,
            nodeId,
            nodeKey,
            nodeByKey = new Map;

        for (i = 0; i < n; ++i) {
          d = nodes[i], node = nodes[i] = new Node$1(d);
          if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
            nodeKey = node.id = nodeId;
            nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
          }
          if ((nodeId = parentId(d, i, data)) != null && (nodeId += "")) {
            node.parent = nodeId;
          }
        }

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (nodeId = node.parent) {
            parent = nodeByKey.get(nodeId);
            if (!parent) throw new Error("missing: " + nodeId);
            if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
            if (parent.children) parent.children.push(node);
            else parent.children = [node];
            node.parent = parent;
          } else {
            if (root) throw new Error("multiple roots");
            root = node;
          }
        }

        if (!root) throw new Error("no root");
        root.parent = preroot;
        root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
        root.parent = null;
        if (n > 0) throw new Error("cycle");

        return root;
      }

      stratify.id = function(x) {
        return arguments.length ? (id = required(x), stratify) : id;
      };

      stratify.parentId = function(x) {
        return arguments.length ? (parentId = required(x), stratify) : parentId;
      };

      return stratify;
    }

    function defaultSeparation(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    // function radialSeparation(a, b) {
    //   return (a.parent === b.parent ? 1 : 2) / a.depth;
    // }

    // This function is used to traverse the left contour of a subtree (or
    // subforest). It returns the successor of v on this contour. This successor is
    // either given by the leftmost child of v or by the thread of v. The function
    // returns null if and only if v is on the highest level of its subtree.
    function nextLeft(v) {
      var children = v.children;
      return children ? children[0] : v.t;
    }

    // This function works analogously to nextLeft.
    function nextRight(v) {
      var children = v.children;
      return children ? children[children.length - 1] : v.t;
    }

    // Shifts the current subtree rooted at w+. This is done by increasing
    // prelim(w+) and mod(w+) by shift.
    function moveSubtree(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }

    // All other shifts, applied to the smaller subtrees between w- and w+, are
    // performed by this function. To prepare the shifts, we have to adjust
    // change(w+), shift(w+), and change(w-).
    function executeShifts(v) {
      var shift = 0,
          change = 0,
          children = v.children,
          i = children.length,
          w;
      while (--i >= 0) {
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }

    // If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
    // returns the specified (default) ancestor.
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null; // default ancestor
      this.a = this; // ancestor
      this.z = 0; // prelim
      this.m = 0; // mod
      this.c = 0; // change
      this.s = 0; // shift
      this.t = null; // thread
      this.i = i; // number
    }

    TreeNode.prototype = Object.create(Node$1.prototype);

    function treeRoot(root) {
      var tree = new TreeNode(root, 0),
          node,
          nodes = [tree],
          child,
          children,
          i,
          n;

      while (node = nodes.pop()) {
        if (children = node._.children) {
          node.children = new Array(n = children.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children[i], i));
            child.parent = node;
          }
        }
      }

      (tree.parent = new TreeNode(null, 0)).children = [tree];
      return tree;
    }

    // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
    function tree() {
      var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = null;

      function tree(root) {
        var t = treeRoot(root);

        // Compute the layout using Buchheim et al.s algorithm.
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);

        // If a fixed node size is specified, scale x and y.
        if (nodeSize) root.eachBefore(sizeNode);

        // If a fixed tree size is specified, scale x and y based on the extent.
        // Compute the left-most, right-most, and depth-most nodes for extents.
        else {
          var left = root,
              right = root,
              bottom = root;
          root.eachBefore(function(node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1);
          root.eachBefore(function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }

        return root;
      }

      // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
      // applied recursively to the children of v, as well as the function
      // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
      // node v is placed to the midpoint of its outermost children.
      function firstWalk(v) {
        var children = v.children,
            siblings = v.parent.children,
            w = v.i ? siblings[v.i - 1] : null;
        if (children) {
          executeShifts(v);
          var midpoint = (children[0].z + children[children.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }

      // Computes all real x-coordinates by summing up the modifiers recursively.
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }

      // The core of the algorithm. Here, a new subtree is combined with the
      // previous subtrees. Threads are used to traverse the inside and outside
      // contours of the left and right subtree up to the highest common level. The
      // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
      // superscript o means outside and i means inside, the subscript - means left
      // subtree and + means right subtree. For summing up the modifiers along the
      // contour, we use respective variables si+, si-, so-, and so+. Whenever two
      // nodes of the inside contours conflict, we compute the left one of the
      // greatest uncommon ancestors using the function ANCESTOR and call MOVE
      // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
      // Finally, we add a new thread (if necessary).
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v,
              vop = v,
              vim = w,
              vom = vip.parent.children[0],
              sip = vip.m,
              sop = vop.m,
              sim = vim.m,
              som = vom.m,
              shift;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }

      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }

      tree.separation = function(x) {
        return arguments.length ? (separation = x, tree) : separation;
      };

      tree.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
      };

      tree.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
      };

      return tree;
    }

    function treemapSlice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
      }
    }

    var phi$1 = (1 + Math.sqrt(5)) / 2;

    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx, dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta;

      while (i0 < n) {
        dx = x1 - x0, dy = y1 - y0;

        // Find the next non-empty node.
        do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);

        // Keep adding nodes while the aspect ratio maintains or improves.
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue) minValue = nodeValue;
          if (nodeValue > maxValue) maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) { sumValue -= nodeValue; break; }
          minRatio = newRatio;
        }

        // Position and record the row orientation.
        rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
        else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
      }

      return rows;
    }

    var squarify = (function custom(ratio) {

      function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }

      squarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return squarify;
    })(phi$1);

    function index() {
      var tile = squarify,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = constantZero,
          paddingTop = constantZero,
          paddingRight = constantZero,
          paddingBottom = constantZero,
          paddingLeft = constantZero;

      function treemap(root) {
        root.x0 =
        root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [0];
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(node) {
        var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
          x0 += paddingLeft(node) - p;
          y0 += paddingTop(node) - p;
          x1 -= paddingRight(node) - p;
          y1 -= paddingBottom(node) - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          tile(node, x0, y0, x1, y1);
        }
      }

      treemap.round = function(x) {
        return arguments.length ? (round = !!x, treemap) : round;
      };

      treemap.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
      };

      treemap.tile = function(x) {
        return arguments.length ? (tile = required(x), treemap) : tile;
      };

      treemap.padding = function(x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
      };

      treemap.paddingInner = function(x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$2(+x), treemap) : paddingInner;
      };

      treemap.paddingOuter = function(x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
      };

      treemap.paddingTop = function(x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$2(+x), treemap) : paddingTop;
      };

      treemap.paddingRight = function(x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$2(+x), treemap) : paddingRight;
      };

      treemap.paddingBottom = function(x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$2(+x), treemap) : paddingBottom;
      };

      treemap.paddingLeft = function(x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$2(+x), treemap) : paddingLeft;
      };

      return treemap;
    }

    function binary(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          i, n = nodes.length,
          sum, sums = new Array(n + 1);

      for (sums[0] = sum = i = 0; i < n; ++i) {
        sums[i + 1] = sum += nodes[i].value;
      }

      partition(0, n, parent.value, x0, y0, x1, y1);

      function partition(i, j, value, x0, y0, x1, y1) {
        if (i >= j - 1) {
          var node = nodes[i];
          node.x0 = x0, node.y0 = y0;
          node.x1 = x1, node.y1 = y1;
          return;
        }

        var valueOffset = sums[i],
            valueTarget = (value / 2) + valueOffset,
            k = i + 1,
            hi = j - 1;

        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget) k = mid + 1;
          else hi = mid;
        }

        if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

        var valueLeft = sums[k] - valueOffset,
            valueRight = value - valueLeft;

        if ((x1 - x0) > (y1 - y0)) {
          var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
          partition(i, k, valueLeft, x0, y0, xk, y1);
          partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
          var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
          partition(i, k, valueLeft, x0, y0, x1, yk);
          partition(k, j, valueRight, x0, yk, x1, y1);
        }
      }
    }

    function sliceDice(parent, x0, y0, x1, y1) {
      (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
    }

    var resquarify = (function custom(ratio) {

      function resquarify(parent, x0, y0, x1, y1) {
        if ((rows = parent._squarify) && (rows.ratio === ratio)) {
          var rows,
              row,
              nodes,
              i,
              j = -1,
              n,
              m = rows.length,
              value = parent.value;

          while (++j < m) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
            if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
            else treemapSlice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
            value -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
          rows.ratio = ratio;
        }
      }

      resquarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return resquarify;
    })(phi$1);

    function area$1(polygon) {
      var i = -1,
          n = polygon.length,
          a,
          b = polygon[n - 1],
          area = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        area += a[1] * b[0] - a[0] * b[1];
      }

      return area / 2;
    }

    function centroid(polygon) {
      var i = -1,
          n = polygon.length,
          x = 0,
          y = 0,
          a,
          b = polygon[n - 1],
          c,
          k = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        k += c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }

      return k *= 3, [x / k, y / k];
    }

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
    // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
    // right, +y is up). Returns a positive value if ABC is counter-clockwise,
    // negative if clockwise, and zero if the points are collinear.
    function cross$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }

    function lexicographicOrder(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }

    // Computes the upper convex hull per the monotone chain algorithm.
    // Assumes points.length >= 3, is sorted by x, unique in y.
    // Returns an array of indices into points in left-to-right order.
    function computeUpperHullIndexes(points) {
      const n = points.length,
          indexes = [0, 1];
      let size = 2, i;

      for (i = 2; i < n; ++i) {
        while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
        indexes[size++] = i;
      }

      return indexes.slice(0, size); // remove popped points
    }

    function hull(points) {
      if ((n = points.length) < 3) return null;

      var i,
          n,
          sortedPoints = new Array(n),
          flippedPoints = new Array(n);

      for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
      sortedPoints.sort(lexicographicOrder);
      for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

      var upperIndexes = computeUpperHullIndexes(sortedPoints),
          lowerIndexes = computeUpperHullIndexes(flippedPoints);

      // Construct the hull polygon, removing possible duplicate endpoints.
      var skipLeft = lowerIndexes[0] === upperIndexes[0],
          skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
          hull = [];

      // Add upper hull in right-to-l order.
      // Then add lower hull in left-to-right order.
      for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
      for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

      return hull;
    }

    function contains(polygon, point) {
      var n = polygon.length,
          p = polygon[n - 1],
          x = point[0], y = point[1],
          x0 = p[0], y0 = p[1],
          x1, y1,
          inside = false;

      for (var i = 0; i < n; ++i) {
        p = polygon[i], x1 = p[0], y1 = p[1];
        if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
        x0 = x1, y0 = y1;
      }

      return inside;
    }

    function length(polygon) {
      var i = -1,
          n = polygon.length,
          b = polygon[n - 1],
          xa,
          ya,
          xb = b[0],
          yb = b[1],
          perimeter = 0;

      while (++i < n) {
        xa = xb;
        ya = yb;
        b = polygon[i];
        xb = b[0];
        yb = b[1];
        xa -= xb;
        ya -= yb;
        perimeter += Math.hypot(xa, ya);
      }

      return perimeter;
    }

    var defaultSource = Math.random;

    var uniform = (function sourceRandomUniform(source) {
      function randomUniform(min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;
        else max -= min;
        return function() {
          return source() * max + min;
        };
      }

      randomUniform.source = sourceRandomUniform;

      return randomUniform;
    })(defaultSource);

    var int = (function sourceRandomInt(source) {
      function randomInt(min, max) {
        if (arguments.length < 2) max = min, min = 0;
        min = Math.floor(min);
        max = Math.floor(max) - min;
        return function() {
          return Math.floor(source() * max + min);
        };
      }

      randomInt.source = sourceRandomInt;

      return randomInt;
    })(defaultSource);

    var normal = (function sourceRandomNormal(source) {
      function randomNormal(mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
          var y;

          // If available, use the second previously-generated uniform random.
          if (x != null) y = x, x = null;

          // Otherwise, generate a new x and y.
          else do {
            x = source() * 2 - 1;
            y = source() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);

          return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
      }

      randomNormal.source = sourceRandomNormal;

      return randomNormal;
    })(defaultSource);

    var logNormal = (function sourceRandomLogNormal(source) {
      var N = normal.source(source);

      function randomLogNormal() {
        var randomNormal = N.apply(this, arguments);
        return function() {
          return Math.exp(randomNormal());
        };
      }

      randomLogNormal.source = sourceRandomLogNormal;

      return randomLogNormal;
    })(defaultSource);

    var irwinHall = (function sourceRandomIrwinHall(source) {
      function randomIrwinHall(n) {
        if ((n = +n) <= 0) return () => 0;
        return function() {
          for (var sum = 0, i = n; i > 1; --i) sum += source();
          return sum + i * source();
        };
      }

      randomIrwinHall.source = sourceRandomIrwinHall;

      return randomIrwinHall;
    })(defaultSource);

    var bates = (function sourceRandomBates(source) {
      var I = irwinHall.source(source);

      function randomBates(n) {
        // use limiting distribution at n === 0
        if ((n = +n) === 0) return source;
        var randomIrwinHall = I(n);
        return function() {
          return randomIrwinHall() / n;
        };
      }

      randomBates.source = sourceRandomBates;

      return randomBates;
    })(defaultSource);

    var exponential = (function sourceRandomExponential(source) {
      function randomExponential(lambda) {
        return function() {
          return -Math.log1p(-source()) / lambda;
        };
      }

      randomExponential.source = sourceRandomExponential;

      return randomExponential;
    })(defaultSource);

    var pareto = (function sourceRandomPareto(source) {
      function randomPareto(alpha) {
        if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
        alpha = 1 / -alpha;
        return function() {
          return Math.pow(1 - source(), alpha);
        };
      }

      randomPareto.source = sourceRandomPareto;

      return randomPareto;
    })(defaultSource);

    var bernoulli = (function sourceRandomBernoulli(source) {
      function randomBernoulli(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        return function() {
          return Math.floor(source() + p);
        };
      }

      randomBernoulli.source = sourceRandomBernoulli;

      return randomBernoulli;
    })(defaultSource);

    var geometric = (function sourceRandomGeometric(source) {
      function randomGeometric(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        if (p === 0) return () => Infinity;
        if (p === 1) return () => 1;
        p = Math.log1p(-p);
        return function() {
          return 1 + Math.floor(Math.log1p(-source()) / p);
        };
      }

      randomGeometric.source = sourceRandomGeometric;

      return randomGeometric;
    })(defaultSource);

    var gamma = (function sourceRandomGamma(source) {
      var randomNormal = normal.source(source)();

      function randomGamma(k, theta) {
        if ((k = +k) < 0) throw new RangeError("invalid k");
        // degenerate distribution if k === 0
        if (k === 0) return () => 0;
        theta = theta == null ? 1 : +theta;
        // exponential distribution if k === 1
        if (k === 1) return () => -Math.log1p(-source()) * theta;

        var d = (k < 1 ? k + 1 : k) - 1 / 3,
            c = 1 / (3 * Math.sqrt(d)),
            multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;
        return function() {
          do {
            do {
              var x = randomNormal(),
                  v = 1 + c * x;
            } while (v <= 0);
            v *= v * v;
            var u = 1 - source();
          } while (u >= 1 - 0.0331 * x * x * x * x && Math.log(u) >= 0.5 * x * x + d * (1 - v + Math.log(v)));
          return d * v * multiplier() * theta;
        };
      }

      randomGamma.source = sourceRandomGamma;

      return randomGamma;
    })(defaultSource);

    var beta = (function sourceRandomBeta(source) {
      var G = gamma.source(source);

      function randomBeta(alpha, beta) {
        var X = G(alpha),
            Y = G(beta);
        return function() {
          var x = X();
          return x === 0 ? 0 : x / (x + Y());
        };
      }

      randomBeta.source = sourceRandomBeta;

      return randomBeta;
    })(defaultSource);

    var binomial = (function sourceRandomBinomial(source) {
      var G = geometric.source(source),
          B = beta.source(source);

      function randomBinomial(n, p) {
        n = +n;
        if ((p = +p) >= 1) return () => n;
        if (p <= 0) return () => 0;
        return function() {
          var acc = 0, nn = n, pp = p;
          while (nn * pp > 16 && nn * (1 - pp) > 16) {
            var i = Math.floor((nn + 1) * pp),
                y = B(i, nn - i + 1)();
            if (y <= pp) {
              acc += i;
              nn -= i;
              pp = (pp - y) / (1 - y);
            } else {
              nn = i - 1;
              pp /= y;
            }
          }
          var sign = pp < 0.5,
              pFinal = sign ? pp : 1 - pp,
              g = G(pFinal);
          for (var s = g(), k = 0; s <= nn; ++k) s += g();
          return acc + (sign ? k : nn - k);
        };
      }

      randomBinomial.source = sourceRandomBinomial;

      return randomBinomial;
    })(defaultSource);

    var weibull = (function sourceRandomWeibull(source) {
      function randomWeibull(k, a, b) {
        var outerFunc;
        if ((k = +k) === 0) {
          outerFunc = x => -Math.log(x);
        } else {
          k = 1 / k;
          outerFunc = x => Math.pow(x, k);
        }
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * outerFunc(-Math.log1p(-source()));
        };
      }

      randomWeibull.source = sourceRandomWeibull;

      return randomWeibull;
    })(defaultSource);

    var cauchy = (function sourceRandomCauchy(source) {
      function randomCauchy(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * Math.tan(Math.PI * source());
        };
      }

      randomCauchy.source = sourceRandomCauchy;

      return randomCauchy;
    })(defaultSource);

    var logistic = (function sourceRandomLogistic(source) {
      function randomLogistic(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          var u = source();
          return a + b * Math.log(u / (1 - u));
        };
      }

      randomLogistic.source = sourceRandomLogistic;

      return randomLogistic;
    })(defaultSource);

    var poisson = (function sourceRandomPoisson(source) {
      var G = gamma.source(source),
          B = binomial.source(source);

      function randomPoisson(lambda) {
        return function() {
          var acc = 0, l = lambda;
          while (l > 16) {
            var n = Math.floor(0.875 * l),
                t = G(n)();
            if (t > l) return acc + B(n - 1, l / t)();
            acc += n;
            l -= t;
          }
          for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k) s -= Math.log1p(-source());
          return acc + k;
        };
      }

      randomPoisson.source = sourceRandomPoisson;

      return randomPoisson;
    })(defaultSource);

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const mul = 0x19660D;
    const inc = 0x3C6EF35F;
    const eps = 1 / 0x100000000;

    function lcg(seed = Math.random()) {
      let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
      return () => (state = mul * state + inc | 0, eps * (state >>> 0));
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0: break;
        case 1: {
          if (typeof domain === "function") this.interpolator(domain);
          else this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function") this.interpolator(interpolator);
          else this.range(interpolator);
          break;
        }
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function band() {
      var scale = ordinal().unknown(undefined),
          domain = scale.domain,
          ordinalRange = scale.range,
          r0 = 0,
          r1 = 1,
          step,
          bandwidth,
          round = false,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;

      delete scale.unknown;

      function rescale() {
        var n = domain().length,
            reverse = r1 < r0,
            start = reverse ? r1 : r0,
            stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = range$2(n).map(function(i) { return start + step * i; });
        return ordinalRange(reverse ? values.reverse() : values);
      }

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };

      scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
      };

      scale.bandwidth = function() {
        return bandwidth;
      };

      scale.step = function() {
        return step;
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
      };

      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };

      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };

      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };

      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };

      scale.copy = function() {
        return band(domain(), [r0, r1])
            .round(round)
            .paddingInner(paddingInner)
            .paddingOuter(paddingOuter)
            .align(align);
      };

      return initRange.apply(rescale(), arguments);
    }

    function pointish(scale) {
      var copy = scale.copy;

      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;

      scale.copy = function() {
        return pointish(copy());
      };

      return scale;
    }

    function point$4() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }

    function constants(x) {
      return function() {
        return x;
      };
    }

    function number$1(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$3(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisectRight(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy$1(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer$2() {
      var domain = unit,
          range = unit,
          interpolate = interpolate$2,
          transform,
          untransform,
          unknown,
          clamp = identity$3,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$3) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer$2()(identity$3, identity$3);
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }

        return scale;
      };

      return scale;
    }

    function linear() {
      var scale = continuous();

      scale.copy = function() {
        return copy$1(scale, linear());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function identity$2(domain) {
      var unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : x;
      }

      scale.invert = scale;

      scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return identity$2(domain).unknown(unknown);
      };

      domain = arguments.length ? Array.from(domain, number$1) : [0, 1];

      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();

      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    function transformLog(x) {
      return Math.log(x);
    }

    function transformExp(x) {
      return Math.exp(x);
    }

    function transformLogn(x) {
      return -Math.log(-x);
    }

    function transformExpn(x) {
      return -Math.exp(-x);
    }

    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }

    function powp(base) {
      return base === 10 ? pow10
          : base === Math.E ? Math.exp
          : function(x) { return Math.pow(base, x); };
    }

    function logp(base) {
      return base === Math.E ? Math.log
          : base === 10 && Math.log10
          || base === 2 && Math.log2
          || (base = Math.log(base), function(x) { return Math.log(x) / base; });
    }

    function reflect(f) {
      return function(x) {
        return -f(-x);
      };
    }

    function loggish(transform) {
      var scale = transform(transformLog, transformExp),
          domain = scale.domain,
          base = 10,
          logs,
          pows;

      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog, transformExp);
        }
        return scale;
      }

      scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.ticks = function(count) {
        var d = domain(),
            u = d[0],
            v = d[d.length - 1],
            r;

        if (r = v < u) i = u, u = v, v = i;

        var i = logs(u),
            j = logs(v),
            p,
            k,
            t,
            n = count == null ? 10 : +count,
            z = [];

        if (!(base % 1) && j - i < n) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u > 0) for (; i <= j; ++i) {
            for (k = 1, p = pows(i); k < base; ++k) {
              t = p * k;
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          } else for (; i <= j; ++i) {
            for (k = base - 1, p = pows(i); k >= 1; --k) {
              t = p * k;
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          }
          if (z.length * 2 < n) z = ticks(u, v, n);
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }

        return r ? z.reverse() : z;
      };

      scale.tickFormat = function(count, specifier) {
        if (specifier == null) specifier = base === 10 ? ".0e" : ",";
        if (typeof specifier !== "function") specifier = format(specifier);
        if (count === Infinity) return specifier;
        if (count == null) count = 10;
        var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return function(d) {
          var i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k ? specifier(d) : "";
        };
      };

      scale.nice = function() {
        return domain(nice(domain(), {
          floor: function(x) { return pows(Math.floor(logs(x))); },
          ceil: function(x) { return pows(Math.ceil(logs(x))); }
        }));
      };

      return scale;
    }

    function log() {
      var scale = loggish(transformer$2()).domain([1, 10]);

      scale.copy = function() {
        return copy$1(scale, log()).base(scale.base());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function transformSymlog(c) {
      return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
      };
    }

    function transformSymexp(c) {
      return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
      };
    }

    function symlogish(transform) {
      var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

      scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
      };

      return linearish(scale);
    }

    function symlog() {
      var scale = symlogish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, symlog()).constant(scale.constant());
      };

      return initRange.apply(scale, arguments);
    }

    function transformPow(exponent) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };
    }

    function transformSqrt(x) {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }

    function transformSquare(x) {
      return x < 0 ? -x * x : x * x;
    }

    function powish(transform) {
      var scale = transform(identity$3, identity$3),
          exponent = 1;

      function rescale() {
        return exponent === 1 ? transform(identity$3, identity$3)
            : exponent === 0.5 ? transform(transformSqrt, transformSquare)
            : transform(transformPow(exponent), transformPow(1 / exponent));
      }

      scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
      };

      return linearish(scale);
    }

    function pow() {
      var scale = powish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, pow()).exponent(scale.exponent());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function sqrt$1() {
      return pow.apply(null, arguments).exponent(0.5);
    }

    function square$1(x) {
      return Math.sign(x) * x * x;
    }

    function unsquare(x) {
      return Math.sign(x) * Math.sqrt(Math.abs(x));
    }

    function radial() {
      var squared = continuous(),
          range = [0, 1],
          round = false,
          unknown;

      function scale(x) {
        var y = unsquare(squared(x));
        return isNaN(y) ? unknown : round ? Math.round(y) : y;
      }

      scale.invert = function(y) {
        return squared.invert(square$1(y));
      };

      scale.domain = function(_) {
        return arguments.length ? (squared.domain(_), scale) : squared.domain();
      };

      scale.range = function(_) {
        return arguments.length ? (squared.range((range = Array.from(_, number$1)).map(square$1)), scale) : range.slice();
      };

      scale.rangeRound = function(_) {
        return scale.range(_).round(true);
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, scale) : round;
      };

      scale.clamp = function(_) {
        return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return radial(squared.domain(), range)
            .round(round)
            .clamp(squared.clamp())
            .unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function quantile() {
      var domain = [],
          range = [],
          thresholds = [],
          unknown;

      function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : range[bisectRight(thresholds, x)];
      }

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return rescale();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.quantiles = function() {
        return thresholds.slice();
      };

      scale.copy = function() {
        return quantile()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    function quantize() {
      var x0 = 0,
          x1 = 1,
          n = 1,
          domain = [0.5],
          range = [0, 1],
          unknown;

      function scale(x) {
        return x != null && x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
      }

      function rescale() {
        var i = -1;
        domain = new Array(n);
        while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
      };

      scale.range = function(_) {
        return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN]
            : i < 1 ? [x0, domain[0]]
            : i >= n ? [domain[n - 1], x1]
            : [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
      };

      scale.thresholds = function() {
        return domain.slice();
      };

      scale.copy = function() {
        return quantize()
            .domain([x0, x1])
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(linearish(scale), arguments);
    }

    function threshold() {
      var domain = [0.5],
          range = [0, 1],
          unknown,
          n = 1;

      function scale(x) {
        return x != null && x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
      }

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return threshold()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    var t0 = new Date,
        t1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
      }

      interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };
    var milliseconds = millisecond.range;

    const durationSecond = 1000;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;

    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });
    var seconds = second.range;

    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });
    var minutes = minute.range;

    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });
    var hours = hour.range;

    var day = newInterval(
      date => date.setHours(0, 0, 0, 0),
      (date, step) => date.setDate(date.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
      date => date.getDate() - 1
    );
    var days = day.range;

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var sundays = sunday.range;
    var mondays = monday.range;
    var tuesdays = tuesday.range;
    var wednesdays = wednesday.range;
    var thursdays = thursday.range;
    var fridays = friday.range;
    var saturdays = saturday.range;

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });
    var months = month.range;

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };
    var years = year.range;

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });
    var utcMinutes = utcMinute.range;

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });
    var utcHours = utcHour.range;

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });
    var utcDays = utcDay.range;

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcSundays = utcSunday.range;
    var utcMondays = utcMonday.range;
    var utcTuesdays = utcTuesday.range;
    var utcWednesdays = utcWednesday.range;
    var utcThursdays = utcThursday.range;
    var utcFridays = utcFriday.range;
    var utcSaturdays = utcSaturday.range;

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });
    var utcMonths = utcMonth.range;

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };
    var utcYears = utcYear.range;

    function ticker(year, month, week, day, hour, minute) {

      const tickIntervals = [
        [second,  1,      durationSecond],
        [second,  5,  5 * durationSecond],
        [second, 15, 15 * durationSecond],
        [second, 30, 30 * durationSecond],
        [minute,  1,      durationMinute],
        [minute,  5,  5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [  hour,  1,      durationHour  ],
        [  hour,  3,  3 * durationHour  ],
        [  hour,  6,  6 * durationHour  ],
        [  hour, 12, 12 * durationHour  ],
        [   day,  1,      durationDay   ],
        [   day,  2,  2 * durationDay   ],
        [  week,  1,      durationWeek  ],
        [ month,  1,      durationMonth ],
        [ month,  3,  3 * durationMonth ],
        [  year,  1,      durationYear  ]
      ];

      function ticks(start, stop, count) {
        const reverse = stop < start;
        if (reverse) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
      }

      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector(([,, step]) => step).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }

      return [ticks, tickInterval];
    }

    const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute);
    const [timeTicks, timeTickInterval] = ticker(year, month, sunday, day, hour, minute);

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day$1;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
              week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
              week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
              week = day.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + day.count(year(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(year(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day = d.getDay();
      return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(year(d) - 1, d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day = d.getUTCDay();
      return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    function date(t) {
      return new Date(t);
    }

    function number(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain;

      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
            : hour(date) < date ? formatMinute
            : day(date) < date ? formatHour
            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
            : year(date) < date ? formatMonth
            : formatYear)(date);
      }

      scale.invert = function(y) {
        return new Date(invert(y));
      };

      scale.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };

      scale.ticks = function(interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };

      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function(interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };

      scale.copy = function() {
        return copy$1(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };

      return scale;
    }

    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, year, month, sunday, day, hour, minute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
    }

    function transformer$1() {
      var x0 = 0,
          x1 = 1,
          t0,
          t1,
          k10,
          transform,
          interpolator = identity$3,
          clamp = false,
          unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function sequential() {
      var scale = linearish(transformer$1()(identity$3));

      scale.copy = function() {
        return copy(scale, sequential());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialLog() {
      var scale = loggish(transformer$1()).domain([1, 10]);

      scale.copy = function() {
        return copy(scale, sequentialLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSymlog() {
      var scale = symlogish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialPow() {
      var scale = powish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }

    function sequentialQuantile() {
      var domain = [],
          interpolator = identity$3;

      function scale(x) {
        if (x != null && !isNaN(x = +x)) return interpolator((bisectRight(domain, x, 1) - 1) / (domain.length - 1));
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return scale;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.range = function() {
        return domain.map((d, i) => interpolator(i / (domain.length - 1)));
      };

      scale.quantiles = function(n) {
        return Array.from({length: n + 1}, (_, i) => quantile$1(domain, i / n));
      };

      scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
      };

      return initInterpolator.apply(scale, arguments);
    }

    function transformer() {
      var x0 = 0,
          x1 = 0.5,
          x2 = 1,
          s = 1,
          t0,
          t1,
          t2,
          k10,
          k21,
          interpolator = identity$3,
          transform,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
        return scale;
      };
    }

    function diverging$1() {
      var scale = linearish(transformer()(identity$3));

      scale.copy = function() {
        return copy(scale, diverging$1());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingLog() {
      var scale = loggish(transformer()).domain([0.1, 1, 10]);

      scale.copy = function() {
        return copy(scale, divergingLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSymlog() {
      var scale = symlogish(transformer());

      scale.copy = function() {
        return copy(scale, divergingSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingPow() {
      var scale = powish(transformer());

      scale.copy = function() {
        return copy(scale, divergingPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    var ramp$1 = scheme => rgbBasis(scheme[scheme.length - 1]);

    var scheme$q = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);

    var BrBG = ramp$1(scheme$q);

    var scheme$p = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);

    var PRGn = ramp$1(scheme$p);

    var scheme$o = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);

    var PiYG = ramp$1(scheme$o);

    var scheme$n = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);

    var PuOr = ramp$1(scheme$n);

    var scheme$m = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);

    var RdBu = ramp$1(scheme$m);

    var scheme$l = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);

    var RdGy = ramp$1(scheme$l);

    var scheme$k = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);

    var RdYlBu = ramp$1(scheme$k);

    var scheme$j = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);

    var RdYlGn = ramp$1(scheme$j);

    var scheme$i = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);

    var Spectral = ramp$1(scheme$i);

    var scheme$h = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);

    var BuGn = ramp$1(scheme$h);

    var scheme$g = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);

    var BuPu = ramp$1(scheme$g);

    var scheme$f = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);

    var GnBu = ramp$1(scheme$f);

    var scheme$e = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);

    var OrRd = ramp$1(scheme$e);

    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);

    var PuBuGn = ramp$1(scheme$d);

    var scheme$c = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);

    var PuBu = ramp$1(scheme$c);

    var scheme$b = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);

    var PuRd = ramp$1(scheme$b);

    var scheme$a = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);

    var RdPu = ramp$1(scheme$a);

    var scheme$9 = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);

    var YlGnBu = ramp$1(scheme$9);

    var scheme$8 = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);

    var YlGn = ramp$1(scheme$8);

    var scheme$7 = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);

    var YlOrBr = ramp$1(scheme$7);

    var scheme$6 = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);

    var YlOrRd = ramp$1(scheme$6);

    var scheme$5 = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);

    var Blues = ramp$1(scheme$5);

    var scheme$4 = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);

    var Greens = ramp$1(scheme$4);

    var scheme$3 = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);

    var Greys = ramp$1(scheme$3);

    var scheme$2 = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);

    var Purples = ramp$1(scheme$2);

    var scheme$1 = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);

    var Reds = ramp$1(scheme$1);

    var scheme = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);

    var Oranges = ramp$1(scheme);

    function cividis(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
          + ")";
    }

    var cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0.0), cubehelix$3(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var c$2 = cubehelix$3();

    function rainbow(t) {
      if (t < 0 || t > 1) t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c$2.h = 360 * t - 100;
      c$2.s = 1.5 - 1.5 * ts;
      c$2.l = 0.8 - 0.9 * ts;
      return c$2 + "";
    }

    var c$1 = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function sinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c$1.r = 255 * (x = Math.sin(t)) * x;
      c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c$1 + "";
    }

    function turbo(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
          + ")";
    }

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function constant$1(x) {
      return function constant() {
        return x;
      };
    }

    var abs = Math.abs;
    var atan2 = Math.atan2;
    var cos = Math.cos;
    var max = Math.max;
    var min = Math.min;
    var sin = Math.sin;
    var sqrt = Math.sqrt;

    var epsilon = 1e-12;
    var pi = Math.PI;
    var halfPi = pi / 2;
    var tau = 2 * pi;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
      return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant$1(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null;

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi,
            a1 = endAngle.apply(this, arguments) - halfPi,
            da = abs(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau - epsilon) {
          context.moveTo(r1 * cos(a0), r1 * sin(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon) {
            context.moveTo(r0 * cos(a1), r0 * sin(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
              rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1  r0, da1  da0.
          if (rp > epsilon) {
            var p0 = asin(rp / r0 * sin(ap)),
                p1 = asin(rp / r1 * sin(ap));
            if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos(a01),
              y01 = r1 * sin(a01),
              x10 = r0 * cos(a10),
              y10 = r0 * sin(a10);

          // Apply rounded corners?
          if (rc > epsilon) {
            var x11 = r1 * cos(a11),
                y11 = r1 * sin(a11),
                x00 = r0 * cos(a00),
                y00 = r0 * sin(a00),
                oc;

            // Restrict the corner radius according to the sector angle.
            if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
                  lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min(rc, (r0 - lc) / (kc - 1));
              rc1 = min(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon)) context.moveTo(x01, y01);

          // Does the sectors outer ring have rounded corners?
          else if (rc1 > epsilon) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and its a circular sector?
          // Or perhaps its an annular sector collapsed due to padding?
          if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

          // Does the sectors inner ring (or point) have rounded corners?
          else if (rc0 > epsilon) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
        return [cos(a) * r, sin(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    var slice = Array.prototype.slice;

    function array(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: this._context.lineTo(x, y); break;
        }
      }
    };

    function curveLinear(context) {
      return new Linear(context);
    }

    function x(p) {
      return p[0];
    }

    function y(p) {
      return p[1];
    }

    function line(x$1, y$1) {
      var defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x$1 = typeof x$1 === "function" ? x$1 : (x$1 === undefined) ? x : constant$1(x$1);
      y$1 = typeof y$1 === "function" ? y$1 : (y$1 === undefined) ? y : constant$1(y$1);

      function line(data) {
        var i,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer;

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), line) : x$1;
      };

      line.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), line) : y$1;
      };

      line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), line) : defined;
      };

      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area(x0, y0, y1) {
      var x1 = null,
          defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x : constant$1(+x0);
      y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant$1(0) : constant$1(+y0);
      y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y : constant$1(+y1);

      function area(data) {
        var i,
            j,
            k,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }

      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
      };

      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
      };

      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
      };

      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
      };

      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
      };

      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
      };

      area.lineX0 =
      area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };

      area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), area) : defined;
      };

      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    function descending$1(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$1(d) {
      return d;
    }

    function pie() {
      var value = identity$1,
          sortValues = descending$1,
          sort = null,
          startAngle = constant$1(0),
          endAngle = constant$1(tau),
          padAngle = constant$1(0);

      function pie(data) {
        var i,
            n = (data = array(data)).length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v;

        for (i = 0; i < n; ++i) {
          if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
            sum += v;
          }
        }

        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
        else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

        // Compute the arcs! They are stored in the original data's order.
        for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
          j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
          };
        }

        return arcs;
      }

      pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), pie) : value;
      };

      pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
      };

      pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
      };

      pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : startAngle;
      };

      pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : endAngle;
      };

      pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : padAngle;
      };

      return pie;
    }

    var curveRadialLinear = curveRadial$1(curveLinear);

    function Radial(curve) {
      this._curve = curve;
    }

    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
      }
    };

    function curveRadial$1(curve) {

      function radial(context) {
        return new Radial(curve(context));
      }

      radial._curve = curve;

      return radial;
    }

    function lineRadial(l) {
      var c = l.curve;

      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;

      l.curve = function(_) {
        return arguments.length ? c(curveRadial$1(_)) : c()._curve;
      };

      return l;
    }

    function lineRadial$1() {
      return lineRadial(line().curve(curveRadialLinear));
    }

    function areaRadial() {
      var a = area().curve(curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1;

      a.angle = a.x, delete a.x;
      a.startAngle = a.x0, delete a.x0;
      a.endAngle = a.x1, delete a.x1;
      a.radius = a.y, delete a.y;
      a.innerRadius = a.y0, delete a.y0;
      a.outerRadius = a.y1, delete a.y1;
      a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
      a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
      a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
      a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

      a.curve = function(_) {
        return arguments.length ? c(curveRadial$1(_)) : c()._curve;
      };

      return a;
    }

    function pointRadial(x, y) {
      return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    function linkSource(d) {
      return d.source;
    }

    function linkTarget(d) {
      return d.target;
    }

    function link(curve) {
      var source = linkSource,
          target = linkTarget,
          x$1 = x,
          y$1 = y,
          context = null;

      function link() {
        var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
        if (!context) context = buffer = path();
        curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
        if (buffer) return context = null, buffer + "" || null;
      }

      link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
      };

      link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
      };

      link.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), link) : x$1;
      };

      link.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), link) : y$1;
      };

      link.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), link) : context;
      };

      return link;
    }

    function curveHorizontal(context, x0, y0, x1, y1) {
      context.moveTo(x0, y0);
      context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
    }

    function curveVertical(context, x0, y0, x1, y1) {
      context.moveTo(x0, y0);
      context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
    }

    function curveRadial(context, x0, y0, x1, y1) {
      var p0 = pointRadial(x0, y0),
          p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
          p2 = pointRadial(x1, y0),
          p3 = pointRadial(x1, y1);
      context.moveTo(p0[0], p0[1]);
      context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
    }

    function linkHorizontal() {
      return link(curveHorizontal);
    }

    function linkVertical() {
      return link(curveVertical);
    }

    function linkRadial() {
      var l = link(curveRadial);
      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;
      return l;
    }

    var circle = {
      draw: function(context, size) {
        var r = Math.sqrt(size / pi);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau);
      }
    };

    var cross = {
      draw: function(context, size) {
        var r = Math.sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };

    var tan30 = Math.sqrt(1 / 3),
        tan30_2 = tan30 * 2;

    var diamond = {
      draw: function(context, size) {
        var y = Math.sqrt(size / tan30_2),
            x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };

    var ka = 0.89081309152928522810,
        kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
        kx = Math.sin(tau / 10) * kr,
        ky = -Math.cos(tau / 10) * kr;

    var star = {
      draw: function(context, size) {
        var r = Math.sqrt(size * ka),
            x = kx * r,
            y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (var i = 1; i < 5; ++i) {
          var a = tau * i / 5,
              c = Math.cos(a),
              s = Math.sin(a);
          context.lineTo(s * r, -c * r);
          context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
      }
    };

    var square = {
      draw: function(context, size) {
        var w = Math.sqrt(size),
            x = -w / 2;
        context.rect(x, x, w, w);
      }
    };

    var sqrt3 = Math.sqrt(3);

    var triangle = {
      draw: function(context, size) {
        var y = -Math.sqrt(size / (sqrt3 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3 * y, -y);
        context.lineTo(sqrt3 * y, -y);
        context.closePath();
      }
    };

    var c = -0.5,
        s = Math.sqrt(3) / 2,
        k = 1 / Math.sqrt(12),
        a = (k / 2 + 1) * 3;

    var wye = {
      draw: function(context, size) {
        var r = Math.sqrt(size / a),
            x0 = r / 2,
            y0 = r * k,
            x1 = x0,
            y1 = r * k + r,
            x2 = -x1,
            y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };

    var symbols = [
      circle,
      cross,
      diamond,
      square,
      star,
      triangle,
      wye
    ];

    function symbol(type, size) {
      var context = null;
      type = typeof type === "function" ? type : constant$1(type || circle);
      size = typeof size === "function" ? size : constant$1(size === undefined ? 64 : +size);

      function symbol() {
        var buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$1(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$1(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function noop$1() {}

    function point$3(that, x, y) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x) / 6,
        (that._y0 + 4 * that._y1 + y) / 6
      );
    }

    function Basis(context) {
      this._context = context;
    }

    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3: point$3(this, this._x1, this._y1); // falls through
          case 2: this._context.lineTo(this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basis(context) {
      return new Basis(context);
    }

    function BasisClosed(context) {
      this._context = context;
    }

    BasisClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
          case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
          case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisClosed(context) {
      return new BasisClosed(context);
    }

    function BasisOpen(context) {
      this._context = context;
    }

    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
          case 3: this._point = 4; // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisOpen(context) {
      return new BasisOpen(context);
    }

    class Bump {
      constructor(context, x) {
        this._context = context;
        this._x = x;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line) this._context.lineTo(x, y);
            else this._context.moveTo(x, y);
            break;
          }
          case 1: this._point = 2; // falls through
          default: {
            if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
            else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
            break;
          }
        }
        this._x0 = x, this._y0 = y;
      }
    }

    function bumpX(context) {
      return new Bump(context, true);
    }

    function bumpY(context) {
      return new Bump(context, false);
    }

    function Bundle(context, beta) {
      this._basis = new Basis(context);
      this._beta = beta;
    }

    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            j = x.length - 1;

        if (j > 0) {
          var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t;

          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }

        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    var bundle = (function custom(beta) {

      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }

      bundle.beta = function(beta) {
        return custom(+beta);
      };

      return bundle;
    })(0.85);

    function point$2(that, x, y) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x),
        that._y2 + that._k * (that._y1 - y),
        that._x2,
        that._y2
      );
    }

    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: point$2(this, this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
          case 2: this._point = 3; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinal = (function custom(tension) {

      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalClosed = (function custom(tension) {

      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalOpen = (function custom(tension) {

      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function point$1(that, x, y) {
      var x1 = that._x1,
          y1 = that._y1,
          x2 = that._x2,
          y2 = that._y2;

      if (that._l01_a > epsilon) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
            n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
      }

      if (that._l23_a > epsilon) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
            m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
      }

      that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }

    function CatmullRom(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: this.point(this._x2, this._y2); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRom = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomClosed(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomClosed = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomOpen(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomOpen = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function LinearClosed(context) {
      this._context = context;
    }

    LinearClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
      }
    };

    function linearClosed(context) {
      return new LinearClosed(context);
    }

    function sign(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bzier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    function monotoneX(context) {
      return new MonotoneX(context);
    }

    function monotoneY(context) {
      return new MonotoneY(context);
    }

    function Natural(context) {
      this._context = context;
    }

    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            n = x.length;

        if (n) {
          this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
          if (n === 2) {
            this._context.lineTo(x[1], y[1]);
          } else {
            var px = controlPoints(x),
                py = controlPoints(y);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
          }
        }

        if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
    function controlPoints(x) {
      var i,
          n = x.length - 1,
          m,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n);
      a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
      for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
      a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
      for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
      a[n - 1] = r[n - 1] / b[n - 1];
      for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
      b[n - 1] = (x[n] + a[n - 1]) / 2;
      for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
      return [a, b];
    }

    function natural(context) {
      return new Natural(context);
    }

    function Step(context, t) {
      this._context = context;
      this._t = t;
    }

    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
        }
        this._x = x, this._y = y;
      }
    };

    function step(context) {
      return new Step(context, 0.5);
    }

    function stepBefore(context) {
      return new Step(context, 0);
    }

    function stepAfter(context) {
      return new Step(context, 1);
    }

    function none$1(series, order) {
      if (!((n = series.length) > 1)) return;
      for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
        s0 = s1, s1 = series[order[i]];
        for (j = 0; j < m; ++j) {
          s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
        }
      }
    }

    function none(series) {
      var n = series.length, o = new Array(n);
      while (--n >= 0) o[n] = n;
      return o;
    }

    function stackValue(d, key) {
      return d[key];
    }

    function stackSeries(key) {
      const series = [];
      series.key = key;
      return series;
    }

    function stack() {
      var keys = constant$1([]),
          order = none,
          offset = none$1,
          value = stackValue;

      function stack(data) {
        var sz = Array.from(keys.apply(this, arguments), stackSeries),
            i, n = sz.length, j = -1,
            oz;

        for (const d of data) {
          for (i = 0, ++j; i < n; ++i) {
            (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
          }
        }

        for (i = 0, oz = array(order(sz)); i < n; ++i) {
          sz[oz[i]].index = i;
        }

        offset(sz, oz);
        return sz;
      }

      stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : keys;
      };

      stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), stack) : value;
      };

      stack.order = function(_) {
        return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : order;
      };

      stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
      };

      return stack;
    }

    function expand(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
        for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
        if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
      }
      none$1(series, order);
    }

    function diverging(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
        for (yp = yn = 0, i = 0; i < n; ++i) {
          if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
            d[0] = yp, d[1] = yp += dy;
          } else if (dy < 0) {
            d[1] = yn, d[0] = yn += dy;
          } else {
            d[0] = 0, d[1] = dy;
          }
        }
      }
    }

    function silhouette(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
        for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
      }
      none$1(series, order);
    }

    function wiggle(series, order) {
      if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
      for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
        for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
          var si = series[order[i]],
              sij0 = si[j][1] || 0,
              sij1 = si[j - 1][1] || 0,
              s3 = (sij0 - sij1) / 2;
          for (var k = 0; k < i; ++k) {
            var sk = series[order[k]],
                skj0 = sk[j][1] || 0,
                skj1 = sk[j - 1][1] || 0;
            s3 += skj0 - skj1;
          }
          s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      none$1(series, order);
    }

    function appearance(series) {
      var peaks = series.map(peak);
      return none(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
    }

    function peak(series) {
      var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
      while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
      return j;
    }

    function ascending(series) {
      var sums = series.map(sum);
      return none(series).sort(function(a, b) { return sums[a] - sums[b]; });
    }

    function sum(series) {
      var s = 0, i = -1, n = series.length, v;
      while (++i < n) if (v = +series[i][1]) s += v;
      return s;
    }

    function descending(series) {
      return ascending(series).reverse();
    }

    function insideOut(series) {
      var n = series.length,
          i,
          j,
          sums = series.map(sum),
          order = appearance(series),
          top = 0,
          bottom = 0,
          tops = [],
          bottoms = [];

      for (i = 0; i < n; ++i) {
        j = order[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }

      return bottoms.reverse().concat(tops);
    }

    function reverse(series) {
      return none(series).reverse();
    }

    var constant = x => () => x;

    function ZoomEvent(type, {
      sourceEvent,
      target,
      transform,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        transform: {value: transform, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }

    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };

    var identity = new Transform(1, 0, 0);

    transform.prototype = Transform.prototype;

    function transform(node) {
      while (!node.__zoom) if (!(node = node.parentNode)) return identity;
      return node.__zoom;
    }

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }

    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === 'wheel') && !event.button;
    }

    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }

    function defaultTransform() {
      return this.__zoom || identity;
    }

    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
          dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
          dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
          dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }

    function zoom() {
      var filter = defaultFilter,
          extent = defaultExtent,
          constrain = defaultConstrain,
          wheelDelta = defaultWheelDelta,
          touchable = defaultTouchable,
          scaleExtent = [0, Infinity],
          translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
          duration = 250,
          interpolate = interpolateZoom,
          listeners = dispatch("start", "zoom", "end"),
          touchstarting,
          touchfirst,
          touchending,
          touchDelay = 500,
          wheelDelay = 150,
          clickDistance2 = 0,
          tapDistance = 10;

      function zoom(selection) {
        selection
            .property("__zoom", defaultTransform)
            .on("wheel.zoom", wheeled, {passive: false})
            .on("mousedown.zoom", mousedowned)
            .on("dblclick.zoom", dblclicked)
          .filter(touchable)
            .on("touchstart.zoom", touchstarted)
            .on("touchmove.zoom", touchmoved)
            .on("touchend.zoom touchcancel.zoom", touchended)
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      zoom.transform = function(collection, transform, point, event) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
          schedule(collection, transform, point, event);
        } else {
          selection.interrupt().each(function() {
            gesture(this, arguments)
              .event(event)
              .start()
              .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
              .end();
          });
        }
      };

      zoom.scaleBy = function(selection, k, p, event) {
        zoom.scaleTo(selection, function() {
          var k0 = this.__zoom.k,
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p, event);
      };

      zoom.scaleTo = function(selection, k, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t0 = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
              p1 = t0.invert(p0),
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p, event);
      };

      zoom.translateBy = function(selection, x, y, event) {
        zoom.transform(selection, function() {
          return constrain(this.__zoom.translate(
            typeof x === "function" ? x.apply(this, arguments) : x,
            typeof y === "function" ? y.apply(this, arguments) : y
          ), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };

      zoom.translateTo = function(selection, x, y, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x === "function" ? -x.apply(this, arguments) : -x,
            typeof y === "function" ? -y.apply(this, arguments) : -y
          ), e, translateExtent);
        }, p, event);
      };

      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }

      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }

      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }

      function schedule(transition, transform, point, event) {
        transition
            .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
            .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
            .tween("zoom", function() {
              var that = this,
                  args = arguments,
                  g = gesture(that, args).event(event),
                  e = extent.apply(that, args),
                  p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
                  w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                  a = that.__zoom,
                  b = typeof transform === "function" ? transform.apply(that, args) : transform,
                  i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
              return function(t) {
                if (t === 1) t = b; // Avoid rounding error on end.
                else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
                g.zoom(null, t);
              };
            });
      }

      function gesture(that, args, clean) {
        return (!clean && that.__zooming) || new Gesture(that, args);
      }

      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }

      Gesture.prototype = {
        event: function(event) {
          if (event) this.sourceEvent = event;
          return this;
        },
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new ZoomEvent(type, {
              sourceEvent: this.sourceEvent,
              target: zoom,
              type,
              transform: this.that.__zoom,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function wheeled(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, args).event(event),
            t = this.__zoom,
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
            p = pointer(event);

        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }
          clearTimeout(g.wheel);
        }

        // If this wheel event wont trigger a transform change, ignore it.
        else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }

      function mousedowned(event, ...args) {
        if (touchending || !filter.apply(this, arguments)) return;
        var currentTarget = event.currentTarget,
            g = gesture(this, args, true).event(event),
            v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
            p = pointer(event, currentTarget),
            x0 = event.clientX,
            y0 = event.clientY;

        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();

        function mousemoved(event) {
          noevent(event);
          if (!g.moved) {
            var dx = event.clientX - x0, dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event)
           .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }

        function mouseupped(event) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent(event);
          g.event(event).end();
        }
      }

      function dblclicked(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
            p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
            p1 = t0.invert(p0),
            k1 = t0.k * (event.shiftKey ? 0.5 : 2),
            t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

        noevent(event);
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);
        else select(this).call(zoom.transform, t1, p0, event);
      }

      function touchstarted(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
            n = touches.length,
            g = gesture(this, args, event.changedTouches.length === n).event(event),
            started, i, t, p;

        nopropagation(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }

        if (touchstarting) touchstarting = clearTimeout(touchstarting);

        if (started) {
          if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
          interrupt(this);
          g.start();
        }
      }

      function touchmoved(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t, p, l;

        noevent(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
          else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1],
              p1 = g.touch1[0], l1 = g.touch1[1],
              dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
              dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        }
        else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
        else return;

        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }

      function touchended(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t;

        nopropagation(event);
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
            }
          }
        }
      }

      zoom.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
      };

      zoom.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
      };

      zoom.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
      };

      zoom.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };

      zoom.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };

      zoom.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };

      zoom.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };

      zoom.duration = function(_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };

      zoom.interpolate = function(_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };

      zoom.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };

      zoom.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };

      zoom.tapDistance = function(_) {
        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
      };

      return zoom;
    }

    var d3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bisect: bisectRight,
        bisectRight: bisectRight,
        bisectLeft: bisectLeft,
        bisectCenter: bisectCenter,
        ascending: ascending$3,
        bisector: bisector,
        count: count$1,
        cross: cross$2,
        cumsum: cumsum,
        descending: descending$2,
        deviation: deviation,
        extent: extent$1,
        Adder: Adder,
        fsum: fsum,
        fcumsum: fcumsum,
        group: group,
        flatGroup: flatGroup,
        flatRollup: flatRollup,
        groups: groups,
        index: index$4,
        indexes: indexes,
        rollup: rollup,
        rollups: rollups,
        groupSort: groupSort,
        bin: bin,
        histogram: bin,
        thresholdFreedmanDiaconis: freedmanDiaconis,
        thresholdScott: scott,
        thresholdSturges: thresholdSturges,
        max: max$3,
        maxIndex: maxIndex,
        mean: mean,
        median: median,
        merge: merge,
        min: min$2,
        minIndex: minIndex,
        mode: mode,
        nice: nice$1,
        pairs: pairs,
        permute: permute,
        quantile: quantile$1,
        quantileSorted: quantileSorted,
        quickselect: quickselect,
        range: range$2,
        least: least,
        leastIndex: leastIndex,
        greatest: greatest,
        greatestIndex: greatestIndex,
        scan: scan,
        shuffle: shuffle$1,
        shuffler: shuffler,
        sum: sum$2,
        ticks: ticks,
        tickIncrement: tickIncrement,
        tickStep: tickStep,
        transpose: transpose,
        variance: variance,
        zip: zip,
        every: every,
        some: some,
        filter: filter$1,
        map: map$1,
        reduce: reduce,
        reverse: reverse$1,
        sort: sort,
        difference: difference,
        disjoint: disjoint,
        intersection: intersection,
        subset: subset,
        superset: superset,
        union: union,
        InternMap: InternMap,
        InternSet: InternSet,
        axisTop: axisTop,
        axisRight: axisRight,
        axisBottom: axisBottom,
        axisLeft: axisLeft,
        brush: brush,
        brushX: brushX,
        brushY: brushY,
        brushSelection: brushSelection,
        chord: chord,
        chordTranspose: chordTranspose,
        chordDirected: chordDirected,
        ribbon: ribbon$1,
        ribbonArrow: ribbonArrow,
        color: color$1,
        rgb: rgb,
        hsl: hsl$2,
        lab: lab$1,
        hcl: hcl$2,
        lch: lch,
        gray: gray,
        cubehelix: cubehelix$3,
        contours: contours,
        contourDensity: density,
        Delaunay: Delaunay,
        Voronoi: Voronoi,
        dispatch: dispatch,
        drag: drag,
        dragDisable: dragDisable,
        dragEnable: yesdrag,
        dsvFormat: dsvFormat,
        csvParse: csvParse,
        csvParseRows: csvParseRows,
        csvFormat: csvFormat,
        csvFormatBody: csvFormatBody,
        csvFormatRows: csvFormatRows,
        csvFormatRow: csvFormatRow,
        csvFormatValue: csvFormatValue,
        tsvParse: tsvParse,
        tsvParseRows: tsvParseRows,
        tsvFormat: tsvFormat,
        tsvFormatBody: tsvFormatBody,
        tsvFormatRows: tsvFormatRows,
        tsvFormatRow: tsvFormatRow,
        tsvFormatValue: tsvFormatValue,
        autoType: autoType,
        easeLinear: linear$1,
        easeQuad: quadInOut,
        easeQuadIn: quadIn,
        easeQuadOut: quadOut,
        easeQuadInOut: quadInOut,
        easeCubic: cubicInOut,
        easeCubicIn: cubicIn,
        easeCubicOut: cubicOut,
        easeCubicInOut: cubicInOut,
        easePoly: polyInOut,
        easePolyIn: polyIn,
        easePolyOut: polyOut,
        easePolyInOut: polyInOut,
        easeSin: sinInOut,
        easeSinIn: sinIn,
        easeSinOut: sinOut,
        easeSinInOut: sinInOut,
        easeExp: expInOut,
        easeExpIn: expIn,
        easeExpOut: expOut,
        easeExpInOut: expInOut,
        easeCircle: circleInOut,
        easeCircleIn: circleIn,
        easeCircleOut: circleOut,
        easeCircleInOut: circleInOut,
        easeBounce: bounceOut,
        easeBounceIn: bounceIn,
        easeBounceOut: bounceOut,
        easeBounceInOut: bounceInOut,
        easeBack: backInOut,
        easeBackIn: backIn,
        easeBackOut: backOut,
        easeBackInOut: backInOut,
        easeElastic: elasticOut,
        easeElasticIn: elasticIn,
        easeElasticOut: elasticOut,
        easeElasticInOut: elasticInOut,
        blob: blob,
        buffer: buffer,
        dsv: dsv,
        csv: csv,
        tsv: tsv,
        image: image,
        json: json,
        text: text,
        xml: xml,
        html: html,
        svg: svg,
        forceCenter: center,
        forceCollide: collide,
        forceLink: link$2,
        forceManyBody: manyBody,
        forceRadial: radial$1,
        forceSimulation: simulation,
        forceX: x$1,
        forceY: y$1,
        formatDefaultLocale: defaultLocale$1,
        get format () { return format; },
        get formatPrefix () { return formatPrefix; },
        formatLocale: formatLocale$1,
        formatSpecifier: formatSpecifier,
        FormatSpecifier: FormatSpecifier,
        precisionFixed: precisionFixed,
        precisionPrefix: precisionPrefix,
        precisionRound: precisionRound,
        geoArea: area$2,
        geoBounds: bounds,
        geoCentroid: centroid$1,
        geoCircle: circle$2,
        geoClipAntimeridian: clipAntimeridian,
        geoClipCircle: clipCircle,
        geoClipExtent: extent,
        geoClipRectangle: clipRectangle,
        geoContains: contains$1,
        geoDistance: distance,
        geoGraticule: graticule,
        geoGraticule10: graticule10,
        geoInterpolate: interpolate,
        geoLength: length$1,
        geoPath: index$2,
        geoAlbers: albers,
        geoAlbersUsa: albersUsa,
        geoAzimuthalEqualArea: azimuthalEqualArea,
        geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
        geoAzimuthalEquidistant: azimuthalEquidistant,
        geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
        geoConicConformal: conicConformal,
        geoConicConformalRaw: conicConformalRaw,
        geoConicEqualArea: conicEqualArea,
        geoConicEqualAreaRaw: conicEqualAreaRaw,
        geoConicEquidistant: conicEquidistant,
        geoConicEquidistantRaw: conicEquidistantRaw,
        geoEqualEarth: equalEarth,
        geoEqualEarthRaw: equalEarthRaw,
        geoEquirectangular: equirectangular,
        geoEquirectangularRaw: equirectangularRaw,
        geoGnomonic: gnomonic,
        geoGnomonicRaw: gnomonicRaw,
        geoIdentity: identity$4,
        geoProjection: projection,
        geoProjectionMutator: projectionMutator,
        geoMercator: mercator,
        geoMercatorRaw: mercatorRaw,
        geoNaturalEarth1: naturalEarth1,
        geoNaturalEarth1Raw: naturalEarth1Raw,
        geoOrthographic: orthographic,
        geoOrthographicRaw: orthographicRaw,
        geoStereographic: stereographic,
        geoStereographicRaw: stereographicRaw,
        geoTransverseMercator: transverseMercator,
        geoTransverseMercatorRaw: transverseMercatorRaw,
        geoRotation: rotation,
        geoStream: geoStream,
        geoTransform: transform$1,
        cluster: cluster,
        hierarchy: hierarchy,
        Node: Node$1,
        pack: index$1,
        packSiblings: siblings,
        packEnclose: enclose,
        partition: partition,
        stratify: stratify,
        tree: tree,
        treemap: index,
        treemapBinary: binary,
        treemapDice: treemapDice,
        treemapSlice: treemapSlice,
        treemapSliceDice: sliceDice,
        treemapSquarify: squarify,
        treemapResquarify: resquarify,
        interpolate: interpolate$2,
        interpolateArray: array$3,
        interpolateBasis: basis$2,
        interpolateBasisClosed: basisClosed$1,
        interpolateDate: date$1,
        interpolateDiscrete: discrete,
        interpolateHue: hue,
        interpolateNumber: interpolateNumber,
        interpolateNumberArray: numberArray,
        interpolateObject: object$1,
        interpolateRound: interpolateRound,
        interpolateString: interpolateString,
        interpolateTransformCss: interpolateTransformCss,
        interpolateTransformSvg: interpolateTransformSvg,
        interpolateZoom: interpolateZoom,
        interpolateRgb: interpolateRgb,
        interpolateRgbBasis: rgbBasis,
        interpolateRgbBasisClosed: rgbBasisClosed,
        interpolateHsl: hsl$1,
        interpolateHslLong: hslLong,
        interpolateLab: lab,
        interpolateHcl: hcl$1,
        interpolateHclLong: hclLong,
        interpolateCubehelix: cubehelix$2,
        interpolateCubehelixLong: cubehelixLong,
        piecewise: piecewise,
        quantize: quantize$1,
        path: path,
        polygonArea: area$1,
        polygonCentroid: centroid,
        polygonHull: hull,
        polygonContains: contains,
        polygonLength: length,
        quadtree: quadtree,
        randomUniform: uniform,
        randomInt: int,
        randomNormal: normal,
        randomLogNormal: logNormal,
        randomBates: bates,
        randomIrwinHall: irwinHall,
        randomExponential: exponential,
        randomPareto: pareto,
        randomBernoulli: bernoulli,
        randomGeometric: geometric,
        randomBinomial: binomial,
        randomGamma: gamma,
        randomBeta: beta,
        randomWeibull: weibull,
        randomCauchy: cauchy,
        randomLogistic: logistic,
        randomPoisson: poisson,
        randomLcg: lcg,
        scaleBand: band,
        scalePoint: point$4,
        scaleIdentity: identity$2,
        scaleLinear: linear,
        scaleLog: log,
        scaleSymlog: symlog,
        scaleOrdinal: ordinal,
        scaleImplicit: implicit,
        scalePow: pow,
        scaleSqrt: sqrt$1,
        scaleRadial: radial,
        scaleQuantile: quantile,
        scaleQuantize: quantize,
        scaleThreshold: threshold,
        scaleTime: time,
        scaleUtc: utcTime,
        scaleSequential: sequential,
        scaleSequentialLog: sequentialLog,
        scaleSequentialPow: sequentialPow,
        scaleSequentialSqrt: sequentialSqrt,
        scaleSequentialSymlog: sequentialSymlog,
        scaleSequentialQuantile: sequentialQuantile,
        scaleDiverging: diverging$1,
        scaleDivergingLog: divergingLog,
        scaleDivergingPow: divergingPow,
        scaleDivergingSqrt: divergingSqrt,
        scaleDivergingSymlog: divergingSymlog,
        tickFormat: tickFormat,
        schemeCategory10: category10,
        schemeAccent: Accent,
        schemeDark2: Dark2,
        schemePaired: Paired,
        schemePastel1: Pastel1,
        schemePastel2: Pastel2,
        schemeSet1: Set1,
        schemeSet2: Set2,
        schemeSet3: Set3,
        schemeTableau10: Tableau10,
        interpolateBrBG: BrBG,
        schemeBrBG: scheme$q,
        interpolatePRGn: PRGn,
        schemePRGn: scheme$p,
        interpolatePiYG: PiYG,
        schemePiYG: scheme$o,
        interpolatePuOr: PuOr,
        schemePuOr: scheme$n,
        interpolateRdBu: RdBu,
        schemeRdBu: scheme$m,
        interpolateRdGy: RdGy,
        schemeRdGy: scheme$l,
        interpolateRdYlBu: RdYlBu,
        schemeRdYlBu: scheme$k,
        interpolateRdYlGn: RdYlGn,
        schemeRdYlGn: scheme$j,
        interpolateSpectral: Spectral,
        schemeSpectral: scheme$i,
        interpolateBuGn: BuGn,
        schemeBuGn: scheme$h,
        interpolateBuPu: BuPu,
        schemeBuPu: scheme$g,
        interpolateGnBu: GnBu,
        schemeGnBu: scheme$f,
        interpolateOrRd: OrRd,
        schemeOrRd: scheme$e,
        interpolatePuBuGn: PuBuGn,
        schemePuBuGn: scheme$d,
        interpolatePuBu: PuBu,
        schemePuBu: scheme$c,
        interpolatePuRd: PuRd,
        schemePuRd: scheme$b,
        interpolateRdPu: RdPu,
        schemeRdPu: scheme$a,
        interpolateYlGnBu: YlGnBu,
        schemeYlGnBu: scheme$9,
        interpolateYlGn: YlGn,
        schemeYlGn: scheme$8,
        interpolateYlOrBr: YlOrBr,
        schemeYlOrBr: scheme$7,
        interpolateYlOrRd: YlOrRd,
        schemeYlOrRd: scheme$6,
        interpolateBlues: Blues,
        schemeBlues: scheme$5,
        interpolateGreens: Greens,
        schemeGreens: scheme$4,
        interpolateGreys: Greys,
        schemeGreys: scheme$3,
        interpolatePurples: Purples,
        schemePurples: scheme$2,
        interpolateReds: Reds,
        schemeReds: scheme$1,
        interpolateOranges: Oranges,
        schemeOranges: scheme,
        interpolateCividis: cividis,
        interpolateCubehelixDefault: cubehelix,
        interpolateRainbow: rainbow,
        interpolateWarm: warm,
        interpolateCool: cool,
        interpolateSinebow: sinebow,
        interpolateTurbo: turbo,
        interpolateViridis: viridis,
        interpolateMagma: magma,
        interpolateInferno: inferno,
        interpolatePlasma: plasma,
        create: create$1,
        creator: creator,
        local: local$1,
        matcher: matcher,
        namespace: namespace,
        namespaces: namespaces,
        pointer: pointer,
        pointers: pointers,
        select: select,
        selectAll: selectAll,
        selection: selection,
        selector: selector,
        selectorAll: selectorAll,
        style: styleValue,
        window: defaultView,
        arc: arc,
        area: area,
        line: line,
        pie: pie,
        areaRadial: areaRadial,
        radialArea: areaRadial,
        lineRadial: lineRadial$1,
        radialLine: lineRadial$1,
        pointRadial: pointRadial,
        linkHorizontal: linkHorizontal,
        linkVertical: linkVertical,
        linkRadial: linkRadial,
        symbol: symbol,
        symbols: symbols,
        symbolCircle: circle,
        symbolCross: cross,
        symbolDiamond: diamond,
        symbolSquare: square,
        symbolStar: star,
        symbolTriangle: triangle,
        symbolWye: wye,
        curveBasisClosed: basisClosed,
        curveBasisOpen: basisOpen,
        curveBasis: basis,
        curveBumpX: bumpX,
        curveBumpY: bumpY,
        curveBundle: bundle,
        curveCardinalClosed: cardinalClosed,
        curveCardinalOpen: cardinalOpen,
        curveCardinal: cardinal,
        curveCatmullRomClosed: catmullRomClosed,
        curveCatmullRomOpen: catmullRomOpen,
        curveCatmullRom: catmullRom,
        curveLinearClosed: linearClosed,
        curveLinear: curveLinear,
        curveMonotoneX: monotoneX,
        curveMonotoneY: monotoneY,
        curveNatural: natural,
        curveStep: step,
        curveStepAfter: stepAfter,
        curveStepBefore: stepBefore,
        stack: stack,
        stackOffsetExpand: expand,
        stackOffsetDiverging: diverging,
        stackOffsetNone: none$1,
        stackOffsetSilhouette: silhouette,
        stackOffsetWiggle: wiggle,
        stackOrderAppearance: appearance,
        stackOrderAscending: ascending,
        stackOrderDescending: descending,
        stackOrderInsideOut: insideOut,
        stackOrderNone: none,
        stackOrderReverse: reverse,
        timeInterval: newInterval,
        timeMillisecond: millisecond,
        timeMilliseconds: milliseconds,
        utcMillisecond: millisecond,
        utcMilliseconds: milliseconds,
        timeSecond: second,
        timeSeconds: seconds,
        utcSecond: second,
        utcSeconds: seconds,
        timeMinute: minute,
        timeMinutes: minutes,
        timeHour: hour,
        timeHours: hours,
        timeDay: day,
        timeDays: days,
        timeWeek: sunday,
        timeWeeks: sundays,
        timeSunday: sunday,
        timeSundays: sundays,
        timeMonday: monday,
        timeMondays: mondays,
        timeTuesday: tuesday,
        timeTuesdays: tuesdays,
        timeWednesday: wednesday,
        timeWednesdays: wednesdays,
        timeThursday: thursday,
        timeThursdays: thursdays,
        timeFriday: friday,
        timeFridays: fridays,
        timeSaturday: saturday,
        timeSaturdays: saturdays,
        timeMonth: month,
        timeMonths: months,
        timeYear: year,
        timeYears: years,
        utcMinute: utcMinute,
        utcMinutes: utcMinutes,
        utcHour: utcHour,
        utcHours: utcHours,
        utcDay: utcDay,
        utcDays: utcDays,
        utcWeek: utcSunday,
        utcWeeks: utcSundays,
        utcSunday: utcSunday,
        utcSundays: utcSundays,
        utcMonday: utcMonday,
        utcMondays: utcMondays,
        utcTuesday: utcTuesday,
        utcTuesdays: utcTuesdays,
        utcWednesday: utcWednesday,
        utcWednesdays: utcWednesdays,
        utcThursday: utcThursday,
        utcThursdays: utcThursdays,
        utcFriday: utcFriday,
        utcFridays: utcFridays,
        utcSaturday: utcSaturday,
        utcSaturdays: utcSaturdays,
        utcMonth: utcMonth,
        utcMonths: utcMonths,
        utcYear: utcYear,
        utcYears: utcYears,
        utcTicks: utcTicks,
        utcTickInterval: utcTickInterval,
        timeTicks: timeTicks,
        timeTickInterval: timeTickInterval,
        timeFormatDefaultLocale: defaultLocale,
        get timeFormat () { return timeFormat; },
        get timeParse () { return timeParse; },
        get utcFormat () { return utcFormat; },
        get utcParse () { return utcParse; },
        timeFormatLocale: formatLocale,
        isoFormat: formatIso,
        isoParse: parseIso,
        now: now,
        timer: timer,
        timerFlush: timerFlush,
        timeout: timeout,
        interval: interval,
        transition: transition,
        active: active,
        interrupt: interrupt,
        zoom: zoom,
        zoomTransform: transform,
        zoomIdentity: identity,
        ZoomTransform: Transform
    });

    const STEP = 0.0125;
    // const STEP = 0.5;
    const CUT_SIZE = 2;
    const ALPHA_RANGE = 5;

    class Plot {
      constructor(context, n) {
        this.touch = 0;
        this.ctx = context; 
        this.height = this.ctx.height;
        this.width = this.ctx.width;
        this.unitToAlpha = linear().domain([0, 1]).range([-ALPHA_RANGE, ALPHA_RANGE]);
        this.n = n;
        this.kernels = [null, null];
        this.kernels[0] = new RBFKernel();
        this.kernels[1] = new RBFShuffleKernel(CUT_SIZE);
        this.active_ker = 0;

        // matrix p = row i is phi(mu_i)
        // matrix f = row i is phi(x_i)
        // pft means P F^T, ppt means P P^T
        // when mu_i = x_i, then P = F, and PF^T = FF^T = K
        this.pft = Matrix.zeros(this.n, this.n);
        this.ppt = Matrix.zeros(this.n, this.n);
        this.fft = Matrix.zeros(this.n, this.n);
        this.invpft = Matrix.zeros(this.n, this.n);
        this.curveCache = null; // cc[ci][xi] = y.  (curve_idx, x_idx)
        this.xCache = null;
        this.invertible = true;

        this.populate();

      }

      get_xrange() {
        return [this.ctx.xmin, this.ctx.xmax];
      }

      // if i is undefined, initialize the whole matrix
      // otherwise, initialize i'th row and column only
      init_metrics() {
        this.init_mat('ppt');
        this.init_mat('pft');
        this.init_mat('fft');
      }

      _init_mat(row, col, type) {
        var m = Matrix.zeros(this.n, this.n);
        for (let i = 0; i != this.n; i++) 
          for (let j = 0; j != this.n; j++)
            m[i][j] = this.kernel(row[i], col[j]); 
        this[type] = m;
      }

      _update_mat(row, col, i, type) {
        for (let j = 0; j != this.n; j++){
          this[type][i][j] = this.kernel(row[i], col[j]);
          this[type][j][i] = this.kernel(row[j], col[i]);
        }
      }

      init_mat(type, i) {
        var row, col;
        if (type == 'ppt') [row, col] = [this.mu, this.mu];
        else if (type == 'pft') [row, col] = [this.mu, this.x];
        else if (type == 'fft') [row, col] = [this.x, this.x];
        else throw `init_mat: invalid type ${type}`;

        if (i === undefined) this._init_mat(row, col, type);
        else this._update_mat(row, col, i, type);
      }

      initXCache() {
        var cuts = [this.ctx.xmin, this.ctx.xmax];
        var xs;
        for (let i = 0; i != this.n; i++)
          cuts.push(...this.jumps(this.x[i]));
        cuts.sort((a, b) => a - b);

        this.xCache = new Array(0);
        for (let s = 0; s != cuts.length - 1; s++) {
          xs = range$2(cuts[s], cuts[s+1], STEP);
          this.xCache.push(xs);
        }
      }

      initCurveCache() {
        var n = this.n;
        this.initXCache();
        this.curveCache = new Array(n);
        for (let ci = 0; ci != n; ci++) 
            this.updateCurveCache(ci);
      }

      // updates i'th curve Cache
      updateCurveCache(ci) {
        var seg;
        this.curveCache[ci] = new Array();
        for (let si = 0; si != this.xCache.length; si++) {
          seg = this.xCache[si].map(x => this.kernel(this.mu[ci], x));
          this.curveCache[ci].push(...seg);
        }
      }

      set_scramble(flag) {
        this.active_ker = flag ? 1 : 0;
        this.init_metrics();
        this.initCurveCache();
      }

      scrambled() {
        return this.active_ker == 1;
      }

      cut_size() {
        return CUT_SIZE;
      }

      resetAlpha() {
        this.alpha.fill(1);
      }

      set_sigma(log_sigma) {
        for (let k = 0; k != this.kernels.length; k++) {
          this.kernels[k].set_sigma(Math.pow(10, log_sigma));
        }
        for (let ci = 0; ci != this.n; ci++)
          this.updateCurveCache(ci);

        this.init_metrics();
      }

      recenter_mu() {
        for (let i = 0; i != this.n; i++) {
          this.mu[i] = this.x[i];
        }
        this.init_metrics();
        this.initCurveCache();
      }

      get_sigma2() {
        return this.kernels[this.active_ker].get_sigma2();
      }

      populate() {
        var n = this.n;
        this.x = new Array(n);
        this.y = new Array(n);
        this.mu = new Array(n);
        this.alpha = new Array(n); 

        for (let i = 0; i != n; i++) {
          this.x[i] = this.ctx.unitToX(Math.random());
          this.mu[i] = this.x[i];
          this.y[i] = this.ctx.unitToY(Math.random());
        }
        this.init_metrics();
        this.initCurveCache();

        /*
        for (let i = 0; i != n; i++) 
          this.y[i] = this.solutionPoint(i);
          */

        this.alpha.fill(1.0);
      }

      setDataPoint(i, u, v) {
        // update the value of the i'th data point
        this.x[i] = this.ctx.x(u);
        this.y[i] = this.ctx.y(v);
        this.init_mat('pft', i);
        this.init_mat('fft', i);
        this.updateCurveCache(i);
      }

      setMu(i, u) {
        this.mu[i] = this.ctx.x(u);
        this.init_mat('ppt', i);
        this.init_mat('pft', i);
        this.updateCurveCache(i);
      }

      kernel(x1, x2) {
        return this.kernels[this.active_ker].call(x1, x2);
      }

      jumps(x) {
        var k = this.kernels[this.active_ker];
        return k.cuts(x, this.ctx.xmin, this.ctx.xmax);
      }


      // return the solution, or if failed,
      // plot.alpha
      solutionAlpha() {
        var y = new Matrix([this.y]);
        try {
          var inv = inverse(this.pft); 
          var alpha = y.mmul(inv).flat();
          self.invertible = true;
          return alpha;

        } catch(err) {
          // console.log('could not invert.  leaving as-is');
          self.invertible = false;
          return this.alpha;
        }

      }

      _fNorm2() {
        var a = new Matrix([this.alpha]);
        return a.mmul(this.ppt).mmul(a.transpose()).flat()[0];
      }

      fNorm() {
        return Math.sqrt(this._fNorm2());
      }

      _fNormParallel2() {
        var a = new Matrix([this.alpha]);
        var b;
        try {
          var fft_inv = inverse(this.fft);
          b = a
            .mmul(this.pft)
            .mmul(fft_inv);
        } catch (err) {
          console.log(`Could not invert matrix`);
          return NaN;
        }

        var norm2 = b.mmul(this.fft).mmul(b.transpose());
        return norm2;
      }

      fNormParallel() {
        return Math.sqrt(this._fNormParallel2());
      }

      fNormPerp() {
        var fnorm2 = this._fNorm2();
        var fparnorm2 = this._fNormParallel2(); 
        var norm2 = fnorm2 - fparnorm2;
        if (norm2 > -1e-8) norm2 = Math.max(0, norm2);

        return Math.sqrt(norm2);
      }


      resize(w, h) {
        this.ctx.setWidth(w);
        this.ctx.setHeight(h);
        this.width = this.ctx.width;
        this.height = this.ctx.height;
      }

      updateContext(context) {
        this.ctx = context;
        this.height = this.ctx.height;
        this.width = this.ctx.width;
      }

      addPoint() {
        this.n++;
        this.populate();
      }

      delPoint() {
        if (this.n == 1) return;
        this.n--;
        this.populate();
      }

      updateAlpha(delta, index) {
        if (isNaN(delta + this.alpha[index])) {
          console.log(`updateAlpha got ${delta} and ${this.alpha[index]}`);
          return;
        }
        this.alpha[index] += delta;
      }

      makeLine(xs, ys) {
        var x2u = this.ctx.xToViewport;
        var [ymin, ymax] = [this.ctx.ymin, this.ctx.ymax];

        var y2v = (y) => this.ctx.yToViewport(Math.max(ymin - 1, Math.min(ymax + 1, y)));
        const path = line()(zip(xs.map(x2u), ys.map(y2v)));
        return path || '';
      }

      makeLines(ys) {
        var line = '';
        var off = 0, rng, len;
        for (let si = 0; si != this.xCache.length; si++) {
          rng = this.xCache[si];
          len = rng.length;
          line += this.makeLine(rng, ys.slice(off, off + len));
          off += len;
        }
        return line;
      }

      curve(ci) {
        var ys;
        var a = this.alpha[ci];
        var ys = this.curveCache[ci].map(y => a * y);
        return this.makeLines(ys);
      }

      solutionCurve() {
        if (this.n == 0) return '';
        var ys = new Array(this.curveCache[0].length).fill(0.0);

        for (let ci = 0; ci != this.n; ci++) {
          var a = this.alpha[ci];
          var cc = this.curveCache[ci];
          for (let xi = 0; xi != cc.length; xi++)
            ys[xi] += cc[xi] * a;
        }
        return this.makeLines(ys);
      }
      
      // return the u,v points for the i'th scaled curve
      points(i) {
        var a = this.alpha[i];
        var pts = range$2(this.n).map(j => [
          this.ctx.u(this.x[j]), 
          this.ctx.v(a * this.pft.get(i,j))
        ]);
        return pts;
      }

      data() {
        return zip(this.x, this.y).map(([x,y]) => 
          [this.ctx.u(x), this.ctx.v(y)]
        );
      }

      getMuX() {
        return zip(this.mu, this.x).map(([mu,x]) => 
          [this.ctx.u(mu), this.ctx.u(x)]
        );
      }

      // return the y value for the solution at the i'th x location
      // unused currently
      solutionPoint(i) {
        var y = range$2(this.n).map(j => this.alpha[j] * this.pft.get(i,j))
          .reduce((y1, y2) => y1 + y2, 0);
        return y;
      }


      u(x) {
        return this.ctx.u(x);
      }

      v(y) {
        return this.ctx.v(y);
      }


    }

    class Context {
      constructor(width, height, [xmin, xmax], [ymin, ymax]) {
        this.width = width;
        this.height = height;
        this.xmin = xmin;
        this.xmax = xmax;
        this.ymin = ymin;
        this.ymax = ymax;
        this.xToViewport = linear().domain([xmin, xmax]).range([0,width]);
        this.yToViewport = linear().domain([ymin, ymax]).range([height,0]);
        this.unitToX = linear().domain([0, 1]).range([xmin, xmax]);
        this.unitToY = linear().domain([0, 1]).range([ymin, ymax]);
        this.xToUnit = linear().domain([xmin, xmax]).range([0, 1]);
        // console.log(d3.scaleLinear);
      }

      setWidth(w) {
        this.width = w;
        this.xToViewport.range([0,w]);
      }

      setHeight(h) {
        this.height = h;
        this.yToViewport.range([h,0]);
      }

      x(u) {
        return this.xToViewport.invert(u);
      }

      y(v) {
        return this.yToViewport.invert(v);
      }

      u(x) {
        return this.xToViewport(x);
      }

      v(y) {
        return this.yToViewport(y);
      }

      xDomain() {
        return this.xToViewport.domain();
      }

      yDomain() {
        return this.yToViewport.domain();
      }
    }

    /* To synchronize two or more components that share data,
     * see https://svelte.dev/repl/a2e5e34a08b4491a975d523ded3b82c2?version=3.41.0
     * 
     */
    class Sync {
      constructor(sig, component_num, update_fn) {
    		component_num = parseInt(component_num);
    		if (isNaN(component_num) || component_num <= 0)
          throw `sync.js: component_num must be integer > 0, got ${component_num}`;
    		
    		this.sig = sig;
    		this.cnum = component_num;
    		this.sig.subscribe((val) => {
      		if (Math.abs(val) != this.cnum) {
    	  		// console.log(`updating component ${this.cnum}`)
      	  	update_fn();
    		  }    
    		});
    	}
    	
    	notify() {
    		// console.log(`notify from component ${this.cnum}`);
    		this.sig.update(n => {
      		var sign = Math.sign(n) || 1;
          return -sign * this.cnum;
    		});
    	}
    }

    /* src/Curves.svelte generated by Svelte v3.40.2 */

    const { console: console_1 } = globals;
    const file$9 = "src/Curves.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i][0];
    	child_ctx[18] = list[i][1];
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i][0];
    	child_ctx[18] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i][0];
    	child_ctx[26] = list[i][1];
    	child_ctx[20] = i;
    	return child_ctx;
    }

    // (119:2) {#each plot.getMuX() as [mu,x], i}
    function create_each_block_3$1(ctx) {
    	let use;
    	let use_x_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			use = svg_element("use");
    			attr_dev(use, "class", "marker draggable svelte-cs9siv");
    			attr_dev(use, "id", "mu" + /*i*/ ctx[20]);
    			attr_dev(use, "x", use_x_value = /*mu*/ ctx[25]);
    			attr_dev(use, "y", "0");
    			xlink_attr(use, "xlink:href", "#mu-select");
    			add_location(use, file$9, 119, 4, 2829);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, use, anchor);

    			if (!mounted) {
    				dispose = listen_dev(use, "mousedown", /*onMouseDown*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && use_x_value !== (use_x_value = /*mu*/ ctx[25])) {
    				attr_dev(use, "x", use_x_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(use);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(119:2) {#each plot.getMuX() as [mu,x], i}",
    		ctx
    	});

    	return block;
    }

    // (127:4) {#if cfg.curves}
    function create_if_block_3(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "curve svelte-cs9siv");
    			attr_dev(path, "d", path_d_value = /*plot*/ ctx[1].curve(/*i*/ ctx[20]));
    			add_location(path, file$9, 127, 6, 3049);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && path_d_value !== (path_d_value = /*plot*/ ctx[1].curve(/*i*/ ctx[20]))) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(127:4) {#if cfg.curves}",
    		ctx
    	});

    	return block;
    }

    // (131:4) {#if cfg.points}
    function create_if_block_2(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*plot*/ ctx[1].points(/*i*/ ctx[20]);
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot, range*/ 2) {
    				each_value_2 = /*plot*/ ctx[1].points(/*i*/ ctx[20]);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(131:4) {#if cfg.points}",
    		ctx
    	});

    	return block;
    }

    // (132:6) {#each plot.points(i) as [u,v]}
    function create_each_block_2$1(ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "point svelte-cs9siv");
    			attr_dev(circle, "cx", circle_cx_value = /*u*/ ctx[17]);
    			attr_dev(circle, "cy", circle_cy_value = /*v*/ ctx[18]);
    			attr_dev(circle, "r", "4");
    			add_location(circle, file$9, 132, 8, 3175);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && circle_cx_value !== (circle_cx_value = /*u*/ ctx[17])) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty & /*plot*/ 2 && circle_cy_value !== (circle_cy_value = /*v*/ ctx[18])) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(132:6) {#each plot.points(i) as [u,v]}",
    		ctx
    	});

    	return block;
    }

    // (126:2) {#each range(plot.n) as i}
    function create_each_block_1$2(ctx) {
    	let if_block0_anchor;
    	let if_block1_anchor;
    	let if_block0 = /*cfg*/ ctx[0].curves && create_if_block_3(ctx);
    	let if_block1 = /*cfg*/ ctx[0].points && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, if_block0_anchor, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*cfg*/ ctx[0].curves) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*cfg*/ ctx[0].points) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(if_block0_anchor);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(126:2) {#each range(plot.n) as i}",
    		ctx
    	});

    	return block;
    }

    // (138:2) {#if cfg.solution}
    function create_if_block_1(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "solution-curve svelte-cs9siv");
    			attr_dev(path, "d", path_d_value = /*plot*/ ctx[1].solutionCurve());
    			add_location(path, file$9, 138, 4, 3291);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && path_d_value !== (path_d_value = /*plot*/ ctx[1].solutionCurve())) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(138:2) {#if cfg.solution}",
    		ctx
    	});

    	return block;
    }

    // (142:2) {#if cfg.show_data}
    function create_if_block$3(ctx) {
    	let each_1_anchor;
    	let each_value = /*plot*/ ctx[1].data();
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot, onMouseDown*/ 34) {
    				each_value = /*plot*/ ctx[1].data();
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(142:2) {#if cfg.show_data}",
    		ctx
    	});

    	return block;
    }

    // (143:4) {#each plot.data() as [u,v], i}
    function create_each_block$4(ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "id", "xy" + /*i*/ ctx[20]);
    			attr_dev(circle, "class", "marker draggable svelte-cs9siv");
    			attr_dev(circle, "cx", circle_cx_value = /*u*/ ctx[17]);
    			attr_dev(circle, "cy", circle_cy_value = /*v*/ ctx[18]);
    			attr_dev(circle, "r", "5");
    			add_location(circle, file$9, 143, 6, 3428);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);

    			if (!mounted) {
    				dispose = listen_dev(circle, "mousedown", /*onMouseDown*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && circle_cx_value !== (circle_cx_value = /*u*/ ctx[17])) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty & /*plot*/ 2 && circle_cy_value !== (circle_cy_value = /*v*/ ctx[18])) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(143:4) {#each plot.data() as [u,v], i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let div;
    	let div_class_value;
    	let div_resize_listener;
    	let t;
    	let svg;
    	let defs;
    	let polygon;
    	let each0_anchor;
    	let each1_anchor;
    	let if_block0_anchor;
    	let svg_class_value;
    	let mounted;
    	let dispose;
    	let each_value_3 = /*plot*/ ctx[1].getMuX();
    	validate_each_argument(each_value_3);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_1[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	let each_value_1 = range$2(/*plot*/ ctx[1].n);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	let if_block0 = /*cfg*/ ctx[0].solution && create_if_block_1(ctx);
    	let if_block1 = /*cfg*/ ctx[0].show_data && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			polygon = svg_element("polygon");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			each0_anchor = empty$3();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each1_anchor = empty$3();
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", div_class_value = "framed " + /*gridarea*/ ctx[2] + " z3" + " svelte-cs9siv");
    			add_render_callback(() => /*div_elementresize_handler*/ ctx[10].call(div));
    			add_location(div, file$9, 110, 0, 2518);
    			attr_dev(polygon, "id", "mu-select");
    			attr_dev(polygon, "points", "-6,0 6,0 0,12");
    			add_location(polygon, file$9, 116, 5, 2717);
    			add_location(defs, file$9, 115, 5, 2705);
    			attr_dev(svg, "class", svg_class_value = "framed " + /*gridarea*/ ctx[2] + " svelte-cs9siv");
    			add_location(svg, file$9, 111, 0, 2602);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[10].bind(div));
    			insert_dev(target, t, anchor);
    			insert_dev(target, svg, anchor);
    			append_dev(svg, defs);
    			append_dev(defs, polygon);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(svg, null);
    			}

    			append_dev(svg, each0_anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svg, null);
    			}

    			append_dev(svg, each1_anchor);
    			if (if_block0) if_block0.m(svg, null);
    			append_dev(svg, if_block0_anchor);
    			if (if_block1) if_block1.m(svg, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "mousemove", /*onMouseMove*/ ctx[6], false, false, false),
    					listen_dev(svg, "mouseup", /*onMouseUp*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*gridarea*/ 4 && div_class_value !== (div_class_value = "framed " + /*gridarea*/ ctx[2] + " z3" + " svelte-cs9siv")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*plot, onMouseDown*/ 34) {
    				each_value_3 = /*plot*/ ctx[1].getMuX();
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_3$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(svg, each0_anchor);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_3.length;
    			}

    			if (dirty & /*plot, range, cfg*/ 3) {
    				each_value_1 = range$2(/*plot*/ ctx[1].n);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(svg, each1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*cfg*/ ctx[0].solution) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					if_block0.m(svg, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*cfg*/ ctx[0].show_data) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$3(ctx);
    					if_block1.c();
    					if_block1.m(svg, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*gridarea*/ 4 && svg_class_value !== (svg_class_value = "framed " + /*gridarea*/ ctx[2] + " svelte-cs9siv")) {
    				attr_dev(svg, "class", svg_class_value);
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			div_resize_listener();
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(svg);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Curves', slots, []);

    	let { sig } = $$props,
    		{ cfg } = $$props,
    		{ plot } = $$props,
    		{ cn } = $$props,
    		{ gridarea } = $$props;

    	let w = 0, h = 0;
    	let drag_point = null;
    	let s, mounted = false;

    	function solve(do_solve, msg) {
    		console.log(`in solve: ${msg}, do_solve=${do_solve}`);
    		if (!do_solve) return;
    		const NSTEPS = 50;
    		var start_alpha = plot.alpha;
    		var end_alpha = plot.solutionAlpha();
    		console.log(`in solve: ${end_alpha}`);

    		function transition(step, nsteps) {
    			if (step == nsteps) {
    				$$invalidate(1, plot.alpha = end_alpha, plot);
    			} else {
    				var delta = step / nsteps;

    				for (let i = 0; i != plot.n; i++) {
    					$$invalidate(1, plot.alpha[i] = delta * end_alpha[i] + (1 - delta) * start_alpha[i], plot);
    				}
    			}

    			s.notify();

    			if (step != nsteps) {
    				setTimeout(() => transition(step + 1, nsteps), 10);
    			}
    		}

    		transition(0, NSTEPS);
    	}

    	function update() {
    		if (!mounted) return;
    		var cmd = cfg.cmd;

    		// console.log(cfg);
    		if (cmd == null) throw 'got null cfg.cmd in Curves update';

    		if (cmd == 'reset_alpha') plot.resetAlpha();
    		if (cmd == 'del_point') plot.delPoint();
    		if (cmd == 'add_point') plot.addPoint();
    		if (cmd == 'new_data') plot.populate();
    		if (cmd == 'auto_solve') solve(cfg.auto_solve);
    		if (cmd == 'mu_tracks_x' && cfg.mu_tracks_x) plot.recenter_mu();
    		if (cmd == 'scramble') plot.set_scramble(cfg.scramble);
    		if (cmd == 'set_sigma') plot.set_sigma(cfg.log_sigma);

    		if (cmd.match(/update_alpha/)) ; else if (cmd == 'set_sigma' || cmd == 'mu_xy_changed') {
    			if (cfg.auto_solve) $$invalidate(1, plot.alpha = plot.solutionAlpha(), plot); // do nothing
    		} else if (cmd != 'reset_alpha') {
    			solve(cfg.auto_solve);
    		}

    		$$invalidate(1, plot.touch++, plot);
    		$$invalidate(0, cfg.cmd = null, cfg);
    		s.notify();
    	}

    	function resize(width, height) {
    		if (!mounted) return;

    		// console.log(`in resize with ${width} x ${height}`);
    		plot.resize(width, height);

    		$$invalidate(1, plot.touch++, plot);
    	}

    	onMount(() => {
    		s = new Sync(sig, cn, update);
    		mounted = true;
    		resize(w, h);
    	});

    	function onMouseDown(evt) {
    		drag_point = evt.target;
    	}

    	function onMouseMove(evt) {
    		if (drag_point == null) return;
    		var g = drag_point.id.match(/(?<code>\D+)(?<num>\d+)/).groups;

    		if (g.code == 'mu') plot.setMu(g.num, evt.offsetX); else if (g.code == 'xy') {
    			plot.setDataPoint(g.num, evt.offsetX, evt.offsetY);
    			if (cfg.mu_tracks_x) plot.setMu(g.num, evt.offsetX);
    		}

    		$$invalidate(0, cfg.cmd = 'mu_xy_changed', cfg);
    		update();
    	} // s.notify();

    	function onMouseUp(evt) {
    		drag_point = null;
    	}

    	const writable_props = ['sig', 'cfg', 'plot', 'cn', 'gridarea'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Curves> was created with unknown prop '${key}'`);
    	});

    	function div_elementresize_handler() {
    		w = this.clientWidth;
    		h = this.clientHeight;
    		$$invalidate(3, w);
    		$$invalidate(4, h);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('gridarea' in $$props) $$invalidate(2, gridarea = $$props.gridarea);
    	};

    	$$self.$capture_state = () => ({
    		Sync,
    		range: range$2,
    		onMount,
    		sig,
    		cfg,
    		plot,
    		cn,
    		gridarea,
    		w,
    		h,
    		drag_point,
    		s,
    		mounted,
    		solve,
    		update,
    		resize,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('gridarea' in $$props) $$invalidate(2, gridarea = $$props.gridarea);
    		if ('w' in $$props) $$invalidate(3, w = $$props.w);
    		if ('h' in $$props) $$invalidate(4, h = $$props.h);
    		if ('drag_point' in $$props) drag_point = $$props.drag_point;
    		if ('s' in $$props) s = $$props.s;
    		if ('mounted' in $$props) mounted = $$props.mounted;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*w, h*/ 24) {
    			resize(w, h);
    		}
    	};

    	return [
    		cfg,
    		plot,
    		gridarea,
    		w,
    		h,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp,
    		sig,
    		cn,
    		div_elementresize_handler
    	];
    }

    class Curves extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			sig: 8,
    			cfg: 0,
    			plot: 1,
    			cn: 9,
    			gridarea: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Curves",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[8] === undefined && !('sig' in props)) {
    			console_1.warn("<Curves> was created without expected prop 'sig'");
    		}

    		if (/*cfg*/ ctx[0] === undefined && !('cfg' in props)) {
    			console_1.warn("<Curves> was created without expected prop 'cfg'");
    		}

    		if (/*plot*/ ctx[1] === undefined && !('plot' in props)) {
    			console_1.warn("<Curves> was created without expected prop 'plot'");
    		}

    		if (/*cn*/ ctx[9] === undefined && !('cn' in props)) {
    			console_1.warn("<Curves> was created without expected prop 'cn'");
    		}

    		if (/*gridarea*/ ctx[2] === undefined && !('gridarea' in props)) {
    			console_1.warn("<Curves> was created without expected prop 'gridarea'");
    		}
    	}

    	get sig() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cfg() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cfg(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gridarea() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gridarea(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // accept single number or array
    // return single number or array
    function numberDisplay(nums) {
      var fn = (n) => 
        Math.abs(n) > 1000 || Math.abs(n) < 1e-2 ? n.toExponential(2) : n.toFixed(2);
      if (nums instanceof Array) return nums.map(fn);
      else return fn(nums);
    }

    /* src/LowPanelControls.svelte generated by Svelte v3.40.2 */
    const file$8 = "src/LowPanelControls.svelte";

    function create_fragment$8(ctx) {
    	let div7;
    	let div0;
    	let span0;
    	let raw0_value = `$\\|f\\| = $` + "";
    	let t0;

    	let t1_value = (/*plot*/ ctx[1].invertible
    	? numberDisplay(/*plot*/ ctx[1].fNorm())
    	: 'Could not solve') + "";

    	let t1;
    	let t2;
    	let div1;
    	let span1;
    	let raw1_value = `$\\|f_\\parallel\\| = $` + "";
    	let t3;

    	let t4_value = (/*plot*/ ctx[1].invertible
    	? numberDisplay(/*plot*/ ctx[1].fNormParallel())
    	: 'Could not solve') + "";

    	let t4;
    	let t5;
    	let div2;
    	let span2;
    	let raw2_value = `$\\|f_\\perp\\| = $` + "";
    	let t6;

    	let t7_value = (/*plot*/ ctx[1].invertible
    	? numberDisplay(/*plot*/ ctx[1].fNormPerp())
    	: 'Could not solve') + "";

    	let t7;
    	let t8;
    	let div3;
    	let label0;
    	let input0;
    	let t9;
    	let t10;
    	let div4;
    	let label1;
    	let input1;
    	let t11;
    	let span3;
    	let html_tag;
    	let raw3_value = `$\\mu$` + "";
    	let t12;
    	let html_tag_1;
    	let raw4_value = `$x$` + "";
    	let t13;
    	let div5;
    	let label2;
    	let input2;
    	let t14;
    	let t15;
    	let div6;
    	let label3;
    	let span4;
    	let raw5_value = `$\\sigma$` + "";
    	let t16;
    	let input3;
    	let t17;
    	let t18_value = numberDisplay(Math.pow(10, /*cfg*/ ctx[0].log_sigma)) + "";
    	let t18;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = space();
    			t1 = text$1(t1_value);
    			t2 = space();
    			div1 = element("div");
    			span1 = element("span");
    			t3 = space();
    			t4 = text$1(t4_value);
    			t5 = space();
    			div2 = element("div");
    			span2 = element("span");
    			t6 = space();
    			t7 = text$1(t7_value);
    			t8 = space();
    			div3 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t9 = text$1("\n      auto solve");
    			t10 = space();
    			div4 = element("div");
    			label1 = element("label");
    			input1 = element("input");
    			t11 = space();
    			span3 = element("span");
    			html_tag = new HtmlTag();
    			t12 = text$1(" tracks ");
    			html_tag_1 = new HtmlTag();
    			t13 = space();
    			div5 = element("div");
    			label2 = element("label");
    			input2 = element("input");
    			t14 = text$1("\n      scramble");
    			t15 = space();
    			div6 = element("div");
    			label3 = element("label");
    			span4 = element("span");
    			t16 = text$1(": \n      ");
    			input3 = element("input");
    			t17 = space();
    			t18 = text$1(t18_value);
    			add_location(span0, file$8, 24, 4, 355);
    			attr_dev(div0, "class", "col1 line svelte-h0ylfy");
    			add_location(div0, file$8, 23, 2, 327);
    			add_location(span1, file$8, 28, 4, 503);
    			attr_dev(div1, "class", "col2 line svelte-h0ylfy");
    			add_location(div1, file$8, 27, 2, 475);
    			add_location(span2, file$8, 32, 4, 675);
    			attr_dev(div2, "class", "col2 row2 line svelte-h0ylfy");
    			add_location(div2, file$8, 31, 2, 642);
    			attr_dev(input0, "id", "auto_solve");
    			attr_dev(input0, "type", "checkbox");
    			add_location(input0, file$8, 37, 6, 864);
    			attr_dev(label0, "class", "ib");
    			add_location(label0, file$8, 36, 4, 839);
    			attr_dev(div3, "class", "col4 row1 line svelte-h0ylfy");
    			add_location(div3, file$8, 35, 2, 806);
    			attr_dev(input1, "id", "mu_tracks_x");
    			attr_dev(input1, "type", "checkbox");
    			add_location(input1, file$8, 46, 6, 1088);
    			html_tag.a = t12;
    			html_tag_1.a = null;
    			add_location(span3, file$8, 50, 6, 1220);
    			attr_dev(label1, "class", "ib");
    			add_location(label1, file$8, 45, 4, 1063);
    			attr_dev(div4, "class", "col4 row2 line svelte-h0ylfy");
    			add_location(div4, file$8, 44, 2, 1030);
    			attr_dev(input2, "id", "scramble");
    			attr_dev(input2, "type", "checkbox");
    			add_location(input2, file$8, 55, 6, 1353);
    			attr_dev(label2, "class", "ib");
    			add_location(label2, file$8, 54, 4, 1328);
    			attr_dev(div5, "class", "col5 row1 line svelte-h0ylfy");
    			add_location(div5, file$8, 53, 2, 1295);
    			add_location(span4, file$8, 63, 22, 1563);
    			attr_dev(input3, "id", "set_sigma");
    			attr_dev(input3, "class", "short svelte-h0ylfy");
    			attr_dev(input3, "type", "range");
    			attr_dev(input3, "min", "-5");
    			attr_dev(input3, "max", "2");
    			attr_dev(input3, "step", "0.01");
    			add_location(input3, file$8, 64, 6, 1604);
    			attr_dev(label3, "class", "ib");
    			add_location(label3, file$8, 63, 4, 1545);
    			attr_dev(div6, "class", "col5 row2 line svelte-h0ylfy");
    			add_location(div6, file$8, 62, 2, 1512);
    			attr_dev(div7, "class", "gb gi svelte-h0ylfy");
    			add_location(div7, file$8, 22, 0, 305);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div0);
    			append_dev(div0, span0);
    			span0.innerHTML = raw0_value;
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div7, t2);
    			append_dev(div7, div1);
    			append_dev(div1, span1);
    			span1.innerHTML = raw1_value;
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			append_dev(div7, t5);
    			append_dev(div7, div2);
    			append_dev(div2, span2);
    			span2.innerHTML = raw2_value;
    			append_dev(div2, t6);
    			append_dev(div2, t7);
    			append_dev(div7, t8);
    			append_dev(div7, div3);
    			append_dev(div3, label0);
    			append_dev(label0, input0);
    			input0.checked = /*cfg*/ ctx[0].auto_solve;
    			append_dev(label0, t9);
    			append_dev(div7, t10);
    			append_dev(div7, div4);
    			append_dev(div4, label1);
    			append_dev(label1, input1);
    			input1.checked = /*cfg*/ ctx[0].mu_tracks_x;
    			append_dev(label1, t11);
    			append_dev(label1, span3);
    			html_tag.m(raw3_value, span3);
    			append_dev(span3, t12);
    			html_tag_1.m(raw4_value, span3);
    			append_dev(div7, t13);
    			append_dev(div7, div5);
    			append_dev(div5, label2);
    			append_dev(label2, input2);
    			input2.checked = /*cfg*/ ctx[0].scramble;
    			append_dev(label2, t14);
    			append_dev(div7, t15);
    			append_dev(div7, div6);
    			append_dev(div6, label3);
    			append_dev(label3, span4);
    			span4.innerHTML = raw5_value;
    			append_dev(label3, t16);
    			append_dev(label3, input3);
    			set_input_value(input3, /*cfg*/ ctx[0].log_sigma);
    			append_dev(label3, t17);
    			append_dev(label3, t18);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[5]),
    					listen_dev(input0, "change", /*h*/ ctx[2], false, false, false),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[6]),
    					listen_dev(input1, "change", /*h*/ ctx[2], false, false, false),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[7]),
    					listen_dev(input2, "change", /*h*/ ctx[2], false, false, false),
    					listen_dev(input3, "change", /*input3_change_input_handler*/ ctx[8]),
    					listen_dev(input3, "input", /*input3_change_input_handler*/ ctx[8]),
    					listen_dev(input3, "input", /*h*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*plot*/ 2 && t1_value !== (t1_value = (/*plot*/ ctx[1].invertible
    			? numberDisplay(/*plot*/ ctx[1].fNorm())
    			: 'Could not solve') + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*plot*/ 2 && t4_value !== (t4_value = (/*plot*/ ctx[1].invertible
    			? numberDisplay(/*plot*/ ctx[1].fNormParallel())
    			: 'Could not solve') + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*plot*/ 2 && t7_value !== (t7_value = (/*plot*/ ctx[1].invertible
    			? numberDisplay(/*plot*/ ctx[1].fNormPerp())
    			: 'Could not solve') + "")) set_data_dev(t7, t7_value);

    			if (dirty & /*cfg*/ 1) {
    				input0.checked = /*cfg*/ ctx[0].auto_solve;
    			}

    			if (dirty & /*cfg*/ 1) {
    				input1.checked = /*cfg*/ ctx[0].mu_tracks_x;
    			}

    			if (dirty & /*cfg*/ 1) {
    				input2.checked = /*cfg*/ ctx[0].scramble;
    			}

    			if (dirty & /*cfg*/ 1) {
    				set_input_value(input3, /*cfg*/ ctx[0].log_sigma);
    			}

    			if (dirty & /*cfg*/ 1 && t18_value !== (t18_value = numberDisplay(Math.pow(10, /*cfg*/ ctx[0].log_sigma)) + "")) set_data_dev(t18, t18_value);
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LowPanelControls', slots, []);
    	let { sig } = $$props, { cn } = $$props, { cfg } = $$props, { plot } = $$props;

    	function update() {
    		$$invalidate(1, plot.touch++, plot);
    	}

    	var s = new Sync(sig, cn, update);

    	// catch-all event handler
    	function h(e) {
    		$$invalidate(0, cfg.cmd = e.target.id, cfg);
    		update();
    		s.notify();
    	}

    	const writable_props = ['sig', 'cn', 'cfg', 'plot'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LowPanelControls> was created with unknown prop '${key}'`);
    	});

    	function input0_change_handler() {
    		cfg.auto_solve = this.checked;
    		$$invalidate(0, cfg);
    	}

    	function input1_change_handler() {
    		cfg.mu_tracks_x = this.checked;
    		$$invalidate(0, cfg);
    	}

    	function input2_change_handler() {
    		cfg.scramble = this.checked;
    		$$invalidate(0, cfg);
    	}

    	function input3_change_input_handler() {
    		cfg.log_sigma = to_number(this.value);
    		$$invalidate(0, cfg);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(4, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    	};

    	$$self.$capture_state = () => ({
    		Sync,
    		numberDisplay,
    		sig,
    		cn,
    		cfg,
    		plot,
    		update,
    		s,
    		h
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(4, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    		if ('s' in $$props) s = $$props.s;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		cfg,
    		plot,
    		h,
    		sig,
    		cn,
    		input0_change_handler,
    		input1_change_handler,
    		input2_change_handler,
    		input3_change_input_handler
    	];
    }

    class LowPanelControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, { sig: 3, cn: 4, cfg: 0, plot: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LowPanelControls",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[3] === undefined && !('sig' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'sig'");
    		}

    		if (/*cn*/ ctx[4] === undefined && !('cn' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'cn'");
    		}

    		if (/*cfg*/ ctx[0] === undefined && !('cfg' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'cfg'");
    		}

    		if (/*plot*/ ctx[1] === undefined && !('plot' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'plot'");
    		}
    	}

    	get sig() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cfg() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cfg(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/SliderControls.svelte generated by Svelte v3.40.2 */
    const file$7 = "src/SliderControls.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[9] = list;
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (23:2) {#each plot.alpha as a, i}
    function create_each_block$3(ctx) {
    	let div1;
    	let label;
    	let span;
    	let raw_value = `$\\alpha_{i}$` + "";
    	let t0;
    	let input;
    	let t1;
    	let div0;
    	let t2_value = numberDisplay(/*a*/ ctx[8]) + "";
    	let t2;
    	let mounted;
    	let dispose;

    	function input_change_input_handler() {
    		/*input_change_input_handler*/ ctx[5].call(input, /*each_value*/ ctx[9], /*i*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			label = element("label");
    			span = element("span");
    			t0 = space();
    			input = element("input");
    			t1 = space();
    			div0 = element("div");
    			t2 = text$1(t2_value);
    			add_location(span, file$7, 24, 24, 394);
    			attr_dev(input, "id", "update_alpha" + /*i*/ ctx[10]);
    			attr_dev(input, "class", "ib slider svelte-n9jner");
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "-10");
    			attr_dev(input, "max", "10");
    			attr_dev(input, "step", "0.01");
    			add_location(input, file$7, 25, 8, 439);
    			attr_dev(div0, "class", "ib svelte-n9jner");
    			add_location(div0, file$7, 31, 6, 631);
    			attr_dev(label, "class", "ib svelte-n9jner");
    			add_location(label, file$7, 24, 6, 376);
    			attr_dev(div1, "class", "alpha svelte-n9jner");
    			add_location(div1, file$7, 23, 4, 350);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label);
    			append_dev(label, span);
    			span.innerHTML = raw_value;
    			append_dev(label, t0);
    			append_dev(label, input);
    			set_input_value(input, /*a*/ ctx[8]);
    			append_dev(label, t1);
    			append_dev(label, div0);
    			append_dev(div0, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", input_change_input_handler),
    					listen_dev(input, "input", input_change_input_handler),
    					listen_dev(input, "input", /*h*/ ctx[1], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*plot*/ 1) {
    				set_input_value(input, /*a*/ ctx[8]);
    			}

    			if (dirty & /*plot*/ 1 && t2_value !== (t2_value = numberDisplay(/*a*/ ctx[8]) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(23:2) {#each plot.alpha as a, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div;
    	let t0;
    	let button0;
    	let t2;
    	let button1;
    	let t3;
    	let d_math;
    	let t5;
    	let button2;
    	let t7;
    	let button3;
    	let mounted;
    	let dispose;
    	let each_value = /*plot*/ ctx[0].alpha;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			button0 = element("button");
    			button0.textContent = "New Data";
    			t2 = space();
    			button1 = element("button");
    			t3 = text$1("Reset ");
    			d_math = element("d-math");
    			d_math.textContent = "\\\\alpha";
    			t5 = space();
    			button2 = element("button");
    			button2.textContent = "Del Point";
    			t7 = space();
    			button3 = element("button");
    			button3.textContent = "Add Point";
    			attr_dev(button0, "id", "new_data");
    			add_location(button0, file$7, 35, 2, 710);
    			add_location(d_math, file$7, 36, 46, 809);
    			attr_dev(button1, "id", "reset_alpha");
    			add_location(button1, file$7, 36, 2, 765);
    			attr_dev(button2, "id", "del_point");
    			add_location(button2, file$7, 37, 2, 845);
    			attr_dev(button3, "id", "add_point");
    			add_location(button3, file$7, 38, 2, 902);
    			attr_dev(div, "class", "gb svelte-n9jner");
    			add_location(div, file$7, 21, 0, 300);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t0);
    			append_dev(div, button0);
    			append_dev(div, t2);
    			append_dev(div, button1);
    			append_dev(button1, t3);
    			append_dev(button1, d_math);
    			append_dev(div, t5);
    			append_dev(div, button2);
    			append_dev(div, t7);
    			append_dev(div, button3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*h*/ ctx[1], false, false, false),
    					listen_dev(button1, "click", /*h*/ ctx[1], false, false, false),
    					listen_dev(button2, "click", /*h*/ ctx[1], false, false, false),
    					listen_dev(button3, "click", /*h*/ ctx[1], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*numberDisplay, plot, h*/ 3) {
    				each_value = /*plot*/ ctx[0].alpha;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, t0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SliderControls', slots, []);
    	let { sig } = $$props, { cn } = $$props, { cfg } = $$props, { plot } = $$props;

    	function update() {
    		$$invalidate(0, plot.touch++, plot);
    	}

    	var s = new Sync(sig, cn, update);

    	// generic handler
    	function h(evt) {
    		$$invalidate(2, cfg.cmd = evt.target.id, cfg);
    		s.notify();
    		update();
    	}

    	const writable_props = ['sig', 'cn', 'cfg', 'plot'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SliderControls> was created with unknown prop '${key}'`);
    	});

    	function input_change_input_handler(each_value, i) {
    		each_value[i] = to_number(this.value);
    		$$invalidate(0, plot);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(4, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(2, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    	};

    	$$self.$capture_state = () => ({
    		Sync,
    		numberDisplay,
    		sig,
    		cn,
    		cfg,
    		plot,
    		update,
    		s,
    		h
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(4, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(2, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('s' in $$props) s = $$props.s;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [plot, h, cfg, sig, cn, input_change_input_handler];
    }

    class SliderControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$7, create_fragment$7, safe_not_equal, { sig: 3, cn: 4, cfg: 2, plot: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliderControls",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[3] === undefined && !('sig' in props)) {
    			console.warn("<SliderControls> was created without expected prop 'sig'");
    		}

    		if (/*cn*/ ctx[4] === undefined && !('cn' in props)) {
    			console.warn("<SliderControls> was created without expected prop 'cn'");
    		}

    		if (/*cfg*/ ctx[2] === undefined && !('cfg' in props)) {
    			console.warn("<SliderControls> was created without expected prop 'cfg'");
    		}

    		if (/*plot*/ ctx[0] === undefined && !('plot' in props)) {
    			console.warn("<SliderControls> was created without expected prop 'plot'");
    		}
    	}

    	get sig() {
    		throw new Error("<SliderControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<SliderControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<SliderControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<SliderControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cfg() {
    		throw new Error("<SliderControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cfg(value) {
    		throw new Error("<SliderControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<SliderControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<SliderControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var win;

    if (typeof window !== "undefined") {
        win = window;
    } else if (typeof commonjsGlobal !== "undefined") {
        win = commonjsGlobal;
    } else if (typeof self !== "undefined"){
        win = self;
    } else {
        win = {};
    }

    var window_1 = win;

    var isFunction_1 = isFunction;

    var toString = Object.prototype.toString;

    function isFunction (fn) {
      if (!fn) {
        return false
      }
      var string = toString.call(fn);
      return string === '[object Function]' ||
        (typeof fn === 'function' && string !== '[object RegExp]') ||
        (typeof window !== 'undefined' &&
         // IE8 and below
         (fn === window.setTimeout ||
          fn === window.alert ||
          fn === window.confirm ||
          fn === window.prompt))
    }

    var trim = function(string) {
      return string.replace(/^\s+|\s+$/g, '');
    }
      , isArray = function(arg) {
          return Object.prototype.toString.call(arg) === '[object Array]';
        };

    var parseHeaders = function (headers) {
      if (!headers)
        return {}

      var result = {};

      var headersArr = trim(headers).split('\n');

      for (var i = 0; i < headersArr.length; i++) {
        var row = headersArr[i];
        var index = row.indexOf(':')
        , key = trim(row.slice(0, index)).toLowerCase()
        , value = trim(row.slice(index + 1));

        if (typeof(result[key]) === 'undefined') {
          result[key] = value;
        } else if (isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [ result[key], value ];
        }
      }

      return result
    };

    var immutable = extend;

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function extend() {
        var target = {};

        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target
    }

    var xhr = createXHR;
    // Allow use of default import syntax in TypeScript
    var _default = createXHR;
    createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop;
    createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window_1.XDomainRequest;

    forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
        createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
            options = initParams(uri, options, callback);
            options.method = method.toUpperCase();
            return _createXHR(options)
        };
    });

    function forEachArray(array, iterator) {
        for (var i = 0; i < array.length; i++) {
            iterator(array[i]);
        }
    }

    function isEmpty(obj){
        for(var i in obj){
            if(obj.hasOwnProperty(i)) return false
        }
        return true
    }

    function initParams(uri, options, callback) {
        var params = uri;

        if (isFunction_1(options)) {
            callback = options;
            if (typeof uri === "string") {
                params = {uri:uri};
            }
        } else {
            params = immutable(options, {uri: uri});
        }

        params.callback = callback;
        return params
    }

    function createXHR(uri, options, callback) {
        options = initParams(uri, options, callback);
        return _createXHR(options)
    }

    function _createXHR(options) {
        if(typeof options.callback === "undefined"){
            throw new Error("callback argument missing")
        }

        var called = false;
        var callback = function cbOnce(err, response, body){
            if(!called){
                called = true;
                options.callback(err, response, body);
            }
        };

        function readystatechange() {
            if (xhr.readyState === 4) {
                setTimeout(loadFunc, 0);
            }
        }

        function getBody() {
            // Chrome with requestType=blob throws errors arround when even testing access to responseText
            var body = undefined;

            if (xhr.response) {
                body = xhr.response;
            } else {
                body = xhr.responseText || getXml(xhr);
            }

            if (isJson) {
                try {
                    body = JSON.parse(body);
                } catch (e) {}
            }

            return body
        }

        function errorFunc(evt) {
            clearTimeout(timeoutTimer);
            if(!(evt instanceof Error)){
                evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") );
            }
            evt.statusCode = 0;
            return callback(evt, failureResponse)
        }

        // will load the data & process the response in a special response object
        function loadFunc() {
            if (aborted) return
            var status;
            clearTimeout(timeoutTimer);
            if(options.useXDR && xhr.status===undefined) {
                //IE8 CORS GET successful response doesn't have a status field, but body is fine
                status = 200;
            } else {
                status = (xhr.status === 1223 ? 204 : xhr.status);
            }
            var response = failureResponse;
            var err = null;

            if (status !== 0){
                response = {
                    body: getBody(),
                    statusCode: status,
                    method: method,
                    headers: {},
                    url: uri,
                    rawRequest: xhr
                };
                if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                    response.headers = parseHeaders(xhr.getAllResponseHeaders());
                }
            } else {
                err = new Error("Internal XMLHttpRequest Error");
            }
            return callback(err, response, response.body)
        }

        var xhr = options.xhr || null;

        if (!xhr) {
            if (options.cors || options.useXDR) {
                xhr = new createXHR.XDomainRequest();
            }else {
                xhr = new createXHR.XMLHttpRequest();
            }
        }

        var key;
        var aborted;
        var uri = xhr.url = options.uri || options.url;
        var method = xhr.method = options.method || "GET";
        var body = options.body || options.data;
        var headers = xhr.headers = options.headers || {};
        var sync = !!options.sync;
        var isJson = false;
        var timeoutTimer;
        var failureResponse = {
            body: undefined,
            headers: {},
            statusCode: 0,
            method: method,
            url: uri,
            rawRequest: xhr
        };

        if ("json" in options && options.json !== false) {
            isJson = true;
            headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json"); //Don't override existing accept header declared by user
            if (method !== "GET" && method !== "HEAD") {
                headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"); //Don't override existing accept header declared by user
                body = JSON.stringify(options.json === true ? body : options.json);
            }
        }

        xhr.onreadystatechange = readystatechange;
        xhr.onload = loadFunc;
        xhr.onerror = errorFunc;
        // IE9 must have onprogress be set to a unique function.
        xhr.onprogress = function () {
            // IE must die
        };
        xhr.onabort = function(){
            aborted = true;
        };
        xhr.ontimeout = errorFunc;
        xhr.open(method, uri, !sync, options.username, options.password);
        //has to be after open
        if(!sync) {
            xhr.withCredentials = !!options.withCredentials;
        }
        // Cannot set timeout with sync request
        // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
        // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
        if (!sync && options.timeout > 0 ) {
            timeoutTimer = setTimeout(function(){
                if (aborted) return
                aborted = true;//IE9 may still call readystatechange
                xhr.abort("timeout");
                var e = new Error("XMLHttpRequest timeout");
                e.code = "ETIMEDOUT";
                errorFunc(e);
            }, options.timeout );
        }

        if (xhr.setRequestHeader) {
            for(key in headers){
                if(headers.hasOwnProperty(key)){
                    xhr.setRequestHeader(key, headers[key]);
                }
            }
        } else if (options.headers && !isEmpty(options.headers)) {
            throw new Error("Headers cannot be set on an XDomainRequest object")
        }

        if ("responseType" in options) {
            xhr.responseType = options.responseType;
        }

        if ("beforeSend" in options &&
            typeof options.beforeSend === "function"
        ) {
            options.beforeSend(xhr);
        }

        // Microsoft Edge browser sends "undefined" when send is called with undefined value.
        // XMLHttpRequest spec says to pass null as body to indicate no body
        // See https://github.com/naugtur/xhr/issues/100.
        xhr.send(body || null);

        return xhr


    }

    function getXml(xhr) {
        // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
        // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
        try {
            if (xhr.responseType === "document") {
                return xhr.responseXML
            }
            var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
            if (xhr.responseType === "" && !firefoxBugTakenEffect) {
                return xhr.responseXML
            }
        } catch (e) {}

        return null
    }

    function noop() {}
    xhr.default = _default;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };





    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();









































    var toConsumableArray = function (arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      } else {
        return Array.from(arr);
      }
    };

    var lastError = '';

    /**
     * Creates the HTLM for a failure message
     * @param {string} canvasContainerId id of container of th
     *        canvas.
     * @return {string} The html.
     */
    function makeFailHTML(msg) {
        return '\n<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>\n<td align="center">\n<div style="display: table-cell; vertical-align: middle;">\n<div style="">' + msg + '</div>\n</div>\n</td></tr></table>\n';
    }

    /**
     * Message for getting a webgl browser
     * @type {string}
     */
    var GET_A_WEBGL_BROWSER = '\n\tThis page requires a browser that supports WebGL.<br/>\n\t<a href="http://get.webgl.org">Click here to upgrade your browser.</a>\n';

    /**
     * Message for need better hardware
     * @type {string}
     */
    var OTHER_PROBLEM = '\n\tIt does not appear your computer can support WebGL.<br/>\n\t<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>\n';

    /**
     * Code to return in `onError` callback when the browser doesn't support webgl
     * @type {number}
     */
    var ERROR_BROWSER_SUPPORT = 1;

    /**
     * Code to return in `onError` callback there's any other problem related to webgl
     * @type {number}
     */
    var ERROR_OTHER = 2;

    /**
     * Creates a webgl context. If creation fails it will
     * change the contents of the container of the <canvas>
     * tag to an error message with the correct links for WebGL,
     * unless `onError` option is defined to a callback,
     * which allows for custom error handling..
     * @param {Element} canvas. The canvas element to create a
     *     context from.
     * @param {WebGLContextCreationAttributes} optAttribs Any
     *     creation attributes you want to pass in.
     * @return {WebGLRenderingContext} The created context.
     */
    function setupWebGL(canvas, optAttribs, onError) {
        function showLink(str) {
            var container = canvas.parentNode;
            if (container) {
                container.innerHTML = makeFailHTML(str);
            }
        }

        function handleError(errorCode, msg) {
            if (typeof onError === 'function') {
                onError(errorCode);
            } else {
                showLink(msg);
            }
        }

        if (!window.WebGLRenderingContext) {
            handleError(ERROR_BROWSER_SUPPORT, GET_A_WEBGL_BROWSER);
            return null;
        }

        var context = create3DContext(canvas, optAttribs);
        if (!context) {
            handleError(ERROR_OTHER, OTHER_PROBLEM);
        } else {
            context.getExtension('OES_standard_derivatives');
        }
        return context;
    }

    /**
     * Creates a webgl context.
     * @param {!Canvas} canvas The canvas tag to get context
     *     from. If one is not passed in one will be created.
     * @return {!WebGLContext} The created context.
     */
    function create3DContext(canvas, optAttribs) {
        var names = ['webgl', 'experimental-webgl'];
        var context = null;
        for (var ii = 0; ii < names.length; ++ii) {
            try {
                context = canvas.getContext(names[ii], optAttribs);
            } catch (e) {
                if (context) {
                    break;
                }
            }
        }
        return context;
    }

    /*
     *	Create a Vertex of a specific type (gl.VERTEX_SHADER/)
     */
    function createShader(main, source, type, offset) {
        var gl = main.gl;

        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

        if (!compiled) {
            // Something went wrong during compilation; get the error
            lastError = gl.getShaderInfoLog(shader);
            console.error('*** Error compiling shader ' + shader + ':' + lastError);
            main.trigger('error', {
                shader: shader,
                source: source,
                type: type,
                error: lastError,
                offset: offset || 0
            });
            gl.deleteShader(shader);
            return null;
        }

        return shader;
    }

    /**
     * Loads a shader.
     * @param {!WebGLContext} gl The WebGLContext to use.
     * @param {string} shaderSource The shader source.
     * @param {number} shaderType The type of shader.
     * @param {function(string): void) opt_errorCallback callback for errors.
     * @return {!WebGLShader} The created shader.
     */
    function createProgram(main, shaders, optAttribs, optLocations) {
        var gl = main.gl;

        var program = gl.createProgram();
        for (var ii = 0; ii < shaders.length; ++ii) {
            gl.attachShader(program, shaders[ii]);
        }
        if (optAttribs) {
            for (var _ii = 0; _ii < optAttribs.length; ++_ii) {
                gl.bindAttribLocation(program, optLocations ? optLocations[_ii] : _ii, optAttribs[_ii]);
            }
        }
        gl.linkProgram(program);

        // Check the link status
        var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!linked) {
            // something went wrong with the link
            lastError = gl.getProgramInfoLog(program);
            console.log('Error in program linking:' + lastError);
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    // By Brett Camber on
    // https://github.com/tangrams/tangram/blob/master/src/gl/glsl.js
    function parseUniforms(uniforms) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var parsed = [];

        for (var name in uniforms) {
            var uniform = uniforms[name];
            var u = void 0;

            if (prefix) {
                name = prefix + '.' + name;
            }

            // Single float
            if (typeof uniform === 'number') {
                parsed.push({
                    type: 'float',
                    method: '1f',
                    name: name,
                    value: uniform
                });
            }
            // Array: vector, array of floats, array of textures, or array of structs
            else if (Array.isArray(uniform)) {
                    // Numeric values
                    if (typeof uniform[0] === 'number') {
                        // float vectors (vec2, vec3, vec4)
                        if (uniform.length === 1) {
                            parsed.push({
                                type: 'float',
                                method: '1f',
                                name: name,
                                value: uniform
                            });
                        }
                        // float vectors (vec2, vec3, vec4)
                        else if (uniform.length >= 2 && uniform.length <= 4) {
                                parsed.push({
                                    type: 'vec' + uniform.length,
                                    method: uniform.length + 'fv',
                                    name: name,
                                    value: uniform
                                });
                            }
                            // float array
                            else if (uniform.length > 4) {
                                    parsed.push({
                                        type: 'float[]',
                                        method: '1fv',
                                        name: name + '[0]',
                                        value: uniform
                                    });
                                }
                        // TODO: assume matrix for (typeof == Float32Array && length == 16)?
                    }
                    // Array of textures
                    else if (typeof uniform[0] === 'string') {
                            parsed.push({
                                type: 'sampler2D',
                                method: '1i',
                                name: name,
                                value: uniform
                            });
                        }
                        // Array of arrays - but only arrays of vectors are allowed in this case
                        else if (Array.isArray(uniform[0]) && typeof uniform[0][0] === 'number') {
                                // float vectors (vec2, vec3, vec4)
                                if (uniform[0].length >= 2 && uniform[0].length <= 4) {
                                    // Set each vector in the array
                                    for (u = 0; u < uniform.length; u++) {
                                        parsed.push({
                                            type: 'vec' + uniform[0].length,
                                            method: uniform[u].length + 'fv',
                                            name: name + '[' + u + ']',
                                            value: uniform[u]
                                        });
                                    }
                                }
                                // else error?
                            }
                            // Array of structures
                            else if (_typeof(uniform[0]) === 'object') {
                                    for (u = 0; u < uniform.length; u++) {
                                        // Set each struct in the array
                                        parsed.push.apply(parsed, toConsumableArray(parseUniforms(uniform[u], name + '[' + u + ']')));
                                    }
                                }
                }
                // Boolean
                else if (typeof uniform === 'boolean') {
                        parsed.push({
                            type: 'bool',
                            method: '1i',
                            name: name,
                            value: uniform
                        });
                    }
                    // Texture
                    else if (typeof uniform === 'string') {
                            parsed.push({
                                type: 'sampler2D',
                                method: '1i',
                                name: name,
                                value: uniform
                            });
                        }
                        // Structure
                        else if ((typeof uniform === 'undefined' ? 'undefined' : _typeof(uniform)) === 'object') {
                                // Set each field in the struct
                                parsed.push.apply(parsed, toConsumableArray(parseUniforms(uniform, name)));
                            }
            // TODO: support other non-float types? (int, etc.)
        }
        return parsed;
    }

    function isCanvasVisible(canvas) {
        return canvas.getBoundingClientRect().top + canvas.height > 0 && canvas.getBoundingClientRect().top < (window.innerHeight || document.documentElement.clientHeight);
    }

    function isPowerOf2(value) {
        return (value & value - 1) === 0;
    }

    function isSafari() {
        return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        );
    }







    function isDiff(a, b) {
        if (a && b) {
            return a.toString() !== b.toString();
        }
        return false;
    }

    function subscribeMixin$1(target) {
        var listeners = new Set();

        return Object.assign(target, {
            on: function on(type, f) {
                var listener = {};
                listener[type] = f;
                listeners.add(listener);
            },
            off: function off(type, f) {
                if (f) {
                    var listener = {};
                    listener[type] = f;
                    listeners.delete(listener);
                } else {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var item = _step.value;
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = Object.keys(item)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var key = _step2.value;

                                    if (key === type) {
                                        listeners.delete(item);
                                        return;
                                    }
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                        _iterator2.return();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
            },
            listSubscriptions: function listSubscriptions() {
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = listeners[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var item = _step3.value;

                        console.log(item);
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
            },
            subscribe: function subscribe(listener) {
                listeners.add(listener);
            },
            unsubscribe: function unsubscribe(listener) {
                listeners.delete(listener);
            },
            unsubscribeAll: function unsubscribeAll() {
                listeners.clear();
            },
            trigger: function trigger(event) {
                for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    data[_key - 1] = arguments[_key];
                }

                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = listeners[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var listener = _step4.value;

                        if (typeof listener[event] === 'function') {
                            listener[event].apply(listener, toConsumableArray(data));
                        }
                    }
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }
            }
        });
    }

    // Texture management
    var Texture = function () {
        function Texture(gl, name) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            classCallCheck(this, Texture);

            subscribeMixin$1(this);

            this.gl = gl;
            this.texture = gl.createTexture();
            if (this.texture) {
                this.valid = true;
            }
            this.bind();

            this.name = name;
            this.source = null;
            this.sourceType = null;
            this.loading = null; // a Promise object to track the loading state of this texture

            // Default to a 1-pixel black texture so we can safely render while we wait for an image to load
            // See: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
            this.setData(1, 1, new Uint8Array([0, 0, 0, 255]), { filtering: 'linear' });
            this.setFiltering(options.filtering);

            this.load(options);
        }

        // Destroy a single texture instance


        createClass(Texture, [{
            key: 'destroy',
            value: function destroy() {
                if (!this.valid) {
                    return;
                }
                this.gl.deleteTexture(this.texture);
                this.texture = null;
                delete this.data;
                this.data = null;
                this.valid = false;
            }
        }, {
            key: 'bind',
            value: function bind(unit) {
                if (!this.valid) {
                    return;
                }
                if (typeof unit === 'number') {
                    if (Texture.activeUnit !== unit) {
                        this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                        Texture.activeUnit = unit;
                    }
                }
                if (Texture.activeTexture !== this.texture) {
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                    Texture.activeTexture = this.texture;
                }
            }
        }, {
            key: 'load',
            value: function load() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                this.loading = null;

                if (typeof options.url === 'string') {
                    if (this.url === undefined || options.url !== this.url) {
                        this.setUrl(options.url, options);
                    }
                } else if (options.element) {
                    this.setElement(options.element, options);
                } else if (options.data && options.width && options.height) {
                    this.setData(options.width, options.height, options.data, options);
                }
            }

            // Sets texture from an url

        }, {
            key: 'setUrl',
            value: function setUrl(url) {
                var _this = this;

                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                if (!this.valid) {
                    return;
                }

                this.url = url; // save URL reference (will be overwritten when element is loaded below)
                this.source = this.url;
                this.sourceType = 'url';

                this.loading = new Promise(function (resolve, reject) {
                    var ext = url.split('.').pop().toLowerCase();
                    var isVideo = ext === 'ogv' || ext === 'webm' || ext === 'mp4';

                    var element = undefined;
                    if (isVideo) {
                        element = document.createElement('video');
                        element.autoplay = true;
                        options.filtering = 'nearest';
                        // element.preload = 'auto';
                        // element.style.display = 'none';
                        // document.body.appendChild(element);
                    } else {
                        element = new Image();
                    }

                    element.onload = function () {
                        try {
                            _this.setElement(element, options);
                        } catch (e) {
                            console.log('Texture \'' + _this.name + '\': failed to load url: \'' + _this.source + '\'', e, options);
                        }
                        resolve(_this);
                    };
                    element.onerror = function (e) {
                        // Warn and resolve on error
                        console.log('Texture \'' + _this.name + '\': failed to load url: \'' + _this.source + '\'', e, options);
                        resolve(_this);
                    };

                    // Safari has a bug loading data-URL elements with CORS enabled, so it must be disabled in that case
                    // https://bugs.webkit.org/show_bug.cgi?id=123978
                    if (!(isSafari() && _this.source.slice(0, 5) === 'data:')) {
                        element.crossOrigin = 'anonymous';
                    }

                    element.src = _this.source;
                    if (isVideo) {
                        _this.setElement(element, options);
                    }
                });
                return this.loading;
            }

            // Sets texture to a raw image buffer

        }, {
            key: 'setData',
            value: function setData(width, height, data) {
                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

                this.width = width;
                this.height = height;

                this.source = data;
                this.sourceType = 'data';

                this.update(options);
                this.setFiltering(options);

                this.loading = Promise.resolve(this);
                return this.loading;
            }

            // Sets the texture to track a element (canvas/image)

        }, {
            key: 'setElement',
            value: function setElement(element, options) {
                var _this2 = this;

                var el = element;

                // a string element is interpeted as a CSS selector
                if (typeof element === 'string') {
                    element = document.querySelector(element);
                }

                if (element instanceof HTMLCanvasElement || element instanceof HTMLImageElement || element instanceof HTMLVideoElement) {
                    this.source = element;
                    this.sourceType = 'element';

                    if (element instanceof HTMLVideoElement) {
                        element.addEventListener('canplaythrough', function () {
                            _this2.intervalID = setInterval(function () {
                                _this2.update(options);
                            }, 15);
                        }, true);
                        element.addEventListener('ended', function () {
                            element.currentTime = 0;
                            element.play();
                        }, true);
                    } else {
                        this.update(options);
                    }
                    this.setFiltering(options);
                } else {
                    var msg = 'the \'element\' parameter (`element: ' + JSON.stringify(el) + '`) must be a CSS ';
                    msg += 'selector string, or a <canvas>, <image> or <video> object';
                    console.log('Texture \'' + this.name + '\': ' + msg, options);
                }

                this.loading = Promise.resolve(this);
                return this.loading;
            }

            // Uploads current image or buffer to the GPU (can be used to update animated textures on the fly)

        }, {
            key: 'update',
            value: function update() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (!this.valid) {
                    return;
                }

                this.bind();
                this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, options.UNPACK_FLIP_Y_WEBGL === false ? false : true);
                this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.UNPACK_PREMULTIPLY_ALPHA_WEBGL || false);

                // Image or Canvas element
                if (this.sourceType === 'element' && (this.source instanceof HTMLCanvasElement || this.source instanceof HTMLVideoElement || this.source instanceof HTMLImageElement && this.source.complete)) {
                    if (this.source instanceof HTMLVideoElement) {
                        this.width = this.source.videoWidth;
                        this.height = this.source.videoHeight;
                    } else {
                        this.width = this.source.width;
                        this.height = this.source.height;
                    }
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.source);
                }
                // Raw image buffer
                else if (this.sourceType === 'data') {
                        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.source);
                    }
                this.trigger('loaded', this);
            }

            // Determines appropriate filtering mode

        }, {
            key: 'setFiltering',
            value: function setFiltering() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (!this.valid) {
                    return;
                }

                this.powerOf2 = isPowerOf2(this.width) && isPowerOf2(this.height);
                var defualtFilter = this.powerOf2 ? 'mipmap' : 'linear';
                this.filtering = options.filtering || defualtFilter;

                var gl = this.gl;
                this.bind();

                // For power-of-2 textures, the following presets are available:
                // mipmap: linear blend from nearest mip
                // linear: linear blend from original image (no mips)
                // nearest: nearest pixel from original image (no mips, 'blocky' look)
                if (this.powerOf2) {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);

                    if (this.filtering === 'mipmap') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR); // TODO: use trilinear filtering by defualt instead?
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else if (this.filtering === 'linear') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    } else if (this.filtering === 'nearest') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    }
                } else {
                    // WebGL has strict requirements on non-power-of-2 textures:
                    // No mipmaps and must clamp to edge
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    if (this.filtering === 'mipmap') {
                        this.filtering = 'linear';
                    }

                    if (this.filtering === 'nearest') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    } else {
                        // default to linear for non-power-of-2 textures
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    }
                }
            }
        }]);
        return Texture;
    }();

    // Report max texture size for a GL context


    Texture.getMaxTextureSize = function (gl) {
        return gl.getParameter(gl.MAX_TEXTURE_SIZE);
    };

    // Global set of textures, by name
    Texture.activeUnit = -1;

    /*
    The MIT License (MIT)

    Copyright (c) 2015 Patricio Gonzalez Vivo ( http://www.patriciogonzalezvivo.com )

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the 'Software'), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
    the Software, and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */

    var GlslCanvas = function () {
        function GlslCanvas(canvas, contextOptions, options) {
            var _this = this;

            classCallCheck(this, GlslCanvas);

            subscribeMixin$1(this);

            contextOptions = contextOptions || {};
            options = options || {};

            this.width = canvas.clientWidth;
            this.height = canvas.clientHeight;

            this.canvas = canvas;
            this.gl = undefined;
            this.program = undefined;
            this.textures = {};
            this.buffers = {};
            this.uniforms = {};
            this.vbo = {};
            this.isValid = false;

            this.BUFFER_COUNT = 0;
            // this.TEXTURE_COUNT = 0;

            this.vertexString = contextOptions.vertexString || '\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nattribute vec2 a_position;\nattribute vec2 a_texcoord;\n\nvarying vec2 v_texcoord;\n\nvoid main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    v_texcoord = a_texcoord;\n}\n';
            this.fragmentString = contextOptions.fragmentString || '\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvarying vec2 v_texcoord;\n\nvoid main(){\n    gl_FragColor = vec4(0.0);\n}\n';

            // GL Context
            var gl = setupWebGL(canvas, contextOptions, options.onError);
            if (!gl) {
                return;
            }
            this.gl = gl;
            this.timeLoad = this.timePrev = performance.now();
            this.timeDelta = 0.0;
            this.forceRender = true;
            this.paused = false;
            this.realToCSSPixels = window.devicePixelRatio || 1;

            // Allow alpha
            canvas.style.backgroundColor = contextOptions.backgroundColor || 'rgba(1,1,1,0)';

            // Load shader
            if (canvas.hasAttribute('data-fragment')) {
                this.fragmentString = canvas.getAttribute('data-fragment');
            } else if (canvas.hasAttribute('data-fragment-url')) {
                var source = canvas.getAttribute('data-fragment-url');
                xhr.get(source, function (error, response, body) {
                    _this.load(body, _this.vertexString);
                });
            }

            // Load shader
            if (canvas.hasAttribute('data-vertex')) {
                this.vertexString = canvas.getAttribute('data-vertex');
            } else if (canvas.hasAttribute('data-vertex-url')) {
                var _source = canvas.getAttribute('data-vertex-url');
                xhr.get(_source, function (error, response, body) {
                    _this.load(_this.fragmentString, body);
                });
            }

            this.load();

            if (!this.program) {
                return;
            }

            // Define Vertex buffer
            var texCoordsLoc = gl.getAttribLocation(this.program, 'a_texcoord');
            this.vbo.texCoords = gl.createBuffer();
            this.gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.texCoords);
            this.gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
            this.gl.enableVertexAttribArray(texCoordsLoc);
            this.gl.vertexAttribPointer(texCoordsLoc, 2, gl.FLOAT, false, 0, 0);

            var verticesLoc = gl.getAttribLocation(this.program, 'a_position');
            this.vbo.vertices = gl.createBuffer();
            this.gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.vertices);
            this.gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]), gl.STATIC_DRAW);
            this.gl.enableVertexAttribArray(verticesLoc);
            this.gl.vertexAttribPointer(verticesLoc, 2, gl.FLOAT, false, 0, 0);

            // load TEXTURES
            if (canvas.hasAttribute('data-textures')) {
                var imgList = canvas.getAttribute('data-textures').split(',');
                for (var nImg in imgList) {
                    this.setUniform('u_tex' + nImg, imgList[nImg]);
                }
            }

            // ========================== EVENTS
            var mouse = {
                x: 0,
                y: 0
            };
            document.addEventListener('mousemove', function (e) {
                mouse.x = e.clientX || e.pageX;
                mouse.y = e.clientY || e.pageY;
            }, false);

            var sandbox = this;
            function RenderLoop() {
                if (sandbox.nMouse > 1) {
                    sandbox.setMouse(mouse);
                }

                if (sandbox.resize()) {
                    sandbox.forceRender = true;
                }

                sandbox.render();
                window.requestAnimationFrame(RenderLoop);
            }

            // Start
            this.setMouse({ x: 0, y: 0 });
            RenderLoop();
            return this;
        }

        createClass(GlslCanvas, [{
            key: 'destroy',
            value: function destroy() {
                this.animated = false;
                this.isValid = false;
                for (var tex in this.textures) {
                    if (tex.destroy) {
                        tex.destroy();
                    }
                }
                this.textures = {};
                for (var att in this.attribs) {
                    this.gl.deleteBuffer(this.attribs[att]);
                }
                this.gl.useProgram(null);
                this.gl.deleteProgram(this.program);
                for (var key in this.buffers) {
                    var buffer = this.buffers[key];
                    this.gl.deleteProgram(buffer.program);
                }
                this.program = null;
                this.gl = null;
            }
        }, {
            key: 'load',
            value: function load(fragString, vertString) {

                // Load vertex shader if there is one
                if (vertString) {
                    this.vertexString = vertString;
                }

                // Load fragment shader if there is one
                if (fragString) {
                    this.fragmentString = fragString;
                }

                this.animated = false;
                this.nDelta = (this.fragmentString.match(/u_delta/g) || []).length;
                this.nTime = (this.fragmentString.match(/u_time/g) || []).length;
                this.nDate = (this.fragmentString.match(/u_date/g) || []).length;
                this.nMouse = (this.fragmentString.match(/u_mouse/g) || []).length;
                this.animated = this.nDate > 1 || this.nTime > 1 || this.nMouse > 1;

                var nTextures = this.fragmentString.search(/sampler2D/g);
                if (nTextures) {
                    var lines = this.fragmentString.split('\n');
                    for (var i = 0; i < lines.length; i++) {
                        var match = lines[i].match(/uniform\s*sampler2D\s*([\w]*);\s*\/\/\s*([\w|\:\/\/|\.|\-|\_]*)/i);
                        if (match) {
                            var ext = match[2].split('.').pop().toLowerCase();
                            if (match[1] && match[2] && (ext === 'jpg' || ext === 'jpeg' || ext === 'png' || ext === 'ogv' || ext === 'webm' || ext === 'mp4')) {
                                this.setUniform(match[1], match[2]);
                            }
                        }
                        var main = lines[i].match(/\s*void\s*main\s*/g);
                        if (main) {
                            break;
                        }
                    }
                }

                var vertexShader = createShader(this, this.vertexString, this.gl.VERTEX_SHADER);
                var fragmentShader = createShader(this, this.fragmentString, this.gl.FRAGMENT_SHADER);

                // If Fragment shader fails load a empty one to sign the error
                if (!fragmentShader) {
                    fragmentShader = createShader(this, 'void main(){\n\tgl_FragColor = vec4(1.0);\n}', this.gl.FRAGMENT_SHADER);
                    this.isValid = false;
                } else {
                    this.isValid = true;
                }

                // Create and use program
                var program = createProgram(this, [vertexShader, fragmentShader]); //, [0,1],['a_texcoord','a_position']);
                this.gl.useProgram(program);

                // Delete shaders
                // this.gl.detachShader(program, vertexShader);
                // this.gl.detachShader(program, fragmentShader);
                this.gl.deleteShader(vertexShader);
                this.gl.deleteShader(fragmentShader);

                this.program = program;
                this.change = true;

                this.BUFFER_COUNT = 0;
                var buffers = this.getBuffers(this.fragmentString);
                if (Object.keys(buffers).length) {
                    this.loadPrograms(buffers);
                }
                this.buffers = buffers;
                this.texureIndex = this.BUFFER_COUNT;

                // Trigger event
                this.trigger('load', {});

                this.forceRender = true;
                this.render();
            }
        }, {
            key: 'test',
            value: function test(callback, fragString, vertString) {
                // Thanks to @thespite for the help here
                // https://www.khronos.org/registry/webgl/extensions/EXT_disjoint_timer_query/
                var pre_test_vert = this.vertexString;
                var pre_test_frag = this.fragmentString;
                var pre_test_paused = this.paused;

                var ext = this.gl.getExtension('EXT_disjoint_timer_query');
                var query = ext.createQueryEXT();
                var wasValid = this.isValid;

                if (fragString || vertString) {
                    this.load(fragString, vertString);
                    wasValid = this.isValid;
                    this.forceRender = true;
                    this.render();
                }

                this.paused = true;
                ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
                this.forceRender = true;
                this.render();
                ext.endQueryEXT(ext.TIME_ELAPSED_EXT);

                var sandbox = this;
                function finishTest() {
                    // Revert changes... go back to normal
                    sandbox.paused = pre_test_paused;
                    if (fragString || vertString) {
                        sandbox.load(pre_test_frag, pre_test_vert);
                    }
                }
                function waitForTest() {
                    sandbox.forceRender = true;
                    sandbox.render();
                    var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
                    var disjoint = sandbox.gl.getParameter(ext.GPU_DISJOINT_EXT);
                    if (available && !disjoint) {
                        var ret = {
                            wasValid: wasValid,
                            frag: fragString || sandbox.fragmentString,
                            vert: vertString || sandbox.vertexString,
                            timeElapsedMs: ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT) / 1000000.0
                        };
                        finishTest();
                        callback(ret);
                    } else {
                        window.requestAnimationFrame(waitForTest);
                    }
                }
                waitForTest();
            }
        }, {
            key: 'loadTexture',
            value: function loadTexture(name, urlElementOrData, options) {
                var _this2 = this;

                if (!options) {
                    options = {};
                }

                if (typeof urlElementOrData === 'string') {
                    options.url = urlElementOrData;
                } else if ((typeof urlElementOrData === 'undefined' ? 'undefined' : _typeof(urlElementOrData)) === 'object' && urlElementOrData.data && urlElementOrData.width && urlElementOrData.height) {
                    options.data = urlElementOrData.data;
                    options.width = urlElementOrData.width;
                    options.height = urlElementOrData.height;
                } else if ((typeof urlElementOrData === 'undefined' ? 'undefined' : _typeof(urlElementOrData)) === 'object') {
                    options.element = urlElementOrData;
                }

                if (this.textures[name]) {
                    if (this.textures[name]) {
                        this.textures[name].load(options);
                        this.textures[name].on('loaded', function (args) {
                            _this2.forceRender = true;
                        });
                    }
                } else {
                    this.textures[name] = new Texture(this.gl, name, options);
                    this.textures[name].on('loaded', function (args) {
                        _this2.forceRender = true;
                    });
                }
            }
        }, {
            key: 'refreshUniforms',
            value: function refreshUniforms() {
                this.uniforms = {};
            }
        }, {
            key: 'setUniform',
            value: function setUniform(name) {
                var u = {};

                for (var _len = arguments.length, value = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    value[_key - 1] = arguments[_key];
                }

                u[name] = value;
                this.setUniforms(u);
            }
        }, {
            key: 'setUniforms',
            value: function setUniforms(uniforms) {
                var parsed = parseUniforms(uniforms);
                // Set each uniform
                for (var u in parsed) {
                    if (parsed[u].type === 'sampler2D') {
                        // For textures, we need to track texture units, so we have a special setter
                        // this.uniformTexture(parsed[u].name, parsed[u].value[0]);
                        this.loadTexture(parsed[u].name, parsed[u].value[0]);
                    } else {
                        this.uniform(parsed[u].method, parsed[u].type, parsed[u].name, parsed[u].value);
                    }
                }
                this.forceRender = true;
            }
        }, {
            key: 'setMouse',
            value: function setMouse(mouse) {
                // set the mouse uniform
                var rect = this.canvas.getBoundingClientRect();
                if (mouse && mouse.x && mouse.x >= rect.left && mouse.x <= rect.right && mouse.y && mouse.y >= rect.top && mouse.y <= rect.bottom) {

                    var mouse_x = (mouse.x - rect.left) * this.realToCSSPixels;
                    var mouse_y = this.canvas.height - (mouse.y - rect.top) * this.realToCSSPixels;

                    this.uniform('2f', 'vec2', 'u_mouse', mouse_x, mouse_y);
                }
            }

            // ex: program.uniform('3f', 'position', x, y, z);

        }, {
            key: 'uniform',
            value: function uniform(method, type, name) {
                // 'value' is a method-appropriate arguments list
                this.uniforms[name] = this.uniforms[name] || {};
                var uniform = this.uniforms[name];

                for (var _len2 = arguments.length, value = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
                    value[_key2 - 3] = arguments[_key2];
                }

                var change = isDiff(uniform.value, value);

                // remember and keep track of uniforms location to save calls
                if (change || this.change || !uniform.location || !uniform.value) {
                    uniform.name = name;
                    uniform.type = type;
                    uniform.value = value;
                    uniform.method = 'uniform' + method;
                    this.gl.useProgram(this.program);
                    uniform.location = this.gl.getUniformLocation(this.program, name);
                    this.gl[uniform.method].apply(this.gl, [uniform.location].concat(uniform.value));
                    // If there is change update and there is buffer update manually one by one
                    for (var key in this.buffers) {
                        var buffer = this.buffers[key];
                        this.gl.useProgram(buffer.program);
                        var location = this.gl.getUniformLocation(buffer.program, name);
                        this.gl[uniform.method].apply(this.gl, [location].concat(uniform.value));
                    }
                }
            }
        }, {
            key: 'uniformTexture',
            value: function uniformTexture(name, texture, options) {
                if (this.textures[name] === undefined) {
                    this.loadTexture(name, texture, options);
                } else {
                    this.uniform('1i', 'sampler2D', name, this.texureIndex);

                    for (var key in this.buffers) {
                        var buffer = this.buffers[key];
                        this.gl.useProgram(buffer.program);
                        this.gl.activeTexture(this.gl.TEXTURE0 + this.texureIndex);
                        this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[name].texture);
                    }
                    this.gl.useProgram(this.program);
                    this.gl.activeTexture(this.gl.TEXTURE0 + this.texureIndex);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[name].texture);
                    this.uniform('2f', 'vec2', name + 'Resolution', this.textures[name].width, this.textures[name].height);
                }
            }
        }, {
            key: 'resize',
            value: function resize() {
                if (this.width !== this.canvas.clientWidth || this.height !== this.canvas.clientHeight) {
                    this.realToCSSPixels = window.devicePixelRatio || 1;

                    // Lookup the size the browser is displaying the canvas in CSS pixels
                    // and compute a size needed to make our drawingbuffer match it in
                    // device pixels.
                    var displayWidth = Math.floor(this.gl.canvas.clientWidth * this.realToCSSPixels);
                    var displayHeight = Math.floor(this.gl.canvas.clientHeight * this.realToCSSPixels);

                    // Check if the canvas is not the same size.
                    if (this.gl.canvas.width !== displayWidth || this.gl.canvas.height !== displayHeight) {
                        // Make the canvas the same size
                        this.gl.canvas.width = displayWidth;
                        this.gl.canvas.height = displayHeight;
                        // Set the viewport to match
                        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
                    }
                    this.width = this.canvas.clientWidth;
                    this.height = this.canvas.clientHeight;
                    this.resizeSwappableBuffers();
                    return true;
                } else {
                    return false;
                }
            }
        }, {
            key: 'render',
            value: function render() {
                this.visible = isCanvasVisible(this.canvas);
                if (this.forceRender || this.change || this.animated && this.visible && !this.paused) {

                    // Update Uniforms when are need
                    var date = new Date();
                    var now = performance.now();
                    this.timeDelta = (now - this.timePrev) / 1000.0;
                    this.timePrev = now;
                    if (this.nDelta > 1) {
                        // set the delta time uniform
                        this.uniform('1f', 'float', 'u_delta', this.timeDelta);
                    }

                    if (this.nTime > 1) {
                        // set the elapsed time uniform
                        this.uniform('1f', 'float', 'u_time', (now - this.timeLoad) / 1000.0);
                    }

                    if (this.nDate) {
                        // Set date uniform: year/month/day/time_in_sec
                        this.uniform('4f', 'float', 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);
                    }

                    // set the resolution uniform
                    this.uniform('2f', 'vec2', 'u_resolution', this.canvas.width, this.canvas.height);

                    for (var key in this.buffers) {
                        var buffer = this.buffers[key];
                        this.uniform('1i', 'sampler2D', buffer.name, buffer.bundle.input.index);
                    }

                    this.texureIndex = this.BUFFER_COUNT;
                    for (var tex in this.textures) {
                        this.uniformTexture(tex);
                        this.texureIndex++;
                    }

                    this.renderPrograms();

                    // Trigger event
                    this.trigger('render', {});
                    this.change = false;
                    this.forceRender = false;
                }
            }
        }, {
            key: 'pause',
            value: function pause() {
                this.paused = true;
            }
        }, {
            key: 'play',
            value: function play() {
                this.paused = false;
            }

            // render main and buffers programs

        }, {
            key: 'renderPrograms',
            value: function renderPrograms() {
                var gl = this.gl;
                var W = gl.canvas.width;
                var H = gl.canvas.height;

                gl.viewport(0, 0, W, H);

                for (var key in this.buffers) {
                    var buffer = this.buffers[key];
                    buffer.bundle.render(W, H, buffer.program, buffer.name);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }

                gl.useProgram(this.program);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            // parse input strings

        }, {
            key: 'getBuffers',
            value: function getBuffers(fragString) {
                var buffers = {};
                if (fragString) {
                    fragString.replace(/(?:^\s*)((?:#if|#elif)(?:\s*)(defined\s*\(\s*BUFFER_)(\d+)(?:\s*\))|(?:#ifdef)(?:\s*BUFFER_)(\d+)(?:\s*))/gm, function () {
                        var i = arguments[3] || arguments[4];
                        buffers['u_buffer' + i] = {
                            fragment: '#define BUFFER_' + i + '\n' + fragString
                        };
                    });
                }
                return buffers;
            }

            // load buffers programs

        }, {
            key: 'loadPrograms',
            value: function loadPrograms(buffers) {
                var glsl = this;
                var gl = this.gl;
                var vertex = createShader(glsl, glsl.vertexString, gl.VERTEX_SHADER);
                for (var key in buffers) {
                    var buffer = buffers[key];
                    var fragment = createShader(glsl, buffer.fragment, gl.FRAGMENT_SHADER, 1);
                    if (!fragment) {
                        fragment = createShader(glsl, 'void main(){\n\tgl_FragColor = vec4(1.0);\n}', gl.FRAGMENT_SHADER);
                        glsl.isValid = false;
                    } else {
                        glsl.isValid = true;
                    }
                    var program = createProgram(glsl, [vertex, fragment]);
                    buffer.name = key;
                    buffer.program = program;
                    buffer.bundle = glsl.createSwappableBuffer(glsl.canvas.width, glsl.canvas.height, program);
                    gl.deleteShader(fragment);
                }
                gl.deleteShader(vertex);
            }

            // create an input / output swappable buffer

        }, {
            key: 'createSwappableBuffer',
            value: function createSwappableBuffer(W, H, program) {
                var input = this.createBuffer(W, H, program);
                var output = this.createBuffer(W, H, program);
                var gl = this.gl;
                return {
                    input: input,
                    output: output,
                    swap: function swap() {
                        var temp = input;
                        input = output;
                        output = temp;
                        this.input = input;
                        this.output = output;
                    },
                    render: function render(W, H, program, name) {
                        gl.useProgram(program);
                        gl.viewport(0, 0, W, H);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, this.input.buffer);
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.output.texture, 0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        this.swap();
                    },
                    resize: function resize(W, H, program, name) {
                        gl.useProgram(program);
                        gl.viewport(0, 0, W, H);
                        this.input.resize(W, H);
                        this.output.resize(W, H);
                    }
                };
            }

            // create a buffers

        }, {
            key: 'createBuffer',
            value: function createBuffer(W, H, program) {
                var gl = this.gl;
                var index = this.BUFFER_COUNT;
                this.BUFFER_COUNT += 2;
                gl.getExtension('OES_texture_float');
                var texture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0 + index);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.FLOAT, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                var buffer = gl.createFramebuffer();
                return {
                    index: index,
                    texture: texture,
                    buffer: buffer,
                    W: W,
                    H: H,
                    resize: function resize(W, H) {
                        gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
                        var minW = Math.min(W, this.W);
                        var minH = Math.min(H, this.H);
                        var pixels = new Float32Array(minW * minH * 4);
                        gl.readPixels(0, 0, minW, minH, gl.RGBA, gl.FLOAT, pixels);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                        var newIndex = index + 1;
                        var newTexture = gl.createTexture();
                        gl.activeTexture(gl.TEXTURE0 + newIndex);
                        gl.bindTexture(gl.TEXTURE_2D, newTexture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.FLOAT, null);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, minW, minH, gl.RGBA, gl.FLOAT, pixels);
                        var newBuffer = gl.createFramebuffer();
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                        gl.deleteTexture(texture);
                        gl.activeTexture(gl.TEXTURE0 + index);
                        gl.bindTexture(gl.TEXTURE_2D, newTexture);
                        index = this.index = index;
                        texture = this.texture = newTexture;
                        buffer = this.buffer = newBuffer;
                        this.W = W;
                        this.H = H;
                    }
                };
            }

            // resize buffers on canvas resize
            // consider applying a throttle of 50 ms on canvas resize
            // to avoid requestAnimationFrame and Gl violations

        }, {
            key: 'resizeSwappableBuffers',
            value: function resizeSwappableBuffers() {
                var gl = this.gl;
                var W = gl.canvas.width,
                    H = gl.canvas.height;
                gl.viewport(0, 0, W, H);
                for (var key in this.buffers) {
                    var buffer = this.buffers[key];
                    buffer.bundle.resize(W, H, buffer.program, buffer.name);
                }
                gl.useProgram(this.program);
            }
        }, {
            key: 'version',
            value: function version() {
                return '0.1.7';
            }
        }]);
        return GlslCanvas;
    }();

    function loadAllGlslCanvas() {
        var list = document.getElementsByClassName('glslCanvas');
        if (list.length > 0) {
            window.glslCanvases = [];
            for (var i = 0; i < list.length; i++) {
                var sandbox = new GlslCanvas(list[i]);
                if (sandbox.isValid) {
                    window.glslCanvases.push(sandbox);
                }
            }
        }
    }

    window.addEventListener('load', function () {
        loadAllGlslCanvas();
    });

    var kernel_frag = "precision mediump float;precision lowp int;\n#define GLSLIFY 1\nuniform vec2 u_resolution;uniform float u_sigma;uniform float cut_size;uniform bool u_do_scramble;uniform float u_xmin;uniform float u_xmax;const vec3 blue=vec3(0.0,0.0,1.0);const vec3 white=vec3(1.0,1.0,1.0);const float pi=3.1415926539;float slope=u_xmax-u_xmin;float intercept=u_xmin;float scramble(float x){float d=floor(x/cut_size);float r=x-d*cut_size;if(abs(mod(d,2.0))==1.0){x=x+cut_size-2.0*r;}return x;}float kernel(vec2 st){float fac=1.0/(u_sigma*sqrt(2.0*pi));return fac*exp(-0.5*pow((st.x-st.y)/u_sigma,2.0));}void main(){vec2 st=gl_FragCoord.xy/u_resolution;st=vec2(st.x,1.0-st.y)*slope+intercept;if(u_do_scramble){st=vec2(scramble(st.x),st.y);}float k=kernel(st)/kernel(vec2(0.0,0.0));vec3 color=k*blue+(1.0-k)*white;gl_FragColor=vec4(color,1.0);}"; // eslint-disable-line

    /* src/KernelHeatmap.svelte generated by Svelte v3.40.2 */
    const file$6 = "src/KernelHeatmap.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	return child_ctx;
    }

    // (68:2) {#if mounted}
    function create_if_block$2(ctx) {
    	let each_1_anchor;
    	let each_value = /*plot*/ ctx[0].x;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot, xTou, yTov*/ 193) {
    				each_value = /*plot*/ ctx[0].x;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(68:2) {#if mounted}",
    		ctx
    	});

    	return block;
    }

    // (70:6) {#each plot.mu as mu}
    function create_each_block_1$1(ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", circle_cx_value = /*xTou*/ ctx[6](/*x*/ ctx[19]));
    			attr_dev(circle, "cy", circle_cy_value = /*yTov*/ ctx[7](/*mu*/ ctx[22]));
    			attr_dev(circle, "r", "2");
    			attr_dev(circle, "fill", "rgba(255,0,0,1)");
    			add_location(circle, file$6, 70, 8, 1798);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 1 && circle_cx_value !== (circle_cx_value = /*xTou*/ ctx[6](/*x*/ ctx[19]))) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty & /*plot*/ 1 && circle_cy_value !== (circle_cy_value = /*yTov*/ ctx[7](/*mu*/ ctx[22]))) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(70:6) {#each plot.mu as mu}",
    		ctx
    	});

    	return block;
    }

    // (69:4) {#each plot.x as x}
    function create_each_block$2(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*plot*/ ctx[0].mu;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*xTou, plot, yTov*/ 193) {
    				each_value_1 = /*plot*/ ctx[0].mu;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(69:4) {#each plot.x as x}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div;
    	let div_class_value;
    	let div_resize_listener;
    	let t0;
    	let canvas;
    	let canvas_class_value;
    	let t1;
    	let svg_1;
    	let svg_1_class_value;
    	let if_block = /*mounted*/ ctx[3] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = space();
    			canvas = element("canvas");
    			t1 = space();
    			svg_1 = svg_element("svg");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", div_class_value = "" + (/*gridarea*/ ctx[1] + " invis-framed" + " svelte-1cp5z7m"));
    			add_render_callback(() => /*div_elementresize_handler*/ ctx[10].call(div));
    			add_location(div, file$6, 64, 0, 1538);
    			attr_dev(canvas, "class", canvas_class_value = "" + (/*gridarea*/ ctx[1] + " framed z1" + " svelte-1cp5z7m"));
    			add_location(canvas, file$6, 65, 0, 1607);
    			attr_dev(svg_1, "class", svg_1_class_value = "" + (/*gridarea*/ ctx[1] + " framed z2" + " svelte-1cp5z7m"));
    			add_location(svg_1, file$6, 66, 0, 1670);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[10].bind(div));
    			insert_dev(target, t0, anchor);
    			insert_dev(target, canvas, anchor);
    			/*canvas_binding*/ ctx[11](canvas);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, svg_1, anchor);
    			if (if_block) if_block.m(svg_1, null);
    			/*svg_1_binding*/ ctx[12](svg_1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*gridarea*/ 2 && div_class_value !== (div_class_value = "" + (/*gridarea*/ ctx[1] + " invis-framed" + " svelte-1cp5z7m"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*gridarea*/ 2 && canvas_class_value !== (canvas_class_value = "" + (/*gridarea*/ ctx[1] + " framed z1" + " svelte-1cp5z7m"))) {
    				attr_dev(canvas, "class", canvas_class_value);
    			}

    			if (/*mounted*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					if_block.m(svg_1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*gridarea*/ 2 && svg_1_class_value !== (svg_1_class_value = "" + (/*gridarea*/ ctx[1] + " framed z2" + " svelte-1cp5z7m"))) {
    				attr_dev(svg_1, "class", svg_1_class_value);
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			div_resize_listener();
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(canvas);
    			/*canvas_binding*/ ctx[11](null);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(svg_1);
    			if (if_block) if_block.d();
    			/*svg_1_binding*/ ctx[12](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('KernelHeatmap', slots, []);

    	let { sig } = $$props,
    		{ cn } = $$props,
    		{ plot } = $$props,
    		{ gridarea } = $$props;

    	let xmin, xmax, mounted = false;
    	let sandbox;
    	let svg, can, divh;
    	let s;

    	function xTou(x) {
    		var h = svg.clientHeight;
    		return h * (x - xmin) / (xmax - xmin);
    	}

    	function yTov(y) {
    		return xTou(y);
    	}

    	function resize(dummy) {
    		if (!mounted) return;
    		var h = svg.clientHeight; // excludes border

    		// console.log(`in KernelHeatmap resize with dummy=${dummy}, svg.clientHeight=${h}`);
    		svg.setAttribute('width', h);

    		can.setAttribute('width', h);
    		update();
    	}

    	function update() {
    		var sigma = Math.sqrt(plot.get_sigma2());
    		var do_scramble = plot.scrambled();
    		var cut_size = plot.cut_size();
    		[xmin, xmax] = plot.get_xrange();

    		if (sandbox instanceof GlslCanvas) {
    			sandbox.setUniform("u_sigma", sigma);
    			sandbox.setUniform("cut_size", cut_size);
    			sandbox.setUniform("u_do_scramble", do_scramble ? 1 : 0);
    			sandbox.setUniform("u_xmin", xmin);
    			sandbox.setUniform("u_xmax", xmax);
    		}

    		$$invalidate(0, plot.touch++, plot);
    	}

    	onMount(() => {
    		s = new Sync(sig, cn, update);
    		var gl = can.getContext('webgl') || can.getContext('experimental-webgl');

    		if (gl && gl instanceof WebGLRenderingContext) {
    			sandbox = new GlslCanvas(can);
    			sandbox.load(kernel_frag);
    		}

    		$$invalidate(3, mounted = true);
    		resize();
    	});

    	const writable_props = ['sig', 'cn', 'plot', 'gridarea'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<KernelHeatmap> was created with unknown prop '${key}'`);
    	});

    	function div_elementresize_handler() {
    		divh = this.clientHeight;
    		$$invalidate(2, divh);
    	}

    	function canvas_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			can = $$value;
    			$$invalidate(5, can);
    		});
    	}

    	function svg_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			svg = $$value;
    			$$invalidate(4, svg);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		GlslCanvas,
    		RBFKernel,
    		RBFShuffleKernel,
    		kernel_frag,
    		Sync,
    		d3,
    		sig,
    		cn,
    		plot,
    		gridarea,
    		xmin,
    		xmax,
    		mounted,
    		sandbox,
    		svg,
    		can,
    		divh,
    		s,
    		xTou,
    		yTov,
    		resize,
    		update
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    		if ('xmin' in $$props) xmin = $$props.xmin;
    		if ('xmax' in $$props) xmax = $$props.xmax;
    		if ('mounted' in $$props) $$invalidate(3, mounted = $$props.mounted);
    		if ('sandbox' in $$props) sandbox = $$props.sandbox;
    		if ('svg' in $$props) $$invalidate(4, svg = $$props.svg);
    		if ('can' in $$props) $$invalidate(5, can = $$props.can);
    		if ('divh' in $$props) $$invalidate(2, divh = $$props.divh);
    		if ('s' in $$props) s = $$props.s;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*divh*/ 4) {
    			resize();
    		}
    	};

    	return [
    		plot,
    		gridarea,
    		divh,
    		mounted,
    		svg,
    		can,
    		xTou,
    		yTov,
    		sig,
    		cn,
    		div_elementresize_handler,
    		canvas_binding,
    		svg_1_binding
    	];
    }

    class KernelHeatmap extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$6, create_fragment$6, safe_not_equal, { sig: 8, cn: 9, plot: 0, gridarea: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KernelHeatmap",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[8] === undefined && !('sig' in props)) {
    			console.warn("<KernelHeatmap> was created without expected prop 'sig'");
    		}

    		if (/*cn*/ ctx[9] === undefined && !('cn' in props)) {
    			console.warn("<KernelHeatmap> was created without expected prop 'cn'");
    		}

    		if (/*plot*/ ctx[0] === undefined && !('plot' in props)) {
    			console.warn("<KernelHeatmap> was created without expected prop 'plot'");
    		}

    		if (/*gridarea*/ ctx[1] === undefined && !('gridarea' in props)) {
    			console.warn("<KernelHeatmap> was created without expected prop 'gridarea'");
    		}
    	}

    	get sig() {
    		throw new Error("<KernelHeatmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<KernelHeatmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<KernelHeatmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<KernelHeatmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<KernelHeatmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<KernelHeatmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gridarea() {
    		throw new Error("<KernelHeatmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gridarea(value) {
    		throw new Error("<KernelHeatmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/KernelMatrix.svelte generated by Svelte v3.40.2 */
    const file$5 = "src/KernelMatrix.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i].x;
    	child_ctx[15] = list[i].y;
    	child_ctx[16] = list[i].v;
    	child_ctx[17] = list[i].side;
    	return child_ctx;
    }

    // (69:2) {#if mounted}
    function create_if_block$1(ctx) {
    	let each_1_anchor;
    	let each_value = /*get_mat*/ ctx[5](/*plot*/ ctx[0]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*get_mat, plot, color*/ 33) {
    				each_value = /*get_mat*/ ctx[5](/*plot*/ ctx[0]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(69:2) {#if mounted}",
    		ctx
    	});

    	return block;
    }

    // (70:4) {#each get_mat(plot) as {x, y, v, side}}
    function create_each_block$1(ctx) {
    	let rect;
    	let rect_width_value;
    	let rect_height_value;
    	let rect_x_value;
    	let rect_y_value;

    	const block = {
    		c: function create() {
    			rect = svg_element("rect");
    			attr_dev(rect, "width", rect_width_value = /*side*/ ctx[17]);
    			attr_dev(rect, "height", rect_height_value = /*side*/ ctx[17]);
    			attr_dev(rect, "x", rect_x_value = /*x*/ ctx[14]);
    			attr_dev(rect, "y", rect_y_value = /*y*/ ctx[15]);
    			set_style(rect, "fill", color(/*v*/ ctx[16]));
    			add_location(rect, file$5, 70, 6, 1450);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, rect, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 1 && rect_width_value !== (rect_width_value = /*side*/ ctx[17])) {
    				attr_dev(rect, "width", rect_width_value);
    			}

    			if (dirty & /*plot*/ 1 && rect_height_value !== (rect_height_value = /*side*/ ctx[17])) {
    				attr_dev(rect, "height", rect_height_value);
    			}

    			if (dirty & /*plot*/ 1 && rect_x_value !== (rect_x_value = /*x*/ ctx[14])) {
    				attr_dev(rect, "x", rect_x_value);
    			}

    			if (dirty & /*plot*/ 1 && rect_y_value !== (rect_y_value = /*y*/ ctx[15])) {
    				attr_dev(rect, "y", rect_y_value);
    			}

    			if (dirty & /*plot*/ 1) {
    				set_style(rect, "fill", color(/*v*/ ctx[16]));
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(rect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(70:4) {#each get_mat(plot) as {x, y, v, side}}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div;
    	let div_class_value;
    	let div_resize_listener;
    	let t;
    	let svg_1;
    	let svg_1_class_value;
    	let if_block = /*mounted*/ ctx[4] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			svg_1 = svg_element("svg");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", div_class_value = "invis-framed " + /*gridarea*/ ctx[1] + " svelte-29ayl0");
    			add_render_callback(() => /*div_elementresize_handler*/ ctx[8].call(div));
    			add_location(div, file$5, 66, 0, 1266);
    			attr_dev(svg_1, "class", svg_1_class_value = "framed " + /*gridarea*/ ctx[1] + " svelte-29ayl0");
    			add_location(svg_1, file$5, 67, 0, 1335);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[8].bind(div));
    			insert_dev(target, t, anchor);
    			insert_dev(target, svg_1, anchor);
    			if (if_block) if_block.m(svg_1, null);
    			/*svg_1_binding*/ ctx[9](svg_1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*gridarea*/ 2 && div_class_value !== (div_class_value = "invis-framed " + /*gridarea*/ ctx[1] + " svelte-29ayl0")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (/*mounted*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(svg_1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*gridarea*/ 2 && svg_1_class_value !== (svg_1_class_value = "framed " + /*gridarea*/ ctx[1] + " svelte-29ayl0")) {
    				attr_dev(svg_1, "class", svg_1_class_value);
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			div_resize_listener();
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(svg_1);
    			if (if_block) if_block.d();
    			/*svg_1_binding*/ ctx[9](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function color(s) {
    	var i = 255 * s;
    	return `rgba(${255 - i}, ${255 - i}, 255)`;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('KernelMatrix', slots, []);

    	let { sig } = $$props,
    		{ cn } = $$props,
    		{ plot } = $$props,
    		{ gridarea } = $$props;

    	let s, divh;
    	let sqr_frac = 0.9;
    	let svg;
    	let mounted = false;

    	function get_mat(plot) {
    		var dat = [];
    		if (plot.n == 0) return dat;
    		var h = svg.clientHeight;
    		var fill = plot.n == 1 ? h : sqr_frac * h;
    		var blank = h - fill;
    		var side = fill / plot.n;
    		var gap = plot.n > 1 ? blank / (plot.n - 1) : 0;
    		var stride = side + gap;

    		for (let i = 0; i != plot.n; i++) {
    			for (let j = 0; j != plot.n; j++) {
    				dat.push({
    					x: stride * i,
    					y: stride * j,
    					v: plot.pft[i][j],
    					side
    				});
    			}
    		}

    		return dat;
    	}

    	function resize(dummy) {
    		if (!mounted) return;
    		var h = svg.clientHeight;

    		// console.log(`in KernelMatrix resize with dummy=${dummy}, svg.clientHeight=${h}`);
    		svg.setAttribute('width', h);

    		update();
    	}

    	function update() {
    		// console.log(`in KernelMatrix update with ${plot.n}`);
    		$$invalidate(0, plot.touch++, plot);
    	}

    	onMount(() => {
    		s = new Sync(sig, cn, update);

    		// console.log(plot.n);
    		$$invalidate(4, mounted = true);

    		resize();
    	});

    	const writable_props = ['sig', 'cn', 'plot', 'gridarea'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<KernelMatrix> was created with unknown prop '${key}'`);
    	});

    	function div_elementresize_handler() {
    		divh = this.clientHeight;
    		$$invalidate(2, divh);
    	}

    	function svg_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			svg = $$value;
    			$$invalidate(3, svg);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(6, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(7, cn = $$props.cn);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    	};

    	$$self.$capture_state = () => ({
    		Sync,
    		numberDisplay,
    		onMount,
    		sig,
    		cn,
    		plot,
    		gridarea,
    		s,
    		divh,
    		sqr_frac,
    		svg,
    		mounted,
    		color,
    		get_mat,
    		resize,
    		update
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(6, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(7, cn = $$props.cn);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    		if ('s' in $$props) s = $$props.s;
    		if ('divh' in $$props) $$invalidate(2, divh = $$props.divh);
    		if ('sqr_frac' in $$props) sqr_frac = $$props.sqr_frac;
    		if ('svg' in $$props) $$invalidate(3, svg = $$props.svg);
    		if ('mounted' in $$props) $$invalidate(4, mounted = $$props.mounted);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*divh*/ 4) {
    			resize();
    		}
    	};

    	return [
    		plot,
    		gridarea,
    		divh,
    		svg,
    		mounted,
    		get_mat,
    		sig,
    		cn,
    		div_elementresize_handler,
    		svg_1_binding
    	];
    }

    class KernelMatrix extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, { sig: 6, cn: 7, plot: 0, gridarea: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KernelMatrix",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[6] === undefined && !('sig' in props)) {
    			console.warn("<KernelMatrix> was created without expected prop 'sig'");
    		}

    		if (/*cn*/ ctx[7] === undefined && !('cn' in props)) {
    			console.warn("<KernelMatrix> was created without expected prop 'cn'");
    		}

    		if (/*plot*/ ctx[0] === undefined && !('plot' in props)) {
    			console.warn("<KernelMatrix> was created without expected prop 'plot'");
    		}

    		if (/*gridarea*/ ctx[1] === undefined && !('gridarea' in props)) {
    			console.warn("<KernelMatrix> was created without expected prop 'gridarea'");
    		}
    	}

    	get sig() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gridarea() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gridarea(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Figure1.svelte generated by Svelte v3.40.2 */
    const file$4 = "src/Figure1.svelte";

    function create_fragment$4(ctx) {
    	let figure;
    	let div8;
    	let div0;
    	let curves;
    	let t0;
    	let slidercontrols;
    	let t1;
    	let lowpanelcontrols;
    	let t2;
    	let div7;
    	let div1;
    	let raw0_value = `$\\mu$` + "";
    	let t3;
    	let kernelheatmap;
    	let t4;
    	let div2;
    	let raw1_value = `$\\mu_i$` + "";
    	let t5;
    	let kernelmatrix;
    	let t6;
    	let div3;
    	let raw2_value = `$x$` + "";
    	let t7;
    	let div4;
    	let raw3_value = `$x_i$` + "";
    	let t8;
    	let div5;
    	let raw4_value = `$\\mathcal{N}(x; \\mu, \\sigma)$` + "";
    	let t9;
    	let div6;
    	let raw5_value = `$\\mathcal{N}(x_i; \\mu_i, \\sigma)$` + "";
    	let t10;
    	let figcaption;
    	let t11;
    	let html_tag;
    	let raw6_value = `$(x_i, y_i)$` + "";
    	let t12;
    	let html_tag_1;
    	let raw7_value = `$\\mu_i$` + "";
    	let t13;
    	let b0;
    	let t15;
    	let html_tag_2;
    	let raw8_value = `$\\mu_i$` + "";
    	let t16;
    	let html_tag_3;
    	let raw9_value = `$\\V{\\alpha}$` + "";
    	let t17;
    	let b1;
    	let t19;
    	let html_tag_4;
    	let raw10_value = `$\\sigma$` + "";
    	let t20;
    	let html_tag_5;
    	let raw11_value = `$\\mu$` + "";
    	let t21;
    	let b2;
    	let t23;
    	let html_tag_6;
    	let raw12_value = `$\\mu_i$` + "";
    	let t24;
    	let html_tag_7;
    	let raw13_value = `$x_i$` + "";
    	let t25;
    	let a;
    	let t27;
    	let current;

    	curves = new Curves({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cn: "1",
    				cfg: /*cfg*/ ctx[1],
    				plot: /*plot*/ ctx[2],
    				gridarea: "curves"
    			},
    			$$inline: true
    		});

    	slidercontrols = new SliderControls({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cn: "3",
    				cfg: /*cfg*/ ctx[1],
    				plot: /*plot*/ ctx[2]
    			},
    			$$inline: true
    		});

    	lowpanelcontrols = new LowPanelControls({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cn: "2",
    				cfg: /*cfg*/ ctx[1],
    				plot: /*plot*/ ctx[2]
    			},
    			$$inline: true
    		});

    	kernelheatmap = new KernelHeatmap({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cn: "4",
    				plot: /*plot*/ ctx[2],
    				gridarea: "cell2"
    			},
    			$$inline: true
    		});

    	kernelmatrix = new KernelMatrix({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cn: "5",
    				plot: /*plot*/ ctx[2],
    				gridarea: "cell6"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			figure = element("figure");
    			div8 = element("div");
    			div0 = element("div");
    			create_component(curves.$$.fragment);
    			t0 = space();
    			create_component(slidercontrols.$$.fragment);
    			t1 = space();
    			create_component(lowpanelcontrols.$$.fragment);
    			t2 = space();
    			div7 = element("div");
    			div1 = element("div");
    			t3 = space();
    			create_component(kernelheatmap.$$.fragment);
    			t4 = space();
    			div2 = element("div");
    			t5 = space();
    			create_component(kernelmatrix.$$.fragment);
    			t6 = space();
    			div3 = element("div");
    			t7 = space();
    			div4 = element("div");
    			t8 = space();
    			div5 = element("div");
    			t9 = space();
    			div6 = element("div");
    			t10 = space();
    			figcaption = element("figcaption");
    			t11 = text$1("Interctive plot.  You can drag the black ");
    			html_tag = new HtmlTag();
    			t12 = text$1(" data points and triangles\n  (");
    			html_tag_1 = new HtmlTag();
    			t13 = text$1(" values).  ");
    			b0 = element("b");
    			b0.textContent = "Top";
    			t15 = text$1(": gray curves are Gaussians centered at the\n  ");
    			html_tag_2 = new HtmlTag();
    			t16 = text$1(".  Blue curve is the ");
    			html_tag_3 = new HtmlTag();
    			t17 = text$1(" linear combination of the gray curves.\n  ");
    			b1 = element("b");
    			b1.textContent = "Bottom left";
    			t19 = text$1(": A heatmap showing the family of Gaussians with the same\n  ");
    			html_tag_4 = new HtmlTag();
    			t20 = text$1(" at every ");
    			html_tag_5 = new HtmlTag();
    			t21 = text$1(" value.  Red dots show the locations of evaluation\n  points.  ");
    			b2 = element("b");
    			b2.textContent = "Bottom right";
    			t23 = text$1(":  The matrix of values of evaluation points\n  organized by ");
    			html_tag_6 = new HtmlTag();
    			t24 = text$1(" and ");
    			html_tag_7 = new HtmlTag();
    			t25 = text$1(".  Other details provided in text.  \n    ");
    			a = element("a");
    			a.textContent = "Full Page Figure";
    			t27 = text$1(".");
    			attr_dev(div0, "class", "fi-upper gbox-upper svelte-frau4j");
    			add_location(div0, file$4, 34, 2, 845);
    			attr_dev(div1, "class", "y1 svelte-frau4j");
    			add_location(div1, file$4, 41, 4, 1160);
    			attr_dev(div2, "class", "y2 svelte-frau4j");
    			add_location(div2, file$4, 43, 2, 1281);
    			attr_dev(div3, "class", "x1 svelte-frau4j");
    			add_location(div3, file$4, 45, 4, 1404);
    			attr_dev(div4, "class", "x2 svelte-frau4j");
    			add_location(div4, file$4, 46, 4, 1444);
    			attr_dev(div5, "class", "cap1 svelte-frau4j");
    			add_location(div5, file$4, 47, 4, 1486);
    			attr_dev(div6, "class", "cap2 svelte-frau4j");
    			add_location(div6, file$4, 48, 4, 1557);
    			attr_dev(div7, "class", "fi-lower gbox-lower svelte-frau4j");
    			add_location(div7, file$4, 40, 1, 1122);
    			attr_dev(div8, "class", "" + (/*topclass*/ ctx[0] + " fb-vert" + " svelte-frau4j"));
    			add_location(div8, file$4, 33, 0, 810);
    			html_tag.a = t12;
    			html_tag_1.a = t13;
    			add_location(b0, file$4, 53, 32, 1781);
    			html_tag_2.a = t16;
    			html_tag_3.a = t17;
    			add_location(b1, file$4, 55, 2, 1942);
    			html_tag_4.a = t20;
    			html_tag_5.a = t21;
    			add_location(b2, file$4, 57, 11, 2127);
    			html_tag_6.a = t24;
    			html_tag_7.a = t25;
    			attr_dev(a, "href", "full.html");
    			add_location(a, file$4, 59, 4, 2285);
    			add_location(figcaption, file$4, 51, 0, 1644);
    			add_location(figure, file$4, 32, 0, 801);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, figure, anchor);
    			append_dev(figure, div8);
    			append_dev(div8, div0);
    			mount_component(curves, div0, null);
    			append_dev(div0, t0);
    			mount_component(slidercontrols, div0, null);
    			append_dev(div0, t1);
    			mount_component(lowpanelcontrols, div0, null);
    			append_dev(div8, t2);
    			append_dev(div8, div7);
    			append_dev(div7, div1);
    			div1.innerHTML = raw0_value;
    			append_dev(div7, t3);
    			mount_component(kernelheatmap, div7, null);
    			append_dev(div7, t4);
    			append_dev(div7, div2);
    			div2.innerHTML = raw1_value;
    			append_dev(div7, t5);
    			mount_component(kernelmatrix, div7, null);
    			append_dev(div7, t6);
    			append_dev(div7, div3);
    			div3.innerHTML = raw2_value;
    			append_dev(div7, t7);
    			append_dev(div7, div4);
    			div4.innerHTML = raw3_value;
    			append_dev(div7, t8);
    			append_dev(div7, div5);
    			div5.innerHTML = raw4_value;
    			append_dev(div7, t9);
    			append_dev(div7, div6);
    			div6.innerHTML = raw5_value;
    			append_dev(figure, t10);
    			append_dev(figure, figcaption);
    			append_dev(figcaption, t11);
    			html_tag.m(raw6_value, figcaption);
    			append_dev(figcaption, t12);
    			html_tag_1.m(raw7_value, figcaption);
    			append_dev(figcaption, t13);
    			append_dev(figcaption, b0);
    			append_dev(figcaption, t15);
    			html_tag_2.m(raw8_value, figcaption);
    			append_dev(figcaption, t16);
    			html_tag_3.m(raw9_value, figcaption);
    			append_dev(figcaption, t17);
    			append_dev(figcaption, b1);
    			append_dev(figcaption, t19);
    			html_tag_4.m(raw10_value, figcaption);
    			append_dev(figcaption, t20);
    			html_tag_5.m(raw11_value, figcaption);
    			append_dev(figcaption, t21);
    			append_dev(figcaption, b2);
    			append_dev(figcaption, t23);
    			html_tag_6.m(raw12_value, figcaption);
    			append_dev(figcaption, t24);
    			html_tag_7.m(raw13_value, figcaption);
    			append_dev(figcaption, t25);
    			append_dev(figcaption, a);
    			append_dev(figcaption, t27);
    			current = true;
    		},
    		p: noop$5,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(curves.$$.fragment, local);
    			transition_in(slidercontrols.$$.fragment, local);
    			transition_in(lowpanelcontrols.$$.fragment, local);
    			transition_in(kernelheatmap.$$.fragment, local);
    			transition_in(kernelmatrix.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(curves.$$.fragment, local);
    			transition_out(slidercontrols.$$.fragment, local);
    			transition_out(lowpanelcontrols.$$.fragment, local);
    			transition_out(kernelheatmap.$$.fragment, local);
    			transition_out(kernelmatrix.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(figure);
    			destroy_component(curves);
    			destroy_component(slidercontrols);
    			destroy_component(lowpanelcontrols);
    			destroy_component(kernelheatmap);
    			destroy_component(kernelmatrix);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Figure1', slots, []);
    	let { fullscreen = false } = $$props;
    	let topclass = fullscreen ? 'screen100' : 'screen80';

    	let cfg = {
    		cmd: null,
    		points: false,
    		curves: true,
    		solution: true,
    		auto_solve: false,
    		mu_tracks_x: true,
    		scramble: false,
    		log_sigma: 0,
    		show_data: true
    	};

    	let ctx = new Context(0, 0, [-4, 4], [-4, 4]);
    	let plot = new Plot(ctx, 3);
    	let sig = writable(0);
    	let h;
    	const writable_props = ['fullscreen'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Figure1> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('fullscreen' in $$props) $$invalidate(4, fullscreen = $$props.fullscreen);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		Plot,
    		Context,
    		Curves,
    		LowPanelControls,
    		SliderControls,
    		KernelHeatmap,
    		KernelMatrix,
    		fullscreen,
    		topclass,
    		cfg,
    		ctx,
    		plot,
    		sig,
    		h
    	});

    	$$self.$inject_state = $$props => {
    		if ('fullscreen' in $$props) $$invalidate(4, fullscreen = $$props.fullscreen);
    		if ('topclass' in $$props) $$invalidate(0, topclass = $$props.topclass);
    		if ('cfg' in $$props) $$invalidate(1, cfg = $$props.cfg);
    		if ('ctx' in $$props) ctx = $$props.ctx;
    		if ('plot' in $$props) $$invalidate(2, plot = $$props.plot);
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    		if ('h' in $$props) h = $$props.h;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [topclass, cfg, plot, sig, fullscreen];
    }

    class Figure1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, { fullscreen: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Figure1",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get fullscreen() {
    		throw new Error("<Figure1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullscreen(value) {
    		throw new Error("<Figure1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const XMIN = -4;
    const XMAX = 4;

    function dotp(p, q) {
      return p[0] * q[0] + p[1] * q[1];
    }

    function norm2(p) {
      return dotp(p, p);
    }

    function scale(p, factor) {
      return [p[0] * factor, p[1] * factor];
    }

    // calculate the vector projection of arg to onto
    function proj(onto, arg) {
      return scale(onto, dotp(onto, arg) / norm2(onto));
    }


    class PhiSpace$1 {
      constructor(max_alpha) {
        this.basis = new Matrix([[1,0], [0,0]]);
        this.xTou = linear().domain([-max_alpha, max_alpha]);
        this.yTov = linear().domain([-max_alpha, max_alpha]);

        var ctx = new Context(10, 10, [XMIN, XMAX], [XMIN, XMAX]);
        this.plot = new Plot(ctx, 2);
        this.updateBasis();
        this.plot.init_metrics();
        this.plot.initCurveCache();
      }

      toUV(xy) {
        return [this.xTou(xy[0]), this.yTov(xy[1])];
      }

      toXY(val) {
        return [this.xTou.invert(val[0]), this.yTov.invert(val[1])];
      }

      resize(w, h) {
        this.xTou.range([0, w]);
        this.yTov.range([h, 0]);
        this.plot.resize(w, h);
      }

      // update the second basis vector, assuming the kernel with k(v, v) = 1 for
      // all v
      updateBasis() {
        var kv = this.plot.ppt[0][1];
        var ang = Math.acos(kv);
        this.basis[1][0] = Math.cos(ang);
        this.basis[1][1] = Math.sin(ang);
      }

      // update the current function f
      updateF(u, v) {
        var f = this.toXY([u, v]);
        var F = new Matrix([f]);
        this.plot.alpha = F.mmul(inverse(this.basis)).flat();
      }

      F() {
        var [x, y] = this.alpha().mmul(this.basis).flat();
        var [u, v] = [this.xTou(x), this.yTov(y)];
        var deg = Math.atan2(y, x) * (-180.0 / Math.PI);
        return {u, v, deg};
      }

      updateY(u, v) {
        var F = new Matrix([this.toXY([u, v])]);
        var alpha  = F.mmul(inverse(this.basis));
        var y = alpha.mmul(this.plot.pft);
        // console.log(y);
        this.plot.y = y.flat();
      }
      
      _fHat() {
        var alpha_hat = new Matrix([this.plot.solutionAlpha()]);
        var f_hat = alpha_hat.mmul(this.basis).flat();
        return f_hat;
      }

      // c'th component of the solution vector
      fHat() {
        var f_hat = this._fHat();
        return this.toUV(f_hat);
      }

      fHatProj(b) {
        var fhp = proj(this.basis[b], this._fHat());
        return this.toUV(fhp);
      }

      alpha() {
        return new Matrix([this.plot.alpha]);
      }

      scr(i) {
        return this.toUV(this.basis[i]);
      }

    }

    var phi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PhiSpace: PhiSpace$1
    });

    /* src/PhiSpace.svelte generated by Svelte v3.40.2 */
    const file$3 = "src/PhiSpace.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i].p1;
    	child_ctx[18] = list[i].p2;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i][0];
    	child_ctx[22] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i][0];
    	child_ctx[26] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i][0];
    	child_ctx[22] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i][0];
    	child_ctx[26] = list[i][1];
    	return child_ctx;
    }

    // (83:4) {#each [pp.scr(0),pp.scr(1)] as [x2,y2]}
    function create_each_block_4(ctx) {
    	let line;
    	let line_x__value;
    	let line_y__value;
    	let line_x__value_1;
    	let line_y__value_1;

    	const block = {
    		c: function create() {
    			line = svg_element("line");
    			attr_dev(line, "class", "basis svelte-li3dzh");
    			attr_dev(line, "x1", line_x__value = /*x1*/ ctx[21]);
    			attr_dev(line, "y1", line_y__value = /*y1*/ ctx[22]);
    			attr_dev(line, "x2", line_x__value_1 = /*x2*/ ctx[25]);
    			attr_dev(line, "y2", line_y__value_1 = /*y2*/ ctx[26]);
    			attr_dev(line, "marker-end", "url(#basis-arrow)");
    			add_location(line, file$3, 83, 6, 1747);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, line, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp*/ 1 && line_x__value !== (line_x__value = /*x1*/ ctx[21])) {
    				attr_dev(line, "x1", line_x__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value !== (line_y__value = /*y1*/ ctx[22])) {
    				attr_dev(line, "y1", line_y__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_x__value_1 !== (line_x__value_1 = /*x2*/ ctx[25])) {
    				attr_dev(line, "x2", line_x__value_1);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value_1 !== (line_y__value_1 = /*y2*/ ctx[26])) {
    				attr_dev(line, "y2", line_y__value_1);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(line);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(83:4) {#each [pp.scr(0),pp.scr(1)] as [x2,y2]}",
    		ctx
    	});

    	return block;
    }

    // (82:2) {#each [pp.toUV([0,0])] as [x1, y1]}
    function create_each_block_3(ctx) {
    	let each_1_anchor;
    	let each_value_4 = [/*pp*/ ctx[0].scr(0), /*pp*/ ctx[0].scr(1)];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < 2; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp*/ 1) {
    				each_value_4 = [/*pp*/ ctx[0].scr(0), /*pp*/ ctx[0].scr(1)];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < 2; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < 2; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(82:2) {#each [pp.toUV([0,0])] as [x1, y1]}",
    		ctx
    	});

    	return block;
    }

    // (89:2) {#if 1}
    function create_if_block(ctx) {
    	let each_1_anchor;
    	let each_value_1 = [/*pp*/ ctx[0].fHat()];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < 1; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp, onMouseDown*/ 17) {
    				each_value_1 = [/*pp*/ ctx[0].fHat()];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < 1; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < 1; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(89:2) {#if 1}",
    		ctx
    	});

    	return block;
    }

    // (91:6) {#each [pp.fHatProj(0), pp.fHatProj(1)] as [x2, y2]}
    function create_each_block_2(ctx) {
    	let line;
    	let line_x__value;
    	let line_y__value;
    	let line_x__value_1;
    	let line_y__value_1;
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			line = svg_element("line");
    			circle = svg_element("circle");
    			attr_dev(line, "class", "perp svelte-li3dzh");
    			attr_dev(line, "x1", line_x__value = /*x1*/ ctx[21]);
    			attr_dev(line, "y1", line_y__value = /*y1*/ ctx[22]);
    			attr_dev(line, "x2", line_x__value_1 = /*x2*/ ctx[25]);
    			attr_dev(line, "y2", line_y__value_1 = /*y2*/ ctx[26]);
    			attr_dev(line, "stroke-dasharray", "4 4");
    			add_location(line, file$3, 91, 8, 1989);
    			attr_dev(circle, "id", "fhat");
    			attr_dev(circle, "class", "perp-target draggable svelte-li3dzh");
    			attr_dev(circle, "r", "6");
    			attr_dev(circle, "cx", circle_cx_value = /*x1*/ ctx[21]);
    			attr_dev(circle, "cy", circle_cy_value = /*y1*/ ctx[22]);
    			add_location(circle, file$3, 94, 8, 2103);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, line, anchor);
    			insert_dev(target, circle, anchor);

    			if (!mounted) {
    				dispose = listen_dev(circle, "mousedown", /*onMouseDown*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp*/ 1 && line_x__value !== (line_x__value = /*x1*/ ctx[21])) {
    				attr_dev(line, "x1", line_x__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value !== (line_y__value = /*y1*/ ctx[22])) {
    				attr_dev(line, "y1", line_y__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_x__value_1 !== (line_x__value_1 = /*x2*/ ctx[25])) {
    				attr_dev(line, "x2", line_x__value_1);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value_1 !== (line_y__value_1 = /*y2*/ ctx[26])) {
    				attr_dev(line, "y2", line_y__value_1);
    			}

    			if (dirty[0] & /*pp*/ 1 && circle_cx_value !== (circle_cx_value = /*x1*/ ctx[21])) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty[0] & /*pp*/ 1 && circle_cy_value !== (circle_cy_value = /*y1*/ ctx[22])) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(line);
    			if (detaching) detach_dev(circle);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(91:6) {#each [pp.fHatProj(0), pp.fHatProj(1)] as [x2, y2]}",
    		ctx
    	});

    	return block;
    }

    // (90:4) {#each [pp.fHat()] as [x1, y1]}
    function create_each_block_1(ctx) {
    	let each_1_anchor;
    	let each_value_2 = [/*pp*/ ctx[0].fHatProj(0), /*pp*/ ctx[0].fHatProj(1)];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < 2; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp, onMouseDown*/ 17) {
    				each_value_2 = [/*pp*/ ctx[0].fHatProj(0), /*pp*/ ctx[0].fHatProj(1)];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < 2; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < 2; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(90:4) {#each [pp.fHat()] as [x1, y1]}",
    		ctx
    	});

    	return block;
    }

    // (102:2) {#each [{ p1: pp.toUV([0,0]), p2: pp.F()} ] as {p1, p2}}
    function create_each_block(ctx) {
    	let line;
    	let line_x__value;
    	let line_y__value;
    	let line_x__value_1;
    	let line_y__value_1;
    	let use;
    	let use_x_value;
    	let use_y_value;
    	let use_transform_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			line = svg_element("line");
    			use = svg_element("use");
    			attr_dev(line, "class", "solution-curve svelte-li3dzh");
    			attr_dev(line, "x1", line_x__value = /*p1*/ ctx[17][0]);
    			attr_dev(line, "y1", line_y__value = /*p1*/ ctx[17][1]);
    			attr_dev(line, "x2", line_x__value_1 = /*p2*/ ctx[18].u);
    			attr_dev(line, "y2", line_y__value_1 = /*p2*/ ctx[18].v);
    			add_location(line, file$3, 102, 4, 2330);
    			attr_dev(use, "class", "solution-arrow draggable svelte-li3dzh");
    			xlink_attr(use, "xlink:href", "#pointer");
    			attr_dev(use, "id", "f");
    			attr_dev(use, "x", use_x_value = /*p2*/ ctx[18].u);
    			attr_dev(use, "y", use_y_value = /*p2*/ ctx[18].v);
    			attr_dev(use, "transform", use_transform_value = "rotate(" + /*p2*/ ctx[18].deg + ", " + /*p2*/ ctx[18].u + ", " + /*p2*/ ctx[18].v + ")");
    			add_location(use, file$3, 105, 4, 2433);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, line, anchor);
    			insert_dev(target, use, anchor);

    			if (!mounted) {
    				dispose = listen_dev(use, "mousedown", /*onMouseDown*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp*/ 1 && line_x__value !== (line_x__value = /*p1*/ ctx[17][0])) {
    				attr_dev(line, "x1", line_x__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value !== (line_y__value = /*p1*/ ctx[17][1])) {
    				attr_dev(line, "y1", line_y__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_x__value_1 !== (line_x__value_1 = /*p2*/ ctx[18].u)) {
    				attr_dev(line, "x2", line_x__value_1);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value_1 !== (line_y__value_1 = /*p2*/ ctx[18].v)) {
    				attr_dev(line, "y2", line_y__value_1);
    			}

    			if (dirty[0] & /*pp*/ 1 && use_x_value !== (use_x_value = /*p2*/ ctx[18].u)) {
    				attr_dev(use, "x", use_x_value);
    			}

    			if (dirty[0] & /*pp*/ 1 && use_y_value !== (use_y_value = /*p2*/ ctx[18].v)) {
    				attr_dev(use, "y", use_y_value);
    			}

    			if (dirty[0] & /*pp*/ 1 && use_transform_value !== (use_transform_value = "rotate(" + /*p2*/ ctx[18].deg + ", " + /*p2*/ ctx[18].u + ", " + /*p2*/ ctx[18].v + ")")) {
    				attr_dev(use, "transform", use_transform_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(line);
    			if (detaching) detach_dev(use);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(102:2) {#each [{ p1: pp.toUV([0,0]), p2: pp.F()} ] as {p1, p2}}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let div;
    	let div_class_value;
    	let div_resize_listener;
    	let t;
    	let svg_1;
    	let defs;
    	let marker;
    	let path;
    	let polygon;
    	let each0_anchor;
    	let if_block_anchor;
    	let svg_1_class_value;
    	let mounted;
    	let dispose;
    	let each_value_3 = [/*pp*/ ctx[0].toUV([0, 0])];
    	validate_each_argument(each_value_3);
    	let each_blocks_1 = [];

    	for (let i = 0; i < 1; i += 1) {
    		each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	let if_block = create_if_block(ctx);

    	let each_value = [
    		{
    			p1: /*pp*/ ctx[0].toUV([0, 0]),
    			p2: /*pp*/ ctx[0].F()
    		}
    	];

    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < 1; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			svg_1 = svg_element("svg");
    			defs = svg_element("defs");
    			marker = svg_element("marker");
    			path = svg_element("path");
    			polygon = svg_element("polygon");

    			for (let i = 0; i < 1; i += 1) {
    				each_blocks_1[i].c();
    			}

    			each0_anchor = empty$3();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();

    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", div_class_value = "" + (/*gridarea*/ ctx[1] + " framed z3" + " svelte-li3dzh"));
    			add_render_callback(() => /*div_elementresize_handler*/ ctx[10].call(div));
    			add_location(div, file$3, 63, 0, 1138);
    			attr_dev(path, "d", "M 0 0 L 10 5 L 0 10 z");
    			add_location(path, file$3, 75, 6, 1527);
    			attr_dev(marker, "id", "basis-arrow");
    			attr_dev(marker, "class", "basis-arrow svelte-li3dzh");
    			attr_dev(marker, "viewBox", "0 0 10 10");
    			attr_dev(marker, "refX", "10");
    			attr_dev(marker, "refY", "5");
    			attr_dev(marker, "markerWidth", "6");
    			attr_dev(marker, "markerHeight", "6");
    			attr_dev(marker, "orient", "auto-start-reverse");
    			add_location(marker, file$3, 69, 4, 1326);
    			attr_dev(polygon, "id", "pointer");
    			attr_dev(polygon, "points", "-10,-5 0,0 -10,5");
    			add_location(polygon, file$3, 78, 4, 1587);
    			add_location(defs, file$3, 67, 2, 1314);
    			attr_dev(svg_1, "class", svg_1_class_value = "" + (/*gridarea*/ ctx[1] + " framed" + " svelte-li3dzh"));
    			add_location(svg_1, file$3, 64, 0, 1204);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[10].bind(div));
    			insert_dev(target, t, anchor);
    			insert_dev(target, svg_1, anchor);
    			append_dev(svg_1, defs);
    			append_dev(defs, marker);
    			append_dev(marker, path);
    			append_dev(defs, polygon);

    			for (let i = 0; i < 1; i += 1) {
    				each_blocks_1[i].m(svg_1, null);
    			}

    			append_dev(svg_1, each0_anchor);
    			if (if_block) if_block.m(svg_1, null);
    			append_dev(svg_1, if_block_anchor);

    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].m(svg_1, null);
    			}

    			/*svg_1_binding*/ ctx[11](svg_1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg_1, "mousemove", /*onMouseMove*/ ctx[5], false, false, false),
    					listen_dev(svg_1, "mouseup", /*onMouseUp*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*gridarea*/ 2 && div_class_value !== (div_class_value = "" + (/*gridarea*/ ctx[1] + " framed z3" + " svelte-li3dzh"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty[0] & /*pp*/ 1) {
    				each_value_3 = [/*pp*/ ctx[0].toUV([0, 0])];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < 1; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_3(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(svg_1, each0_anchor);
    					}
    				}

    				for (; i < 1; i += 1) {
    					each_blocks_1[i].d(1);
    				}
    			}

    			if_block.p(ctx, dirty);

    			if (dirty[0] & /*pp, onMouseDown*/ 17) {
    				each_value = [
    					{
    						p1: /*pp*/ ctx[0].toUV([0, 0]),
    						p2: /*pp*/ ctx[0].F()
    					}
    				];

    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < 1; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(svg_1, null);
    					}
    				}

    				for (; i < 1; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}

    			if (dirty[0] & /*gridarea*/ 2 && svg_1_class_value !== (svg_1_class_value = "" + (/*gridarea*/ ctx[1] + " framed" + " svelte-li3dzh"))) {
    				attr_dev(svg_1, "class", svg_1_class_value);
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			div_resize_listener();
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(svg_1);
    			destroy_each(each_blocks_1, detaching);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    			/*svg_1_binding*/ ctx[11](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PhiSpace', slots, []);

    	let { sig } = $$props,
    		{ cn } = $$props,
    		{ cfg } = $$props,
    		{ pp } = $$props,
    		{ gridarea } = $$props;

    	let s, divh, svg, mounted = false;
    	let drag_point = null;

    	// called in response to a notify() call from any component
    	// that shares sig with this component
    	function update() {
    		if (!mounted) return;
    		pp.updateBasis();
    		$$invalidate(0, pp.plot.touch++, pp);
    		$$invalidate(0, pp.touch++, pp);
    	}

    	onMount(() => {
    		s = new Sync(sig, cn, update);
    		mounted = true;
    		resize();
    		update();
    	});

    	function onMouseDown(evt) {
    		drag_point = evt.target;
    	}

    	function onMouseMove(evt) {
    		if (drag_point == null) return;

    		if (drag_point.id == 'fhat') {
    			pp.updateY(evt.offsetX, evt.offsetY);
    			$$invalidate(7, cfg.cmd = 'mu_xy_changed', cfg);
    		} else {
    			pp.updateF(evt.offsetX, evt.offsetY);
    			$$invalidate(7, cfg.cmd = 'update_alpha', cfg);
    		}

    		update();
    		s.notify();
    	}

    	function onMouseUp(evt) {
    		drag_point = null;
    	}

    	function resize(dummy) {
    		if (!mounted) return;
    		var h = svg.clientHeight;
    		svg.setAttribute('width', h);
    		pp.resize(h, h);
    		$$invalidate(0, pp.plot.touch++, pp);
    		$$invalidate(0, pp.touch++, pp);
    	}

    	const writable_props = ['sig', 'cn', 'cfg', 'pp', 'gridarea'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PhiSpace> was created with unknown prop '${key}'`);
    	});

    	function div_elementresize_handler() {
    		divh = this.clientHeight;
    		$$invalidate(2, divh);
    	}

    	function svg_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			svg = $$value;
    			$$invalidate(3, svg);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(7, cfg = $$props.cfg);
    		if ('pp' in $$props) $$invalidate(0, pp = $$props.pp);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    	};

    	$$self.$capture_state = () => ({
    		Sync,
    		numberDisplay,
    		d3,
    		onMount,
    		sig,
    		cn,
    		cfg,
    		pp,
    		gridarea,
    		s,
    		divh,
    		svg,
    		mounted,
    		drag_point,
    		update,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp,
    		resize
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(7, cfg = $$props.cfg);
    		if ('pp' in $$props) $$invalidate(0, pp = $$props.pp);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    		if ('s' in $$props) s = $$props.s;
    		if ('divh' in $$props) $$invalidate(2, divh = $$props.divh);
    		if ('svg' in $$props) $$invalidate(3, svg = $$props.svg);
    		if ('mounted' in $$props) mounted = $$props.mounted;
    		if ('drag_point' in $$props) drag_point = $$props.drag_point;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*divh*/ 4) {
    			resize();
    		}
    	};

    	return [
    		pp,
    		gridarea,
    		divh,
    		svg,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp,
    		cfg,
    		sig,
    		cn,
    		div_elementresize_handler,
    		svg_1_binding
    	];
    }

    class PhiSpace extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$3,
    			create_fragment$3,
    			safe_not_equal,
    			{
    				sig: 8,
    				cn: 9,
    				cfg: 7,
    				pp: 0,
    				gridarea: 1
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PhiSpace",
    			options,
    			id: create_fragment$3.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[8] === undefined && !('sig' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'sig'");
    		}

    		if (/*cn*/ ctx[9] === undefined && !('cn' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'cn'");
    		}

    		if (/*cfg*/ ctx[7] === undefined && !('cfg' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'cfg'");
    		}

    		if (/*pp*/ ctx[0] === undefined && !('pp' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'pp'");
    		}

    		if (/*gridarea*/ ctx[1] === undefined && !('gridarea' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'gridarea'");
    		}
    	}

    	get sig() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cfg() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cfg(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pp() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pp(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gridarea() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gridarea(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Figure2.svelte generated by Svelte v3.40.2 */
    const file$2 = "src/Figure2.svelte";

    function create_fragment$2(ctx) {
    	let figure;
    	let div1;
    	let curves;
    	let t0;
    	let phispace;
    	let t1;
    	let lowpanelcontrols;
    	let t2;
    	let div0;
    	let t3;
    	let html_tag;
    	let raw0_value = `$\\vec\\phi_\\sigma(\\mu_1)$` + "";
    	let t4;
    	let html_tag_1;
    	let raw1_value = `$\\vec\\phi_\\sigma(\\mu_2)$` + "";
    	let t5;
    	let figcaption;
    	let b0;
    	let t7;
    	let b1;
    	let t9;
    	let html_tag_2;
    	let raw2_value = `$\\vec\\phi(\\mu_1)$` + "";
    	let t10;
    	let html_tag_3;
    	let raw3_value = `$\\vec\\phi(\\mu_2)$` + "";
    	let t11;
    	let html_tag_4;

    	let raw4_value = `$\\alpha_1 \\vec\\phi(\\mu_1) + \\alpha_2
    \\vec\\phi(\\mu_2)$` + "";

    	let t12;
    	let current;

    	curves = new Curves({
    			props: {
    				sig: /*sig*/ ctx[2],
    				cfg: /*cfg*/ ctx[0],
    				cn: "1",
    				plot: /*pp*/ ctx[1].plot,
    				gridarea: "curves"
    			},
    			$$inline: true
    		});

    	phispace = new PhiSpace({
    			props: {
    				sig: /*sig*/ ctx[2],
    				cn: "2",
    				cfg: /*cfg*/ ctx[0],
    				pp: /*pp*/ ctx[1],
    				gridarea: "phi"
    			},
    			$$inline: true
    		});

    	lowpanelcontrols = new LowPanelControls({
    			props: {
    				sig: /*sig*/ ctx[2],
    				cfg: /*cfg*/ ctx[0],
    				cn: "3",
    				plot: /*pp*/ ctx[1].plot
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			figure = element("figure");
    			div1 = element("div");
    			create_component(curves.$$.fragment);
    			t0 = space();
    			create_component(phispace.$$.fragment);
    			t1 = space();
    			create_component(lowpanelcontrols.$$.fragment);
    			t2 = space();
    			div0 = element("div");
    			t3 = text$1("Plane spanned by ");
    			html_tag = new HtmlTag();
    			t4 = text$1(" and ");
    			html_tag_1 = new HtmlTag();
    			t5 = space();
    			figcaption = element("figcaption");
    			b0 = element("b");
    			b0.textContent = "Left";
    			t7 = text$1(": The curves plot as before with only two curves.\n    ");
    			b1 = element("b");
    			b1.textContent = "Right";
    			t9 = text$1(": The plane in feature space spanned by vectors ");
    			html_tag_2 = new HtmlTag();
    			t10 = text$1("\n    and ");
    			html_tag_3 = new HtmlTag();
    			t11 = text$1(" The blue arrow is ");
    			html_tag_4 = new HtmlTag();
    			t12 = text$1(".");
    			html_tag.a = t4;
    			html_tag_1.a = null;
    			add_location(div0, file$2, 35, 6, 924);
    			attr_dev(div1, "class", "gb screen svelte-h34vza");
    			add_location(div1, file$2, 31, 2, 651);
    			add_location(b0, file$2, 37, 15, 1058);
    			add_location(b1, file$2, 38, 4, 1123);
    			html_tag_2.a = t10;
    			html_tag_3.a = t11;
    			html_tag_4.a = t12;
    			add_location(figcaption, file$2, 37, 2, 1045);
    			add_location(figure, file$2, 30, 0, 640);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, figure, anchor);
    			append_dev(figure, div1);
    			mount_component(curves, div1, null);
    			append_dev(div1, t0);
    			mount_component(phispace, div1, null);
    			append_dev(div1, t1);
    			mount_component(lowpanelcontrols, div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			append_dev(div0, t3);
    			html_tag.m(raw0_value, div0);
    			append_dev(div0, t4);
    			html_tag_1.m(raw1_value, div0);
    			append_dev(figure, t5);
    			append_dev(figure, figcaption);
    			append_dev(figcaption, b0);
    			append_dev(figcaption, t7);
    			append_dev(figcaption, b1);
    			append_dev(figcaption, t9);
    			html_tag_2.m(raw2_value, figcaption);
    			append_dev(figcaption, t10);
    			html_tag_3.m(raw3_value, figcaption);
    			append_dev(figcaption, t11);
    			html_tag_4.m(raw4_value, figcaption);
    			append_dev(figcaption, t12);
    			current = true;
    		},
    		p: noop$5,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(curves.$$.fragment, local);
    			transition_in(phispace.$$.fragment, local);
    			transition_in(lowpanelcontrols.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(curves.$$.fragment, local);
    			transition_out(phispace.$$.fragment, local);
    			transition_out(lowpanelcontrols.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(figure);
    			destroy_component(curves);
    			destroy_component(phispace);
    			destroy_component(lowpanelcontrols);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Figure2', slots, []);
    	let box = { w: 10, h: 10 };

    	let cfg = {
    		cmd: null,
    		points: false,
    		curves: true,
    		solution: true,
    		auto_solve: false,
    		mu_tracks_x: true,
    		scramble: false,
    		log_sigma: 0,
    		show_data: true
    	};

    	var max_alpha = 4;
    	let pp = new PhiSpace$1(max_alpha);
    	let sig = writable(0);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Figure2> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		writable,
    		Plot,
    		Context,
    		phi,
    		Curves,
    		PhiSpace,
    		LowPanelControls,
    		numberDisplay,
    		box,
    		cfg,
    		max_alpha,
    		pp,
    		sig
    	});

    	$$self.$inject_state = $$props => {
    		if ('box' in $$props) box = $$props.box;
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('max_alpha' in $$props) max_alpha = $$props.max_alpha;
    		if ('pp' in $$props) $$invalidate(1, pp = $$props.pp);
    		if ('sig' in $$props) $$invalidate(2, sig = $$props.sig);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [cfg, pp, sig];
    }

    class Figure2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Figure2",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/kernel_methods.md generated by Svelte v3.40.2 */
    const file$1 = "src/kernel_methods.md";

    function create_fragment$1(ctx) {
    	let p0;

    	let raw0_value = `$
\\newcommand\\B[1]{\\boldsymbol{#1}}
\\newcommand\\norm[1]{\\|#1\\|}
\\newcommand\\ang[1]{\\theta_{#1}}
\\newcommand\\dist{\\mathrm{dist}}
\\newcommand\\half{{\\small {1 \\over 2}}}
\\newcommand\\FeatSpace{\\mathcal{\\Phi}}
\\newcommand\\GSpace{\\mathcal{G}_\\sigma}
\\newcommand\\proj[2]{#1_{\\small \\parallel #2}}
\\newcommand\\rej[2]{#1_{\\small \\perp #2}}
\\newcommand\\V[1]{\\vec{#1}}
\\newcommand\\len[1]{\\mathrm{len}(#1)}
\\newcommand\\disp[1]{\\mathrm{disp}(#1)}
$` + "";

    	let t0;
    	let h10;
    	let t2;
    	let p1;
    	let t4;
    	let p2;
    	let t6;
    	let p3;
    	let t8;
    	let p4;
    	let t10;
    	let p5;
    	let t12;
    	let p6;
    	let t14;
    	let h11;
    	let t16;
    	let p7;
    	let t17;
    	let html_tag;
    	let raw1_value = `$(x_i, y_i)$` + "";
    	let t18;
    	let html_tag_1;
    	let raw2_value = `$x_i$` + "";
    	let t19;
    	let html_tag_2;
    	let raw3_value = `$(\\alpha_1, \\cdots, \\alpha_n)$` + "";
    	let t20;
    	let html_tag_3;
    	let raw4_value = `$\\alpha_i$` + "";
    	let t21;
    	let t22;
    	let p8;
    	let t23;
    	let html_tag_4;
    	let raw5_value = `$y_i$` + "";
    	let t24;
    	let html_tag_5;
    	let raw6_value = `$\\alpha$` + "";
    	let t25;
    	let html_tag_6;
    	let raw7_value = `$(x_i, y_i)$` + "";
    	let t26;
    	let t27;
    	let p9;
    	let t28;
    	let html_tag_7;
    	let raw8_value = `$x_i$` + "";
    	let t29;
    	let em0;
    	let t31;
    	let html_tag_8;
    	let raw9_value = `$k_j(x)$` + "";
    	let t32;
    	let html_tag_9;
    	let raw10_value = `$(k_j(x_1), k_j(x_2), \\cdots, k_j(x_n))$` + "";
    	let t33;
    	let html_tag_10;
    	let raw11_value = `$(x_1, x_2, \\cdots, x_n)$` + "";
    	let t34;
    	let t35;
    	let figure1;
    	let t36;
    	let p10;
    	let t37;
    	let html_tag_11;
    	let raw12_value = `$x_i$` + "";
    	let t38;
    	let html_tag_12;
    	let raw13_value = `$(x_i, y_i)$` + "";
    	let t39;
    	let t40;
    	let p11;
    	let t42;
    	let p12;
    	let t43;
    	let html_tag_13;
    	let raw14_value = `$\\sigma$` + "";
    	let t44;
    	let html_tag_14;
    	let raw15_value = `$n$` + "";
    	let t45;
    	let html_tag_15;
    	let raw16_value = `$\\mathbb{R}^n$` + "";
    	let t46;
    	let html_tag_16;
    	let raw17_value = `$(y_i)$` + "";
    	let t47;
    	let t48;
    	let p13;
    	let t50;
    	let html_tag_17;

    	let raw18_value = `$$
\\begin{aligned}
k_j(x) & & \\text{Gaussians centered at $x_j$, $j = 1 .. n$} \\\\
f(x) & \\equiv \\sum_j { \\alpha_j k_j(x) } & \\text{the blue curve}\\\\
f(x_i) & = \\sum_j { \\alpha_j k_j(x_i) } = y_i & \\text{fitting the blue curve to the black points} \\\\
\\B{\\alpha K} & = \\B{y} , & \\text{$\\B{K}$: rows are vectors of evaluation} \\\\
\\end{aligned}
$$` + "";

    	let p14;
    	let t51;
    	let html_tag_18;
    	let raw19_value = `$\\B{\\alpha}$` + "";
    	let t52;
    	let html_tag_19;
    	let raw20_value = `$\\B{K}$` + "";
    	let t53;
    	let html_tag_20;
    	let raw21_value = `$\\B{K}$` + "";
    	let t54;
    	let html_tag_21;
    	let raw22_value = `$\\sigma$` + "";
    	let t55;
    	let html_tag_22;
    	let raw23_value = `$(f_j(x_1), \\cdots, f_j(x_n))$` + "";
    	let t56;
    	let html_tag_23;
    	let raw24_value = `$\\B{\\alpha}$` + "";
    	let t57;
    	let t58;
    	let p15;
    	let t59;
    	let html_tag_24;
    	let raw25_value = `$x_i$` + "";
    	let t60;
    	let t61;
    	let h20;
    	let t63;
    	let p16;
    	let strong0;
    	let t64;
    	let html_tag_25;
    	let raw26_value = `$\\mathbb{R} \\times \\mathbb{R}$` + "";
    	let t65;
    	let t66;
    	let em1;
    	let t68;
    	let html_tag_26;
    	let raw27_value = `$x_i$` + "";
    	let t69;
    	let html_tag_27;
    	let raw28_value = `$k_j(\\cdot)$` + "";
    	let t70;
    	let html_tag_28;
    	let raw29_value = `$(k_j(x_i))$` + "";
    	let t71;
    	let html_tag_29;
    	let raw30_value = `$(x_i, y_i)$` + "";
    	let t72;
    	let t73;
    	let p17;
    	let strong1;
    	let t74;
    	let html_tag_30;
    	let raw31_value = `$x_i$` + "";
    	let t75;
    	let em2;
    	let t77;
    	let html_tag_31;
    	let raw32_value = `$n$` + "";
    	let t78;
    	let html_tag_32;
    	let raw33_value = `$\\mathbb{R}^n$` + "";
    	let t79;
    	let html_tag_33;
    	let raw34_value = `$n$` + "";
    	let t80;
    	let em3;
    	let t82;
    	let html_tag_34;
    	let raw35_value = `$x_i$` + "";
    	let t83;
    	let t84;
    	let p18;
    	let strong2;
    	let t86;
    	let html_tag_35;
    	let raw36_value = `$\\mathbb{R}$` + "";
    	let t87;
    	let t88;
    	let p19;
    	let strong3;
    	let t90;
    	let html_tag_36;
    	let raw37_value = `$\\mathcal{X}$` + "";
    	let t91;
    	let t92;
    	let p20;
    	let t93;
    	let html_tag_37;
    	let raw38_value = `$\\B{\\alpha}$` + "";
    	let t94;
    	let t95;
    	let h21;
    	let t97;
    	let p21;
    	let t99;
    	let h30;
    	let t101;
    	let p22;
    	let em4;
    	let strong4;
    	let t102;
    	let html_tag_38;
    	let raw39_value = `$\\mathcal{X}$` + "";
    	let t103;
    	let html_tag_39;
    	let raw40_value = `$f_i: \\mathcal{X} \\mapsto \\mathcal{Y}$` + "";
    	let t104;
    	let html_tag_40;
    	let raw41_value = `$f_i$` + "";
    	let t105;
    	let html_tag_41;
    	let raw42_value = `$x_i \\in \\mathcal{X}$` + "";
    	let t106;
    	let html_tag_42;
    	let raw43_value = `$x_i$` + "";
    	let t107;
    	let html_tag_43;
    	let raw44_value = `$\\mathcal{X}$` + "";
    	let t108;
    	let t109;
    	let h31;
    	let t111;
    	let p23;
    	let em5;
    	let strong5;
    	let t113;
    	let html_tag_44;
    	let raw45_value = `$n$` + "";
    	let t114;
    	let html_tag_45;
    	let raw46_value = `$n$` + "";
    	let t115;
    	let html_tag_46;
    	let raw47_value = `$n$` + "";
    	let t116;
    	let html_tag_47;
    	let raw48_value = `$\\mathcal{X}$` + "";
    	let t117;
    	let html_tag_48;
    	let raw49_value = `$n$` + "";
    	let t118;
    	let em6;
    	let t120;
    	let html_tag_49;
    	let raw50_value = `$(f_i(x_1), f_i(x_2), \\cdots, f_i(x_n))$` + "";
    	let t121;
    	let t122;
    	let h32;
    	let t124;
    	let p24;
    	let em7;
    	let strong6;
    	let t126;
    	let html_tag_50;
    	let raw51_value = `$f_i(x) \\equiv \\V{\\phi_f}_i \\cdot \\B{\\phi}(x)$` + "";
    	let t127;
    	let html_tag_51;
    	let raw52_value = `$\\V{\\phi_f}_i$` + "";
    	let t128;
    	let t129;
    	let p25;
    	let t130;
    	let html_tag_52;
    	let raw53_value = `$\\sigma$` + "";
    	let t131;
    	let html_tag_53;
    	let raw54_value = `$\\mu \\in \\mathcal{X}$` + "";
    	let t132;
    	let t133;
    	let h22;
    	let t135;
    	let p26;
    	let t136;
    	let html_tag_54;
    	let raw55_value = `$\\mu$` + "";
    	let t137;
    	let html_tag_55;
    	let raw56_value = `$\\vec{\\phi}(\\mu)$` + "";
    	let t138;
    	let html_tag_56;
    	let raw57_value = `$x$` + "";
    	let t139;
    	let html_tag_57;
    	let raw58_value = `$\\vec{\\phi}(x)$` + "";
    	let t140;
    	let html_tag_58;
    	let raw59_value = `$\\sigma$` + "";
    	let t141;
    	let html_tag_59;
    	let raw60_value = `$\\vec{\\phi}(\\cdot)$` + "";
    	let t142;
    	let html_tag_60;
    	let raw61_value = `$\\sigma$` + "";
    	let t143;
    	let html_tag_61;
    	let raw62_value = `$\\mu$` + "";
    	let t144;
    	let html_tag_62;
    	let raw63_value = `$\\vec{\\phi_\\sigma}(\\cdot)$` + "";
    	let t145;
    	let t146;
    	let p27;
    	let t147;
    	let html_tag_63;
    	let raw64_value = `$e^{axy}$` + "";
    	let t148;
    	let html_tag_64;
    	let raw65_value = `$e^{-\\half a(x-y)^2}$` + "";
    	let t149;
    	let html_tag_65;
    	let raw66_value = `$a$` + "";
    	let t150;
    	let t151;
    	let html_tag_66;

    	let raw67_value = `$$
\\begin{aligned}
e^{axy} & = \\sum_{i=0} { \\dfrac{a^i(xy)^i}{i!} } & \\text{Taylor expansion} \\\\
& = \\sum_{i=0} { \\dfrac{(a^\\half x)^i}{(i!)^\\half} \\dfrac{(a^\\half y)^i}{(i!)^\\half} } & \\text{Separate $x$ and $y$ terms to symmetric roles} \\\\
& = \\sum_{i=0} { \\psi_{a,i}(x) \\psi_{a,i}(y) } & \\text{Let $\\psi_{a,i}(p) \\equiv \\dfrac{(a^\\half p)^i}{(i!)^\\half}$ }\\\\
& = \\vec{\\psi_a}(x) \\cdot \\vec{\\psi_a}(y) & \\text{Let $\\vec{\\psi_a}(p) \\equiv (\\psi_{a,1}(p), \\psi_{a,2}(p), \\cdots)$ } \\\\
\\end{aligned}
$$` + "";

    	let p28;
    	let t152;
    	let html_tag_67;
    	let raw68_value = `$e^{axy}$` + "";
    	let t153;
    	let html_tag_68;
    	let raw69_value = `$y = \\mu$` + "";
    	let t154;
    	let t155;
    	let html_tag_69;

    	let raw70_value = `$$
\\begin{aligned}
e^{-\\half a(x-\\mu)^2} & = e^{-\\half a(x^2-2x\\mu+\\mu^2)} \\\\[1em]
& = e^{-\\half a x^2} e^{ax\\mu} e^{-\\half a \\mu^2} \\\\[1em]
& = e^{-\\half a x^2} ( \\vec{\\psi_a}(x) \\cdot \\vec{\\psi_a}(\\mu) ) e^{-\\half a \\mu^2} & \\text{substitute formula above} \\\\[1em]
& = (e^{-\\half a x^2} \\vec{\\psi_a}(x) \\cdot e^{-\\half a \\mu^2} \\vec{\\psi_a}(\\mu)) & \\text{By bilinearity of dot product} \\\\[1em]
& = \\vec{\\phi_{\\sigma}}(x) \\cdot \\vec{\\phi_{\\sigma}}(\\mu) & \\text{Let $\\vec{\\phi_{\\sigma}}(p) \\equiv e^{-\\half a p^2} \\vec{\\psi_a}(p)$ with $a = {\\small 1 \\over \\sigma^2}$} \\\\
\\end{aligned}
$$` + "";

    	let p29;
    	let t156;
    	let html_tag_70;
    	let raw71_value = `$e^{-\\tfrac{1}{2} {(\\tfrac{x - \\mu}{\\sigma})}^2 }$` + "";
    	let t157;
    	let html_tag_71;
    	let raw72_value = `$\\dfrac{1}{\\sigma^\\half (2 \\pi)^{\\small 1 \\over 4}}$` + "";
    	let t158;
    	let p30;
    	let t159;
    	let html_tag_72;
    	let raw73_value = `$\\mathcal{N}(x; \\mu, \\sigma)$` + "";
    	let t160;
    	let html_tag_73;
    	let raw74_value = `$k(x, \\mu)$` + "";
    	let t161;
    	let html_tag_74;
    	let raw75_value = `$\\sigma$` + "";
    	let t162;
    	let html_tag_75;
    	let raw76_value = `$x$` + "";
    	let t163;
    	let html_tag_76;
    	let raw77_value = `$\\mu$` + "";
    	let t164;
    	let html_tag_77;
    	let raw78_value = `$\\mathcal{N}(x;\\sigma,\\mu) = \\mathcal{N}(\\mu;\\sigma, x)$` + "";
    	let t165;
    	let em8;
    	let t167;
    	let html_tag_78;
    	let raw79_value = `$\\mu \\in \\mathcal{X}$` + "";
    	let t168;
    	let em9;
    	let t170;
    	let em10;
    	let t172;
    	let t173;
    	let p31;
    	let t174;
    	let html_tag_79;
    	let raw80_value = `$x = \\mu$` + "";
    	let t175;
    	let html_tag_80;
    	let raw81_value = `$\\vec{\\phi_\\sigma}(\\mu) \\cdot \\vec{\\phi_\\sigma}(\\mu) \\equiv \\norm{\\vec{\\phi_\\sigma}(x)}^2$` + "";
    	let t176;
    	let html_tag_81;
    	let raw82_value = `$x$` + "";
    	let t177;
    	let html_tag_82;
    	let raw83_value = `$\\cos \\theta_{\\vec{\\phi}(x), \\vec{\\phi}(\\mu)}$` + "";
    	let t178;
    	let t179;
    	let p32;
    	let t180;
    	let html_tag_83;
    	let raw84_value = `$x$` + "";
    	let t181;
    	let html_tag_84;
    	let raw85_value = `$\\mu$` + "";
    	let t182;
    	let html_tag_85;
    	let raw86_value = `$90^\\circ$` + "";
    	let t183;
    	let html_tag_86;
    	let raw87_value = `$[0^\\circ, 90^\\circ)$` + "";
    	let t184;
    	let html_tag_87;
    	let raw88_value = `$x_1, x_2, x_3$` + "";
    	let t185;
    	let html_tag_88;
    	let raw89_value = `$\\vec{\\phi}(x_1), \\vec{\\phi}(x_2), \\vec{\\phi}(x_3)$` + "";
    	let t186;
    	let html_tag_89;
    	let raw90_value = `$\\infty$` + "";
    	let t187;
    	let html_tag_90;
    	let raw91_value = `$\\mathbb{R}^3$` + "";
    	let t188;
    	let t189;
    	let h23;
    	let t191;
    	let p33;
    	let t192;
    	let html_tag_91;
    	let raw92_value = `$\\mathcal{X} \\times \\mathcal{Y}$` + "";
    	let t193;
    	let t194;
    	let p34;
    	let t196;
    	let p35;
    	let t197;
    	let html_tag_92;
    	let raw93_value = `$\\sigma$` + "";
    	let t198;
    	let html_tag_93;
    	let raw94_value = `$\\GSpace$` + "";
    	let t199;
    	let html_tag_94;
    	let raw95_value = `$\\FeatSpace$` + "";
    	let t200;
    	let t201;
    	let ol0;
    	let li0;
    	let p36;
    	let strong7;
    	let t203;
    	let html_tag_95;
    	let raw96_value = `$x \\in \\mathcal{X}$` + "";
    	let t204;
    	let html_tag_96;
    	let raw97_value = `$\\vec{\\phi_\\sigma}(x) \\in \\FeatSpace$` + "";
    	let t205;
    	let t206;
    	let li1;
    	let p37;
    	let strong8;
    	let t208;
    	let html_tag_97;
    	let raw98_value = `$f_{\\mu_i}(\\cdot) \\in \\GSpace$` + "";
    	let t209;
    	let html_tag_98;
    	let raw99_value = `$\\vec{\\phi_\\sigma}(\\mu_i) \\in \\FeatSpace$` + "";
    	let t210;
    	let t211;
    	let li2;
    	let p38;
    	let strong9;
    	let t213;
    	let html_tag_99;
    	let raw100_value = `$f_{\\mu_i}(x)$` + "";
    	let t214;
    	let html_tag_100;
    	let raw101_value = `$\\vec{\\phi_\\sigma}(\\mu_i) \\cdot \\vec{\\phi_\\sigma}(x)$` + "";
    	let t215;
    	let html_tag_101;
    	let raw102_value = `$\\vec{\\phi}(\\mu_i)$` + "";
    	let t216;
    	let html_tag_102;
    	let raw103_value = `$\\vec{\\phi}(x)$` + "";
    	let t217;
    	let html_tag_103;
    	let raw104_value = `$\\theta = 0$` + "";
    	let t218;
    	let html_tag_104;
    	let raw105_value = `$\\theta \\rightarrow 90^\\circ$` + "";
    	let t219;
    	let html_tag_105;
    	let raw106_value = `$+ \\infty$` + "";
    	let t220;
    	let html_tag_106;
    	let raw107_value = `$- \\infty$` + "";
    	let t221;
    	let t222;
    	let p39;
    	let t224;
    	let ol1;
    	let li3;
    	let p40;
    	let strong10;
    	let t226;
    	let html_tag_107;
    	let raw108_value = `$\\mu$` + "";
    	let t227;
    	let t228;
    	let li4;
    	let p41;
    	let strong11;
    	let t229;
    	let html_tag_108;
    	let raw109_value = `$\\mu$` + "";
    	let t230;
    	let t231;
    	let html_tag_109;
    	let raw110_value = `$\\vec{\\alpha}$` + "";
    	let t232;
    	let html_tag_110;
    	let raw111_value = `$f_{\\mu_i}(\\cdot) \\in \\GSpace$` + "";
    	let t233;
    	let em11;
    	let t235;
    	let html_tag_111;
    	let raw112_value = `$\\vec{\\alpha}$` + "";
    	let t236;
    	let html_tag_112;
    	let raw113_value = `$\\vec{\\phi_\\sigma}(\\mu_i)$` + "";
    	let t237;
    	let html_tag_113;
    	let raw114_value = `$\\mu$` + "";
    	let t238;
    	let t239;
    	let li5;
    	let p42;
    	let strong12;
    	let t241;
    	let html_tag_114;
    	let raw115_value = `$x$` + "";
    	let t242;
    	let t243;
    	let li6;
    	let p43;
    	let strong13;
    	let t245;
    	let html_tag_115;
    	let raw116_value = `$f$` + "";
    	let t246;
    	let html_tag_116;
    	let raw117_value = `$\\mu$` + "";
    	let t247;
    	let html_tag_117;
    	let raw118_value = `$\\vec{\\phi_\\sigma}(x_i)$` + "";
    	let t248;
    	let html_tag_118;
    	let raw119_value = `$x$` + "";
    	let t249;
    	let html_tag_119;
    	let raw120_value = `$f_\\parallel$` + "";
    	let t250;
    	let html_tag_120;
    	let raw121_value = `$x$` + "";
    	let t251;
    	let html_tag_121;
    	let raw122_value = `$y_i$` + "";
    	let t252;
    	let t253;
    	let p44;
    	let t254;
    	let html_tag_122;
    	let raw123_value = `$\\mu$` + "";
    	let t255;
    	let html_tag_123;
    	let raw124_value = `$x$` + "";
    	let t256;
    	let t257;
    	let h24;
    	let t259;
    	let p45;
    	let t260;
    	let html_tag_124;
    	let raw125_value = `$\\mu_i$` + "";
    	let t261;
    	let html_tag_125;
    	let raw126_value = `$\\sigma$` + "";
    	let t262;
    	let html_tag_126;
    	let raw127_value = `$\\alpha_i$` + "";
    	let t263;
    	let t264;
    	let p46;
    	let t265;
    	let html_tag_127;
    	let raw128_value = `$\\mu_i$` + "";
    	let t266;
    	let html_tag_128;
    	let raw129_value = `$(x_i, y_i)$` + "";
    	let t267;
    	let html_tag_129;
    	let raw130_value = `$\\mu$` + "";
    	let t268;
    	let html_tag_130;
    	let raw131_value = `$x$` + "";
    	let t269;
    	let t270;
    	let p47;
    	let t271;
    	let html_tag_131;
    	let raw132_value = `$\\alpha_i$` + "";
    	let t272;
    	let html_tag_132;
    	let raw133_value = `$\\mu_i$` + "";
    	let t273;
    	let html_tag_133;
    	let raw134_value = `$\\alpha_i$` + "";
    	let t274;
    	let html_tag_134;
    	let raw135_value = `$(x_i, y_i)$` + "";
    	let t275;
    	let t276;
    	let p48;
    	let t277;
    	let html_tag_135;
    	let raw136_value = `$\\sigma$` + "";
    	let t278;
    	let html_tag_136;
    	let raw137_value = `$\\mu$` + "";
    	let t279;
    	let html_tag_137;
    	let raw138_value = `$\\mu$` + "";
    	let t280;
    	let html_tag_138;
    	let raw139_value = `$\\alpha_i$` + "";
    	let t281;
    	let html_tag_139;
    	let raw140_value = `$\\mathcal{X}$` + "";
    	let t282;
    	let p49;
    	let t283;
    	let html_tag_140;
    	let raw141_value = `$\\mu_i$` + "";
    	let t284;
    	let html_tag_141;
    	let raw142_value = `$x_i$` + "";
    	let t285;
    	let em12;
    	let t287;
    	let html_tag_142;
    	let raw143_value = `$\\mu_i$` + "";
    	let t288;
    	let html_tag_143;
    	let raw144_value = `$\\alpha_i$` + "";
    	let t289;
    	let html_tag_144;
    	let raw145_value = `$x_i$` + "";
    	let t290;
    	let html_tag_145;
    	let raw146_value = `$\\mathrm{K}$` + "";
    	let t291;
    	let html_tag_146;
    	let raw147_value = `$\\alpha \\mathrm{K}$` + "";
    	let t292;
    	let t293;
    	let p50;
    	let t294;
    	let html_tag_147;
    	let raw148_value = `$\\mu_i = x_i$` + "";
    	let t295;
    	let html_tag_148;
    	let raw149_value = `$\\mu$` + "";
    	let t296;
    	let html_tag_149;
    	let raw150_value = `$x$` + "";
    	let t297;
    	let html_tag_150;
    	let raw151_value = `$x_i = \\mu_i$` + "";
    	let t298;
    	let html_tag_151;
    	let raw152_value = `$\\mathcal{N}(x; \\mu, \\sigma) = \\mathcal{N}(\\mu; x, \\sigma)$` + "";
    	let t299;
    	let html_tag_152;
    	let raw153_value = `$\\mu_i \\ne x_i$` + "";
    	let t300;
    	let t301;
    	let h33;
    	let t303;
    	let p51;
    	let t304;
    	let html_tag_153;
    	let raw154_value = `$\\sigma$` + "";
    	let t305;
    	let html_tag_154;
    	let raw155_value = `$\\sigma$` + "";
    	let t306;
    	let html_tag_155;
    	let raw156_value = `$\\vec{\\phi_\\sigma}(x)$` + "";
    	let t307;
    	let html_tag_156;
    	let raw157_value = `$\\vec{\\phi_x}$` + "";
    	let t308;
    	let html_tag_157;
    	let raw158_value = `$f = \\sum_i { \\alpha_i f_{\\mu_i} }$` + "";
    	let t309;
    	let html_tag_158;
    	let raw159_value = `$\\sum_i { \\alpha_i \\V{\\phi_{\\mu_i}}}$` + "";
    	let t310;
    	let html_tag_159;
    	let raw160_value = `$\\vec{\\phi_f}$` + "";
    	let t311;
    	let t312;
    	let p52;
    	let strong14;
    	let t314;
    	let html_tag_160;
    	let raw161_value = `$\\mu$` + "";
    	let t315;
    	let html_tag_161;
    	let raw162_value = `$x$` + "";
    	let t316;
    	let html_tag_162;
    	let raw163_value = `$\\mu_i$` + "";
    	let t317;
    	let html_tag_163;
    	let raw164_value = `$\\alpha_i$` + "";
    	let t318;
    	let html_tag_164;
    	let raw165_value = `$\\alpha_i \\vec{\\phi_\\sigma}(\\mu_i)$` + "";
    	let t319;
    	let html_tag_165;
    	let raw166_value = `$x$` + "";
    	let t320;
    	let t321;
    	let p53;
    	let t322;
    	let html_tag_166;
    	let raw167_value = `$\\sigma$` + "";
    	let t323;
    	let html_tag_167;
    	let raw168_value = `$x$` + "";
    	let t324;
    	let html_tag_168;
    	let raw169_value = `$\\mu_i$` + "";
    	let t325;
    	let html_tag_169;
    	let raw170_value = `$\\sigma$` + "";
    	let t326;
    	let html_tag_170;
    	let raw171_value = `$\\sigma$` + "";
    	let t327;
    	let html_tag_171;
    	let raw172_value = `$\\mu_i$` + "";
    	let t328;
    	let html_tag_172;
    	let raw173_value = `$\\sigma$` + "";
    	let t329;
    	let html_tag_173;
    	let raw174_value = `$\\mu_i$` + "";
    	let t330;
    	let html_tag_174;
    	let raw175_value = `$x$` + "";
    	let t331;
    	let html_tag_175;
    	let raw176_value = `$|\\mu_i - x|$` + "";
    	let t332;
    	let html_tag_176;
    	let raw177_value = `$\\sigma \\rightarrow 0$` + "";
    	let t333;
    	let html_tag_177;
    	let raw178_value = `$\\sigma \\rightarrow \\infty$` + "";
    	let t334;
    	let html_tag_178;
    	let raw179_value = `$\\mu$` + "";
    	let t335;
    	let t336;
    	let p54;
    	let t337;
    	let html_tag_179;
    	let raw180_value = `$\\mathcal{X}$` + "";
    	let t338;
    	let html_tag_180;
    	let raw181_value = `$|\\mu - x|$` + "";
    	let t339;
    	let html_tag_181;
    	let raw182_value = `$\\mu$` + "";
    	let t340;
    	let html_tag_182;
    	let raw183_value = `$\\mu$` + "";
    	let t341;
    	let t342;
    	let p55;
    	let t343;
    	let html_tag_183;
    	let raw184_value = `$\\mathcal{X}$` + "";
    	let t344;
    	let html_tag_184;
    	let raw185_value = `$\\mathcal{X}$` + "";
    	let t345;
    	let html_tag_185;
    	let raw186_value = `$\\mathcal{X}$` + "";
    	let t346;
    	let t347;
    	let p56;
    	let strong15;
    	let t349;
    	let p57;
    	let t350;
    	let html_tag_186;
    	let raw187_value = `$\\mu$` + "";
    	let t351;
    	let html_tag_187;
    	let raw188_value = `$x$` + "";
    	let t352;
    	let html_tag_188;
    	let raw189_value = `$\\sigma$` + "";
    	let t353;
    	let html_tag_189;
    	let raw190_value = `$\\mu_2$` + "";
    	let t354;
    	let html_tag_190;
    	let raw191_value = `$f_1$` + "";
    	let t355;
    	let html_tag_191;
    	let raw192_value = `$\\vec{\\phi_{\\mu_1}}$` + "";
    	let t356;
    	let html_tag_192;
    	let raw193_value = `$\\vec{\\phi_{\\mu_1}}$` + "";
    	let t357;
    	let t358;
    	let p58;
    	let t359;
    	let html_tag_193;
    	let raw194_value = `$\\alpha_i$` + "";
    	let t360;
    	let html_tag_194;
    	let raw195_value = `$\\vec{\\phi_{\\mu_1}}$` + "";
    	let t361;
    	let html_tag_195;
    	let raw196_value = `$\\vec{\\phi_{\\mu_1}}$` + "";
    	let t362;
    	let html_tag_196;
    	let raw197_value = `$\\vec{\\phi_f}$` + "";
    	let t363;
    	let html_tag_197;
    	let raw198_value = `$\\disp{\\proj{\\V{\\phi_f}}{\\V{\\phi_{x_i}}}} = y_i$` + "";
    	let t364;
    	let html_tag_198;
    	let raw199_value = `$x_i = \\mu_i$` + "";
    	let t365;
    	let html_tag_199;
    	let raw200_value = `$\\vec{\\phi_{x_1}}$` + "";
    	let t366;
    	let html_tag_200;
    	let raw201_value = `$\\vec{\\phi_{x_2}}$` + "";
    	let t367;
    	let html_tag_201;
    	let raw202_value = `$\\alpha_1$` + "";
    	let t368;
    	let html_tag_202;
    	let raw203_value = `$\\disp{\\proj{\\V{\\phi_f}}{\\V{\\phi_{x_2}}}}$` + "";
    	let t369;
    	let t370;
    	let p59;
    	let t371;
    	let html_tag_203;
    	let raw204_value = `$\\sigma$` + "";
    	let t372;
    	let html_tag_204;
    	let raw205_value = `$\\alpha_i$` + "";
    	let t373;
    	let t374;
    	let p60;
    	let strong16;
    	let t376;
    	let p61;
    	let t377;
    	let html_tag_205;
    	let raw206_value = `$f$` + "";
    	let t378;
    	let em13;
    	let t380;
    	let html_tag_206;
    	let raw207_value = `$\\norm{f}$` + "";
    	let t381;
    	let html_tag_207;
    	let raw208_value = `$\\norm{f}$` + "";
    	let t382;
    	let html_tag_208;
    	let raw209_value = `$\\norm{f_\\parallel}$` + "";
    	let t383;
    	let html_tag_209;
    	let raw210_value = `$\\norm{f_\\perp}$` + "";
    	let t384;
    	let t385;
    	let p62;
    	let t386;
    	let html_tag_210;
    	let raw211_value = `$x$` + "";
    	let t387;
    	let html_tag_211;
    	let raw212_value = `$\\alpha_i$` + "";
    	let t388;
    	let html_tag_212;
    	let raw213_value = `$\\|f\\|$` + "";
    	let t389;
    	let html_tag_213;
    	let raw214_value = `$(x_i, y_i)$` + "";
    	let t390;
    	let html_tag_214;
    	let raw215_value = `$\\sigma$` + "";
    	let t391;
    	let t392;
    	let p63;
    	let t393;
    	let html_tag_215;
    	let raw216_value = `$\\V{\\phi_{\\mu_1}}$` + "";
    	let t394;
    	let html_tag_216;
    	let raw217_value = `$\\V{\\phi_{\\mu_2}}$` + "";
    	let t395;
    	let html_tag_217;
    	let raw218_value = `$\\V{\\phi_f}$` + "";
    	let t396;
    	let t397;
    	let p64;
    	let t398;
    	let em14;
    	let t400;
    	let html_tag_218;
    	let raw219_value = `$y_i$` + "";
    	let t401;
    	let html_tag_219;
    	let raw220_value = `$\\sigma$` + "";
    	let t402;
    	let t403;
    	let p65;
    	let t404;
    	let html_tag_220;
    	let raw221_value = `$y_i$` + "";
    	let t405;
    	let t406;
    	let p66;
    	let strong17;
    	let t407;
    	let html_tag_221;
    	let raw222_value = `$\\mu$` + "";
    	let t408;
    	let html_tag_222;
    	let raw223_value = `$x$` + "";
    	let t409;
    	let t410;
    	let p67;
    	let t411;
    	let html_tag_223;
    	let raw224_value = `$\\V{\\phi_f}$` + "";
    	let t412;
    	let html_tag_224;
    	let raw225_value = `$\\mu$` + "";
    	let t413;
    	let html_tag_225;
    	let raw226_value = `$n$` + "";
    	let t414;
    	let html_tag_226;
    	let raw227_value = `$\\mathbb{span}(\\V{\\phi_{\\mu_i}})$` + "";
    	let t415;
    	let html_tag_227;
    	let raw228_value = `$\\proj{\\V{\\phi_f}}{\\mathbb{x-span}}$` + "";
    	let t416;
    	let html_tag_228;
    	let raw229_value = `$x$` + "";
    	let t417;
    	let html_tag_229;
    	let raw230_value = `$\\mathbb{span}(\\V{\\phi_{x_i}})$` + "";
    	let t418;
    	let html_tag_230;
    	let raw231_value = `$\\mu_i = x_i$` + "";
    	let t419;
    	let html_tag_231;
    	let raw232_value = `$\\V{\\phi_f} = \\V{\\phi_{f_\\parallel}}$` + "";
    	let t420;
    	let html_tag_232;
    	let raw233_value = `$\\V{\\phi_{f_\\perp}} = \\V{0}$` + "";
    	let t421;
    	let html_tag_233;
    	let raw234_value = `$\\mu$` + "";
    	let t422;
    	let html_tag_234;
    	let raw235_value = `$\\mu_i$` + "";
    	let t423;
    	let html_tag_235;
    	let raw236_value = `$f$` + "";
    	let t424;
    	let html_tag_236;
    	let raw237_value = `$\\norm{f}$` + "";
    	let t425;
    	let html_tag_237;
    	let raw238_value = `$\\V{\\phi_f}$` + "";
    	let t426;
    	let html_tag_238;
    	let raw239_value = `$\\mu$` + "";
    	let t427;
    	let html_tag_239;
    	let raw240_value = `$\\V{\\phi_f} = \\V{\\phi_{f_\\parallel}} + \\V{\\phi_{f_\\perp}}$` + "";
    	let t428;
    	let html_tag_240;
    	let raw241_value = `$x$` + "";
    	let t429;
    	let html_tag_241;
    	let raw242_value = `$\\norm{f}$` + "";
    	let t430;
    	let html_tag_242;
    	let raw243_value = `$x$` + "";
    	let t431;
    	let t432;
    	let p68;
    	let t433;
    	let html_tag_243;
    	let raw244_value = `$\\mu$` + "";
    	let t434;
    	let html_tag_244;
    	let raw245_value = `$x$` + "";
    	let t435;
    	let html_tag_245;
    	let raw246_value = `$x$` + "";
    	let t436;
    	let t437;
    	let h12;
    	let t439;
    	let figure2;
    	let t440;
    	let p69;
    	let t441;
    	let html_tag_246;
    	let raw247_value = `$\\mu$` + "";
    	let t442;
    	let html_tag_247;
    	let raw248_value = `$\\V{\\phi_{\\mu_1}}$` + "";
    	let t443;
    	let html_tag_248;
    	let raw249_value = `$\\V{\\phi_{\\mu_2}}$` + "";
    	let t444;
    	let html_tag_249;
    	let raw250_value = `$\\V{\\phi_f} = \\sum_i { \\alpha_i \\V{\\phi_{\\mu_i}}}$` + "";
    	let t445;
    	let html_tag_250;
    	let raw251_value = `$x$` + "";
    	let t446;
    	let html_tag_251;
    	let raw252_value = `$\\V{\\phi_{x_i}}$` + "";
    	let t447;
    	let html_tag_252;
    	let raw253_value = `$\\mu_i = x_i$` + "";
    	let t448;
    	let html_tag_253;
    	let raw254_value = `$\\V{\\phi_f}$` + "";
    	let t449;
    	let html_tag_254;
    	let raw255_value = `$\\V{\\phi_{\\mu_i}}$` + "";
    	let t450;
    	let html_tag_255;
    	let raw256_value = `$f(x_i)$` + "";
    	let t451;
    	let t452;
    	let p70;
    	let strong18;
    	let t453;
    	let html_tag_256;
    	let raw257_value = `$\\V{\\phi_{\\mu_1}}$` + "";
    	let t454;
    	let html_tag_257;
    	let raw258_value = `$\\V{\\phi_{\\mu_2}}$` + "";
    	let t455;
    	let html_tag_258;
    	let raw259_value = `$\\mu_i$` + "";
    	let t456;
    	let t457;
    	let p71;
    	let strong19;
    	let t458;
    	let html_tag_259;
    	let raw260_value = `$\\V{\\phi_{\\mu_1}}$` + "";
    	let t459;
    	let html_tag_260;
    	let raw261_value = `$\\V{\\phi_{\\mu_2}}$` + "";
    	let t460;
    	let html_tag_261;
    	let raw262_value = `$f(\\cdot)$` + "";
    	let t461;
    	let html_tag_262;
    	let raw263_value = `$\\mu_i$` + "";
    	let t462;
    	let html_tag_263;
    	let raw264_value = `$\\mu$` + "";
    	let t463;
    	let html_tag_264;
    	let raw265_value = `$x$` + "";
    	let t464;
    	let html_tag_265;
    	let raw266_value = `$\\V{\\phi_{\\mu_i}}$` + "";
    	let t465;
    	let t466;
    	let p72;
    	let strong20;
    	let t467;
    	let html_tag_266;
    	let raw267_value = `$\\V{\\phi_{\\mu_1}}$` + "";
    	let t468;
    	let html_tag_267;
    	let raw268_value = `$\\V{\\phi_{\\mu_2}}$` + "";
    	let t469;
    	let html_tag_268;
    	let raw269_value = `$f(\\cdot)$` + "";
    	let t470;
    	let html_tag_269;
    	let raw270_value = `$\\mu_i$` + "";
    	let t471;
    	let html_tag_270;
    	let raw271_value = `$\\mu$` + "";
    	let t472;
    	let html_tag_271;
    	let raw272_value = `$x$` + "";
    	let t473;
    	let html_tag_272;
    	let raw273_value = `$y$` + "";
    	let t474;
    	let t475;
    	let h25;
    	let t476;
    	let html_tag_273;
    	let raw274_value = `$\\mu_i = x_i$` + "";
    	let t477;
    	let t478;
    	let p73;
    	let t479;
    	let html_tag_274;
    	let raw275_value = `$\\mu$` + "";
    	let t480;
    	let html_tag_275;
    	let raw276_value = `$x$` + "";
    	let t481;
    	let html_tag_276;
    	let raw277_value = `$\\mu$` + "";
    	let t482;
    	let t483;
    	let p74;
    	let t484;
    	let html_tag_277;
    	let raw278_value = `$f$` + "";
    	let t485;
    	let html_tag_278;
    	let raw279_value = `$\\V{\\phi_f} = \\B{\\alpha M}$` + "";
    	let t486;
    	let html_tag_279;
    	let raw280_value = `$\\B{M}$` + "";
    	let t487;
    	let html_tag_280;
    	let raw281_value = `$\\V{\\phi_{\\mu_i}}$` + "";
    	let t488;
    	let html_tag_281;
    	let raw282_value = `$f$` + "";
    	let t489;
    	let em15;
    	let t491;
    	let html_tag_282;
    	let raw283_value = `$x_i$` + "";
    	let t492;
    	let html_tag_283;
    	let raw284_value = `$\\B{\\alpha M X}^T$` + "";
    	let t493;
    	let html_tag_284;
    	let raw285_value = `$\\B{X}$` + "";
    	let t494;
    	let html_tag_285;
    	let raw286_value = `$\\V{\\phi_{x_i}}$` + "";
    	let t495;
    	let html_tag_286;
    	let raw287_value = `$\\B{M} = \\B{X}$` + "";
    	let t496;
    	let t497;
    	let p75;
    	let t498;
    	let html_tag_287;
    	let raw288_value = `$\\B{\\alpha M X}^T = \\B{y}$` + "";
    	let t499;
    	let html_tag_288;
    	let raw289_value = `$\\B{\\alpha}$` + "";
    	let t500;
    	let t501;
    	let html_tag_289;

    	let raw290_value = `$$
\\begin{aligned}
\\B{a} \\cdot \\B{b} & = (\\proj{\\B{a}}{\\B{b}} + \\rej{\\B{a}}{\\B{b}}) \\cdot \\B{b} & \\text{orthogonal decomposition}\\\\
& = \\proj{\\B{a}}{\\B{b}} \\cdot \\B{b} + \\rej{\\B{a}}{\\B{b}} \\cdot \\B{b} & \\text{linearity of dot product}\\\\
& = \\proj{\\B{a}}{\\B{b}} \\cdot \\B{b} & \\text{zero orthogonal contribution} \\\\
\\end{aligned}
$$` + "";

    	let p76;
    	let t503;
    	let html_tag_290;

    	let raw291_value = `$$
\\begin{aligned}
\\B{\\alpha M X}^T & = \\B{\\alpha} (\\proj{\\B{M}}{\\texttt{span}(\\B{X})} + \\rej{\\B{M}}{\\texttt{span}(\\B{X})}) \\B{X}^T \\\\
& = \\B{\\alpha} \\proj{\\B{M}}{\\texttt{span}(\\B{X})} \\B{X}^T
\\end{aligned}
$$` + "";

    	let p77;
    	let html_tag_291;
    	let raw292_value = `$\\proj{\\B{M}}{}$` + "";
    	let t504;
    	let html_tag_292;
    	let raw293_value = `$\\texttt{span}(\\B{X})$` + "";
    	let t505;
    	let html_tag_293;
    	let raw294_value = `$\\mu_i = x_i$` + "";
    	let t506;
    	let html_tag_294;
    	let raw295_value = `$\\mu_i$` + "";
    	let t507;
    	let html_tag_295;
    	let raw296_value = `$\\texttt{span}(\\B{M}) = \\texttt{span}(\\B{X})$` + "";
    	let t508;
    	let html_tag_296;
    	let raw297_value = `$\\B{y}$` + "";
    	let t509;
    	let html_tag_297;
    	let raw298_value = `$\\mu_i$` + "";
    	let t510;
    	let t511;
    	let p78;
    	let t512;
    	let html_tag_298;
    	let raw299_value = `$\\norm{\\V{\\phi_f}}^2$` + "";
    	let t513;
    	let t514;
    	let html_tag_299;

    	let raw300_value = `$$
\\begin{aligned}
\\B{\\alpha M X}^T & = \\B{\\beta X X}^T = \\B{y} &\\text{a $\\B{\\beta}$ exists, by previous argument}\\\\
\\norm{\\V{\\phi_f}}^2 & = \\B{\\alpha M M}^T \\B{\\alpha}^T \\\\
& = \\B{\\alpha} (\\proj{\\B{M}}{} + \\rej{\\B{M}}{}) (\\proj{\\B{M}}{} + \\rej{\\B{M}}{})^T \\B{\\alpha}^T \\\\
& = \\B{\\alpha} \\proj{\\B{M}}{} \\proj{\\B{M}}{}^T \\B{\\alpha}^T
+ 2 \\B{\\alpha} \\proj{\\B{M}}{} \\rej{\\B{M}}{}^T \\B{\\alpha}^T
+ \\B{\\alpha} \\rej{\\B{M}}{} \\rej{\\B{M}}{}^T \\B{\\alpha}^T \\\\
& \\ge \\B{\\alpha} \\proj{\\B{M}}{} \\proj{\\B{M}}{}^T \\B{\\alpha}^T \\\\[1em]
& = \\B{\\beta X X}^T \\B{\\beta}^T & \\text{by uniqueness of span}\\\\
\\end{aligned}
$$` + "";

    	let h26;
    	let t516;
    	let p79;
    	let t517;
    	let html_tag_300;
    	let raw301_value = `$f$` + "";
    	let t518;
    	let html_tag_301;
    	let raw302_value = `$\\norm{\\V{\\phi_f}}$` + "";
    	let t519;
    	let t520;
    	let p80;
    	let t521;
    	let html_tag_302;
    	let raw303_value = `$a, b \\in \\mathcal{X}$` + "";
    	let t522;
    	let html_tag_303;
    	let raw304_value = `$|f(a)|$` + "";
    	let t523;
    	let html_tag_304;
    	let raw305_value = `$|f(a) - f(b)|$` + "";
    	let t524;
    	let t525;
    	let html_tag_305;

    	let raw306_value = `$$
\\begin{aligned}
f(a) & = \\V{\\phi_f} \\cdot \\V{\\phi_a} & \\text{definition of $f(x)$} \\\\
& = \\norm{\\V{\\phi_f}} \\|\\V{\\phi_a}\\| \\cos \\theta_{\\V{\\phi_f},\\V{\\phi_a}} & \\text{definition of dot product} \\\\
\\implies |f(a)| & \\le \\norm{\\V{\\phi_f}}\\|\\V{\\phi_a}\\| & \\text{Cauchy Schwarz inequality} \\\\[2em]
f(a) - f(b) & = \\V{\\phi_f} \\cdot \\V{\\phi_a} - \\V{\\phi_f} \\cdot \\V{\\phi_b} &\\text{definition of $f(x)$} \\\\
& = \\V{\\phi_f} \\cdot (\\V{\\phi_a} - \\V{\\phi_b}) & \\text{bilinearity of dot product} \\\\
& = \\norm{\\V{\\phi_f}} \\|\\V{\\phi_a} - \\V{\\phi_b}\\| \\cos \\theta_{\\V{\\phi_f}, \\V{\\phi_a} - \\V{\\phi_b}} & \\text{definition of dot product} \\\\
\\implies |f(a) - f(b)| & \\le \\norm{\\V{\\phi_f}} \\|\\V{\\phi_a} - \\V{\\phi_b}\\| & \\text{Cauchy Schwarz inequality} \\\\
\\end{aligned}
$$` + "";

    	let p81;
    	let t526;
    	let html_tag_306;
    	let raw307_value = `$f$` + "";
    	let t527;
    	let html_tag_307;
    	let raw308_value = `$\\norm{\\V{\\phi_f}}$` + "";
    	let t528;
    	let html_tag_308;
    	let raw309_value = `$\\norm{\\V{\\phi_a}}$` + "";
    	let t529;
    	let html_tag_309;
    	let raw310_value = `$\\B{\\phi}(\\cdot)$` + "";
    	let t530;
    	let html_tag_310;
    	let raw311_value = `$\\norm{\\V{\\phi_f}}$` + "";
    	let t531;
    	let html_tag_311;
    	let raw312_value = `$f$` + "";
    	let t532;
    	let t533;
    	let p82;
    	let t534;
    	let html_tag_312;
    	let raw313_value = `$\\norm{\\V{\\phi_a} - \\V{\\phi_b}}$` + "";
    	let t535;
    	let html_tag_313;
    	let raw314_value = `$\\norm{\\V{\\phi_f}}$` + "";
    	let t536;
    	let t537;
    	let p83;
    	let t538;
    	let html_tag_314;
    	let raw315_value = `$y_a$` + "";
    	let t539;
    	let html_tag_315;
    	let raw316_value = `$y_b$` + "";
    	let t540;
    	let html_tag_316;
    	let raw317_value = `$|f(a) - f(b)| = |y_a - y_b|$` + "";
    	let t541;
    	let html_tag_317;
    	let raw318_value = `$\\|\\V{\\phi_f}\\|$` + "";
    	let t542;
    	let html_tag_318;
    	let raw319_value = `$\\|\\V{\\phi_a} - \\V{\\phi_b}\\|$` + "";
    	let t543;
    	let html_tag_319;
    	let raw320_value = `$x$` + "";
    	let t544;
    	let t545;
    	let p84;
    	let t546;
    	let html_tag_320;
    	let raw321_value = `$\\B{\\phi}(\\cdot)$` + "";
    	let t547;
    	let html_tag_321;
    	let raw322_value = `$\\B{\\phi}(\\cdot)$` + "";
    	let t548;
    	let html_tag_322;
    	let raw323_value = `$\\norm{\\V{\\phi_a} - \\V{\\phi_b}}$` + "";
    	let t549;
    	let html_tag_323;
    	let raw324_value = `$|y_a - y_b|$` + "";
    	let t550;
    	let html_tag_324;
    	let raw325_value = `$(a, b) \\in \\mathcal{X}$` + "";
    	let t551;
    	let t552;
    	let h27;
    	let t554;
    	let p85;
    	let t555;
    	let html_tag_325;
    	let raw326_value = `$\\B{M} \\equiv \\B{X}$` + "";
    	let t556;
    	let t557;
    	let html_tag_326;

    	let raw327_value = `$$
\\begin{aligned}
\\B{X} & & \\text{matrix of rows of $\\V{\\phi_{x_i}}$ as defined before} \\\\
\\V{\\phi_f} & = \\B{\\alpha X} & \\text{$f$'s parameter vector}\\\\
(f(x_i))_{(1..n)} &= \\B{\\alpha X X}^T & \\text{$f$'s vector of evaluation } \\\\
\\end{aligned}
$$` + "";

    	let p86;
    	let t558;
    	let html_tag_327;
    	let raw328_value = `$\\B{\\hat \\alpha}$` + "";
    	let t559;
    	let t560;
    	let html_tag_328;

    	let raw329_value = `$$
\\begin{aligned}
\\B{\\hat{\\alpha}} & = \\min_{\\alpha} { \\norm{\\B{\\alpha X X}^T - \\B{y}}^2 }
\\end{aligned}
$$` + "";

    	let p87;
    	let t562;
    	let html_tag_329;

    	let raw330_value = `$$
\\begin{aligned}
\\B{\\hat{\\alpha}} & = \\min_{\\alpha} ( \\norm{\\B{\\alpha X X}^T - \\B{y}}^2 + \\lambda \\norm{\\B{\\alpha X}}^2 ) & \\text{sum of squared error, regularized by norm of $\\V{\\phi_f}$}\\\\
& = \\min_{\\alpha} ( \\norm{\\B{\\alpha X X}^T - \\B{y}}^2 + \\lambda \\B{\\alpha X X}^T \\B{\\alpha}^T )
\\end{aligned}
$$` + "";

    	let p88;
    	let t564;
    	let html_tag_330;

    	let raw331_value = `$$
\\begin{aligned}
f(x) & = \\V{\\phi_f} \\cdot \\V{\\phi_x} \\\\
& = \\B{\\hat{\\alpha} X} \\cdot \\V{\\phi_x} \\\\
& = \\sum_i { \\hat{\\alpha}_i \\V{\\phi_{x_i}} \\cdot \\V{\\phi_x} } \\\\
\\end{aligned}
$$` + "";

    	let p89;
    	let t565;
    	let html_tag_331;
    	let raw332_value = `$\\mathcal{X}$` + "";
    	let t566;
    	let html_tag_332;
    	let raw333_value = `$\\V{\\phi_{x_i}} \\cdot \\V{\\phi_{x_j}}$` + "";
    	let t567;
    	let html_tag_333;
    	let raw334_value = `$\\B{X X}^T$` + "";
    	let t568;
    	let t569;
    	let html_tag_334;

    	let raw335_value = `$$
\\begin{aligned}
k(x,x') & \\equiv \\V{\\phi_x} \\cdot \\V{\\phi_{x'}} & \\text{The kernel function} \\\\
\\B{K} & \\equiv [ \\B{K}_{ij} = k(x_i, x_j) ] & \\text{The Kernel matrix, metric matrix or Gram matrix} \\\\
& = \\B{X X}^T & \\text{from above}
\\end{aligned}
$$` + "";

    	let p90;
    	let t571;
    	let html_tag_335;

    	let raw336_value = `$$
\\begin{aligned}
\\B{\\hat{\\alpha}} & = \\min_{\\alpha} ( \\norm{\\B{\\alpha K}- \\B{y}}^2 + \\lambda \\B{\\alpha K} \\B{\\alpha}^T )
\\end{aligned}
$$` + "";

    	let p91;
    	let t573;
    	let html_tag_336;

    	let raw337_value = `$$
\\begin{aligned}
f(x) & = \\sum_i { \\hat{\\alpha}_i k(x_i, x) } \\\\
\\end{aligned}
$$` + "";

    	let p92;
    	let t574;
    	let html_tag_337;
    	let raw338_value = `$x$` + "";
    	let t575;
    	let html_tag_338;
    	let raw339_value = `$\\B{\\alpha}$` + "";
    	let t576;
    	let html_tag_339;
    	let raw340_value = `$x_i$` + "";
    	let t577;
    	let html_tag_340;
    	let raw341_value = `$k(x, x') \\equiv \\mathcal{N}(x; x', \\sigma) = \\mathcal{N}(x'; x, \\sigma)$` + "";
    	let t578;
    	let t579;
    	let h13;
    	let t581;
    	let p93;
    	let t582;
    	let html_tag_341;
    	let raw342_value = `$\\mathcal{X} \\times \\mathbb{R}$` + "";
    	let t583;
    	let t584;
    	let p94;
    	let t585;
    	let html_tag_342;
    	let raw343_value = `$x_i$` + "";
    	let t586;
    	let html_tag_343;
    	let raw344_value = `$x_i$` + "";
    	let t587;
    	let html_tag_344;
    	let raw345_value = `$y_i$` + "";
    	let t588;
    	let html_tag_345;
    	let raw346_value = `$x_i$` + "";
    	let t589;
    	let t590;
    	let p95;
    	let t591;
    	let html_tag_346;
    	let raw347_value = `$f_{x_i}(x) \\equiv \\V{\\phi_{x_i}} \\cdot \\V{\\phi_x}$` + "";
    	let t592;
    	let t593;
    	let ol2;
    	let li7;
    	let p96;
    	let t595;
    	let li8;
    	let p97;
    	let t597;
    	let li9;
    	let p98;
    	let t599;
    	let h14;
    	let t601;
    	let p99;
    	let t603;
    	let h28;
    	let t605;
    	let p100;
    	let t606;
    	let html_tag_347;
    	let raw348_value = `$XX^T$` + "";
    	let t607;
    	let html_tag_348;
    	let raw349_value = `$X$` + "";
    	let t608;
    	let html_tag_349;
    	let raw350_value = `$X$` + "";
    	let t609;
    	let html_tag_350;
    	let raw351_value = `$X$` + "";
    	let t610;
    	let html_tag_351;
    	let raw352_value = `$XX^T$` + "";
    	let t611;
    	let html_tag_352;
    	let raw353_value = `$\\alpha K \\alpha^T \\ge 0$` + "";
    	let t612;
    	let html_tag_353;
    	let raw354_value = `$\\alpha$` + "";
    	let t613;
    	let html_tag_354;
    	let raw355_value = `$K = XX^T$` + "";
    	let t614;
    	let html_tag_355;
    	let raw356_value = `$X$` + "";
    	let t615;
    	let html_tag_356;
    	let raw357_value = `$X$` + "";
    	let t616;
    	let html_tag_357;
    	let raw358_value = `$\\alpha X$` + "";
    	let t617;
    	let html_tag_358;
    	let raw359_value = `$\\alpha X X^T \\alpha^T$` + "";
    	let t618;
    	let t619;
    	let h29;
    	let t621;
    	let p101;
    	let t622;
    	let html_tag_359;
    	let raw360_value = `$k(x, x') \\equiv \\V{\\phi_x} \\cdot \\V{\\phi_x'}$` + "";
    	let t623;
    	let t624;
    	let h210;
    	let t626;
    	let p102;
    	let t628;
    	let p103;
    	let t629;
    	let html_tag_360;
    	let raw361_value = `$f_{x_i}(\\cdot): \\mathcal{X} \\mapsto \\mathbb{R}$` + "";
    	let t630;
    	let em16;
    	let t632;
    	let html_tag_361;
    	let raw362_value = `$\\V{\\phi_{x_i}}: \\mathbb{R}^\\infty \\equiv \\mathcal{F}$` + "";
    	let t633;
    	let em17;
    	let t635;
    	let html_tag_362;
    	let raw363_value = `$K$` + "";
    	let t636;
    	let html_tag_363;
    	let raw364_value = `$(\\V{\\phi_{x_i}})$` + "";
    	let t637;
    	let html_tag_364;
    	let raw365_value = `$x_i$` + "";
    	let t638;
    	let t639;
    	let p104;
    	let t640;
    	let html_tag_365;
    	let raw366_value = `$f_{x_i}(\\cdot)$` + "";
    	let t641;
    	let html_tag_366;
    	let raw367_value = `$x \\in \\mathcal{X}$` + "";
    	let t642;
    	let em18;
    	let t644;
    	let html_tag_367;
    	let raw368_value = `$f_{x_i}(\\cdot): \\mathbb{R}^\\mathcal{X}$` + "";
    	let t645;
    	let html_tag_368;
    	let raw369_value = `$\\mathbb{R}^3$` + "";
    	let t646;
    	let html_tag_369;
    	let raw370_value = `$|\\mathcal{X}|$` + "";
    	let t647;
    	let em19;
    	let t649;
    	let em20;
    	let t651;
    	let html_tag_370;
    	let raw371_value = `$\\mathbb{R}^\\mathcal{X}$` + "";
    	let t652;
    	let html_tag_371;
    	let raw372_value = `$\\mathcal{H}$` + "";
    	let t653;
    	let html_tag_372;
    	let raw373_value = `$\\langle f_{x_i}, f_{x_j} \\rangle \\equiv \\V{\\phi_{x_i}} \\cdot \\V{\\phi_{x_j}} \\equiv f_{x_i}(x_j) \\equiv f_{x_j}(x_i)$` + "";
    	let t654;
    	let t655;
    	let p105;
    	let t656;
    	let html_tag_373;
    	let raw374_value = `$(f_{x_i})$` + "";
    	let t657;
    	let html_tag_374;
    	let raw375_value = `$K:[K_{ij} = f_{x_i}(x_j)]$` + "";
    	let t658;
    	let html_tag_375;
    	let raw376_value = `$KK^T = K$` + "";
    	let t659;
    	let a0;
    	let t661;
    	let t662;
    	let h211;
    	let t664;
    	let p106;
    	let t665;
    	let html_tag_376;
    	let raw377_value = `$f_x \\in \\mathcal{H}$` + "";
    	let t666;
    	let html_tag_377;
    	let raw378_value = `$x \\in \\mathcal{X}$` + "";
    	let t667;
    	let html_tag_378;
    	let raw379_value = `$x$` + "";
    	let t668;
    	let em21;
    	let t670;
    	let html_tag_379;
    	let raw380_value = `$\\mathcal{H}$` + "";
    	let t671;
    	let em22;
    	let t673;
    	let html_tag_380;
    	let raw381_value = `$(f_{x_i})$` + "";
    	let t674;
    	let html_tag_381;
    	let raw382_value = `$\\B{M} = \\B{X}$` + "";
    	let t675;
    	let a1;
    	let current;
    	figure1 = new Figure1({ $$inline: true });
    	figure2 = new Figure2({ $$inline: true });

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			t0 = space();
    			h10 = element("h1");
    			h10.textContent = "Introduction";
    			t2 = space();
    			p1 = element("p");
    			p1.textContent = "In this article, I introduce the main mathematical apparatus at the core of all Kernel Methods.  To me, the apparatus is best introduced as the inevitable consequence of three design goals, in the same way that a bicycle is the consequence of design goals (\"a thing the rider must be able to steer, sit on, accelerate, and stop\").";
    			t4 = space();
    			p2 = element("p");
    			p2.textContent = "I take a somewhat unconventional approach by first considering a slightly wider class, and then show that a narrower class (still with multiple choices) is the most optimal.  The Kernel method is one choice in this narrower class.  While any choice within this narrower class provides exactly the same solution to a problem, the Kernel method is the only computable member of this class.  This should hopefully make the Kernel Method seem less contrived and arbitrary.";
    			t6 = space();
    			p3 = element("p");
    			p3.textContent = "There are two interactive visualizations in this article, using the 1-D Gaussian Kernel.  In writing it, I built a lot of intuition about these core concepts by fiddling with the two figures.";
    			t8 = space();
    			p4 = element("p");
    			p4.textContent = "All Kernel methods, such as Kernel Regression, Kernel SVM, PCA, CCA, K-means use the same mathematical apparatus at the core, but solve a different linear problem.  In this article, I use the simplest among these, the perfect-fit Kernel Regression, as a worked example.  Since it is perfect-fit, it has the drawback of not using regularization.  Instead, I introduce the concept of regularization through function norm reduction while considering the design of the Kernel Method itself.   Imperfect-fit (least squares) regression, and other variations serve to further decrease the function norm, or achieve other objectives such as classification.";
    			t10 = space();
    			p5 = element("p");
    			p5.textContent = "A core concept of Kernel Methods is the so-called \"feature space\" - a (possibly) infinite dimensional vector space, whose points correspond one-to-one with functions.  There is a distinct concept called the Reproducing Kernel Hilbert Space.  The RKHS is a more abstract concept; it is also a vector space whose points correspond to the points in the feature space, and the functions.  The feature space and the RKHS are distinct, but represent aspects of the same underlying mathematical object.  But often in the literature, they are spoken about interchangeably, which was a major source of confusion.  I only mention them here to help the reader avoid the same confusion.";
    			t12 = space();
    			p6 = element("p");
    			p6.textContent = "Kernel methods, particularly SVMs, were for a time a dominant model used in Machine Learning, but have been eclipsed by deep Neural networks trained by stochastic gradient descent.  More recently, it was recognized that NNs trained by SGD approximate Kernel methods, and this has led to increased interest and new applications.";
    			t14 = space();
    			h11 = element("h1");
    			h11.textContent = "An illustration of Kernel Regression";
    			t16 = space();
    			p7 = element("p");
    			t17 = text$1("In the interactive figure, data points ");
    			html_tag = new HtmlTag();
    			t18 = text$1(" are shown as black dots.  There is one Gaussian centered at each ");
    			html_tag_1 = new HtmlTag();
    			t19 = text$1(".  The blue curve is a linear combination ");
    			html_tag_2 = new HtmlTag();
    			t20 = text$1(" of these Gaussians.  Each slider controls one of the ");
    			html_tag_3 = new HtmlTag();
    			t21 = text$1(".");
    			t22 = space();
    			p8 = element("p");
    			t23 = text$1("You can adjust the sliders to make the blue curve perfectly fit the ");
    			html_tag_4 = new HtmlTag();
    			t24 = text$1(".  It may be surprising to note that a unique, perfect-fitting ");
    			html_tag_5 = new HtmlTag();
    			t25 = text$1(" exists for any set of ");
    			html_tag_6 = new HtmlTag();
    			t26 = text$1(" and for any number of points (click 'Add Points' and/or 'New Data' to adjust).");
    			t27 = space();
    			p9 = element("p");
    			t28 = text$1("To see why, note that each gray curve's set of values along the ");
    			html_tag_7 = new HtmlTag();
    			t29 = text$1(" produces a vector, which I call the function's ");
    			em0 = element("em");
    			em0.textContent = "vector of evaluation";
    			t31 = text$1(".  Denoting the j'th curve as ");
    			html_tag_8 = new HtmlTag();
    			t32 = text$1(", its vector of evaluation is ");
    			html_tag_9 = new HtmlTag();
    			t33 = text$1(", where the order of components is always the order of the ");
    			html_tag_10 = new HtmlTag();
    			t34 = text$1(".");
    			t35 = space();
    			create_component(figure1.$$.fragment);
    			t36 = space();
    			p10 = element("p");
    			t37 = text$1("Note that there isn't any rule that the ");
    			html_tag_11 = new HtmlTag();
    			t38 = text$1(" need be monotonically increasing.  They are simply given in some arbitrary order from the dataset. In the plot, they aren't labeled.  You can adjust the i'th slider and see which curve moves.  The point located horizontally at the peak of that curve is ");
    			html_tag_12 = new HtmlTag();
    			t39 = text$1(".  Ultimately it doesn't matter for the purposes of illustration.  The important thing is that all the gray functions' vectors of evaluation are in the same order.");
    			t40 = space();
    			p11 = element("p");
    			p11.textContent = "Also note, although Gaussians are most often interpreted as probability distributions, in this article, there is no such interpretation, and there is no process of sampling from Gaussians.  We are simply using them as curves, like splines, to generate more complex shapes.  So, there is no requirement that they be normalized.";
    			t42 = space();
    			p12 = element("p");
    			t43 = text$1("Particularly for a collection of Gaussians all with the same ");
    			html_tag_13 = new HtmlTag();
    			t44 = text$1(", the set of these ");
    			html_tag_14 = new HtmlTag();
    			t45 = text$1(" vectors are linearly independent.  This is not at all obvious, but please accept it for now.  Then, by the linear algebra expansion theorem, they span ");
    			html_tag_15 = new HtmlTag();
    			t46 = text$1(" and so can form any set of ");
    			html_tag_16 = new HtmlTag();
    			t47 = text$1(".");
    			t48 = space();
    			p13 = element("p");
    			p13.textContent = "Explicitly:";
    			t50 = space();
    			html_tag_17 = new HtmlTag();
    			p14 = element("p");
    			t51 = text$1("The ");
    			html_tag_18 = new HtmlTag();
    			t52 = text$1(" that fits the data perfectly is found by inverting ");
    			html_tag_19 = new HtmlTag();
    			t53 = text$1(", which is possible because ");
    			html_tag_20 = new HtmlTag();
    			t54 = text$1(" is full-rank.  That is, its rows are linearly independent, due to the property of a collections of Gaussians of the same ");
    			html_tag_21 = new HtmlTag();
    			t55 = text$1(".  Even though we are taking linear combinations of functions, it is only the vectors of evaluation ");
    			html_tag_22 = new HtmlTag();
    			t56 = text$1(" which affect the choice of ");
    			html_tag_23 = new HtmlTag();
    			t57 = text$1(".");
    			t58 = space();
    			p15 = element("p");
    			t59 = text$1("Of course, the whole purpose is for the curve to specify desirable values at other points, by some criterion.  But, so far the discussion is only concerned with how to make the curve have desired values at the ");
    			html_tag_24 = new HtmlTag();
    			t60 = text$1(".");
    			t61 = space();
    			h20 = element("h2");
    			h20.textContent = "Some Observations";
    			t63 = space();
    			p16 = element("p");
    			strong0 = element("strong");
    			t64 = text$1("This method can fit any set of data in ");
    			html_tag_25 = new HtmlTag();
    			t65 = text$1(".");
    			t66 = text$1("  Given a ");
    			em1 = element("em");
    			em1.textContent = "particular";
    			t68 = text$1(" set ");
    			html_tag_26 = new HtmlTag();
    			t69 = text$1(", you could hand-pick a set of functions ");
    			html_tag_27 = new HtmlTag();
    			t70 = text$1(" which happen to produce linearly independent vectors ");
    			html_tag_28 = new HtmlTag();
    			t71 = text$1(" of evaluation on that particular data set.  However, the procedure shown above can fit any data set ");
    			html_tag_29 = new HtmlTag();
    			t72 = text$1(".  This is useful because it would be laborious to have to hand-pick functions for each new data set.");
    			t73 = space();
    			p17 = element("p");
    			strong1 = element("strong");
    			t74 = text$1("There is nothing (yet) special about the Gaussians being centered at the ");
    			html_tag_30 = new HtmlTag();
    			t75 = text$1(".  It turns out that ");
    			em2 = element("em");
    			em2.textContent = "any";
    			t77 = text$1(" choice of ");
    			html_tag_31 = new HtmlTag();
    			t78 = text$1(" Gaussians will span ");
    			html_tag_32 = new HtmlTag();
    			t79 = text$1(" when evaluated at any ");
    			html_tag_33 = new HtmlTag();
    			t80 = text$1(" values.  There ");
    			em3 = element("em");
    			em3.textContent = "is";
    			t82 = text$1(" indeed something special about the Gaussians being centered at the ");
    			html_tag_34 = new HtmlTag();
    			t83 = text$1(", but it has nothing to do with the ability to fit arbitrary data.");
    			t84 = space();
    			p18 = element("p");
    			strong2 = element("strong");
    			strong2.textContent = "Many functions have this infinite capacity";
    			t86 = text$1(".  Not just Gaussians, but many other families of functions have this capacity to perfectly fit any data, due to the vectors of evaluation being linearly independent.  Not only that, but families of functions can be found for many different domains, not just ");
    			html_tag_35 = new HtmlTag();
    			t87 = text$1(" as shown above.   Both discrete and continuous domains, and of arbitrary dimensions.");
    			t88 = space();
    			p19 = element("p");
    			strong3 = element("strong");
    			strong3.textContent = "Linear independence is preserved under permutation of components";
    			t90 = text$1(".  The Gaussians are able to fit any data because they produce vectors that are linearly independent.  But, note that vectors that are linearly independent would still be so, after you permute their elements all in the same way.  For vectors, there is no meaning to the ordering of the elements.  To illustrate, click the 'scramble' button.  This remaps all points in ");
    			html_tag_36 = new HtmlTag();
    			t91 = text$1(" in one-to-one fashion by reversing the order of every other interval of some fixed size.  Or think of it as re-ordering the components of the Gaussian \"vectors\" all in the same way, preserving their linear independence.  You can still toggle 'auto solve' and see that a unique solution exists.");
    			t92 = space();
    			p20 = element("p");
    			t93 = text$1("Of course, these permuted Gaussians don't have the same relationship with the original data, so there will be a different ");
    			html_tag_37 = new HtmlTag();
    			t94 = text$1(" solution.  This is only to show that the continuity or shape of the original Gaussians is not what gives them this capacity to fit arbitrary data.");
    			t95 = space();
    			h21 = element("h2");
    			h21.textContent = "The three design choices underlying all Kernel methods";
    			t97 = space();
    			p21 = element("p");
    			p21.textContent = "Underlying all Kernel methods are three choices for how to construct the function to fit a given data set.  Like all machine learning methods, these chocies are guided by classic requirements.  First, the approach must be a \"universal approximator\", or as I call it, have arbitrary model capacity.  This means, the ability to perfectly fit any data set.  Second, it should be possible to regularize, meaning that the function gives useful interpolation behavior.  Finally, it should be computationally tractable.  The three design choices serve these requirements as you will see.";
    			t99 = space();
    			h30 = element("h3");
    			h30.textContent = "First design choice";
    			t101 = space();
    			p22 = element("p");
    			em4 = element("em");
    			strong4 = element("strong");
    			t102 = text$1("Set of functions indexed by ");
    			html_tag_38 = new HtmlTag();
    			t103 = text$1(".  We specify a set of functions ");
    			html_tag_39 = new HtmlTag();
    			t104 = text$1(", such that there is exactly one member of the set, ");
    			html_tag_40 = new HtmlTag();
    			t105 = text$1(", corresponding to each element ");
    			html_tag_41 = new HtmlTag();
    			t106 = text$1(".  We then use the subset of this set corresponding to our ");
    			html_tag_42 = new HtmlTag();
    			t107 = text$1(" in the dataset to build a solution function as a linear combination of them.  The fact that the functions are already indexed by elements of the domain ");
    			html_tag_43 = new HtmlTag();
    			t108 = text$1(" makes the choice automatic.  There is no hand-specifying a set of functions tailor made for each new data set.  This choice also serves the purpose of regularization, to be proved later.");
    			t109 = space();
    			h31 = element("h3");
    			h31.textContent = "Second design choice";
    			t111 = space();
    			p23 = element("p");
    			em5 = element("em");
    			strong5 = element("strong");
    			strong5.textContent = "Members of the set exhibit linearly independent vectors of evaluation";
    			t113 = text$1(". The members of the set have the following property:  For any value of ");
    			html_tag_44 = new HtmlTag();
    			t114 = text$1(", and for any ");
    			html_tag_45 = new HtmlTag();
    			t115 = text$1(" functions from the set, and for any choice of ");
    			html_tag_46 = new HtmlTag();
    			t116 = text$1(" evaluation points in ");
    			html_tag_47 = new HtmlTag();
    			t117 = text$1(", the set of ");
    			html_tag_48 = new HtmlTag();
    			t118 = space();
    			em6 = element("em");
    			em6.textContent = "vectors of evaluation";
    			t120 = text$1(" of the chosen functions should be linearly independent.  A \"vector of evaluation\" as explained above is my term for the vector of function values in the order of data set points, ");
    			html_tag_49 = new HtmlTag();
    			t121 = text$1(".  This design choice allows the approach to fit any data set, as argued above by appealing to the linear algebra expansion theorem.  This gives the approach arbitrary capacity.  As an aside, there are choices of families that don't have this property, but since we are speaking generally about the approach of Kernel methods, it is important that some families do exhibit this property.");
    			t122 = space();
    			h32 = element("h3");
    			h32.textContent = "Third design choice";
    			t124 = space();
    			p24 = element("p");
    			em7 = element("em");
    			strong6 = element("strong");
    			strong6.textContent = "The functions are in the form of dot products of feature vectors";
    			t126 = text$1(".  This is the biggest leap.  The members of the set are of the form:  ");
    			html_tag_50 = new HtmlTag();
    			t127 = text$1(".  That is, each function is identified by a distinct \"parameter vector\" ");
    			html_tag_51 = new HtmlTag();
    			t128 = text$1(", and the function is defined as the dot product between its parameter vector and some as-yet undefined vector-valued function of the input.  As I will show soon, this third choice provides a way to regularize the method, and makes finding the solution function readily computable.  It also maintains the first goal of having arbitrary capacity to fit any data.  For readers already familiar with literature on Kernel methods, the notion of a \"parameter vector\" is not conventional, but it is my device for motivating Kernels.");
    			t129 = space();
    			p25 = element("p");
    			t130 = text$1("To motivate these ideas and make the discussion more concrete, I first show that the Gaussian set of functions, all with the same ");
    			html_tag_52 = new HtmlTag();
    			t131 = text$1(" and indexed over ");
    			html_tag_53 = new HtmlTag();
    			t132 = text$1(", fit these three design choices.");
    			t133 = space();
    			h22 = element("h2");
    			h22.textContent = "Gaussians have a Dot-product form";
    			t135 = space();
    			p26 = element("p");
    			t136 = text$1("The values of the Gaussian function turn out to be a dot product between two infinite dimensional vectors.  The first vector is a vector-valued function of ");
    			html_tag_54 = new HtmlTag();
    			t137 = text$1(", named as ");
    			html_tag_55 = new HtmlTag();
    			t138 = text$1(".   The second, the same function of ");
    			html_tag_56 = new HtmlTag();
    			t139 = text$1(", named as ");
    			html_tag_57 = new HtmlTag();
    			t140 = text$1(".  Note that the ");
    			html_tag_58 = new HtmlTag();
    			t141 = text$1(" parameter to a Gaussian will determine ");
    			html_tag_59 = new HtmlTag();
    			t142 = text$1(" itself.  ");
    			html_tag_60 = new HtmlTag();
    			t143 = text$1(" is not an argument like ");
    			html_tag_61 = new HtmlTag();
    			t144 = text$1(" is.  So, below we write the function as ");
    			html_tag_62 = new HtmlTag();
    			t145 = text$1(".");
    			t146 = space();
    			p27 = element("p");
    			t147 = text$1("To show this, we first show how the simpler formula ");
    			html_tag_63 = new HtmlTag();
    			t148 = text$1(" can be written as a dot product.  Then, using this first result, we show that ");
    			html_tag_64 = new HtmlTag();
    			t149 = text$1(" can also be written as a dot product.  The Gaussian is just a scaled version with a special choice for ");
    			html_tag_65 = new HtmlTag();
    			t150 = text$1(".");
    			t151 = space();
    			html_tag_66 = new HtmlTag();
    			p28 = element("p");
    			t152 = text$1("Now, using the first result for ");
    			html_tag_67 = new HtmlTag();
    			t153 = text$1(", and letting ");
    			html_tag_68 = new HtmlTag();
    			t154 = text$1(":");
    			t155 = space();
    			html_tag_69 = new HtmlTag();
    			p29 = element("p");
    			t156 = text$1("So we have ");
    			html_tag_70 = new HtmlTag();
    			t157 = text$1(" and all that remains is to scale both vectors by ");
    			html_tag_71 = new HtmlTag();
    			t158 = space();
    			p30 = element("p");
    			t159 = text$1("In particular, the Gaussian ");
    			html_tag_72 = new HtmlTag();
    			t160 = text$1(" is reinterpreted as a two-argument function ");
    			html_tag_73 = new HtmlTag();
    			t161 = text$1(" parameterized by ");
    			html_tag_74 = new HtmlTag();
    			t162 = text$1(", symmetric in the roles of ");
    			html_tag_75 = new HtmlTag();
    			t163 = text$1(" and ");
    			html_tag_76 = new HtmlTag();
    			t164 = text$1(", that is: ");
    			html_tag_77 = new HtmlTag();
    			t165 = text$1(".  In the ");
    			em8 = element("em");
    			em8.textContent = "first design choice";
    			t167 = text$1(", ");
    			html_tag_78 = new HtmlTag();
    			t168 = text$1(" plays the role of indexing the family of functions.  The ");
    			em9 = element("em");
    			em9.textContent = "third design choice";
    			t170 = text$1(" is proven.  The ");
    			em10 = element("em");
    			em10.textContent = "second design choice";
    			t172 = text$1(", that members of the family have arbitrary ability to produce linearly independent vectors of evaluation, has not been proven, but for the moment please accept it.");
    			t173 = space();
    			p31 = element("p");
    			t174 = text$1("Note that the height at the peak of every Gaussian, the location where ");
    			html_tag_79 = new HtmlTag();
    			t175 = text$1(", is the value of ");
    			html_tag_80 = new HtmlTag();
    			t176 = text$1(", implying every feature vector has the same norm since peak heights are the same for all ");
    			html_tag_81 = new HtmlTag();
    			t177 = text$1(".  To simplify the example further, the family of functions used in the worked example are scaled so that peak height = 1.  In particular this means the values of the dot products are simply the cosine of the angle between the two feature vectors, ");
    			html_tag_82 = new HtmlTag();
    			t178 = text$1(".");
    			t179 = space();
    			p32 = element("p");
    			t180 = text$1("The value of the Gaussian as ");
    			html_tag_83 = new HtmlTag();
    			t181 = text$1(" moves far away from ");
    			html_tag_84 = new HtmlTag();
    			t182 = text$1(" approaches zero.  This indicates the angle between the feature vectors asymptotically approaches ");
    			html_tag_85 = new HtmlTag();
    			t183 = text$1(", but never reaches it.  The Gaussian is positive everywhere, therefore the angle ranges in ");
    			html_tag_86 = new HtmlTag();
    			t184 = text$1(" in the infinite dimensional feature space.  In particular, considering three far points ");
    			html_tag_87 = new HtmlTag();
    			t185 = text$1(", their corresponding feature vectors ");
    			html_tag_88 = new HtmlTag();
    			t186 = text$1(" are nearly mutually orthogonal while still having acute angles between them.  In the infinite dimensional feature space, it is possible to have arbitrarily many of these.  The vectors occupy some ");
    			html_tag_89 = new HtmlTag();
    			t187 = text$1("-tant of the space (like an octant in ");
    			html_tag_90 = new HtmlTag();
    			t188 = text$1("), if you will.");
    			t189 = space();
    			h23 = element("h2");
    			h23.textContent = "The mapping between input and Feature Space";
    			t191 = space();
    			p33 = element("p");
    			t192 = text$1("There are two main aims of this article.  The first is to demonstrate that every aspect of Kernel methods is simply a consequence of the classic requirements acting through the three design choices.  The second is to use the worked example of the 1D Gaussian Kernel, and build the habit of simultaneously visualizing the shapes of the curves and their linear combinations in the data domain ");
    			html_tag_91 = new HtmlTag();
    			t193 = text$1(", and their corresponding feature vectors in the feature space, visualizing angles, planes and lengths.");
    			t194 = space();
    			p34 = element("p");
    			p34.textContent = "The following is a list of some of the facts tying the input to the geometry of the feature space.  It can be used as a reference while interacting with the visualizations.";
    			t196 = space();
    			p35 = element("p");
    			t197 = text$1("Denoting the family of Gaussians (all with the same ");
    			html_tag_92 = new HtmlTag();
    			t198 = text$1(") as ");
    			html_tag_93 = new HtmlTag();
    			t199 = text$1(", and the feature space as ");
    			html_tag_94 = new HtmlTag();
    			t200 = text$1(":");
    			t201 = space();
    			ol0 = element("ol");
    			li0 = element("li");
    			p36 = element("p");
    			strong7 = element("strong");
    			strong7.textContent = "Every input has a feature vector";
    			t203 = text$1(".  Every point ");
    			html_tag_95 = new HtmlTag();
    			t204 = text$1(" corresponds to a feature vector ");
    			html_tag_96 = new HtmlTag();
    			t205 = text$1(".");
    			t206 = space();
    			li1 = element("li");
    			p37 = element("p");
    			strong8 = element("strong");
    			strong8.textContent = "Every function has a feature vector";
    			t208 = text$1(".  Every function ");
    			html_tag_97 = new HtmlTag();
    			t209 = text$1(" corresponds to feature vector ");
    			html_tag_98 = new HtmlTag();
    			t210 = text$1(".");
    			t211 = space();
    			li2 = element("li");
    			p38 = element("p");
    			strong9 = element("strong");
    			strong9.textContent = "Every evaluation is a dot product of feature vectors";
    			t213 = text$1(".  The evaluation ");
    			html_tag_99 = new HtmlTag();
    			t214 = text$1(" corresponds to the dot product ");
    			html_tag_100 = new HtmlTag();
    			t215 = text$1(".  It this worked example, since the feature vectors are unit norm, it is the cosine of the angle of feature vectors ");
    			html_tag_101 = new HtmlTag();
    			t216 = text$1(" and ");
    			html_tag_102 = new HtmlTag();
    			t217 = text$1(".  For example, ");
    			html_tag_103 = new HtmlTag();
    			t218 = text$1(" at the peak, and ");
    			html_tag_104 = new HtmlTag();
    			t219 = text$1(" asymptotically towards ");
    			html_tag_105 = new HtmlTag();
    			t220 = text$1(" or ");
    			html_tag_106 = new HtmlTag();
    			t221 = text$1(".");
    			t222 = space();
    			p39 = element("p");
    			p39.textContent = "And, some consequences from this:";
    			t224 = space();
    			ol1 = element("ol");
    			li3 = element("li");
    			p40 = element("p");
    			strong10 = element("strong");
    			strong10.textContent = "A set of functions defines a linear subspace in feature space";
    			t226 = text$1(".  For short, one could call this subspace the ");
    			html_tag_107 = new HtmlTag();
    			t227 = text$1("-span.");
    			t228 = space();
    			li4 = element("li");
    			p41 = element("p");
    			strong11 = element("strong");
    			t229 = text$1("Every linear combination of those functions is a point in the ");
    			html_tag_108 = new HtmlTag();
    			t230 = text$1("-span");
    			t231 = text$1(".  The ");
    			html_tag_109 = new HtmlTag();
    			t232 = text$1(" linear combination of functions ");
    			html_tag_110 = new HtmlTag();
    			t233 = text$1(" corresponds to the ");
    			em11 = element("em");
    			em11.textContent = "same";
    			t235 = space();
    			html_tag_111 = new HtmlTag();
    			t236 = text$1(" linear combination of feature vectors ");
    			html_tag_112 = new HtmlTag();
    			t237 = text$1(".  Although the family functions all have the same feature vector length, in general a linear combination will not.  The goal is to find a single point in the ");
    			html_tag_113 = new HtmlTag();
    			t238 = text$1("-span which fits the data and has other desirable properties.");
    			t239 = space();
    			li5 = element("li");
    			p42 = element("p");
    			strong12 = element("strong");
    			strong12.textContent = "A set of inputs defines a linear subspace in feature space";
    			t241 = text$1(".  For short, one could call this subspace the ");
    			html_tag_114 = new HtmlTag();
    			t242 = text$1("-span.");
    			t243 = space();
    			li6 = element("li");
    			p43 = element("p");
    			strong13 = element("strong");
    			strong13.textContent = "A set of input labels defines a point in that linear subspace";
    			t245 = text$1(".  Every point ");
    			html_tag_115 = new HtmlTag();
    			t246 = text$1(" in the ");
    			html_tag_116 = new HtmlTag();
    			t247 = text$1("-span induces a tuple of dot-product values with the ");
    			html_tag_117 = new HtmlTag();
    			t248 = text$1(" of the ");
    			html_tag_118 = new HtmlTag();
    			t249 = text$1("-span, which also corresponds to its projection ");
    			html_tag_119 = new HtmlTag();
    			t250 = text$1(" onto the ");
    			html_tag_120 = new HtmlTag();
    			t251 = text$1("-span.  Those dot-product values correspond to the labels (");
    			html_tag_121 = new HtmlTag();
    			t252 = text$1(" values).");
    			t253 = space();
    			p44 = element("p");
    			t254 = text$1("As a spoiler, it will be shown that the ");
    			html_tag_122 = new HtmlTag();
    			t255 = text$1("-span and ");
    			html_tag_123 = new HtmlTag();
    			t256 = text$1("-span are chosen to be the same subspace.  The motivation for this choice will be made clear, but it is helpful to distinguish the two conceptually at first.");
    			t257 = space();
    			h24 = element("h2");
    			h24.textContent = "Interactive Figure 1";
    			t259 = space();
    			p45 = element("p");
    			t260 = text$1("Figure 1 has three coordinated panels with different views of the same information.  In the main plot at the top, each gray curve is an individual Gaussian with mean ");
    			html_tag_124 = new HtmlTag();
    			t261 = text$1(" indicated by the triangle at the top edge.  They all share the same ");
    			html_tag_125 = new HtmlTag();
    			t262 = text$1(", controlled by the slider.  Each gray curve is scaled by an ");
    			html_tag_126 = new HtmlTag();
    			t263 = text$1(" shown in a slider to the right.");
    			t264 = space();
    			p46 = element("p");
    			t265 = text$1("You may drag any triangle to change ");
    			html_tag_127 = new HtmlTag();
    			t266 = text$1(" and the corresponding gray curve will follow.  The ");
    			html_tag_128 = new HtmlTag();
    			t267 = text$1(" points are shown as black circles.  You may change them as well.  If ");
    			html_tag_129 = new HtmlTag();
    			t268 = text$1(" tracks ");
    			html_tag_130 = new HtmlTag();
    			t269 = text$1(" is checked, the triangles will follow.");
    			t270 = space();
    			p47 = element("p");
    			t271 = text$1("The blue curve is simply the sum of the gray curves.  Its shape is thus controlled by choices of the ");
    			html_tag_131 = new HtmlTag();
    			t272 = text$1(" and the ");
    			html_tag_132 = new HtmlTag();
    			t273 = text$1(".  If auto solve is checked, the plot will set the ");
    			html_tag_133 = new HtmlTag();
    			t274 = text$1(" to values to fit the ");
    			html_tag_134 = new HtmlTag();
    			t275 = text$1(" data.  While the sliders have a limited range for manual adjustment, the 'auto solve' may set them to very large values positive or negative values depending on the data.");
    			t276 = space();
    			p48 = element("p");
    			t277 = text$1("The heatmap at the lower left is a complete space showing where the information in the main plot is situated.  It shows the values of all Gaussian curves of a particular ");
    			html_tag_135 = new HtmlTag();
    			t278 = text$1(", (0 to 1, white to blue scale).  Each horizontal line shows one curve centered at a particular ");
    			html_tag_136 = new HtmlTag();
    			t279 = text$1(", with ");
    			html_tag_137 = new HtmlTag();
    			t280 = text$1(" increasing downwards.  While the gray curves show the ");
    			html_tag_138 = new HtmlTag();
    			t281 = text$1("-scaled Gaussian, the heatmap shows these Gaussians unscaled so their peak height is 1.  In this worked example of 1D Gaussians, the heatmap depicts the entire family of functions indexed by points in the input domain ");
    			html_tag_139 = new HtmlTag();
    			t282 = space();
    			p49 = element("p");
    			t283 = text$1("The red dots show the current locations of all combinations of ");
    			html_tag_140 = new HtmlTag();
    			t284 = text$1(" and ");
    			html_tag_141 = new HtmlTag();
    			t285 = text$1(".  The heatmap values at the dots in a particular row denote the ");
    			em12 = element("em");
    			em12.textContent = "vector of evaluation";
    			t287 = text$1(" of Gaussian at ");
    			html_tag_142 = new HtmlTag();
    			t288 = text$1(" - that is, height of the gray curve if its ");
    			html_tag_143 = new HtmlTag();
    			t289 = text$1(" were set to 1.  The matrix at the lower right shows these values, organized in the same way.  The same values can be seen as heights of the gray curves at each ");
    			html_tag_144 = new HtmlTag();
    			t290 = text$1(".  Letting the matrix be ");
    			html_tag_145 = new HtmlTag();
    			t291 = text$1(", the vector of evalution of the blue curve is just ");
    			html_tag_146 = new HtmlTag();
    			t292 = text$1(".");
    			t293 = space();
    			p50 = element("p");
    			t294 = text$1("Notice that if all ");
    			html_tag_147 = new HtmlTag();
    			t295 = text$1(" (check ");
    			html_tag_148 = new HtmlTag();
    			t296 = text$1(" tracks ");
    			html_tag_149 = new HtmlTag();
    			t297 = text$1("s), then the diagonals of this matrix are equal to 1 since each unscaled curve has a peak height of 1 at ");
    			html_tag_150 = new HtmlTag();
    			t298 = text$1(".  Furthermore the matrix is symmetric since ");
    			html_tag_151 = new HtmlTag();
    			t299 = text$1(".  It is not symmetric when ");
    			html_tag_152 = new HtmlTag();
    			t300 = text$1(" in general.");
    			t301 = space();
    			h33 = element("h3");
    			h33.textContent = "Some experiments";
    			t303 = space();
    			p51 = element("p");
    			t304 = text$1("Here are some experiments that I found are useful to build intuition.  In the experiments where ");
    			html_tag_153 = new HtmlTag();
    			t305 = text$1(" is not the focus, I'll omit the mention of ");
    			html_tag_154 = new HtmlTag();
    			t306 = text$1(" and abbreviate the feature vector notation ");
    			html_tag_155 = new HtmlTag();
    			t307 = text$1(" as ");
    			html_tag_156 = new HtmlTag();
    			t308 = text$1(".  For linear combinations of feature vectors, I'll use the name of the corresponding function.  For example, ");
    			html_tag_157 = new HtmlTag();
    			t309 = text$1(", with feature vector ");
    			html_tag_158 = new HtmlTag();
    			t310 = text$1(" will be simply notated ");
    			html_tag_159 = new HtmlTag();
    			t311 = text$1(".");
    			t312 = space();
    			p52 = element("p");
    			strong14 = element("strong");
    			strong14.textContent = "Interpolation behavior from a single point";
    			t314 = text$1(".  Click 'Del Point' until there is a single gray curve.  With 'auto solve' checked, drag the black point up and down, and observe how the other values change.  Obviously, points x near ");
    			html_tag_160 = new HtmlTag();
    			t315 = text$1(" change almost the same, while more distant points don't change much.  The central idea here is that height of the gray curve at arbitrary ");
    			html_tag_161 = new HtmlTag();
    			t316 = text$1(" defines defines a kind of similarity with ");
    			html_tag_162 = new HtmlTag();
    			t317 = text$1(".  The ");
    			html_tag_163 = new HtmlTag();
    			t318 = text$1(" scaled gray curve corresponds to the scaled feature vector ");
    			html_tag_164 = new HtmlTag();
    			t319 = text$1(".  Because the evaluations are dot products, and the dot product is linear in each argument, the values of the function at every ");
    			html_tag_165 = new HtmlTag();
    			t320 = text$1(" scale as well.");
    			t321 = space();
    			p53 = element("p");
    			t322 = text$1("Now, if you shrink ");
    			html_tag_166 = new HtmlTag();
    			t323 = text$1(", the similarity of a given point ");
    			html_tag_167 = new HtmlTag();
    			t324 = text$1(" with ");
    			html_tag_168 = new HtmlTag();
    			t325 = text$1(" goes down.  Shrinking ");
    			html_tag_169 = new HtmlTag();
    			t326 = text$1(" results in the shape of the feature vectors changing, although their norm stays the same.  With a very low ");
    			html_tag_170 = new HtmlTag();
    			t327 = text$1(", a smaller neighborhood of points are considered similar, and the rest of them don't move much when the value at ");
    			html_tag_171 = new HtmlTag();
    			t328 = text$1(" is scaled.  ");
    			html_tag_172 = new HtmlTag();
    			t329 = text$1(" thus controls the similarity between ");
    			html_tag_173 = new HtmlTag();
    			t330 = text$1(" and ");
    			html_tag_174 = new HtmlTag();
    			t331 = text$1(" in relation to euclidean distance ");
    			html_tag_175 = new HtmlTag();
    			t332 = text$1(".  In the ");
    			html_tag_176 = new HtmlTag();
    			t333 = text$1(" limit, the gray curve interpolates nothing.  In the ");
    			html_tag_177 = new HtmlTag();
    			t334 = text$1(" limit, every point is considered identical with ");
    			html_tag_178 = new HtmlTag();
    			t335 = text$1(".");
    			t336 = space();
    			p54 = element("p");
    			t337 = text$1("Now, check 'scramble'.  The shape of the curve is now the same except that every other unit interval in ");
    			html_tag_179 = new HtmlTag();
    			t338 = text$1(" has been reversed.  This new shape is piecewise continuous.  Positioning the black point near a discontinuity and move it up and down, you can see that even points very close in ");
    			html_tag_180 = new HtmlTag();
    			t339 = text$1(" distance are not as influenced.  The relation between influence of ");
    			html_tag_181 = new HtmlTag();
    			t340 = text$1(" along the curve and euclidean distance from ");
    			html_tag_182 = new HtmlTag();
    			t341 = text$1(" is no longer monotonic.");
    			t342 = space();
    			p55 = element("p");
    			t343 = text$1("The notion that a similarity measure on pairs of points in ");
    			html_tag_183 = new HtmlTag();
    			t344 = text$1(" may not be related to the geometry of ");
    			html_tag_184 = new HtmlTag();
    			t345 = text$1(" is a central idea in kernel methods.  ");
    			html_tag_185 = new HtmlTag();
    			t346 = text$1(" need not be a continuous domain or even ordered in any way - the corresponding gray \"curves\" would not be curves in that case, but they would be capable of interpolating values assigned to points in the domain.  This gives kernel methods great flexibility.");
    			t347 = space();
    			p56 = element("p");
    			strong15 = element("strong");
    			strong15.textContent = "Interaction between Two Points";
    			t349 = space();
    			p57 = element("p");
    			t350 = text$1("Now increase to two points.  With '");
    			html_tag_186 = new HtmlTag();
    			t351 = text$1(" tracks ");
    			html_tag_187 = new HtmlTag();
    			t352 = text$1("' and 'auto solve' checked, move the two data points well apart, and adjust ");
    			html_tag_188 = new HtmlTag();
    			t353 = text$1(" so the two gray curves are well separated - that is, such that the height at ");
    			html_tag_189 = new HtmlTag();
    			t354 = text$1(" of ");
    			html_tag_190 = new HtmlTag();
    			t355 = text$1(" is near zero, and vice versa.  The off-diagonal elements of the matrix at the bottom right should be nearly white.  The feature vectors ");
    			html_tag_191 = new HtmlTag();
    			t356 = text$1(" and ");
    			html_tag_192 = new HtmlTag();
    			t357 = text$1(" corresponding to these two functions are approaching right angles with each other.");
    			t358 = space();
    			p58 = element("p");
    			t359 = text$1("Now drag one of the data points up and down.  You'll notice that only one of the ");
    			html_tag_193 = new HtmlTag();
    			t360 = text$1(" components moves to solve the curve.  In feature space terms, ");
    			html_tag_194 = new HtmlTag();
    			t361 = text$1(" and ");
    			html_tag_195 = new HtmlTag();
    			t362 = text$1(" are nearly orthogonal.  The goal is to find some linear combination ");
    			html_tag_196 = new HtmlTag();
    			t363 = text$1(" of them such that the signed length (displacement) of the projections ");
    			html_tag_197 = new HtmlTag();
    			t364 = text$1(".   Since the ");
    			html_tag_198 = new HtmlTag();
    			t365 = text$1(", ");
    			html_tag_199 = new HtmlTag();
    			t366 = text$1(" and ");
    			html_tag_200 = new HtmlTag();
    			t367 = text$1(" are the same.  So, scaling one component ");
    			html_tag_201 = new HtmlTag();
    			t368 = text$1(" doesn't affect ");
    			html_tag_202 = new HtmlTag();
    			t369 = text$1(" and vice versa.");
    			t370 = space();
    			p59 = element("p");
    			t371 = text$1("Now move the points closer together, or increase ");
    			html_tag_203 = new HtmlTag();
    			t372 = text$1(", so that the off-diagonal elements are bluish.  Then, moving one of the points influences the other, and both ");
    			html_tag_204 = new HtmlTag();
    			t373 = text$1(" need to be adjusted to find the solution.  A limited visualizatoin of this is available in the second interactive figure.");
    			t374 = space();
    			p60 = element("p");
    			strong16 = element("strong");
    			strong16.textContent = "Exploding Norm";
    			t376 = space();
    			p61 = element("p");
    			t377 = text$1("The blue curve ");
    			html_tag_205 = new HtmlTag();
    			t378 = text$1("'s associated parameter vector's norm is also called the ");
    			em13 = element("em");
    			em13.textContent = "function norm";
    			t380 = text$1(", shown as ");
    			html_tag_206 = new HtmlTag();
    			t381 = text$1(" below the main plot.  For the moment, let's consider only ");
    			html_tag_207 = new HtmlTag();
    			t382 = text$1(" and ignore ");
    			html_tag_208 = new HtmlTag();
    			t383 = text$1(" and ");
    			html_tag_209 = new HtmlTag();
    			t384 = text$1(".");
    			t385 = space();
    			p62 = element("p");
    			t386 = text$1("If you move one of the points very close to the other in the ");
    			html_tag_210 = new HtmlTag();
    			t387 = text$1(" direction, but differing in height, the slope of the curve explodes, as does the magnitude of the ");
    			html_tag_211 = new HtmlTag();
    			t388 = text$1(" and ");
    			html_tag_212 = new HtmlTag();
    			t389 = text$1(".  At a given setting for the ");
    			html_tag_213 = new HtmlTag();
    			t390 = text$1(" with high norm, try reducing ");
    			html_tag_214 = new HtmlTag();
    			t391 = text$1(" until the curves are again well separated, and the function norm will shrink.");
    			t392 = space();
    			p63 = element("p");
    			t393 = text$1("In feature space terms, this situation is the opposite of when ");
    			html_tag_215 = new HtmlTag();
    			t394 = text$1(" and ");
    			html_tag_216 = new HtmlTag();
    			t395 = text$1(" were nearly orthogonal.  Now, they are nearly parallel.  In order for some solution vector ");
    			html_tag_217 = new HtmlTag();
    			t396 = text$1(" to achieve very different projection lengths against nearly parallel vectors, it has to be very long to exploit the slight difference in angle.");
    			t397 = space();
    			p64 = element("p");
    			t398 = text$1("In semantic terms, one interpretation is, an exploding norm indicates the individual component curves overestimate the degree of similarity of that pair of data points, relative to their ");
    			em14 = element("em");
    			em14.textContent = "actual";
    			t400 = text$1(" similarity which is a function of their ");
    			html_tag_218 = new HtmlTag();
    			t401 = text$1(" values.  Adjusting ");
    			html_tag_219 = new HtmlTag();
    			t402 = text$1(" remedies this problem, at the expense of less interpolation.");
    			t403 = space();
    			p65 = element("p");
    			t404 = text$1("Since this worked example is doing exact-fit linear regression, we aren't considering the possibility that the ");
    			html_tag_220 = new HtmlTag();
    			t405 = text$1(" values may have noise.  If that is the case, the interpretation is more complicated.");
    			t406 = space();
    			p66 = element("p");
    			strong17 = element("strong");
    			t407 = text$1("Changing ");
    			html_tag_221 = new HtmlTag();
    			t408 = text$1("-span away from ");
    			html_tag_222 = new HtmlTag();
    			t409 = text$1("-span");
    			t410 = space();
    			p67 = element("p");
    			t411 = text$1("Recall that ");
    			html_tag_223 = new HtmlTag();
    			t412 = text$1(" resides in the ");
    			html_tag_224 = new HtmlTag();
    			t413 = text$1("-span, the ");
    			html_tag_225 = new HtmlTag();
    			t414 = text$1("-dimensional linear subspace ");
    			html_tag_226 = new HtmlTag();
    			t415 = text$1(".   and its projection, ");
    			html_tag_227 = new HtmlTag();
    			t416 = text$1(" resides in the ");
    			html_tag_228 = new HtmlTag();
    			t417 = text$1("-span, ");
    			html_tag_229 = new HtmlTag();
    			t418 = text$1(".  Up until now, ");
    			html_tag_230 = new HtmlTag();
    			t419 = text$1(" and the two spans coincide.  In that case, ");
    			html_tag_231 = new HtmlTag();
    			t420 = text$1(", and ");
    			html_tag_232 = new HtmlTag();
    			t421 = text$1(".\nIf you unlock '");
    			html_tag_233 = new HtmlTag();
    			t422 = text$1(" tracks x', you can drag the triangles (");
    			html_tag_234 = new HtmlTag();
    			t423 = text$1(") or the data points and the two spans are allowed to differ, and the orthogonal decomposition of ");
    			html_tag_235 = new HtmlTag();
    			t424 = text$1(" starts to show.  ");
    			html_tag_236 = new HtmlTag();
    			t425 = text$1(" still shows the length of ");
    			html_tag_237 = new HtmlTag();
    			t426 = text$1(" which exists in the ");
    			html_tag_238 = new HtmlTag();
    			t427 = text$1("-span, but the lengths of orthogonal decomposition ");
    			html_tag_239 = new HtmlTag();
    			t428 = text$1(" taken relative to the ");
    			html_tag_240 = new HtmlTag();
    			t429 = text$1("-span is also shown.  In the limit, the spans are nearly orthogonal, and the parallel component is extremely small, forcing ");
    			html_tag_241 = new HtmlTag();
    			t430 = text$1(" to grow without bound in order to project onto the ");
    			html_tag_242 = new HtmlTag();
    			t431 = text$1("-span any particular solution.");
    			t432 = space();
    			p68 = element("p");
    			t433 = text$1("As mentioned before, this experiment is only for didactic purposes since Kernel methods assign the ");
    			html_tag_243 = new HtmlTag();
    			t434 = text$1("-span to the ");
    			html_tag_244 = new HtmlTag();
    			t435 = text$1("-span.  But, it is worth noting that any new unseen data resides in general outside of the ");
    			html_tag_245 = new HtmlTag();
    			t436 = text$1("-span which is derived from the dataset.  This is a good illustration of why off-manifold data is hard to predict.");
    			t437 = space();
    			h12 = element("h1");
    			h12.textContent = "Experiments to try with Figure 2";
    			t439 = space();
    			create_component(figure2.$$.fragment);
    			t440 = space();
    			p69 = element("p");
    			t441 = text$1("Figure 2 left panel shows the same plot with just two functions.  The right panel shows the 2d ");
    			html_tag_246 = new HtmlTag();
    			t442 = text$1("-span, with the gray vectors denoting ");
    			html_tag_247 = new HtmlTag();
    			t443 = text$1(" and ");
    			html_tag_248 = new HtmlTag();
    			t444 = text$1(", and the blue vector ");
    			html_tag_249 = new HtmlTag();
    			t445 = text$1(".  The black dot on the right panel shows the parameter vector which fits the data.  Not shown are the ");
    			html_tag_250 = new HtmlTag();
    			t446 = text$1("-span or the ");
    			html_tag_251 = new HtmlTag();
    			t447 = text$1(".  However, when ");
    			html_tag_252 = new HtmlTag();
    			t448 = text$1(", they coincide.  In this case, the black dotted lines show the length of the projection of ");
    			html_tag_253 = new HtmlTag();
    			t449 = text$1(" onto each of the ");
    			html_tag_254 = new HtmlTag();
    			t450 = text$1(", which equals ");
    			html_tag_255 = new HtmlTag();
    			t451 = text$1(".  There are a few informative experiments to try.");
    			t452 = space();
    			p70 = element("p");
    			strong18 = element("strong");
    			t453 = text$1("Changing the angle between ");
    			html_tag_256 = new HtmlTag();
    			t454 = text$1(" and ");
    			html_tag_257 = new HtmlTag();
    			t455 = text$1(".  If you drag one of the ");
    			html_tag_258 = new HtmlTag();
    			t456 = text$1(" close to the other one, notice the angle between the gray vectors change.  Dragging them apart causes the gray vectors to asymptotically approach right angles.");
    			t457 = space();
    			p71 = element("p");
    			strong19 = element("strong");
    			t458 = text$1("Nearly orthogonal ");
    			html_tag_259 = new HtmlTag();
    			t459 = text$1(" and ");
    			html_tag_260 = new HtmlTag();
    			t460 = text$1(" have independent contributions to the values of ");
    			html_tag_261 = new HtmlTag();
    			t461 = text$1(" at each ");
    			html_tag_262 = new HtmlTag();
    			t462 = text$1(".  With 'auto solve' and '");
    			html_tag_263 = new HtmlTag();
    			t463 = text$1(" tracks x' checked, on the left panel, drag the black dots well apart on the ");
    			html_tag_264 = new HtmlTag();
    			t464 = text$1(" axis.  Then, drag one dot up and down, observing the motion of the blue arrow on the right panel.  It moves back and forth in the direction of one of the ");
    			html_tag_265 = new HtmlTag();
    			t465 = text$1(" while its projection against the other gray arrow remains nearly constant.");
    			t466 = space();
    			p72 = element("p");
    			strong20 = element("strong");
    			t467 = text$1("Nearly parallel ");
    			html_tag_266 = new HtmlTag();
    			t468 = text$1(" and ");
    			html_tag_267 = new HtmlTag();
    			t469 = text$1(" have highly dependent contributions to the values of ");
    			html_tag_268 = new HtmlTag();
    			t470 = text$1(" at each ");
    			html_tag_269 = new HtmlTag();
    			t471 = text$1(".  With 'auto solve' and '");
    			html_tag_270 = new HtmlTag();
    			t472 = text$1(" tracks x' checked, on the left panel, drag the black dots close together on the ");
    			html_tag_271 = new HtmlTag();
    			t473 = text$1(" axis.  Now, move one of the dots up and down.  Observe that as the ");
    			html_tag_272 = new HtmlTag();
    			t474 = text$1(" values of the dots widen, the blue vector on the right panel must grow very long to achieve the differing projection lengths.");
    			t475 = space();
    			h25 = element("h2");
    			t476 = text$1("Proof that ");
    			html_tag_273 = new HtmlTag();
    			t477 = text$1(" is optimal");
    			t478 = space();
    			p73 = element("p");
    			t479 = text$1("Having highlighted the separate notions of the ");
    			html_tag_274 = new HtmlTag();
    			t480 = text$1("-span and ");
    			html_tag_275 = new HtmlTag();
    			t481 = text$1("-span for conceptual reasons, we now show that the optimal choice is to set the ");
    			html_tag_276 = new HtmlTag();
    			t482 = text$1("-span equal to it.");
    			t483 = space();
    			p74 = element("p");
    			t484 = text$1("The matrix form for a function ");
    			html_tag_277 = new HtmlTag();
    			t485 = text$1("'s associated parameter vector ");
    			html_tag_278 = new HtmlTag();
    			t486 = text$1(", with ");
    			html_tag_279 = new HtmlTag();
    			t487 = text$1(" the matrix of row vectors ");
    			html_tag_280 = new HtmlTag();
    			t488 = text$1(".  ");
    			html_tag_281 = new HtmlTag();
    			t489 = text$1("'s ");
    			em15 = element("em");
    			em15.textContent = "vector of evaluation";
    			t491 = text$1(" on the ");
    			html_tag_282 = new HtmlTag();
    			t492 = text$1(" is then given by ");
    			html_tag_283 = new HtmlTag();
    			t493 = text$1(", where ");
    			html_tag_284 = new HtmlTag();
    			t494 = text$1(" is similarly the matrix of row vectors ");
    			html_tag_285 = new HtmlTag();
    			t495 = text$1(".  We now show why ");
    			html_tag_286 = new HtmlTag();
    			t496 = text$1(" is the optimal choice.");
    			t497 = space();
    			p75 = element("p");
    			t498 = text$1("Suppose ");
    			html_tag_287 = new HtmlTag();
    			t499 = text$1(" for some ");
    			html_tag_288 = new HtmlTag();
    			t500 = text$1(".  By the property of dot products:");
    			t501 = space();
    			html_tag_289 = new HtmlTag();
    			p76 = element("p");
    			p76.textContent = "In matrix form:";
    			t503 = space();
    			html_tag_290 = new HtmlTag();
    			p77 = element("p");
    			html_tag_291 = new HtmlTag();
    			t504 = text$1(" spans either the same subspace as ");
    			html_tag_292 = new HtmlTag();
    			t505 = text$1(", or a subspace of it.  Thus, the choice of ");
    			html_tag_293 = new HtmlTag();
    			t506 = text$1(" (or any choice of ");
    			html_tag_294 = new HtmlTag();
    			t507 = text$1(" such that ");
    			html_tag_295 = new HtmlTag();
    			t508 = text$1(") will be able to fit any set of labels ");
    			html_tag_296 = new HtmlTag();
    			t509 = text$1(" that any other choice of ");
    			html_tag_297 = new HtmlTag();
    			t510 = text$1(" can fit, but possibly more.");
    			t511 = space();
    			p78 = element("p");
    			t512 = text$1("Furthermore, as will be argued in the next section, any two functions having the same vector of evaluation, the one with smaller parameter norm is preferable.  The squared norm ");
    			html_tag_298 = new HtmlTag();
    			t513 = text$1(" is given by:");
    			t514 = space();
    			html_tag_299 = new HtmlTag();
    			h26 = element("h2");
    			h26.textContent = "Regularizing by Minimizing the Function Norm";
    			t516 = space();
    			p79 = element("p");
    			t517 = text$1("There are two properties a function ");
    			html_tag_300 = new HtmlTag();
    			t518 = text$1(" has related to its parameter vector norm ");
    			html_tag_301 = new HtmlTag();
    			t519 = text$1(".  The first is the overall magnitude (positive and negative) of its values.  The second is the magnitude of the difference between pairs of points, relative to how similar those points are by the measure of the family of functions.");
    			t520 = space();
    			p80 = element("p");
    			t521 = text$1("To illustrate, consider two arbitrary inputs ");
    			html_tag_302 = new HtmlTag();
    			t522 = text$1(".  How do  the magnitudes of values ");
    			html_tag_303 = new HtmlTag();
    			t523 = text$1(" and difference in values ");
    			html_tag_304 = new HtmlTag();
    			t524 = text$1(" relate to the norm of its parameter vector?");
    			t525 = space();
    			html_tag_305 = new HtmlTag();
    			p81 = element("p");
    			t526 = text$1("The first inequality tells us that the magnitude of values of the function ");
    			html_tag_306 = new HtmlTag();
    			t527 = text$1(" is bounded by a fixed multiple of ");
    			html_tag_307 = new HtmlTag();
    			t528 = text$1(".  The multiple itself, ");
    			html_tag_308 = new HtmlTag();
    			t529 = text$1(" we have no control over - it is determined by the choice of ");
    			html_tag_309 = new HtmlTag();
    			t530 = text$1(".  But by controlling ");
    			html_tag_310 = new HtmlTag();
    			t531 = text$1(" we can control the range of values of ");
    			html_tag_311 = new HtmlTag();
    			t532 = text$1(".");
    			t533 = space();
    			p82 = element("p");
    			t534 = text$1("The second inequality tells us that the absolute difference in value between any two points is proportional to ");
    			html_tag_312 = new HtmlTag();
    			t535 = text$1(".  As the distance shrinks, the values will be equal.  By bounding ");
    			html_tag_313 = new HtmlTag();
    			t536 = text$1(", we can control how sensitive the function could be to distance between input feature vectors.");
    			t537 = space();
    			p83 = element("p");
    			t538 = text$1("Conversely, if you demand the solution function fit a particular set of fixed ");
    			html_tag_314 = new HtmlTag();
    			t539 = text$1(" and ");
    			html_tag_315 = new HtmlTag();
    			t540 = text$1(" values, that is, ");
    			html_tag_316 = new HtmlTag();
    			t541 = text$1(", then ");
    			html_tag_317 = new HtmlTag();
    			t542 = text$1(" must grow to compensate for small ");
    			html_tag_318 = new HtmlTag();
    			t543 = text$1(".  This is the behavior you observe by dragging one of the black dots close on the ");
    			html_tag_319 = new HtmlTag();
    			t544 = text$1(" axis in 'auto solve' mode, while maintaining a fixed gap in height.  The norm of the function explodes.");
    			t545 = space();
    			p84 = element("p");
    			t546 = text$1("It also says something about the choice of ");
    			html_tag_320 = new HtmlTag();
    			t547 = text$1(".  Ideally, we would like to choose a ");
    			html_tag_321 = new HtmlTag();
    			t548 = text$1(" such that ");
    			html_tag_322 = new HtmlTag();
    			t549 = text$1(" is roughy proportional to ");
    			html_tag_323 = new HtmlTag();
    			t550 = text$1(" in the data set for all pairs ");
    			html_tag_324 = new HtmlTag();
    			t551 = text$1(".");
    			t552 = space();
    			h27 = element("h2");
    			h27.textContent = "Finally, enter the Kernel";
    			t554 = space();
    			p85 = element("p");
    			t555 = text$1("Recall from the previous section that using ");
    			html_tag_325 = new HtmlTag();
    			t556 = text$1(" as the set of parameter vectors ensures 1) the method has arbitrary fitting capacity and 2) the solution will be the lowest norm solution possible.  So we have the following:");
    			t557 = space();
    			html_tag_326 = new HtmlTag();
    			p86 = element("p");
    			t558 = text$1("To find ");
    			html_tag_327 = new HtmlTag();
    			t559 = text$1(", solve:");
    			t560 = space();
    			html_tag_328 = new HtmlTag();
    			p87 = element("p");
    			p87.textContent = "This will minimize to zero if the assumptions above hold.  To compromise between a perfectly fitting function and the bounds the norm provides, instead solve:";
    			t562 = space();
    			html_tag_329 = new HtmlTag();
    			p88 = element("p");
    			p88.textContent = "Finally, to evaluate the function on new data:";
    			t564 = space();
    			html_tag_330 = new HtmlTag();
    			p89 = element("p");
    			t565 = text$1("So we see that the only quantities dependent on the ");
    			html_tag_331 = new HtmlTag();
    			t566 = text$1(" data are dot products ");
    			html_tag_332 = new HtmlTag();
    			t567 = text$1(", appearing in the ");
    			html_tag_333 = new HtmlTag();
    			t568 = text$1(" terms or the solution function.  Finally, we define a function called the \"kernel\" as:");
    			t569 = space();
    			html_tag_334 = new HtmlTag();
    			p90 = element("p");
    			p90.textContent = "Then, the general optimization formula simplifies to:";
    			t571 = space();
    			html_tag_335 = new HtmlTag();
    			p91 = element("p");
    			p91.textContent = "and evaluating the solution function is now written as:";
    			t573 = space();
    			html_tag_336 = new HtmlTag();
    			p92 = element("p");
    			t574 = text$1("Returning back to the plot, you can see that the blue curve evaluated at any given ");
    			html_tag_337 = new HtmlTag();
    			t575 = text$1(" is the ");
    			html_tag_338 = new HtmlTag();
    			t576 = text$1(" weighted sum of scaled gray curves - individual Gaussians with means equal to the ");
    			html_tag_339 = new HtmlTag();
    			t577 = text$1("'s.  Since ");
    			html_tag_340 = new HtmlTag();
    			t578 = text$1(", the expression above is precisely that.");
    			t579 = space();
    			h13 = element("h1");
    			h13.textContent = "Summary and Conclusion";
    			t581 = space();
    			p93 = element("p");
    			t582 = text$1("The Kernel Method allow discovering a function to fit an arbitrary data relationship ");
    			html_tag_341 = new HtmlTag();
    			t583 = text$1(", while at the same time providing a computable means to bound the function's overall magnitude at individual inputs, and the magnitude of the difference at pairs of inputs.");
    			t584 = space();
    			p94 = element("p");
    			t585 = text$1("Kernel methods achieve this by automatically providing a library of functions, one for each ");
    			html_tag_342 = new HtmlTag();
    			t586 = text$1(" in the data set.  When each is evaluated on the ");
    			html_tag_343 = new HtmlTag();
    			t587 = text$1(", they provide linearly independent sets of values.  Thus a unique linear combination of these functions exists to fit any set of target values ");
    			html_tag_344 = new HtmlTag();
    			t588 = text$1(" at the ");
    			html_tag_345 = new HtmlTag();
    			t589 = text$1(".");
    			t590 = space();
    			p95 = element("p");
    			t591 = text$1("The functions are defined as dot products between \"feature vectors\": ");
    			html_tag_346 = new HtmlTag();
    			t592 = text$1(".  This has three main benefits:");
    			t593 = space();
    			ol2 = element("ol");
    			li7 = element("li");
    			p96 = element("p");
    			p96.textContent = "It is possible to prove, using linear algebra alone, that a perfect-fitting solution exists and is of minimal norm.";
    			t595 = space();
    			li8 = element("li");
    			p97 = element("p");
    			p97.textContent = "For further regularization, the Cauchy Schwarz inequality shows the \"function norm\" provides bounds on magnitude of values and differences of pairs of values.";
    			t597 = space();
    			li9 = element("li");
    			p98 = element("p");
    			p98.textContent = "Data fitting and regularization are now purely linear problems, and the arsenal of linear optimization techniques can be applied.";
    			t599 = space();
    			h14 = element("h1");
    			h14.textContent = "Recommended reading and Notes";
    			t601 = space();
    			p99 = element("p");
    			p99.textContent = "In the above essay I intentionally avoided some of the terminology and names of theorems.  When I was learning about Kernel methods, I found that they seemed to hint at giving insight, but ultimately they did not.  Here are some of the concepts, linking them to the above, or a critique why I didn't include them in the main text.";
    			t603 = space();
    			h28 = element("h2");
    			h28.textContent = "Positive (semi)Definite matrices";
    			t605 = space();
    			p100 = element("p");
    			t606 = text$1("It turns out that all square matrices, if they can be written as the product ");
    			html_tag_347 = new HtmlTag();
    			t607 = text$1(" for some ");
    			html_tag_348 = new HtmlTag();
    			t608 = text$1(", are either positive definite (if all rows of ");
    			html_tag_349 = new HtmlTag();
    			t609 = text$1(" are linearly independent), or positive semidefinite (if the rank of ");
    			html_tag_350 = new HtmlTag();
    			t610 = text$1(" is less than its number of rows).  Since the central idea of Kernel methods is constructing functions as dot products, it seemed much more of essence to focus on the construction ");
    			html_tag_351 = new HtmlTag();
    			t611 = text$1(" itself.  This also makes clear why the definition of p.s.d, namely that ");
    			html_tag_352 = new HtmlTag();
    			t612 = text$1(" for all ");
    			html_tag_353 = new HtmlTag();
    			t613 = text$1(" implies that ");
    			html_tag_354 = new HtmlTag();
    			t614 = text$1(" for some ");
    			html_tag_355 = new HtmlTag();
    			t615 = text$1(":  The ");
    			html_tag_356 = new HtmlTag();
    			t616 = text$1(" are simply a basis in a subspace, ");
    			html_tag_357 = new HtmlTag();
    			t617 = text$1(" is a vector, and ");
    			html_tag_358 = new HtmlTag();
    			t618 = text$1(" is the dot product of the vector with itself - its length squared.");
    			t619 = space();
    			h29 = element("h2");
    			h29.textContent = "The Kernel Trick";
    			t621 = space();
    			p101 = element("p");
    			t622 = text$1("The \"kernel trick\" is the idea that a kernel function ");
    			html_tag_359 = new HtmlTag();
    			t623 = text$1(" can be evaluated without actually evaluating the feature vectors and taking their dot product.  While this is important for computational efficiency, it ultimately is uninformative for the purposes of understanding Kernel methods.  Indeed, the Kernel trick doesn't magically allow one to compute exact Gaussian values - doing so would require an infinite amount of computation.  So, whether or not a given kernel has an infinite or finite dimensional feature space, and whether it is implemented approximately or exactly, doesn't really decide its usefulness as a kernel.  In short, the kernel trick is just one form of mathematical shortcut (if it exists), and doesn't really enlighten one as to the nature of Kernel methods.  One could use a Kernel that has only finite capacity and no known Kernel trick, and it could still be a valid Kernel.");
    			t624 = space();
    			h210 = element("h2");
    			h210.textContent = "Distinction between Feature Space and Reproducing Kernel Hilbert Space";
    			t626 = space();
    			p102 = element("p");
    			p102.textContent = "In my reading, I found the discussion of feature space and the 'Hilbert space' (from the RHKS) blurred together.  They are distinct mathematical entities.  Although more subtle results in Kernel research are proved with the help of the RKHS, I didn't feel the basics were much helped by them.  But, in the theory elements in the RKHS map one-to-one to elements in feature space and to functions in input space, so they are sometimes spoken of interchangeably.";
    			t628 = space();
    			p103 = element("p");
    			t629 = text$1("In an effort to disambiguate them, here is a summary.  In Kernel Methods, functions ");
    			html_tag_360 = new HtmlTag();
    			t630 = space();
    			em16 = element("em");
    			em16.textContent = "correspond one-to-one";
    			t632 = text$1(" with feature vectors ");
    			html_tag_361 = new HtmlTag();
    			t633 = text$1(", because of their definition as a dot product.  As any vector space, the feature space has an inner product defined on it, which is the simple dot product, and the ");
    			em17 = element("em");
    			em17.textContent = "kernel matrix";
    			t635 = space();
    			html_tag_362 = new HtmlTag();
    			t636 = text$1(" is the matrix of inner products on a basis ");
    			html_tag_363 = new HtmlTag();
    			t637 = text$1(", the ");
    			html_tag_364 = new HtmlTag();
    			t638 = text$1(" from the dataset, in this feature space.");
    			t639 = space();
    			p104 = element("p");
    			t640 = text$1("Separately from this, the function itself, ");
    			html_tag_365 = new HtmlTag();
    			t641 = text$1(" associates one real value for each ");
    			html_tag_366 = new HtmlTag();
    			t642 = text$1(".  This collection of values could be viewed as the components of ");
    			em18 = element("em");
    			em18.textContent = "another";
    			t644 = text$1(" infinite-dimensional vector.  In conventional notation, ");
    			html_tag_367 = new HtmlTag();
    			t645 = text$1(".  This is like ");
    			html_tag_368 = new HtmlTag();
    			t646 = text$1(",  but instead of 3 real components, ");
    			html_tag_369 = new HtmlTag();
    			t647 = text$1(" components.  Then, the function is not merely ");
    			em19 = element("em");
    			em19.textContent = "corresponding to a vector";
    			t649 = text$1(" but ");
    			em20 = element("em");
    			em20.textContent = "is";
    			t651 = text$1(" a vector.  The space ");
    			html_tag_370 = new HtmlTag();
    			t652 = text$1(" of such functions-as-vectors is known as the Hilbert Space ");
    			html_tag_371 = new HtmlTag();
    			t653 = text$1(".  It has a specific inner product defined on it which links it up to the original feature space: ");
    			html_tag_372 = new HtmlTag();
    			t654 = text$1(".");
    			t655 = space();
    			p105 = element("p");
    			t656 = text$1("Now that the Hilbert space has a set of basis vectors ");
    			html_tag_373 = new HtmlTag();
    			t657 = text$1(", and an inner product, a Kernel matrix ");
    			html_tag_374 = new HtmlTag();
    			t658 = text$1(" can be defined.  But now, note that the rows and columns of the Kernel matrix are vectors of values.  Unlike the feature space, where the rows of the kernel matrix were not of the same type as the vectors in the space itself, in the Hilbert space they are.  Therefore, ");
    			html_tag_375 = new HtmlTag();
    			t659 = text$1(", because this is just a set of inner products between two rows.   This is what gives rise to the phrase \"Reproducing Kernel\".  See ");
    			a0 = element("a");
    			a0.textContent = "https://arxiv.org/pdf/1408.0952.pdf";
    			t661 = text$1(".");
    			t662 = space();
    			h211 = element("h2");
    			h211.textContent = "Representer Theorem";
    			t664 = space();
    			p106 = element("p");
    			t665 = text$1("In the parlance of RHKS theory, the point ");
    			html_tag_376 = new HtmlTag();
    			t666 = text$1(" corresponding to a given ");
    			html_tag_377 = new HtmlTag();
    			t667 = text$1(" is called ");
    			html_tag_378 = new HtmlTag();
    			t668 = text$1("'s ");
    			em21 = element("em");
    			em21.textContent = "representer";
    			t670 = text$1(" of evaluation, and more generally, any point in ");
    			html_tag_379 = new HtmlTag();
    			t671 = text$1(" is a ");
    			em22 = element("em");
    			em22.textContent = "representation";
    			t673 = text$1(" of some function in an abstract way.  So, the Representer Theorem asserts that an optimal solution to a data fitting problem exists in the span of the representers of the data.  That is, in the span of ");
    			html_tag_380 = new HtmlTag();
    			t674 = text$1(".  The section on this article proving through orthogonal decomposition, that setting ");
    			html_tag_381 = new HtmlTag();
    			t675 = text$1(" results in the minimum norm solution without any loss of expressive power, is a simplified version of this theorem.  For more detail, see:  ");
    			a1 = element("a");
    			a1.textContent = "https://alex.smola.org/papers/2001/SchHerSmo01.pdf";
    			add_location(p0, file$1, 0, 0, 0);
    			attr_dev(h10, "id", "introduction");
    			add_location(h10, file$1, 20, 0, 596);
    			add_location(p1, file$1, 21, 0, 636);
    			add_location(p2, file$1, 22, 0, 984);
    			add_location(p3, file$1, 23, 0, 1460);
    			add_location(p4, file$1, 24, 0, 1659);
    			add_location(p5, file$1, 25, 0, 2315);
    			add_location(p6, file$1, 26, 0, 3007);
    			attr_dev(h11, "id", "an-illustration-of-kernel-regression");
    			add_location(h11, file$1, 27, 0, 3342);
    			html_tag.a = t18;
    			html_tag_1.a = t19;
    			html_tag_2.a = t20;
    			html_tag_3.a = t21;
    			add_location(p7, file$1, 28, 0, 3430);
    			html_tag_4.a = t24;
    			html_tag_5.a = t25;
    			html_tag_6.a = t26;
    			add_location(p8, file$1, 29, 0, 3741);
    			html_tag_7.a = t29;
    			add_location(em0, file$1, 30, 138, 4192);
    			html_tag_8.a = t32;
    			html_tag_9.a = t33;
    			html_tag_10.a = t34;
    			add_location(p9, file$1, 30, 0, 4054);
    			html_tag_11.a = t38;
    			html_tag_12.a = t39;
    			add_location(p10, file$1, 35, 0, 4472);
    			add_location(p11, file$1, 36, 0, 4994);
    			html_tag_13.a = t44;
    			html_tag_14.a = t45;
    			html_tag_15.a = t46;
    			html_tag_16.a = t47;
    			add_location(p12, file$1, 37, 0, 5328);
    			add_location(p13, file$1, 38, 0, 5671);
    			html_tag_17.a = p14;
    			html_tag_18.a = t52;
    			html_tag_19.a = t53;
    			html_tag_20.a = t54;
    			html_tag_21.a = t55;
    			html_tag_22.a = t56;
    			html_tag_23.a = t57;
    			add_location(p14, file$1, 46, 4, 6066);
    			html_tag_24.a = t60;
    			add_location(p15, file$1, 47, 0, 6553);
    			attr_dev(h20, "id", "some-observations");
    			add_location(h20, file$1, 48, 0, 6787);
    			html_tag_25.a = t65;
    			add_location(strong0, file$1, 49, 3, 6840);
    			add_location(em1, file$1, 49, 113, 6950);
    			html_tag_26.a = t69;
    			html_tag_27.a = t70;
    			html_tag_28.a = t71;
    			html_tag_29.a = t72;
    			add_location(p16, file$1, 49, 0, 6837);
    			html_tag_30.a = null;
    			add_location(strong1, file$1, 50, 3, 7361);
    			add_location(em2, file$1, 50, 129, 7487);
    			html_tag_31.a = t78;
    			html_tag_32.a = t79;
    			html_tag_33.a = t80;
    			add_location(em3, file$1, 50, 263, 7621);
    			html_tag_34.a = t83;
    			add_location(p17, file$1, 50, 0, 7358);
    			add_location(strong2, file$1, 51, 3, 7789);
    			html_tag_35.a = t87;
    			add_location(p18, file$1, 51, 0, 7786);
    			add_location(strong3, file$1, 52, 3, 8223);
    			html_tag_36.a = t91;
    			add_location(p19, file$1, 52, 0, 8220);
    			html_tag_37.a = t94;
    			add_location(p20, file$1, 53, 0, 9021);
    			attr_dev(h21, "id", "the-three-design-choices-underlying-all-kernel-methods");
    			add_location(h21, file$1, 54, 0, 9326);
    			add_location(p21, file$1, 55, 0, 9450);
    			attr_dev(h30, "id", "first-design-choice");
    			add_location(h30, file$1, 56, 0, 10048);
    			html_tag_38.a = null;
    			add_location(strong4, file$1, 57, 7, 10109);
    			add_location(em4, file$1, 57, 3, 10105);
    			html_tag_39.a = t104;
    			html_tag_40.a = t105;
    			html_tag_41.a = t106;
    			html_tag_42.a = t107;
    			html_tag_43.a = t108;
    			add_location(p22, file$1, 57, 0, 10102);
    			attr_dev(h31, "id", "second-design-choice");
    			add_location(h31, file$1, 58, 0, 10842);
    			add_location(strong5, file$1, 59, 7, 10905);
    			add_location(em5, file$1, 59, 3, 10901);
    			html_tag_44.a = t114;
    			html_tag_45.a = t115;
    			html_tag_46.a = t116;
    			html_tag_47.a = t117;
    			html_tag_48.a = t118;
    			add_location(em6, file$1, 59, 343, 11241);
    			html_tag_49.a = t121;
    			add_location(p23, file$1, 59, 0, 10898);
    			attr_dev(h32, "id", "third-design-choice");
    			add_location(h32, file$1, 60, 0, 11908);
    			add_location(strong6, file$1, 61, 7, 11969);
    			add_location(em7, file$1, 61, 3, 11965);
    			html_tag_50.a = t127;
    			html_tag_51.a = t128;
    			add_location(p24, file$1, 61, 0, 11962);
    			html_tag_52.a = t131;
    			html_tag_53.a = t132;
    			add_location(p25, file$1, 62, 0, 12838);
    			attr_dev(h22, "id", "gaussians-have-a-dot-product-form");
    			add_location(h22, file$1, 63, 0, 13080);
    			html_tag_54.a = t137;
    			html_tag_55.a = t138;
    			html_tag_56.a = t139;
    			html_tag_57.a = t140;
    			html_tag_58.a = t141;
    			html_tag_59.a = t142;
    			html_tag_60.a = t143;
    			html_tag_61.a = t144;
    			html_tag_62.a = t145;
    			add_location(p26, file$1, 64, 0, 13162);
    			html_tag_63.a = t148;
    			html_tag_64.a = t149;
    			html_tag_65.a = t150;
    			add_location(p27, file$1, 65, 0, 13731);
    			html_tag_66.a = p28;
    			html_tag_67.a = t153;
    			html_tag_68.a = t154;
    			add_location(p28, file$1, 73, 4, 14592);
    			html_tag_69.a = p29;
    			html_tag_70.a = t157;
    			html_tag_71.a = null;
    			add_location(p29, file$1, 82, 4, 15344);
    			html_tag_72.a = t160;
    			html_tag_73.a = t161;
    			html_tag_74.a = t162;
    			html_tag_75.a = t163;
    			html_tag_76.a = t164;
    			html_tag_77.a = t165;
    			add_location(em8, file$1, 83, 332, 15877);
    			html_tag_78.a = t168;
    			add_location(em9, file$1, 83, 454, 15999);
    			add_location(em10, file$1, 83, 499, 16044);
    			add_location(p30, file$1, 83, 0, 15545);
    			html_tag_79.a = t175;
    			html_tag_80.a = t176;
    			html_tag_81.a = t177;
    			html_tag_82.a = t178;
    			add_location(p31, file$1, 84, 0, 16242);
    			html_tag_83.a = t181;
    			html_tag_84.a = t182;
    			html_tag_85.a = t183;
    			html_tag_86.a = t184;
    			html_tag_87.a = t185;
    			html_tag_88.a = t186;
    			html_tag_89.a = t187;
    			html_tag_90.a = t188;
    			add_location(p32, file$1, 85, 0, 16888);
    			attr_dev(h23, "id", "the-mapping-between-input-and-feature-space");
    			add_location(h23, file$1, 86, 0, 17732);
    			html_tag_91.a = t193;
    			add_location(p33, file$1, 87, 0, 17834);
    			add_location(p34, file$1, 88, 0, 18381);
    			html_tag_92.a = t198;
    			html_tag_93.a = t199;
    			html_tag_94.a = t200;
    			add_location(p35, file$1, 89, 0, 18561);
    			add_location(strong7, file$1, 91, 7, 18728);
    			html_tag_95.a = t204;
    			html_tag_96.a = t205;
    			add_location(p36, file$1, 91, 4, 18725);
    			add_location(li0, file$1, 91, 0, 18721);
    			add_location(strong8, file$1, 93, 7, 18927);
    			html_tag_97.a = t209;
    			html_tag_98.a = t210;
    			add_location(p37, file$1, 93, 4, 18924);
    			add_location(li1, file$1, 93, 0, 18920);
    			add_location(strong9, file$1, 95, 7, 19148);
    			html_tag_99.a = t214;
    			html_tag_100.a = t215;
    			html_tag_101.a = t216;
    			html_tag_102.a = t217;
    			html_tag_103.a = t218;
    			html_tag_104.a = t219;
    			html_tag_105.a = t220;
    			html_tag_106.a = t221;
    			add_location(p38, file$1, 95, 4, 19145);
    			add_location(li2, file$1, 95, 0, 19141);
    			add_location(ol0, file$1, 90, 0, 18716);
    			add_location(p39, file$1, 98, 0, 19731);
    			add_location(strong10, file$1, 100, 7, 19794);
    			html_tag_107.a = t227;
    			add_location(p40, file$1, 100, 4, 19791);
    			add_location(li3, file$1, 100, 0, 19787);
    			html_tag_108.a = t230;
    			add_location(strong11, file$1, 102, 7, 19959);
    			html_tag_109.a = t232;
    			html_tag_110.a = t233;
    			add_location(em11, file$1, 102, 237, 20189);
    			html_tag_111.a = t236;
    			html_tag_112.a = t237;
    			html_tag_113.a = t238;
    			add_location(p41, file$1, 102, 4, 19956);
    			add_location(li4, file$1, 102, 0, 19952);
    			add_location(strong12, file$1, 104, 7, 20562);
    			html_tag_114.a = t242;
    			add_location(p42, file$1, 104, 4, 20559);
    			add_location(li5, file$1, 104, 0, 20555);
    			add_location(strong13, file$1, 106, 7, 20721);
    			html_tag_115.a = t246;
    			html_tag_116.a = t247;
    			html_tag_117.a = t248;
    			html_tag_118.a = t249;
    			html_tag_119.a = t250;
    			html_tag_120.a = t251;
    			html_tag_121.a = t252;
    			add_location(p43, file$1, 106, 4, 20718);
    			add_location(li6, file$1, 106, 0, 20714);
    			attr_dev(ol1, "start", "4");
    			add_location(ol1, file$1, 99, 0, 19772);
    			html_tag_122.a = t255;
    			html_tag_123.a = t256;
    			add_location(p44, file$1, 109, 0, 21157);
    			attr_dev(h24, "id", "interactive-figure-1");
    			add_location(h24, file$1, 110, 0, 21401);
    			html_tag_124.a = t261;
    			html_tag_125.a = t262;
    			html_tag_126.a = t263;
    			add_location(p45, file$1, 111, 0, 21457);
    			html_tag_127.a = t266;
    			html_tag_128.a = t267;
    			html_tag_129.a = t268;
    			html_tag_130.a = t269;
    			add_location(p46, file$1, 112, 0, 21851);
    			html_tag_131.a = t272;
    			html_tag_132.a = t273;
    			html_tag_133.a = t274;
    			html_tag_134.a = t275;
    			add_location(p47, file$1, 113, 0, 22133);
    			html_tag_135.a = t278;
    			html_tag_136.a = t279;
    			html_tag_137.a = t280;
    			html_tag_138.a = t281;
    			html_tag_139.a = null;
    			add_location(p48, file$1, 114, 0, 22585);
    			html_tag_140.a = t284;
    			html_tag_141.a = t285;
    			add_location(em12, file$1, 115, 169, 23404);
    			html_tag_142.a = t288;
    			html_tag_143.a = t289;
    			html_tag_144.a = t290;
    			html_tag_145.a = t291;
    			html_tag_146.a = t292;
    			add_location(p49, file$1, 115, 0, 23235);
    			html_tag_147.a = t295;
    			html_tag_148.a = t296;
    			html_tag_149.a = t297;
    			html_tag_150.a = t298;
    			html_tag_151.a = t299;
    			html_tag_152.a = t300;
    			add_location(p50, file$1, 116, 0, 23845);
    			attr_dev(h33, "id", "some-experiments");
    			add_location(h33, file$1, 117, 0, 24257);
    			html_tag_153.a = t305;
    			html_tag_154.a = t306;
    			html_tag_155.a = t307;
    			html_tag_156.a = t308;
    			html_tag_157.a = t309;
    			html_tag_158.a = t310;
    			html_tag_159.a = t311;
    			add_location(p51, file$1, 118, 0, 24305);
    			add_location(strong14, file$1, 119, 3, 24894);
    			html_tag_160.a = t315;
    			html_tag_161.a = t316;
    			html_tag_162.a = t317;
    			html_tag_163.a = t318;
    			html_tag_164.a = t319;
    			html_tag_165.a = t320;
    			add_location(p52, file$1, 119, 0, 24891);
    			html_tag_166.a = t323;
    			html_tag_167.a = t324;
    			html_tag_168.a = t325;
    			html_tag_169.a = t326;
    			html_tag_170.a = t327;
    			html_tag_171.a = t328;
    			html_tag_172.a = t329;
    			html_tag_173.a = t330;
    			html_tag_174.a = t331;
    			html_tag_175.a = t332;
    			html_tag_176.a = t333;
    			html_tag_177.a = t334;
    			html_tag_178.a = t335;
    			add_location(p53, file$1, 120, 0, 25688);
    			html_tag_179.a = t338;
    			html_tag_180.a = t339;
    			html_tag_181.a = t340;
    			html_tag_182.a = t341;
    			add_location(p54, file$1, 121, 0, 26478);
    			html_tag_183.a = t344;
    			html_tag_184.a = t345;
    			html_tag_185.a = t346;
    			add_location(p55, file$1, 122, 0, 26992);
    			add_location(strong15, file$1, 123, 3, 27479);
    			add_location(p56, file$1, 123, 0, 27476);
    			html_tag_186.a = t351;
    			html_tag_187.a = t352;
    			html_tag_188.a = t353;
    			html_tag_189.a = t354;
    			html_tag_190.a = t355;
    			html_tag_191.a = t356;
    			html_tag_192.a = t357;
    			add_location(p57, file$1, 124, 0, 27531);
    			html_tag_193.a = t360;
    			html_tag_194.a = t361;
    			html_tag_195.a = t362;
    			html_tag_196.a = t363;
    			html_tag_197.a = t364;
    			html_tag_198.a = t365;
    			html_tag_199.a = t366;
    			html_tag_200.a = t367;
    			html_tag_201.a = t368;
    			html_tag_202.a = t369;
    			add_location(p58, file$1, 125, 0, 28128);
    			html_tag_203.a = t372;
    			html_tag_204.a = t373;
    			add_location(p59, file$1, 126, 0, 28870);
    			add_location(strong16, file$1, 127, 3, 29203);
    			add_location(p60, file$1, 127, 0, 29200);
    			html_tag_205.a = t378;
    			add_location(em13, file$1, 128, 96, 29335);
    			html_tag_206.a = t381;
    			html_tag_207.a = t382;
    			html_tag_208.a = t383;
    			html_tag_209.a = t384;
    			add_location(p61, file$1, 128, 0, 29239);
    			html_tag_210.a = t387;
    			html_tag_211.a = t388;
    			html_tag_212.a = t389;
    			html_tag_213.a = t390;
    			html_tag_214.a = t391;
    			add_location(p62, file$1, 129, 0, 29556);
    			html_tag_215.a = t394;
    			html_tag_216.a = t395;
    			html_tag_217.a = t396;
    			add_location(p63, file$1, 130, 0, 29961);
    			add_location(em14, file$1, 131, 190, 30549);
    			html_tag_218.a = t401;
    			html_tag_219.a = t402;
    			add_location(p64, file$1, 131, 0, 30359);
    			html_tag_220.a = t405;
    			add_location(p65, file$1, 132, 0, 30725);
    			html_tag_221.a = t408;
    			html_tag_222.a = t409;
    			add_location(strong17, file$1, 133, 3, 30951);
    			add_location(p66, file$1, 133, 0, 30948);
    			html_tag_223.a = t412;
    			html_tag_224.a = t413;
    			html_tag_225.a = t414;
    			html_tag_226.a = t415;
    			html_tag_227.a = t416;
    			html_tag_228.a = t417;
    			html_tag_229.a = t418;
    			html_tag_230.a = t419;
    			html_tag_231.a = t420;
    			html_tag_232.a = t421;
    			html_tag_233.a = t422;
    			html_tag_234.a = t423;
    			html_tag_235.a = t424;
    			html_tag_236.a = t425;
    			html_tag_237.a = t426;
    			html_tag_238.a = t427;
    			html_tag_239.a = t428;
    			html_tag_240.a = t429;
    			html_tag_241.a = t430;
    			html_tag_242.a = t431;
    			add_location(p67, file$1, 134, 0, 31032);
    			html_tag_243.a = t434;
    			html_tag_244.a = t435;
    			html_tag_245.a = t436;
    			add_location(p68, file$1, 136, 0, 32287);
    			attr_dev(h12, "id", "experiments-to-try-with-figure-2");
    			add_location(h12, file$1, 137, 0, 32654);
    			html_tag_246.a = t442;
    			html_tag_247.a = t443;
    			html_tag_248.a = t444;
    			html_tag_249.a = t445;
    			html_tag_250.a = t446;
    			html_tag_251.a = t447;
    			html_tag_252.a = t448;
    			html_tag_253.a = t449;
    			html_tag_254.a = t450;
    			html_tag_255.a = t451;
    			add_location(p69, file$1, 140, 0, 32747);
    			html_tag_256.a = t454;
    			html_tag_257.a = null;
    			add_location(strong18, file$1, 141, 3, 33509);
    			html_tag_258.a = t456;
    			add_location(p70, file$1, 141, 0, 33506);
    			html_tag_259.a = t459;
    			html_tag_260.a = t460;
    			html_tag_261.a = t461;
    			html_tag_262.a = null;
    			add_location(strong19, file$1, 142, 3, 33832);
    			html_tag_263.a = t463;
    			html_tag_264.a = t464;
    			html_tag_265.a = t465;
    			add_location(p71, file$1, 142, 0, 33829);
    			html_tag_266.a = t468;
    			html_tag_267.a = t469;
    			html_tag_268.a = t470;
    			html_tag_269.a = null;
    			add_location(strong20, file$1, 143, 3, 34448);
    			html_tag_270.a = t472;
    			html_tag_271.a = t473;
    			html_tag_272.a = t474;
    			add_location(p72, file$1, 143, 0, 34445);
    			html_tag_273.a = t477;
    			attr_dev(h25, "id", "proof-that-html-mu_i--x_i-is-optimal");
    			add_location(h25, file$1, 144, 0, 35014);
    			html_tag_274.a = t480;
    			html_tag_275.a = t481;
    			html_tag_276.a = t482;
    			add_location(p73, file$1, 145, 0, 35112);
    			html_tag_277.a = t485;
    			html_tag_278.a = t486;
    			html_tag_279.a = t487;
    			html_tag_280.a = t488;
    			html_tag_281.a = t489;
    			add_location(em15, file$1, 146, 229, 35549);
    			html_tag_282.a = t492;
    			html_tag_283.a = t493;
    			html_tag_284.a = t494;
    			html_tag_285.a = t495;
    			html_tag_286.a = t496;
    			add_location(p74, file$1, 146, 0, 35320);
    			html_tag_287.a = t499;
    			html_tag_288.a = t500;
    			add_location(p75, file$1, 147, 0, 35817);
    			html_tag_289.a = p76;
    			add_location(p76, file$1, 154, 4, 36318);
    			html_tag_290.a = p77;
    			html_tag_291.a = t504;
    			html_tag_292.a = t505;
    			html_tag_293.a = t506;
    			html_tag_294.a = t507;
    			html_tag_295.a = t508;
    			html_tag_296.a = t509;
    			html_tag_297.a = t510;
    			add_location(p77, file$1, 160, 4, 36584);
    			html_tag_298.a = t513;
    			add_location(p78, file$1, 161, 0, 36994);
    			html_tag_299.a = h26;
    			attr_dev(h26, "id", "regularizing-by-minimizing-the-function-norm");
    			add_location(h26, file$1, 173, 4, 37917);
    			html_tag_300.a = t518;
    			html_tag_301.a = t519;
    			add_location(p79, file$1, 174, 0, 38021);
    			html_tag_302.a = t522;
    			html_tag_303.a = t523;
    			html_tag_304.a = t524;
    			add_location(p80, file$1, 175, 0, 38384);
    			html_tag_305.a = p81;
    			html_tag_306.a = t527;
    			html_tag_307.a = t528;
    			html_tag_308.a = t529;
    			html_tag_309.a = t530;
    			html_tag_310.a = t531;
    			html_tag_311.a = t532;
    			add_location(p81, file$1, 186, 4, 39481);
    			html_tag_312.a = t535;
    			html_tag_313.a = t536;
    			add_location(p82, file$1, 187, 0, 39898);
    			html_tag_314.a = t539;
    			html_tag_315.a = t540;
    			html_tag_316.a = t541;
    			html_tag_317.a = t542;
    			html_tag_318.a = t543;
    			html_tag_319.a = t544;
    			add_location(p83, file$1, 188, 0, 40258);
    			html_tag_320.a = t547;
    			html_tag_321.a = t548;
    			html_tag_322.a = t549;
    			html_tag_323.a = t550;
    			html_tag_324.a = t551;
    			add_location(p84, file$1, 189, 0, 40761);
    			attr_dev(h27, "id", "finally-enter-the-kernel");
    			add_location(h27, file$1, 190, 0, 41086);
    			html_tag_325.a = t556;
    			add_location(p85, file$1, 191, 0, 41151);
    			html_tag_326.a = p86;
    			html_tag_327.a = t559;
    			add_location(p86, file$1, 198, 4, 41689);
    			html_tag_328.a = p87;
    			add_location(p87, file$1, 203, 4, 41872);
    			html_tag_329.a = p88;
    			add_location(p88, file$1, 209, 4, 42384);
    			html_tag_330.a = p89;
    			html_tag_331.a = t566;
    			html_tag_332.a = t567;
    			html_tag_333.a = t568;
    			add_location(p89, file$1, 216, 4, 42658);
    			html_tag_334.a = p90;
    			add_location(p90, file$1, 223, 4, 43237);
    			html_tag_335.a = p91;
    			add_location(p91, file$1, 228, 4, 43463);
    			html_tag_336.a = p92;
    			html_tag_337.a = t575;
    			html_tag_338.a = t576;
    			html_tag_339.a = t577;
    			html_tag_340.a = t578;
    			add_location(p92, file$1, 233, 4, 43626);
    			attr_dev(h13, "id", "summary-and-conclusion");
    			add_location(h13, file$1, 234, 0, 44004);
    			html_tag_341.a = t583;
    			add_location(p93, file$1, 235, 0, 44064);
    			html_tag_342.a = t586;
    			html_tag_343.a = t587;
    			html_tag_344.a = t588;
    			html_tag_345.a = t589;
    			add_location(p94, file$1, 236, 0, 44378);
    			html_tag_346.a = t592;
    			add_location(p95, file$1, 237, 0, 44740);
    			add_location(p96, file$1, 239, 4, 44935);
    			add_location(li7, file$1, 239, 0, 44931);
    			add_location(p97, file$1, 241, 4, 45068);
    			add_location(li8, file$1, 241, 0, 45064);
    			add_location(p98, file$1, 243, 4, 45254);
    			add_location(li9, file$1, 243, 0, 45250);
    			add_location(ol2, file$1, 238, 0, 44926);
    			attr_dev(h14, "id", "recommended-reading-and-notes");
    			add_location(h14, file$1, 246, 0, 45403);
    			add_location(p99, file$1, 247, 0, 45477);
    			attr_dev(h28, "id", "positive-semidefinite-matrices");
    			add_location(h28, file$1, 248, 0, 45819);
    			html_tag_347.a = t607;
    			html_tag_348.a = t608;
    			html_tag_349.a = t609;
    			html_tag_350.a = t610;
    			html_tag_351.a = t611;
    			html_tag_352.a = t612;
    			html_tag_353.a = t613;
    			html_tag_354.a = t614;
    			html_tag_355.a = t615;
    			html_tag_356.a = t616;
    			html_tag_357.a = t617;
    			html_tag_358.a = t618;
    			add_location(p100, file$1, 249, 0, 45897);
    			attr_dev(h29, "id", "the-kernel-trick");
    			add_location(h29, file$1, 250, 0, 46751);
    			html_tag_359.a = t623;
    			add_location(p101, file$1, 251, 0, 46799);
    			attr_dev(h210, "id", "distinction-between-feature-space-and-reproducing-kernel-hilbert-space");
    			add_location(h210, file$1, 252, 0, 47791);
    			add_location(p102, file$1, 253, 0, 47947);
    			html_tag_360.a = t630;
    			add_location(em16, file$1, 254, 150, 48576);
    			html_tag_361.a = t633;
    			add_location(em17, file$1, 254, 437, 48863);
    			html_tag_362.a = t636;
    			html_tag_363.a = t637;
    			html_tag_364.a = t638;
    			add_location(p103, file$1, 254, 0, 48426);
    			html_tag_365.a = t641;
    			html_tag_366.a = t642;
    			add_location(em18, file$1, 255, 206, 49246);
    			html_tag_367.a = t645;
    			html_tag_368.a = t646;
    			html_tag_369.a = t647;
    			add_location(em19, file$1, 255, 483, 49523);
    			add_location(em20, file$1, 255, 522, 49562);
    			html_tag_370.a = t652;
    			html_tag_371.a = t653;
    			html_tag_372.a = t654;
    			add_location(p104, file$1, 255, 0, 49040);
    			html_tag_373.a = t657;
    			html_tag_374.a = t658;
    			html_tag_375.a = t659;
    			attr_dev(a0, "href", "https://arxiv.org/pdf/1408.0952.pdf");
    			add_location(a0, file$1, 256, 587, 50543);
    			add_location(p105, file$1, 256, 0, 49956);
    			attr_dev(h211, "id", "representer-theorem");
    			add_location(h211, file$1, 257, 0, 50634);
    			html_tag_376.a = t666;
    			html_tag_377.a = t667;
    			html_tag_378.a = t668;
    			add_location(em21, file$1, 258, 166, 50854);
    			html_tag_379.a = t671;
    			add_location(em22, file$1, 258, 265, 50953);
    			html_tag_380.a = t674;
    			html_tag_381.a = t675;
    			attr_dev(a1, "href", "https://alex.smola.org/papers/2001/SchHerSmo01.pdf");
    			add_location(a1, file$1, 258, 766, 51454);
    			add_location(p106, file$1, 258, 0, 50688);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			p0.innerHTML = raw0_value;
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h10, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, p3, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, p4, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, p5, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, p6, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, h11, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, p7, anchor);
    			append_dev(p7, t17);
    			html_tag.m(raw1_value, p7);
    			append_dev(p7, t18);
    			html_tag_1.m(raw2_value, p7);
    			append_dev(p7, t19);
    			html_tag_2.m(raw3_value, p7);
    			append_dev(p7, t20);
    			html_tag_3.m(raw4_value, p7);
    			append_dev(p7, t21);
    			insert_dev(target, t22, anchor);
    			insert_dev(target, p8, anchor);
    			append_dev(p8, t23);
    			html_tag_4.m(raw5_value, p8);
    			append_dev(p8, t24);
    			html_tag_5.m(raw6_value, p8);
    			append_dev(p8, t25);
    			html_tag_6.m(raw7_value, p8);
    			append_dev(p8, t26);
    			insert_dev(target, t27, anchor);
    			insert_dev(target, p9, anchor);
    			append_dev(p9, t28);
    			html_tag_7.m(raw8_value, p9);
    			append_dev(p9, t29);
    			append_dev(p9, em0);
    			append_dev(p9, t31);
    			html_tag_8.m(raw9_value, p9);
    			append_dev(p9, t32);
    			html_tag_9.m(raw10_value, p9);
    			append_dev(p9, t33);
    			html_tag_10.m(raw11_value, p9);
    			append_dev(p9, t34);
    			insert_dev(target, t35, anchor);
    			mount_component(figure1, target, anchor);
    			insert_dev(target, t36, anchor);
    			insert_dev(target, p10, anchor);
    			append_dev(p10, t37);
    			html_tag_11.m(raw12_value, p10);
    			append_dev(p10, t38);
    			html_tag_12.m(raw13_value, p10);
    			append_dev(p10, t39);
    			insert_dev(target, t40, anchor);
    			insert_dev(target, p11, anchor);
    			insert_dev(target, t42, anchor);
    			insert_dev(target, p12, anchor);
    			append_dev(p12, t43);
    			html_tag_13.m(raw14_value, p12);
    			append_dev(p12, t44);
    			html_tag_14.m(raw15_value, p12);
    			append_dev(p12, t45);
    			html_tag_15.m(raw16_value, p12);
    			append_dev(p12, t46);
    			html_tag_16.m(raw17_value, p12);
    			append_dev(p12, t47);
    			insert_dev(target, t48, anchor);
    			insert_dev(target, p13, anchor);
    			insert_dev(target, t50, anchor);
    			html_tag_17.m(raw18_value, target, anchor);
    			insert_dev(target, p14, anchor);
    			append_dev(p14, t51);
    			html_tag_18.m(raw19_value, p14);
    			append_dev(p14, t52);
    			html_tag_19.m(raw20_value, p14);
    			append_dev(p14, t53);
    			html_tag_20.m(raw21_value, p14);
    			append_dev(p14, t54);
    			html_tag_21.m(raw22_value, p14);
    			append_dev(p14, t55);
    			html_tag_22.m(raw23_value, p14);
    			append_dev(p14, t56);
    			html_tag_23.m(raw24_value, p14);
    			append_dev(p14, t57);
    			insert_dev(target, t58, anchor);
    			insert_dev(target, p15, anchor);
    			append_dev(p15, t59);
    			html_tag_24.m(raw25_value, p15);
    			append_dev(p15, t60);
    			insert_dev(target, t61, anchor);
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t63, anchor);
    			insert_dev(target, p16, anchor);
    			append_dev(p16, strong0);
    			append_dev(strong0, t64);
    			html_tag_25.m(raw26_value, strong0);
    			append_dev(strong0, t65);
    			append_dev(p16, t66);
    			append_dev(p16, em1);
    			append_dev(p16, t68);
    			html_tag_26.m(raw27_value, p16);
    			append_dev(p16, t69);
    			html_tag_27.m(raw28_value, p16);
    			append_dev(p16, t70);
    			html_tag_28.m(raw29_value, p16);
    			append_dev(p16, t71);
    			html_tag_29.m(raw30_value, p16);
    			append_dev(p16, t72);
    			insert_dev(target, t73, anchor);
    			insert_dev(target, p17, anchor);
    			append_dev(p17, strong1);
    			append_dev(strong1, t74);
    			html_tag_30.m(raw31_value, strong1);
    			append_dev(p17, t75);
    			append_dev(p17, em2);
    			append_dev(p17, t77);
    			html_tag_31.m(raw32_value, p17);
    			append_dev(p17, t78);
    			html_tag_32.m(raw33_value, p17);
    			append_dev(p17, t79);
    			html_tag_33.m(raw34_value, p17);
    			append_dev(p17, t80);
    			append_dev(p17, em3);
    			append_dev(p17, t82);
    			html_tag_34.m(raw35_value, p17);
    			append_dev(p17, t83);
    			insert_dev(target, t84, anchor);
    			insert_dev(target, p18, anchor);
    			append_dev(p18, strong2);
    			append_dev(p18, t86);
    			html_tag_35.m(raw36_value, p18);
    			append_dev(p18, t87);
    			insert_dev(target, t88, anchor);
    			insert_dev(target, p19, anchor);
    			append_dev(p19, strong3);
    			append_dev(p19, t90);
    			html_tag_36.m(raw37_value, p19);
    			append_dev(p19, t91);
    			insert_dev(target, t92, anchor);
    			insert_dev(target, p20, anchor);
    			append_dev(p20, t93);
    			html_tag_37.m(raw38_value, p20);
    			append_dev(p20, t94);
    			insert_dev(target, t95, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t97, anchor);
    			insert_dev(target, p21, anchor);
    			insert_dev(target, t99, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t101, anchor);
    			insert_dev(target, p22, anchor);
    			append_dev(p22, em4);
    			append_dev(em4, strong4);
    			append_dev(strong4, t102);
    			html_tag_38.m(raw39_value, strong4);
    			append_dev(p22, t103);
    			html_tag_39.m(raw40_value, p22);
    			append_dev(p22, t104);
    			html_tag_40.m(raw41_value, p22);
    			append_dev(p22, t105);
    			html_tag_41.m(raw42_value, p22);
    			append_dev(p22, t106);
    			html_tag_42.m(raw43_value, p22);
    			append_dev(p22, t107);
    			html_tag_43.m(raw44_value, p22);
    			append_dev(p22, t108);
    			insert_dev(target, t109, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t111, anchor);
    			insert_dev(target, p23, anchor);
    			append_dev(p23, em5);
    			append_dev(em5, strong5);
    			append_dev(p23, t113);
    			html_tag_44.m(raw45_value, p23);
    			append_dev(p23, t114);
    			html_tag_45.m(raw46_value, p23);
    			append_dev(p23, t115);
    			html_tag_46.m(raw47_value, p23);
    			append_dev(p23, t116);
    			html_tag_47.m(raw48_value, p23);
    			append_dev(p23, t117);
    			html_tag_48.m(raw49_value, p23);
    			append_dev(p23, t118);
    			append_dev(p23, em6);
    			append_dev(p23, t120);
    			html_tag_49.m(raw50_value, p23);
    			append_dev(p23, t121);
    			insert_dev(target, t122, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t124, anchor);
    			insert_dev(target, p24, anchor);
    			append_dev(p24, em7);
    			append_dev(em7, strong6);
    			append_dev(p24, t126);
    			html_tag_50.m(raw51_value, p24);
    			append_dev(p24, t127);
    			html_tag_51.m(raw52_value, p24);
    			append_dev(p24, t128);
    			insert_dev(target, t129, anchor);
    			insert_dev(target, p25, anchor);
    			append_dev(p25, t130);
    			html_tag_52.m(raw53_value, p25);
    			append_dev(p25, t131);
    			html_tag_53.m(raw54_value, p25);
    			append_dev(p25, t132);
    			insert_dev(target, t133, anchor);
    			insert_dev(target, h22, anchor);
    			insert_dev(target, t135, anchor);
    			insert_dev(target, p26, anchor);
    			append_dev(p26, t136);
    			html_tag_54.m(raw55_value, p26);
    			append_dev(p26, t137);
    			html_tag_55.m(raw56_value, p26);
    			append_dev(p26, t138);
    			html_tag_56.m(raw57_value, p26);
    			append_dev(p26, t139);
    			html_tag_57.m(raw58_value, p26);
    			append_dev(p26, t140);
    			html_tag_58.m(raw59_value, p26);
    			append_dev(p26, t141);
    			html_tag_59.m(raw60_value, p26);
    			append_dev(p26, t142);
    			html_tag_60.m(raw61_value, p26);
    			append_dev(p26, t143);
    			html_tag_61.m(raw62_value, p26);
    			append_dev(p26, t144);
    			html_tag_62.m(raw63_value, p26);
    			append_dev(p26, t145);
    			insert_dev(target, t146, anchor);
    			insert_dev(target, p27, anchor);
    			append_dev(p27, t147);
    			html_tag_63.m(raw64_value, p27);
    			append_dev(p27, t148);
    			html_tag_64.m(raw65_value, p27);
    			append_dev(p27, t149);
    			html_tag_65.m(raw66_value, p27);
    			append_dev(p27, t150);
    			insert_dev(target, t151, anchor);
    			html_tag_66.m(raw67_value, target, anchor);
    			insert_dev(target, p28, anchor);
    			append_dev(p28, t152);
    			html_tag_67.m(raw68_value, p28);
    			append_dev(p28, t153);
    			html_tag_68.m(raw69_value, p28);
    			append_dev(p28, t154);
    			insert_dev(target, t155, anchor);
    			html_tag_69.m(raw70_value, target, anchor);
    			insert_dev(target, p29, anchor);
    			append_dev(p29, t156);
    			html_tag_70.m(raw71_value, p29);
    			append_dev(p29, t157);
    			html_tag_71.m(raw72_value, p29);
    			insert_dev(target, t158, anchor);
    			insert_dev(target, p30, anchor);
    			append_dev(p30, t159);
    			html_tag_72.m(raw73_value, p30);
    			append_dev(p30, t160);
    			html_tag_73.m(raw74_value, p30);
    			append_dev(p30, t161);
    			html_tag_74.m(raw75_value, p30);
    			append_dev(p30, t162);
    			html_tag_75.m(raw76_value, p30);
    			append_dev(p30, t163);
    			html_tag_76.m(raw77_value, p30);
    			append_dev(p30, t164);
    			html_tag_77.m(raw78_value, p30);
    			append_dev(p30, t165);
    			append_dev(p30, em8);
    			append_dev(p30, t167);
    			html_tag_78.m(raw79_value, p30);
    			append_dev(p30, t168);
    			append_dev(p30, em9);
    			append_dev(p30, t170);
    			append_dev(p30, em10);
    			append_dev(p30, t172);
    			insert_dev(target, t173, anchor);
    			insert_dev(target, p31, anchor);
    			append_dev(p31, t174);
    			html_tag_79.m(raw80_value, p31);
    			append_dev(p31, t175);
    			html_tag_80.m(raw81_value, p31);
    			append_dev(p31, t176);
    			html_tag_81.m(raw82_value, p31);
    			append_dev(p31, t177);
    			html_tag_82.m(raw83_value, p31);
    			append_dev(p31, t178);
    			insert_dev(target, t179, anchor);
    			insert_dev(target, p32, anchor);
    			append_dev(p32, t180);
    			html_tag_83.m(raw84_value, p32);
    			append_dev(p32, t181);
    			html_tag_84.m(raw85_value, p32);
    			append_dev(p32, t182);
    			html_tag_85.m(raw86_value, p32);
    			append_dev(p32, t183);
    			html_tag_86.m(raw87_value, p32);
    			append_dev(p32, t184);
    			html_tag_87.m(raw88_value, p32);
    			append_dev(p32, t185);
    			html_tag_88.m(raw89_value, p32);
    			append_dev(p32, t186);
    			html_tag_89.m(raw90_value, p32);
    			append_dev(p32, t187);
    			html_tag_90.m(raw91_value, p32);
    			append_dev(p32, t188);
    			insert_dev(target, t189, anchor);
    			insert_dev(target, h23, anchor);
    			insert_dev(target, t191, anchor);
    			insert_dev(target, p33, anchor);
    			append_dev(p33, t192);
    			html_tag_91.m(raw92_value, p33);
    			append_dev(p33, t193);
    			insert_dev(target, t194, anchor);
    			insert_dev(target, p34, anchor);
    			insert_dev(target, t196, anchor);
    			insert_dev(target, p35, anchor);
    			append_dev(p35, t197);
    			html_tag_92.m(raw93_value, p35);
    			append_dev(p35, t198);
    			html_tag_93.m(raw94_value, p35);
    			append_dev(p35, t199);
    			html_tag_94.m(raw95_value, p35);
    			append_dev(p35, t200);
    			insert_dev(target, t201, anchor);
    			insert_dev(target, ol0, anchor);
    			append_dev(ol0, li0);
    			append_dev(li0, p36);
    			append_dev(p36, strong7);
    			append_dev(p36, t203);
    			html_tag_95.m(raw96_value, p36);
    			append_dev(p36, t204);
    			html_tag_96.m(raw97_value, p36);
    			append_dev(p36, t205);
    			append_dev(ol0, t206);
    			append_dev(ol0, li1);
    			append_dev(li1, p37);
    			append_dev(p37, strong8);
    			append_dev(p37, t208);
    			html_tag_97.m(raw98_value, p37);
    			append_dev(p37, t209);
    			html_tag_98.m(raw99_value, p37);
    			append_dev(p37, t210);
    			append_dev(ol0, t211);
    			append_dev(ol0, li2);
    			append_dev(li2, p38);
    			append_dev(p38, strong9);
    			append_dev(p38, t213);
    			html_tag_99.m(raw100_value, p38);
    			append_dev(p38, t214);
    			html_tag_100.m(raw101_value, p38);
    			append_dev(p38, t215);
    			html_tag_101.m(raw102_value, p38);
    			append_dev(p38, t216);
    			html_tag_102.m(raw103_value, p38);
    			append_dev(p38, t217);
    			html_tag_103.m(raw104_value, p38);
    			append_dev(p38, t218);
    			html_tag_104.m(raw105_value, p38);
    			append_dev(p38, t219);
    			html_tag_105.m(raw106_value, p38);
    			append_dev(p38, t220);
    			html_tag_106.m(raw107_value, p38);
    			append_dev(p38, t221);
    			insert_dev(target, t222, anchor);
    			insert_dev(target, p39, anchor);
    			insert_dev(target, t224, anchor);
    			insert_dev(target, ol1, anchor);
    			append_dev(ol1, li3);
    			append_dev(li3, p40);
    			append_dev(p40, strong10);
    			append_dev(p40, t226);
    			html_tag_107.m(raw108_value, p40);
    			append_dev(p40, t227);
    			append_dev(ol1, t228);
    			append_dev(ol1, li4);
    			append_dev(li4, p41);
    			append_dev(p41, strong11);
    			append_dev(strong11, t229);
    			html_tag_108.m(raw109_value, strong11);
    			append_dev(strong11, t230);
    			append_dev(p41, t231);
    			html_tag_109.m(raw110_value, p41);
    			append_dev(p41, t232);
    			html_tag_110.m(raw111_value, p41);
    			append_dev(p41, t233);
    			append_dev(p41, em11);
    			append_dev(p41, t235);
    			html_tag_111.m(raw112_value, p41);
    			append_dev(p41, t236);
    			html_tag_112.m(raw113_value, p41);
    			append_dev(p41, t237);
    			html_tag_113.m(raw114_value, p41);
    			append_dev(p41, t238);
    			append_dev(ol1, t239);
    			append_dev(ol1, li5);
    			append_dev(li5, p42);
    			append_dev(p42, strong12);
    			append_dev(p42, t241);
    			html_tag_114.m(raw115_value, p42);
    			append_dev(p42, t242);
    			append_dev(ol1, t243);
    			append_dev(ol1, li6);
    			append_dev(li6, p43);
    			append_dev(p43, strong13);
    			append_dev(p43, t245);
    			html_tag_115.m(raw116_value, p43);
    			append_dev(p43, t246);
    			html_tag_116.m(raw117_value, p43);
    			append_dev(p43, t247);
    			html_tag_117.m(raw118_value, p43);
    			append_dev(p43, t248);
    			html_tag_118.m(raw119_value, p43);
    			append_dev(p43, t249);
    			html_tag_119.m(raw120_value, p43);
    			append_dev(p43, t250);
    			html_tag_120.m(raw121_value, p43);
    			append_dev(p43, t251);
    			html_tag_121.m(raw122_value, p43);
    			append_dev(p43, t252);
    			insert_dev(target, t253, anchor);
    			insert_dev(target, p44, anchor);
    			append_dev(p44, t254);
    			html_tag_122.m(raw123_value, p44);
    			append_dev(p44, t255);
    			html_tag_123.m(raw124_value, p44);
    			append_dev(p44, t256);
    			insert_dev(target, t257, anchor);
    			insert_dev(target, h24, anchor);
    			insert_dev(target, t259, anchor);
    			insert_dev(target, p45, anchor);
    			append_dev(p45, t260);
    			html_tag_124.m(raw125_value, p45);
    			append_dev(p45, t261);
    			html_tag_125.m(raw126_value, p45);
    			append_dev(p45, t262);
    			html_tag_126.m(raw127_value, p45);
    			append_dev(p45, t263);
    			insert_dev(target, t264, anchor);
    			insert_dev(target, p46, anchor);
    			append_dev(p46, t265);
    			html_tag_127.m(raw128_value, p46);
    			append_dev(p46, t266);
    			html_tag_128.m(raw129_value, p46);
    			append_dev(p46, t267);
    			html_tag_129.m(raw130_value, p46);
    			append_dev(p46, t268);
    			html_tag_130.m(raw131_value, p46);
    			append_dev(p46, t269);
    			insert_dev(target, t270, anchor);
    			insert_dev(target, p47, anchor);
    			append_dev(p47, t271);
    			html_tag_131.m(raw132_value, p47);
    			append_dev(p47, t272);
    			html_tag_132.m(raw133_value, p47);
    			append_dev(p47, t273);
    			html_tag_133.m(raw134_value, p47);
    			append_dev(p47, t274);
    			html_tag_134.m(raw135_value, p47);
    			append_dev(p47, t275);
    			insert_dev(target, t276, anchor);
    			insert_dev(target, p48, anchor);
    			append_dev(p48, t277);
    			html_tag_135.m(raw136_value, p48);
    			append_dev(p48, t278);
    			html_tag_136.m(raw137_value, p48);
    			append_dev(p48, t279);
    			html_tag_137.m(raw138_value, p48);
    			append_dev(p48, t280);
    			html_tag_138.m(raw139_value, p48);
    			append_dev(p48, t281);
    			html_tag_139.m(raw140_value, p48);
    			insert_dev(target, t282, anchor);
    			insert_dev(target, p49, anchor);
    			append_dev(p49, t283);
    			html_tag_140.m(raw141_value, p49);
    			append_dev(p49, t284);
    			html_tag_141.m(raw142_value, p49);
    			append_dev(p49, t285);
    			append_dev(p49, em12);
    			append_dev(p49, t287);
    			html_tag_142.m(raw143_value, p49);
    			append_dev(p49, t288);
    			html_tag_143.m(raw144_value, p49);
    			append_dev(p49, t289);
    			html_tag_144.m(raw145_value, p49);
    			append_dev(p49, t290);
    			html_tag_145.m(raw146_value, p49);
    			append_dev(p49, t291);
    			html_tag_146.m(raw147_value, p49);
    			append_dev(p49, t292);
    			insert_dev(target, t293, anchor);
    			insert_dev(target, p50, anchor);
    			append_dev(p50, t294);
    			html_tag_147.m(raw148_value, p50);
    			append_dev(p50, t295);
    			html_tag_148.m(raw149_value, p50);
    			append_dev(p50, t296);
    			html_tag_149.m(raw150_value, p50);
    			append_dev(p50, t297);
    			html_tag_150.m(raw151_value, p50);
    			append_dev(p50, t298);
    			html_tag_151.m(raw152_value, p50);
    			append_dev(p50, t299);
    			html_tag_152.m(raw153_value, p50);
    			append_dev(p50, t300);
    			insert_dev(target, t301, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t303, anchor);
    			insert_dev(target, p51, anchor);
    			append_dev(p51, t304);
    			html_tag_153.m(raw154_value, p51);
    			append_dev(p51, t305);
    			html_tag_154.m(raw155_value, p51);
    			append_dev(p51, t306);
    			html_tag_155.m(raw156_value, p51);
    			append_dev(p51, t307);
    			html_tag_156.m(raw157_value, p51);
    			append_dev(p51, t308);
    			html_tag_157.m(raw158_value, p51);
    			append_dev(p51, t309);
    			html_tag_158.m(raw159_value, p51);
    			append_dev(p51, t310);
    			html_tag_159.m(raw160_value, p51);
    			append_dev(p51, t311);
    			insert_dev(target, t312, anchor);
    			insert_dev(target, p52, anchor);
    			append_dev(p52, strong14);
    			append_dev(p52, t314);
    			html_tag_160.m(raw161_value, p52);
    			append_dev(p52, t315);
    			html_tag_161.m(raw162_value, p52);
    			append_dev(p52, t316);
    			html_tag_162.m(raw163_value, p52);
    			append_dev(p52, t317);
    			html_tag_163.m(raw164_value, p52);
    			append_dev(p52, t318);
    			html_tag_164.m(raw165_value, p52);
    			append_dev(p52, t319);
    			html_tag_165.m(raw166_value, p52);
    			append_dev(p52, t320);
    			insert_dev(target, t321, anchor);
    			insert_dev(target, p53, anchor);
    			append_dev(p53, t322);
    			html_tag_166.m(raw167_value, p53);
    			append_dev(p53, t323);
    			html_tag_167.m(raw168_value, p53);
    			append_dev(p53, t324);
    			html_tag_168.m(raw169_value, p53);
    			append_dev(p53, t325);
    			html_tag_169.m(raw170_value, p53);
    			append_dev(p53, t326);
    			html_tag_170.m(raw171_value, p53);
    			append_dev(p53, t327);
    			html_tag_171.m(raw172_value, p53);
    			append_dev(p53, t328);
    			html_tag_172.m(raw173_value, p53);
    			append_dev(p53, t329);
    			html_tag_173.m(raw174_value, p53);
    			append_dev(p53, t330);
    			html_tag_174.m(raw175_value, p53);
    			append_dev(p53, t331);
    			html_tag_175.m(raw176_value, p53);
    			append_dev(p53, t332);
    			html_tag_176.m(raw177_value, p53);
    			append_dev(p53, t333);
    			html_tag_177.m(raw178_value, p53);
    			append_dev(p53, t334);
    			html_tag_178.m(raw179_value, p53);
    			append_dev(p53, t335);
    			insert_dev(target, t336, anchor);
    			insert_dev(target, p54, anchor);
    			append_dev(p54, t337);
    			html_tag_179.m(raw180_value, p54);
    			append_dev(p54, t338);
    			html_tag_180.m(raw181_value, p54);
    			append_dev(p54, t339);
    			html_tag_181.m(raw182_value, p54);
    			append_dev(p54, t340);
    			html_tag_182.m(raw183_value, p54);
    			append_dev(p54, t341);
    			insert_dev(target, t342, anchor);
    			insert_dev(target, p55, anchor);
    			append_dev(p55, t343);
    			html_tag_183.m(raw184_value, p55);
    			append_dev(p55, t344);
    			html_tag_184.m(raw185_value, p55);
    			append_dev(p55, t345);
    			html_tag_185.m(raw186_value, p55);
    			append_dev(p55, t346);
    			insert_dev(target, t347, anchor);
    			insert_dev(target, p56, anchor);
    			append_dev(p56, strong15);
    			insert_dev(target, t349, anchor);
    			insert_dev(target, p57, anchor);
    			append_dev(p57, t350);
    			html_tag_186.m(raw187_value, p57);
    			append_dev(p57, t351);
    			html_tag_187.m(raw188_value, p57);
    			append_dev(p57, t352);
    			html_tag_188.m(raw189_value, p57);
    			append_dev(p57, t353);
    			html_tag_189.m(raw190_value, p57);
    			append_dev(p57, t354);
    			html_tag_190.m(raw191_value, p57);
    			append_dev(p57, t355);
    			html_tag_191.m(raw192_value, p57);
    			append_dev(p57, t356);
    			html_tag_192.m(raw193_value, p57);
    			append_dev(p57, t357);
    			insert_dev(target, t358, anchor);
    			insert_dev(target, p58, anchor);
    			append_dev(p58, t359);
    			html_tag_193.m(raw194_value, p58);
    			append_dev(p58, t360);
    			html_tag_194.m(raw195_value, p58);
    			append_dev(p58, t361);
    			html_tag_195.m(raw196_value, p58);
    			append_dev(p58, t362);
    			html_tag_196.m(raw197_value, p58);
    			append_dev(p58, t363);
    			html_tag_197.m(raw198_value, p58);
    			append_dev(p58, t364);
    			html_tag_198.m(raw199_value, p58);
    			append_dev(p58, t365);
    			html_tag_199.m(raw200_value, p58);
    			append_dev(p58, t366);
    			html_tag_200.m(raw201_value, p58);
    			append_dev(p58, t367);
    			html_tag_201.m(raw202_value, p58);
    			append_dev(p58, t368);
    			html_tag_202.m(raw203_value, p58);
    			append_dev(p58, t369);
    			insert_dev(target, t370, anchor);
    			insert_dev(target, p59, anchor);
    			append_dev(p59, t371);
    			html_tag_203.m(raw204_value, p59);
    			append_dev(p59, t372);
    			html_tag_204.m(raw205_value, p59);
    			append_dev(p59, t373);
    			insert_dev(target, t374, anchor);
    			insert_dev(target, p60, anchor);
    			append_dev(p60, strong16);
    			insert_dev(target, t376, anchor);
    			insert_dev(target, p61, anchor);
    			append_dev(p61, t377);
    			html_tag_205.m(raw206_value, p61);
    			append_dev(p61, t378);
    			append_dev(p61, em13);
    			append_dev(p61, t380);
    			html_tag_206.m(raw207_value, p61);
    			append_dev(p61, t381);
    			html_tag_207.m(raw208_value, p61);
    			append_dev(p61, t382);
    			html_tag_208.m(raw209_value, p61);
    			append_dev(p61, t383);
    			html_tag_209.m(raw210_value, p61);
    			append_dev(p61, t384);
    			insert_dev(target, t385, anchor);
    			insert_dev(target, p62, anchor);
    			append_dev(p62, t386);
    			html_tag_210.m(raw211_value, p62);
    			append_dev(p62, t387);
    			html_tag_211.m(raw212_value, p62);
    			append_dev(p62, t388);
    			html_tag_212.m(raw213_value, p62);
    			append_dev(p62, t389);
    			html_tag_213.m(raw214_value, p62);
    			append_dev(p62, t390);
    			html_tag_214.m(raw215_value, p62);
    			append_dev(p62, t391);
    			insert_dev(target, t392, anchor);
    			insert_dev(target, p63, anchor);
    			append_dev(p63, t393);
    			html_tag_215.m(raw216_value, p63);
    			append_dev(p63, t394);
    			html_tag_216.m(raw217_value, p63);
    			append_dev(p63, t395);
    			html_tag_217.m(raw218_value, p63);
    			append_dev(p63, t396);
    			insert_dev(target, t397, anchor);
    			insert_dev(target, p64, anchor);
    			append_dev(p64, t398);
    			append_dev(p64, em14);
    			append_dev(p64, t400);
    			html_tag_218.m(raw219_value, p64);
    			append_dev(p64, t401);
    			html_tag_219.m(raw220_value, p64);
    			append_dev(p64, t402);
    			insert_dev(target, t403, anchor);
    			insert_dev(target, p65, anchor);
    			append_dev(p65, t404);
    			html_tag_220.m(raw221_value, p65);
    			append_dev(p65, t405);
    			insert_dev(target, t406, anchor);
    			insert_dev(target, p66, anchor);
    			append_dev(p66, strong17);
    			append_dev(strong17, t407);
    			html_tag_221.m(raw222_value, strong17);
    			append_dev(strong17, t408);
    			html_tag_222.m(raw223_value, strong17);
    			append_dev(strong17, t409);
    			insert_dev(target, t410, anchor);
    			insert_dev(target, p67, anchor);
    			append_dev(p67, t411);
    			html_tag_223.m(raw224_value, p67);
    			append_dev(p67, t412);
    			html_tag_224.m(raw225_value, p67);
    			append_dev(p67, t413);
    			html_tag_225.m(raw226_value, p67);
    			append_dev(p67, t414);
    			html_tag_226.m(raw227_value, p67);
    			append_dev(p67, t415);
    			html_tag_227.m(raw228_value, p67);
    			append_dev(p67, t416);
    			html_tag_228.m(raw229_value, p67);
    			append_dev(p67, t417);
    			html_tag_229.m(raw230_value, p67);
    			append_dev(p67, t418);
    			html_tag_230.m(raw231_value, p67);
    			append_dev(p67, t419);
    			html_tag_231.m(raw232_value, p67);
    			append_dev(p67, t420);
    			html_tag_232.m(raw233_value, p67);
    			append_dev(p67, t421);
    			html_tag_233.m(raw234_value, p67);
    			append_dev(p67, t422);
    			html_tag_234.m(raw235_value, p67);
    			append_dev(p67, t423);
    			html_tag_235.m(raw236_value, p67);
    			append_dev(p67, t424);
    			html_tag_236.m(raw237_value, p67);
    			append_dev(p67, t425);
    			html_tag_237.m(raw238_value, p67);
    			append_dev(p67, t426);
    			html_tag_238.m(raw239_value, p67);
    			append_dev(p67, t427);
    			html_tag_239.m(raw240_value, p67);
    			append_dev(p67, t428);
    			html_tag_240.m(raw241_value, p67);
    			append_dev(p67, t429);
    			html_tag_241.m(raw242_value, p67);
    			append_dev(p67, t430);
    			html_tag_242.m(raw243_value, p67);
    			append_dev(p67, t431);
    			insert_dev(target, t432, anchor);
    			insert_dev(target, p68, anchor);
    			append_dev(p68, t433);
    			html_tag_243.m(raw244_value, p68);
    			append_dev(p68, t434);
    			html_tag_244.m(raw245_value, p68);
    			append_dev(p68, t435);
    			html_tag_245.m(raw246_value, p68);
    			append_dev(p68, t436);
    			insert_dev(target, t437, anchor);
    			insert_dev(target, h12, anchor);
    			insert_dev(target, t439, anchor);
    			mount_component(figure2, target, anchor);
    			insert_dev(target, t440, anchor);
    			insert_dev(target, p69, anchor);
    			append_dev(p69, t441);
    			html_tag_246.m(raw247_value, p69);
    			append_dev(p69, t442);
    			html_tag_247.m(raw248_value, p69);
    			append_dev(p69, t443);
    			html_tag_248.m(raw249_value, p69);
    			append_dev(p69, t444);
    			html_tag_249.m(raw250_value, p69);
    			append_dev(p69, t445);
    			html_tag_250.m(raw251_value, p69);
    			append_dev(p69, t446);
    			html_tag_251.m(raw252_value, p69);
    			append_dev(p69, t447);
    			html_tag_252.m(raw253_value, p69);
    			append_dev(p69, t448);
    			html_tag_253.m(raw254_value, p69);
    			append_dev(p69, t449);
    			html_tag_254.m(raw255_value, p69);
    			append_dev(p69, t450);
    			html_tag_255.m(raw256_value, p69);
    			append_dev(p69, t451);
    			insert_dev(target, t452, anchor);
    			insert_dev(target, p70, anchor);
    			append_dev(p70, strong18);
    			append_dev(strong18, t453);
    			html_tag_256.m(raw257_value, strong18);
    			append_dev(strong18, t454);
    			html_tag_257.m(raw258_value, strong18);
    			append_dev(p70, t455);
    			html_tag_258.m(raw259_value, p70);
    			append_dev(p70, t456);
    			insert_dev(target, t457, anchor);
    			insert_dev(target, p71, anchor);
    			append_dev(p71, strong19);
    			append_dev(strong19, t458);
    			html_tag_259.m(raw260_value, strong19);
    			append_dev(strong19, t459);
    			html_tag_260.m(raw261_value, strong19);
    			append_dev(strong19, t460);
    			html_tag_261.m(raw262_value, strong19);
    			append_dev(strong19, t461);
    			html_tag_262.m(raw263_value, strong19);
    			append_dev(p71, t462);
    			html_tag_263.m(raw264_value, p71);
    			append_dev(p71, t463);
    			html_tag_264.m(raw265_value, p71);
    			append_dev(p71, t464);
    			html_tag_265.m(raw266_value, p71);
    			append_dev(p71, t465);
    			insert_dev(target, t466, anchor);
    			insert_dev(target, p72, anchor);
    			append_dev(p72, strong20);
    			append_dev(strong20, t467);
    			html_tag_266.m(raw267_value, strong20);
    			append_dev(strong20, t468);
    			html_tag_267.m(raw268_value, strong20);
    			append_dev(strong20, t469);
    			html_tag_268.m(raw269_value, strong20);
    			append_dev(strong20, t470);
    			html_tag_269.m(raw270_value, strong20);
    			append_dev(p72, t471);
    			html_tag_270.m(raw271_value, p72);
    			append_dev(p72, t472);
    			html_tag_271.m(raw272_value, p72);
    			append_dev(p72, t473);
    			html_tag_272.m(raw273_value, p72);
    			append_dev(p72, t474);
    			insert_dev(target, t475, anchor);
    			insert_dev(target, h25, anchor);
    			append_dev(h25, t476);
    			html_tag_273.m(raw274_value, h25);
    			append_dev(h25, t477);
    			insert_dev(target, t478, anchor);
    			insert_dev(target, p73, anchor);
    			append_dev(p73, t479);
    			html_tag_274.m(raw275_value, p73);
    			append_dev(p73, t480);
    			html_tag_275.m(raw276_value, p73);
    			append_dev(p73, t481);
    			html_tag_276.m(raw277_value, p73);
    			append_dev(p73, t482);
    			insert_dev(target, t483, anchor);
    			insert_dev(target, p74, anchor);
    			append_dev(p74, t484);
    			html_tag_277.m(raw278_value, p74);
    			append_dev(p74, t485);
    			html_tag_278.m(raw279_value, p74);
    			append_dev(p74, t486);
    			html_tag_279.m(raw280_value, p74);
    			append_dev(p74, t487);
    			html_tag_280.m(raw281_value, p74);
    			append_dev(p74, t488);
    			html_tag_281.m(raw282_value, p74);
    			append_dev(p74, t489);
    			append_dev(p74, em15);
    			append_dev(p74, t491);
    			html_tag_282.m(raw283_value, p74);
    			append_dev(p74, t492);
    			html_tag_283.m(raw284_value, p74);
    			append_dev(p74, t493);
    			html_tag_284.m(raw285_value, p74);
    			append_dev(p74, t494);
    			html_tag_285.m(raw286_value, p74);
    			append_dev(p74, t495);
    			html_tag_286.m(raw287_value, p74);
    			append_dev(p74, t496);
    			insert_dev(target, t497, anchor);
    			insert_dev(target, p75, anchor);
    			append_dev(p75, t498);
    			html_tag_287.m(raw288_value, p75);
    			append_dev(p75, t499);
    			html_tag_288.m(raw289_value, p75);
    			append_dev(p75, t500);
    			insert_dev(target, t501, anchor);
    			html_tag_289.m(raw290_value, target, anchor);
    			insert_dev(target, p76, anchor);
    			insert_dev(target, t503, anchor);
    			html_tag_290.m(raw291_value, target, anchor);
    			insert_dev(target, p77, anchor);
    			html_tag_291.m(raw292_value, p77);
    			append_dev(p77, t504);
    			html_tag_292.m(raw293_value, p77);
    			append_dev(p77, t505);
    			html_tag_293.m(raw294_value, p77);
    			append_dev(p77, t506);
    			html_tag_294.m(raw295_value, p77);
    			append_dev(p77, t507);
    			html_tag_295.m(raw296_value, p77);
    			append_dev(p77, t508);
    			html_tag_296.m(raw297_value, p77);
    			append_dev(p77, t509);
    			html_tag_297.m(raw298_value, p77);
    			append_dev(p77, t510);
    			insert_dev(target, t511, anchor);
    			insert_dev(target, p78, anchor);
    			append_dev(p78, t512);
    			html_tag_298.m(raw299_value, p78);
    			append_dev(p78, t513);
    			insert_dev(target, t514, anchor);
    			html_tag_299.m(raw300_value, target, anchor);
    			insert_dev(target, h26, anchor);
    			insert_dev(target, t516, anchor);
    			insert_dev(target, p79, anchor);
    			append_dev(p79, t517);
    			html_tag_300.m(raw301_value, p79);
    			append_dev(p79, t518);
    			html_tag_301.m(raw302_value, p79);
    			append_dev(p79, t519);
    			insert_dev(target, t520, anchor);
    			insert_dev(target, p80, anchor);
    			append_dev(p80, t521);
    			html_tag_302.m(raw303_value, p80);
    			append_dev(p80, t522);
    			html_tag_303.m(raw304_value, p80);
    			append_dev(p80, t523);
    			html_tag_304.m(raw305_value, p80);
    			append_dev(p80, t524);
    			insert_dev(target, t525, anchor);
    			html_tag_305.m(raw306_value, target, anchor);
    			insert_dev(target, p81, anchor);
    			append_dev(p81, t526);
    			html_tag_306.m(raw307_value, p81);
    			append_dev(p81, t527);
    			html_tag_307.m(raw308_value, p81);
    			append_dev(p81, t528);
    			html_tag_308.m(raw309_value, p81);
    			append_dev(p81, t529);
    			html_tag_309.m(raw310_value, p81);
    			append_dev(p81, t530);
    			html_tag_310.m(raw311_value, p81);
    			append_dev(p81, t531);
    			html_tag_311.m(raw312_value, p81);
    			append_dev(p81, t532);
    			insert_dev(target, t533, anchor);
    			insert_dev(target, p82, anchor);
    			append_dev(p82, t534);
    			html_tag_312.m(raw313_value, p82);
    			append_dev(p82, t535);
    			html_tag_313.m(raw314_value, p82);
    			append_dev(p82, t536);
    			insert_dev(target, t537, anchor);
    			insert_dev(target, p83, anchor);
    			append_dev(p83, t538);
    			html_tag_314.m(raw315_value, p83);
    			append_dev(p83, t539);
    			html_tag_315.m(raw316_value, p83);
    			append_dev(p83, t540);
    			html_tag_316.m(raw317_value, p83);
    			append_dev(p83, t541);
    			html_tag_317.m(raw318_value, p83);
    			append_dev(p83, t542);
    			html_tag_318.m(raw319_value, p83);
    			append_dev(p83, t543);
    			html_tag_319.m(raw320_value, p83);
    			append_dev(p83, t544);
    			insert_dev(target, t545, anchor);
    			insert_dev(target, p84, anchor);
    			append_dev(p84, t546);
    			html_tag_320.m(raw321_value, p84);
    			append_dev(p84, t547);
    			html_tag_321.m(raw322_value, p84);
    			append_dev(p84, t548);
    			html_tag_322.m(raw323_value, p84);
    			append_dev(p84, t549);
    			html_tag_323.m(raw324_value, p84);
    			append_dev(p84, t550);
    			html_tag_324.m(raw325_value, p84);
    			append_dev(p84, t551);
    			insert_dev(target, t552, anchor);
    			insert_dev(target, h27, anchor);
    			insert_dev(target, t554, anchor);
    			insert_dev(target, p85, anchor);
    			append_dev(p85, t555);
    			html_tag_325.m(raw326_value, p85);
    			append_dev(p85, t556);
    			insert_dev(target, t557, anchor);
    			html_tag_326.m(raw327_value, target, anchor);
    			insert_dev(target, p86, anchor);
    			append_dev(p86, t558);
    			html_tag_327.m(raw328_value, p86);
    			append_dev(p86, t559);
    			insert_dev(target, t560, anchor);
    			html_tag_328.m(raw329_value, target, anchor);
    			insert_dev(target, p87, anchor);
    			insert_dev(target, t562, anchor);
    			html_tag_329.m(raw330_value, target, anchor);
    			insert_dev(target, p88, anchor);
    			insert_dev(target, t564, anchor);
    			html_tag_330.m(raw331_value, target, anchor);
    			insert_dev(target, p89, anchor);
    			append_dev(p89, t565);
    			html_tag_331.m(raw332_value, p89);
    			append_dev(p89, t566);
    			html_tag_332.m(raw333_value, p89);
    			append_dev(p89, t567);
    			html_tag_333.m(raw334_value, p89);
    			append_dev(p89, t568);
    			insert_dev(target, t569, anchor);
    			html_tag_334.m(raw335_value, target, anchor);
    			insert_dev(target, p90, anchor);
    			insert_dev(target, t571, anchor);
    			html_tag_335.m(raw336_value, target, anchor);
    			insert_dev(target, p91, anchor);
    			insert_dev(target, t573, anchor);
    			html_tag_336.m(raw337_value, target, anchor);
    			insert_dev(target, p92, anchor);
    			append_dev(p92, t574);
    			html_tag_337.m(raw338_value, p92);
    			append_dev(p92, t575);
    			html_tag_338.m(raw339_value, p92);
    			append_dev(p92, t576);
    			html_tag_339.m(raw340_value, p92);
    			append_dev(p92, t577);
    			html_tag_340.m(raw341_value, p92);
    			append_dev(p92, t578);
    			insert_dev(target, t579, anchor);
    			insert_dev(target, h13, anchor);
    			insert_dev(target, t581, anchor);
    			insert_dev(target, p93, anchor);
    			append_dev(p93, t582);
    			html_tag_341.m(raw342_value, p93);
    			append_dev(p93, t583);
    			insert_dev(target, t584, anchor);
    			insert_dev(target, p94, anchor);
    			append_dev(p94, t585);
    			html_tag_342.m(raw343_value, p94);
    			append_dev(p94, t586);
    			html_tag_343.m(raw344_value, p94);
    			append_dev(p94, t587);
    			html_tag_344.m(raw345_value, p94);
    			append_dev(p94, t588);
    			html_tag_345.m(raw346_value, p94);
    			append_dev(p94, t589);
    			insert_dev(target, t590, anchor);
    			insert_dev(target, p95, anchor);
    			append_dev(p95, t591);
    			html_tag_346.m(raw347_value, p95);
    			append_dev(p95, t592);
    			insert_dev(target, t593, anchor);
    			insert_dev(target, ol2, anchor);
    			append_dev(ol2, li7);
    			append_dev(li7, p96);
    			append_dev(ol2, t595);
    			append_dev(ol2, li8);
    			append_dev(li8, p97);
    			append_dev(ol2, t597);
    			append_dev(ol2, li9);
    			append_dev(li9, p98);
    			insert_dev(target, t599, anchor);
    			insert_dev(target, h14, anchor);
    			insert_dev(target, t601, anchor);
    			insert_dev(target, p99, anchor);
    			insert_dev(target, t603, anchor);
    			insert_dev(target, h28, anchor);
    			insert_dev(target, t605, anchor);
    			insert_dev(target, p100, anchor);
    			append_dev(p100, t606);
    			html_tag_347.m(raw348_value, p100);
    			append_dev(p100, t607);
    			html_tag_348.m(raw349_value, p100);
    			append_dev(p100, t608);
    			html_tag_349.m(raw350_value, p100);
    			append_dev(p100, t609);
    			html_tag_350.m(raw351_value, p100);
    			append_dev(p100, t610);
    			html_tag_351.m(raw352_value, p100);
    			append_dev(p100, t611);
    			html_tag_352.m(raw353_value, p100);
    			append_dev(p100, t612);
    			html_tag_353.m(raw354_value, p100);
    			append_dev(p100, t613);
    			html_tag_354.m(raw355_value, p100);
    			append_dev(p100, t614);
    			html_tag_355.m(raw356_value, p100);
    			append_dev(p100, t615);
    			html_tag_356.m(raw357_value, p100);
    			append_dev(p100, t616);
    			html_tag_357.m(raw358_value, p100);
    			append_dev(p100, t617);
    			html_tag_358.m(raw359_value, p100);
    			append_dev(p100, t618);
    			insert_dev(target, t619, anchor);
    			insert_dev(target, h29, anchor);
    			insert_dev(target, t621, anchor);
    			insert_dev(target, p101, anchor);
    			append_dev(p101, t622);
    			html_tag_359.m(raw360_value, p101);
    			append_dev(p101, t623);
    			insert_dev(target, t624, anchor);
    			insert_dev(target, h210, anchor);
    			insert_dev(target, t626, anchor);
    			insert_dev(target, p102, anchor);
    			insert_dev(target, t628, anchor);
    			insert_dev(target, p103, anchor);
    			append_dev(p103, t629);
    			html_tag_360.m(raw361_value, p103);
    			append_dev(p103, t630);
    			append_dev(p103, em16);
    			append_dev(p103, t632);
    			html_tag_361.m(raw362_value, p103);
    			append_dev(p103, t633);
    			append_dev(p103, em17);
    			append_dev(p103, t635);
    			html_tag_362.m(raw363_value, p103);
    			append_dev(p103, t636);
    			html_tag_363.m(raw364_value, p103);
    			append_dev(p103, t637);
    			html_tag_364.m(raw365_value, p103);
    			append_dev(p103, t638);
    			insert_dev(target, t639, anchor);
    			insert_dev(target, p104, anchor);
    			append_dev(p104, t640);
    			html_tag_365.m(raw366_value, p104);
    			append_dev(p104, t641);
    			html_tag_366.m(raw367_value, p104);
    			append_dev(p104, t642);
    			append_dev(p104, em18);
    			append_dev(p104, t644);
    			html_tag_367.m(raw368_value, p104);
    			append_dev(p104, t645);
    			html_tag_368.m(raw369_value, p104);
    			append_dev(p104, t646);
    			html_tag_369.m(raw370_value, p104);
    			append_dev(p104, t647);
    			append_dev(p104, em19);
    			append_dev(p104, t649);
    			append_dev(p104, em20);
    			append_dev(p104, t651);
    			html_tag_370.m(raw371_value, p104);
    			append_dev(p104, t652);
    			html_tag_371.m(raw372_value, p104);
    			append_dev(p104, t653);
    			html_tag_372.m(raw373_value, p104);
    			append_dev(p104, t654);
    			insert_dev(target, t655, anchor);
    			insert_dev(target, p105, anchor);
    			append_dev(p105, t656);
    			html_tag_373.m(raw374_value, p105);
    			append_dev(p105, t657);
    			html_tag_374.m(raw375_value, p105);
    			append_dev(p105, t658);
    			html_tag_375.m(raw376_value, p105);
    			append_dev(p105, t659);
    			append_dev(p105, a0);
    			append_dev(p105, t661);
    			insert_dev(target, t662, anchor);
    			insert_dev(target, h211, anchor);
    			insert_dev(target, t664, anchor);
    			insert_dev(target, p106, anchor);
    			append_dev(p106, t665);
    			html_tag_376.m(raw377_value, p106);
    			append_dev(p106, t666);
    			html_tag_377.m(raw378_value, p106);
    			append_dev(p106, t667);
    			html_tag_378.m(raw379_value, p106);
    			append_dev(p106, t668);
    			append_dev(p106, em21);
    			append_dev(p106, t670);
    			html_tag_379.m(raw380_value, p106);
    			append_dev(p106, t671);
    			append_dev(p106, em22);
    			append_dev(p106, t673);
    			html_tag_380.m(raw381_value, p106);
    			append_dev(p106, t674);
    			html_tag_381.m(raw382_value, p106);
    			append_dev(p106, t675);
    			append_dev(p106, a1);
    			current = true;
    		},
    		p: noop$5,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(figure1.$$.fragment, local);
    			transition_in(figure2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(figure1.$$.fragment, local);
    			transition_out(figure2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h10);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(p4);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(p5);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(p6);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(h11);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(p7);
    			if (detaching) detach_dev(t22);
    			if (detaching) detach_dev(p8);
    			if (detaching) detach_dev(t27);
    			if (detaching) detach_dev(p9);
    			if (detaching) detach_dev(t35);
    			destroy_component(figure1, detaching);
    			if (detaching) detach_dev(t36);
    			if (detaching) detach_dev(p10);
    			if (detaching) detach_dev(t40);
    			if (detaching) detach_dev(p11);
    			if (detaching) detach_dev(t42);
    			if (detaching) detach_dev(p12);
    			if (detaching) detach_dev(t48);
    			if (detaching) detach_dev(p13);
    			if (detaching) detach_dev(t50);
    			if (detaching) html_tag_17.d();
    			if (detaching) detach_dev(p14);
    			if (detaching) detach_dev(t58);
    			if (detaching) detach_dev(p15);
    			if (detaching) detach_dev(t61);
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t63);
    			if (detaching) detach_dev(p16);
    			if (detaching) detach_dev(t73);
    			if (detaching) detach_dev(p17);
    			if (detaching) detach_dev(t84);
    			if (detaching) detach_dev(p18);
    			if (detaching) detach_dev(t88);
    			if (detaching) detach_dev(p19);
    			if (detaching) detach_dev(t92);
    			if (detaching) detach_dev(p20);
    			if (detaching) detach_dev(t95);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t97);
    			if (detaching) detach_dev(p21);
    			if (detaching) detach_dev(t99);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t101);
    			if (detaching) detach_dev(p22);
    			if (detaching) detach_dev(t109);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t111);
    			if (detaching) detach_dev(p23);
    			if (detaching) detach_dev(t122);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t124);
    			if (detaching) detach_dev(p24);
    			if (detaching) detach_dev(t129);
    			if (detaching) detach_dev(p25);
    			if (detaching) detach_dev(t133);
    			if (detaching) detach_dev(h22);
    			if (detaching) detach_dev(t135);
    			if (detaching) detach_dev(p26);
    			if (detaching) detach_dev(t146);
    			if (detaching) detach_dev(p27);
    			if (detaching) detach_dev(t151);
    			if (detaching) html_tag_66.d();
    			if (detaching) detach_dev(p28);
    			if (detaching) detach_dev(t155);
    			if (detaching) html_tag_69.d();
    			if (detaching) detach_dev(p29);
    			if (detaching) detach_dev(t158);
    			if (detaching) detach_dev(p30);
    			if (detaching) detach_dev(t173);
    			if (detaching) detach_dev(p31);
    			if (detaching) detach_dev(t179);
    			if (detaching) detach_dev(p32);
    			if (detaching) detach_dev(t189);
    			if (detaching) detach_dev(h23);
    			if (detaching) detach_dev(t191);
    			if (detaching) detach_dev(p33);
    			if (detaching) detach_dev(t194);
    			if (detaching) detach_dev(p34);
    			if (detaching) detach_dev(t196);
    			if (detaching) detach_dev(p35);
    			if (detaching) detach_dev(t201);
    			if (detaching) detach_dev(ol0);
    			if (detaching) detach_dev(t222);
    			if (detaching) detach_dev(p39);
    			if (detaching) detach_dev(t224);
    			if (detaching) detach_dev(ol1);
    			if (detaching) detach_dev(t253);
    			if (detaching) detach_dev(p44);
    			if (detaching) detach_dev(t257);
    			if (detaching) detach_dev(h24);
    			if (detaching) detach_dev(t259);
    			if (detaching) detach_dev(p45);
    			if (detaching) detach_dev(t264);
    			if (detaching) detach_dev(p46);
    			if (detaching) detach_dev(t270);
    			if (detaching) detach_dev(p47);
    			if (detaching) detach_dev(t276);
    			if (detaching) detach_dev(p48);
    			if (detaching) detach_dev(t282);
    			if (detaching) detach_dev(p49);
    			if (detaching) detach_dev(t293);
    			if (detaching) detach_dev(p50);
    			if (detaching) detach_dev(t301);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t303);
    			if (detaching) detach_dev(p51);
    			if (detaching) detach_dev(t312);
    			if (detaching) detach_dev(p52);
    			if (detaching) detach_dev(t321);
    			if (detaching) detach_dev(p53);
    			if (detaching) detach_dev(t336);
    			if (detaching) detach_dev(p54);
    			if (detaching) detach_dev(t342);
    			if (detaching) detach_dev(p55);
    			if (detaching) detach_dev(t347);
    			if (detaching) detach_dev(p56);
    			if (detaching) detach_dev(t349);
    			if (detaching) detach_dev(p57);
    			if (detaching) detach_dev(t358);
    			if (detaching) detach_dev(p58);
    			if (detaching) detach_dev(t370);
    			if (detaching) detach_dev(p59);
    			if (detaching) detach_dev(t374);
    			if (detaching) detach_dev(p60);
    			if (detaching) detach_dev(t376);
    			if (detaching) detach_dev(p61);
    			if (detaching) detach_dev(t385);
    			if (detaching) detach_dev(p62);
    			if (detaching) detach_dev(t392);
    			if (detaching) detach_dev(p63);
    			if (detaching) detach_dev(t397);
    			if (detaching) detach_dev(p64);
    			if (detaching) detach_dev(t403);
    			if (detaching) detach_dev(p65);
    			if (detaching) detach_dev(t406);
    			if (detaching) detach_dev(p66);
    			if (detaching) detach_dev(t410);
    			if (detaching) detach_dev(p67);
    			if (detaching) detach_dev(t432);
    			if (detaching) detach_dev(p68);
    			if (detaching) detach_dev(t437);
    			if (detaching) detach_dev(h12);
    			if (detaching) detach_dev(t439);
    			destroy_component(figure2, detaching);
    			if (detaching) detach_dev(t440);
    			if (detaching) detach_dev(p69);
    			if (detaching) detach_dev(t452);
    			if (detaching) detach_dev(p70);
    			if (detaching) detach_dev(t457);
    			if (detaching) detach_dev(p71);
    			if (detaching) detach_dev(t466);
    			if (detaching) detach_dev(p72);
    			if (detaching) detach_dev(t475);
    			if (detaching) detach_dev(h25);
    			if (detaching) detach_dev(t478);
    			if (detaching) detach_dev(p73);
    			if (detaching) detach_dev(t483);
    			if (detaching) detach_dev(p74);
    			if (detaching) detach_dev(t497);
    			if (detaching) detach_dev(p75);
    			if (detaching) detach_dev(t501);
    			if (detaching) html_tag_289.d();
    			if (detaching) detach_dev(p76);
    			if (detaching) detach_dev(t503);
    			if (detaching) html_tag_290.d();
    			if (detaching) detach_dev(p77);
    			if (detaching) detach_dev(t511);
    			if (detaching) detach_dev(p78);
    			if (detaching) detach_dev(t514);
    			if (detaching) html_tag_299.d();
    			if (detaching) detach_dev(h26);
    			if (detaching) detach_dev(t516);
    			if (detaching) detach_dev(p79);
    			if (detaching) detach_dev(t520);
    			if (detaching) detach_dev(p80);
    			if (detaching) detach_dev(t525);
    			if (detaching) html_tag_305.d();
    			if (detaching) detach_dev(p81);
    			if (detaching) detach_dev(t533);
    			if (detaching) detach_dev(p82);
    			if (detaching) detach_dev(t537);
    			if (detaching) detach_dev(p83);
    			if (detaching) detach_dev(t545);
    			if (detaching) detach_dev(p84);
    			if (detaching) detach_dev(t552);
    			if (detaching) detach_dev(h27);
    			if (detaching) detach_dev(t554);
    			if (detaching) detach_dev(p85);
    			if (detaching) detach_dev(t557);
    			if (detaching) html_tag_326.d();
    			if (detaching) detach_dev(p86);
    			if (detaching) detach_dev(t560);
    			if (detaching) html_tag_328.d();
    			if (detaching) detach_dev(p87);
    			if (detaching) detach_dev(t562);
    			if (detaching) html_tag_329.d();
    			if (detaching) detach_dev(p88);
    			if (detaching) detach_dev(t564);
    			if (detaching) html_tag_330.d();
    			if (detaching) detach_dev(p89);
    			if (detaching) detach_dev(t569);
    			if (detaching) html_tag_334.d();
    			if (detaching) detach_dev(p90);
    			if (detaching) detach_dev(t571);
    			if (detaching) html_tag_335.d();
    			if (detaching) detach_dev(p91);
    			if (detaching) detach_dev(t573);
    			if (detaching) html_tag_336.d();
    			if (detaching) detach_dev(p92);
    			if (detaching) detach_dev(t579);
    			if (detaching) detach_dev(h13);
    			if (detaching) detach_dev(t581);
    			if (detaching) detach_dev(p93);
    			if (detaching) detach_dev(t584);
    			if (detaching) detach_dev(p94);
    			if (detaching) detach_dev(t590);
    			if (detaching) detach_dev(p95);
    			if (detaching) detach_dev(t593);
    			if (detaching) detach_dev(ol2);
    			if (detaching) detach_dev(t599);
    			if (detaching) detach_dev(h14);
    			if (detaching) detach_dev(t601);
    			if (detaching) detach_dev(p99);
    			if (detaching) detach_dev(t603);
    			if (detaching) detach_dev(h28);
    			if (detaching) detach_dev(t605);
    			if (detaching) detach_dev(p100);
    			if (detaching) detach_dev(t619);
    			if (detaching) detach_dev(h29);
    			if (detaching) detach_dev(t621);
    			if (detaching) detach_dev(p101);
    			if (detaching) detach_dev(t624);
    			if (detaching) detach_dev(h210);
    			if (detaching) detach_dev(t626);
    			if (detaching) detach_dev(p102);
    			if (detaching) detach_dev(t628);
    			if (detaching) detach_dev(p103);
    			if (detaching) detach_dev(t639);
    			if (detaching) detach_dev(p104);
    			if (detaching) detach_dev(t655);
    			if (detaching) detach_dev(p105);
    			if (detaching) detach_dev(t662);
    			if (detaching) detach_dev(h211);
    			if (detaching) detach_dev(t664);
    			if (detaching) detach_dev(p106);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Kernel_methods', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Kernel_methods> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Figure1, Figure2 });
    	return [];
    }

    class Kernel_methods extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Kernel_methods",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.40.2 */
    const file = "src/App.svelte";

    function create_fragment(ctx) {
    	let article;
    	let kernelmethods;
    	let current;
    	kernelmethods = new Kernel_methods({ $$inline: true });

    	const block = {
    		c: function create() {
    			article = element("article");
    			create_component(kernelmethods.$$.fragment);
    			attr_dev(article, "class", "svelte-1qj6pij");
    			add_location(article, file, 5, 0, 75);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, article, anchor);
    			mount_component(kernelmethods, article, null);
    			current = true;
    		},
    		p: noop$5,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kernelmethods.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kernelmethods.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(article);
    			destroy_component(kernelmethods);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ KernelMethods: Kernel_methods });
    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    function get_target() {
      var sel;
      if (location.hostname.endsWith('ghost.io'))
        sel = 'main -> article > section';
      else
        sel = 'body';

      return document.querySelector(sel);
    }

    const app = new App({
    	target: get_target(),
      props: { }
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
