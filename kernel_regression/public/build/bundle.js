
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$5() { }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function empty$3() {
        return text$1('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }
    function update_await_block_branch(info, ctx, dirty) {
        const child_ctx = ctx.slice();
        const { resolved } = info;
        if (info.current === info.then) {
            child_ctx[info.value] = resolved;
        }
        if (info.current === info.catch) {
            child_ctx[info.error] = resolved;
        }
        info.block.p(child_ctx, dirty);
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$5,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$5;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.40.2' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /* src/kernel_methods.md generated by Svelte v3.40.2 */

    const file$a = "src/kernel_methods.md";

    function create_fragment$a(ctx) {
    	let h10;
    	let t1;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let p2;
    	let t7;
    	let p3;
    	let t9;
    	let p4;
    	let t11;
    	let p5;
    	let t13;
    	let h11;
    	let t15;
    	let p6;
    	let t16;
    	let d_math0;

    	let raw0_value = `(x_i, y_i)
` + "";

    	let t17;
    	let d_math1;

    	let raw1_value = `x_i
` + "";

    	let t18;
    	let d_math2;

    	let raw2_value = `(\\alpha_1, \\cdots, \\alpha_n)
` + "";

    	let t19;
    	let d_math3;

    	let raw3_value = `\\alpha_i
` + "";

    	let t20;
    	let t21;
    	let p7;
    	let t22;
    	let d_math4;

    	let raw4_value = `y_i
` + "";

    	let t23;
    	let d_math5;

    	let raw5_value = `\\alpha
` + "";

    	let t24;
    	let d_math6;

    	let raw6_value = `(x_i, y_i)
` + "";

    	let t25;
    	let t26;
    	let p8;
    	let t27;
    	let d_math7;

    	let raw7_value = `x_i
` + "";

    	let t28;
    	let em0;
    	let t30;
    	let d_math8;

    	let raw8_value = `k_j(x)
` + "";

    	let t31;
    	let d_math9;

    	let raw9_value = `(k_j(x_1), k_j(x_2), \\cdots, k_j(x_n))
` + "";

    	let t32;
    	let d_math10;

    	let raw10_value = `(x_1, x_2, \\cdots, x_n)
` + "";

    	let t33;
    	let t34;
    	let p9;
    	let t35;
    	let d_math11;

    	let raw11_value = `x_i
` + "";

    	let t36;
    	let d_math12;

    	let raw12_value = `(x_i, y_i)
` + "";

    	let t37;
    	let t38;
    	let p10;
    	let t40;
    	let p11;
    	let t41;
    	let d_math13;

    	let raw13_value = `\\sigma
` + "";

    	let t42;
    	let d_math14;

    	let raw14_value = `n
` + "";

    	let t43;
    	let d_math15;

    	let raw15_value = `\\mathbb{R}^n
` + "";

    	let t44;
    	let d_math16;

    	let raw16_value = `(y_i)
` + "";

    	let t45;
    	let t46;
    	let p12;
    	let t48;
    	let d_math17;

    	let raw17_value = `
\\begin{aligned}
k_j(x) & & \\text{Gaussians centered at $x_j$, $j = 1 .. n$} \\\\
f(x) & \\equiv \\sum_j { \\alpha_j k_j(x) } & \\text{the blue curve}\\\\
f(x_i) & = \\sum_j { \\alpha_j k_j(x_i) } = y_i & \\text{fitting the blue curve to the black points} \\\\
\\\\boldsymbol{\\alpha K} & = \\\\boldsymbol{y} , & \\text{$\\\\boldsymbol{K}$: rows are vectors of evaluation} \\\\
\\end{aligned}
` + "";

    	let t49;
    	let p13;
    	let t50;
    	let d_math18;

    	let raw18_value = `\\\\boldsymbol{\\alpha}
` + "";

    	let t51;
    	let d_math19;

    	let raw19_value = `\\\\boldsymbol{K}
` + "";

    	let t52;
    	let d_math20;

    	let raw20_value = `\\\\boldsymbol{K}
` + "";

    	let t53;
    	let d_math21;

    	let raw21_value = `\\sigma
` + "";

    	let t54;
    	let d_math22;

    	let raw22_value = `(f_j(x_1), \\cdots, f_j(x_n))
` + "";

    	let t55;
    	let d_math23;

    	let raw23_value = `\\\\boldsymbol{\\alpha}
` + "";

    	let t56;
    	let t57;
    	let p14;
    	let t58;
    	let d_math24;

    	let raw24_value = `x_i
` + "";

    	let t59;
    	let t60;
    	let h20;
    	let t62;
    	let p15;
    	let strong0;
    	let t63;
    	let d_math25;

    	let raw25_value = `\\mathbb{R} \\times \\mathbb{R}
` + "";

    	let t64;
    	let t65;
    	let em1;
    	let t67;
    	let d_math26;

    	let raw26_value = `x_i
` + "";

    	let t68;
    	let d_math27;

    	let raw27_value = `k_j(\\cdot)
` + "";

    	let t69;
    	let d_math28;

    	let raw28_value = `(k_j(x_i))
` + "";

    	let t70;
    	let d_math29;

    	let raw29_value = `(x_i, y_i)
` + "";

    	let t71;
    	let t72;
    	let p16;
    	let strong1;
    	let t73;
    	let d_math30;

    	let raw30_value = `x_i
` + "";

    	let t74;
    	let em2;
    	let t76;
    	let d_math31;

    	let raw31_value = `n
` + "";

    	let t77;
    	let d_math32;

    	let raw32_value = `\\mathbb{R}^n
` + "";

    	let t78;
    	let d_math33;

    	let raw33_value = `n
` + "";

    	let t79;
    	let em3;
    	let t81;
    	let d_math34;

    	let raw34_value = `x_i
` + "";

    	let t82;
    	let t83;
    	let p17;
    	let strong2;
    	let t85;
    	let d_math35;

    	let raw35_value = `\\mathbb{R}
` + "";

    	let t86;
    	let t87;
    	let p18;
    	let strong3;
    	let t89;
    	let d_math36;

    	let raw36_value = `\\mathcal{X}
` + "";

    	let t90;
    	let t91;
    	let p19;
    	let t92;
    	let d_math37;

    	let raw37_value = `\\\\boldsymbol{\\alpha}
` + "";

    	let t93;
    	let t94;
    	let h21;
    	let t96;
    	let p20;
    	let t98;
    	let h30;
    	let t100;
    	let p21;
    	let em4;
    	let strong4;
    	let t101;
    	let d_math38;

    	let raw38_value = `\\mathcal{X}
` + "";

    	let t102;
    	let d_math39;

    	let raw39_value = `f_i: \\mathcal{X} \\mapsto \\mathcal{Y}
` + "";

    	let t103;
    	let d_math40;

    	let raw40_value = `f_i
` + "";

    	let t104;
    	let d_math41;

    	let raw41_value = `x_i \\in \\mathcal{X}
` + "";

    	let t105;
    	let d_math42;

    	let raw42_value = `x_i
` + "";

    	let t106;
    	let d_math43;

    	let raw43_value = `\\mathcal{X}
` + "";

    	let t107;
    	let t108;
    	let h31;
    	let t110;
    	let p22;
    	let em5;
    	let strong5;
    	let t112;
    	let d_math44;

    	let raw44_value = `n
` + "";

    	let t113;
    	let d_math45;

    	let raw45_value = `n
` + "";

    	let t114;
    	let d_math46;

    	let raw46_value = `n
` + "";

    	let t115;
    	let d_math47;

    	let raw47_value = `\\mathcal{X}
` + "";

    	let t116;
    	let d_math48;

    	let raw48_value = `n
` + "";

    	let t117;
    	let em6;
    	let t119;
    	let d_math49;

    	let raw49_value = `(f_i(x_1), f_i(x_2), \\cdots, f_i(x_n))
` + "";

    	let t120;
    	let t121;
    	let h32;
    	let t123;
    	let p23;
    	let em7;
    	let strong6;
    	let t125;
    	let br0;
    	let d_math50;

    	let raw50_value = `f_i(x) \\equiv \\\\vec{\\phi_f}_i \\cdot \\\\boldsymbol{\\phi}(x)
` + "";

    	let t126;
    	let d_math51;

    	let raw51_value = `\\\\vec{\\phi_f}_i
` + "";

    	let t127;
    	let t128;
    	let p24;
    	let t129;
    	let d_math52;

    	let raw52_value = `\\sigma
` + "";

    	let t130;
    	let d_math53;

    	let raw53_value = `\\mu \\in \\mathcal{X}
` + "";

    	let t131;
    	let t132;
    	let h22;
    	let t134;
    	let p25;
    	let t135;
    	let d_math54;

    	let raw54_value = `\\mu
` + "";

    	let t136;
    	let d_math55;

    	let raw55_value = `\\vec{\\phi}(\\mu)
` + "";

    	let t137;
    	let d_math56;

    	let raw56_value = `x
` + "";

    	let t138;
    	let d_math57;

    	let raw57_value = `\\vec{\\phi}(x)
` + "";

    	let t139;
    	let d_math58;

    	let raw58_value = `\\sigma
` + "";

    	let t140;
    	let d_math59;

    	let raw59_value = `\\vec{\\phi}(\\cdot)
` + "";

    	let t141;
    	let br1;
    	let d_math60;

    	let raw60_value = `\\sigma
` + "";

    	let t142;
    	let d_math61;

    	let raw61_value = `\\mu
` + "";

    	let t143;
    	let d_math62;

    	let raw62_value = `\\vec{\\phi_\\sigma}(\\cdot)
` + "";

    	let t144;
    	let t145;
    	let p26;
    	let t146;
    	let d_math63;

    	let raw63_value = `e^{axy}
` + "";

    	let t147;
    	let d_math64;

    	let raw64_value = `e^{-{\\\\small {1 \\\\over 2}} a(x-y)^2}
` + "";

    	let t148;
    	let d_math65;

    	let raw65_value = `a
` + "";

    	let t149;
    	let t150;
    	let d_math66;

    	let raw66_value = `
\\begin{aligned}
e^{axy} & = \\sum_{i=0} { \\dfrac{a^i(xy)^i}{i!} } & \\text{Taylor expansion} \\\\
& = \\sum_{i=0} { \\dfrac{(a^{\\\\small {1 \\\\over 2}} x)^i}{(i!)^{\\\\small {1 \\\\over 2}}} \\dfrac{(a^{\\\\small {1 \\\\over 2}} y)^i}{(i!)^{\\\\small {1 \\\\over 2}}} } & \\text{Separate $x$ and $y$ terms to symmetric roles} \\\\
& = \\sum_{i=0} { \\psi_{a,i}(x) \\psi_{a,i}(y) } & \\text{Let $\\psi_{a,i}(p) \\equiv \\dfrac{(a^{\\\\small {1 \\\\over 2}} p)^i}{(i!)^{\\\\small {1 \\\\over 2}}}$ }\\\\
& = \\vec{\\psi_a}(x) \\cdot \\vec{\\psi_a}(y) & \\text{Let $\\vec{\\psi_a}(p) \\equiv (\\psi_{a,1}(p), \\psi_{a,2}(p), \\cdots)$ } \\\\
\\end{aligned}
` + "";

    	let t151;
    	let p27;
    	let t152;
    	let d_math67;

    	let raw67_value = `e^{axy}
` + "";

    	let t153;
    	let d_math68;

    	let raw68_value = `y = \\mu
` + "";

    	let t154;
    	let t155;
    	let d_math69;

    	let raw69_value = `
\\begin{aligned}
e^{-{\\\\small {1 \\\\over 2}} a(x-\\mu)^2} & = e^{-{\\\\small {1 \\\\over 2}} a(x^2-2x\\mu+\\mu^2)} \\\\[1em]
& = e^{-{\\\\small {1 \\\\over 2}} a x^2} e^{ax\\mu} e^{-{\\\\small {1 \\\\over 2}} a \\mu^2} \\\\[1em]
& = e^{-{\\\\small {1 \\\\over 2}} a x^2} ( \\vec{\\psi_a}(x) \\cdot \\vec{\\psi_a}(\\mu) ) e^{-{\\\\small {1 \\\\over 2}} a \\mu^2} & \\text{substitute formula above} \\\\[1em]
& = (e^{-{\\\\small {1 \\\\over 2}} a x^2} \\vec{\\psi_a}(x) \\cdot e^{-{\\\\small {1 \\\\over 2}} a \\mu^2} \\vec{\\psi_a}(\\mu)) & \\text{By bilinearity of dot product} \\\\[1em]
& = \\vec{\\phi_{\\sigma}}(x) \\cdot \\vec{\\phi_{\\sigma}}(\\mu) & \\text{Let $\\vec{\\phi_{\\sigma}}(p) \\equiv e^{-{\\\\small {1 \\\\over 2}} a p^2} \\vec{\\psi_a}(p)$ with $a = {\\small 1 \\over \\sigma^2}$} \\\\
\\end{aligned}
` + "";

    	let t156;
    	let p28;
    	let t157;
    	let d_math70;

    	let raw70_value = `e^{-\\tfrac{1}{2} {(\\tfrac{x - \\mu}{\\sigma})}^2 }
` + "";

    	let t158;
    	let d_math71;

    	let raw71_value = `\\dfrac{1}{\\sigma^{\\\\small {1 \\\\over 2}} (2 \\pi)^{\\small 1 \\over 4}}
` + "";

    	let t159;
    	let p29;
    	let t160;
    	let d_math72;

    	let raw72_value = `\\mathcal{N}(x; \\mu, \\sigma)
` + "";

    	let t161;
    	let d_math73;

    	let raw73_value = `k(x, \\mu)
` + "";

    	let t162;
    	let d_math74;

    	let raw74_value = `\\sigma
` + "";

    	let t163;
    	let d_math75;

    	let raw75_value = `x
` + "";

    	let t164;
    	let d_math76;

    	let raw76_value = `\\mu
` + "";

    	let t165;
    	let d_math77;

    	let raw77_value = `\\mathcal{N}(x;\\sigma,\\mu) = \\mathcal{N}(\\mu;\\sigma, x)
` + "";

    	let t166;
    	let em8;
    	let t168;
    	let d_math78;

    	let raw78_value = `\\mu \\in \\mathcal{X}
` + "";

    	let t169;
    	let em9;
    	let t171;
    	let em10;
    	let t173;
    	let t174;
    	let p30;
    	let t175;
    	let d_math79;

    	let raw79_value = `x = \\mu
` + "";

    	let t176;
    	let d_math80;

    	let raw80_value = `\\vec{\\phi_\\sigma}(\\mu) \\cdot \\vec{\\phi_\\sigma}(\\mu) \\equiv \\\\|\\vec{\\phi_\\sigma\\\\|(x)}^2
` + "";

    	let t177;
    	let d_math81;

    	let raw81_value = `x
` + "";

    	let t178;
    	let d_math82;

    	let raw82_value = `\\cos \\theta_{\\vec{\\phi}(x), \\vec{\\phi}(\\mu)}
` + "";

    	let t179;
    	let t180;
    	let p31;
    	let t181;
    	let d_math83;

    	let raw83_value = `x
` + "";

    	let t182;
    	let d_math84;

    	let raw84_value = `\\mu
` + "";

    	let t183;
    	let d_math85;

    	let raw85_value = `90^\\circ
` + "";

    	let t184;
    	let d_math86;

    	let raw86_value = `[0^\\circ, 90^\\circ)
` + "";

    	let t185;
    	let d_math87;

    	let raw87_value = `x_1, x_2, x_3
` + "";

    	let t186;
    	let d_math88;

    	let raw88_value = `\\vec{\\phi}(x_1), \\vec{\\phi}(x_2), \\vec{\\phi}(x_3)
` + "";

    	let t187;
    	let d_math89;

    	let raw89_value = `\\infty
` + "";

    	let t188;
    	let d_math90;

    	let raw90_value = `\\mathbb{R}^3
` + "";

    	let t189;
    	let t190;
    	let h23;
    	let t192;
    	let p32;
    	let t193;
    	let d_math91;

    	let raw91_value = `\\mathcal{X} \\times \\mathcal{Y}
` + "";

    	let t194;
    	let t195;
    	let p33;
    	let t197;
    	let p34;
    	let t198;
    	let d_math92;

    	let raw92_value = `\\sigma
` + "";

    	let t199;
    	let d_math93;

    	let raw93_value = `\\\\mathcal{G}_\\\\sigma
` + "";

    	let t200;
    	let d_math94;

    	let raw94_value = `\\\\mathcal{\\\\Phi}
` + "";

    	let t201;
    	let t202;
    	let ol0;
    	let li0;
    	let p35;
    	let strong7;
    	let t204;
    	let d_math95;
    	let raw95_value = `x \\in \\mathcal{X}` + "";
    	let t205;
    	let d_math96;
    	let raw96_value = `\\vec{\\phi_\\sigma}(x) \\in \\\\mathcal{\\\\Phi}` + "";
    	let t206;
    	let t207;
    	let li1;
    	let p36;
    	let strong8;
    	let t209;
    	let d_math97;
    	let raw97_value = `f_{\\mu_i}(\\cdot) \\in \\\\mathcal{G}_\\\\sigma` + "";
    	let t210;
    	let d_math98;
    	let raw98_value = `\\vec{\\phi_\\sigma}(\\mu_i) \\in \\\\mathcal{\\\\Phi}` + "";
    	let t211;
    	let t212;
    	let li2;
    	let p37;
    	let strong9;
    	let t214;
    	let d_math99;
    	let raw99_value = `f_{\\mu_i}(x)` + "";
    	let t215;
    	let d_math100;
    	let raw100_value = `\\vec{\\phi_\\sigma}(\\mu_i) \\cdot \\vec{\\phi_\\sigma}(x)` + "";
    	let t216;
    	let d_math101;
    	let raw101_value = `\\vec{\\phi}(\\mu_i)` + "";
    	let t217;
    	let d_math102;
    	let raw102_value = `\\vec{\\phi}(x)` + "";
    	let t218;
    	let d_math103;
    	let raw103_value = `\\theta = 0` + "";
    	let t219;
    	let d_math104;
    	let raw104_value = `\\theta \\rightarrow 90^\\circ` + "";
    	let t220;
    	let d_math105;
    	let raw105_value = `+ \\infty` + "";
    	let t221;
    	let d_math106;
    	let raw106_value = `- \\infty` + "";
    	let t222;
    	let t223;
    	let p38;
    	let t225;
    	let ol1;
    	let li3;
    	let p39;
    	let strong10;
    	let t227;
    	let d_math107;
    	let raw107_value = `\\mu` + "";
    	let t228;
    	let t229;
    	let li4;
    	let p40;
    	let strong11;
    	let t230;
    	let d_math108;
    	let raw108_value = `\\mu` + "";
    	let t231;
    	let t232;
    	let d_math109;
    	let raw109_value = `\\vec{\\alpha}` + "";
    	let t233;
    	let d_math110;
    	let raw110_value = `f_{\\mu_i}(\\cdot) \\in \\\\mathcal{G}_\\\\sigma` + "";
    	let t234;
    	let em11;
    	let t236;
    	let d_math111;
    	let raw111_value = `\\vec{\\alpha}` + "";
    	let t237;
    	let d_math112;
    	let raw112_value = `\\vec{\\phi_\\sigma}(\\mu_i)` + "";
    	let t238;
    	let d_math113;
    	let raw113_value = `\\mu` + "";
    	let t239;
    	let t240;
    	let li5;
    	let p41;
    	let strong12;
    	let t242;
    	let d_math114;
    	let raw114_value = `x` + "";
    	let t243;
    	let t244;
    	let li6;
    	let p42;
    	let strong13;
    	let t246;
    	let d_math115;
    	let raw115_value = `f` + "";
    	let t247;
    	let d_math116;
    	let raw116_value = `\\mu` + "";
    	let t248;
    	let d_math117;
    	let raw117_value = `\\vec{\\phi_\\sigma}(x_i)` + "";
    	let t249;
    	let d_math118;
    	let raw118_value = `x` + "";
    	let t250;
    	let d_math119;
    	let raw119_value = `f_\\parallel` + "";
    	let t251;
    	let d_math120;
    	let raw120_value = `x` + "";
    	let t252;
    	let d_math121;
    	let raw121_value = `y_i` + "";
    	let t253;
    	let t254;
    	let p43;
    	let t255;
    	let d_math122;

    	let raw122_value = `\\mu
` + "";

    	let t256;
    	let d_math123;

    	let raw123_value = `x
` + "";

    	let t257;
    	let t258;
    	let h24;
    	let t260;
    	let p44;
    	let t261;
    	let d_math124;

    	let raw124_value = `\\mu_i
` + "";

    	let t262;
    	let d_math125;

    	let raw125_value = `\\sigma
` + "";

    	let t263;
    	let d_math126;

    	let raw126_value = `\\alpha_i
` + "";

    	let t264;
    	let t265;
    	let p45;
    	let t266;
    	let d_math127;

    	let raw127_value = `\\mu_i
` + "";

    	let t267;
    	let d_math128;

    	let raw128_value = `(x_i, y_i)
` + "";

    	let t268;
    	let d_math129;

    	let raw129_value = `\\mu
` + "";

    	let t269;
    	let d_math130;

    	let raw130_value = `x
` + "";

    	let t270;
    	let t271;
    	let p46;
    	let t272;
    	let d_math131;

    	let raw131_value = `\\alpha_i
` + "";

    	let t273;
    	let d_math132;

    	let raw132_value = `\\mu_i
` + "";

    	let t274;
    	let d_math133;

    	let raw133_value = `\\alpha_i
` + "";

    	let t275;
    	let d_math134;

    	let raw134_value = `(x_i, y_i)
` + "";

    	let t276;
    	let t277;
    	let p47;
    	let t278;
    	let d_math135;

    	let raw135_value = `\\sigma
` + "";

    	let t279;
    	let d_math136;

    	let raw136_value = `\\mu
` + "";

    	let t280;
    	let d_math137;

    	let raw137_value = `\\mu
` + "";

    	let t281;
    	let d_math138;

    	let raw138_value = `\\alpha_i
` + "";

    	let t282;
    	let d_math139;

    	let raw139_value = `\\mathcal{X}
` + "";

    	let t283;
    	let p48;
    	let t284;
    	let d_math140;

    	let raw140_value = `\\mu_i
` + "";

    	let t285;
    	let d_math141;

    	let raw141_value = `x_i
` + "";

    	let t286;
    	let em12;
    	let t288;
    	let d_math142;

    	let raw142_value = `\\mu_i
` + "";

    	let t289;
    	let d_math143;

    	let raw143_value = `\\alpha_i
` + "";

    	let t290;
    	let d_math144;

    	let raw144_value = `x_i
` + "";

    	let t291;
    	let d_math145;

    	let raw145_value = `\\mathrm{K}
` + "";

    	let t292;
    	let d_math146;

    	let raw146_value = `\\alpha \\mathrm{K}
` + "";

    	let t293;
    	let t294;
    	let p49;
    	let t295;
    	let d_math147;

    	let raw147_value = `\\mu_i = x_i
` + "";

    	let t296;
    	let d_math148;

    	let raw148_value = `\\mu
` + "";

    	let t297;
    	let d_math149;

    	let raw149_value = `x
` + "";

    	let t298;
    	let d_math150;

    	let raw150_value = `x_i = \\mu_i
` + "";

    	let t299;
    	let d_math151;

    	let raw151_value = `\\mathcal{N}(x; \\mu, \\sigma) = \\mathcal{N}(\\mu; x, \\sigma)
` + "";

    	let t300;
    	let d_math152;

    	let raw152_value = `\\mu_i \\ne x_i
` + "";

    	let t301;
    	let t302;
    	let h33;
    	let t304;
    	let p50;
    	let t305;
    	let d_math153;

    	let raw153_value = `\\sigma
` + "";

    	let t306;
    	let d_math154;

    	let raw154_value = `\\sigma
` + "";

    	let t307;
    	let d_math155;

    	let raw155_value = `\\vec{\\phi_\\sigma}(x)
` + "";

    	let t308;
    	let d_math156;

    	let raw156_value = `\\vec{\\phi_x}
` + "";

    	let t309;
    	let d_math157;

    	let raw157_value = `f = \\sum_i { \\alpha_i f_{\\mu_i} }
` + "";

    	let t310;
    	let d_math158;

    	let raw158_value = `\\sum_i { \\alpha_i \\\\vec{\\phi_{\\mu_i}}}
` + "";

    	let t311;
    	let d_math159;

    	let raw159_value = `\\vec{\\phi_f}
` + "";

    	let t312;
    	let t313;
    	let p51;
    	let strong14;
    	let t315;
    	let d_math160;

    	let raw160_value = `\\mu
` + "";

    	let t316;
    	let d_math161;

    	let raw161_value = `x
` + "";

    	let t317;
    	let d_math162;

    	let raw162_value = `\\mu_i
` + "";

    	let t318;
    	let d_math163;

    	let raw163_value = `\\alpha_i
` + "";

    	let t319;
    	let d_math164;

    	let raw164_value = `\\alpha_i \\vec{\\phi_\\sigma}(\\mu_i)
` + "";

    	let t320;
    	let d_math165;

    	let raw165_value = `x
` + "";

    	let t321;
    	let t322;
    	let p52;
    	let t323;
    	let d_math166;

    	let raw166_value = `\\sigma
` + "";

    	let t324;
    	let d_math167;

    	let raw167_value = `x
` + "";

    	let t325;
    	let d_math168;

    	let raw168_value = `\\mu_i
` + "";

    	let t326;
    	let d_math169;

    	let raw169_value = `\\sigma
` + "";

    	let t327;
    	let d_math170;

    	let raw170_value = `\\sigma
` + "";

    	let t328;
    	let d_math171;

    	let raw171_value = `\\mu_i
` + "";

    	let t329;
    	let br2;
    	let d_math172;

    	let raw172_value = `\\sigma
` + "";

    	let t330;
    	let d_math173;

    	let raw173_value = `\\mu_i
` + "";

    	let t331;
    	let d_math174;

    	let raw174_value = `x
` + "";

    	let t332;
    	let d_math175;

    	let raw175_value = `|\\mu_i - x|
` + "";

    	let t333;
    	let d_math176;

    	let raw176_value = `\\sigma \\rightarrow 0
` + "";

    	let t334;
    	let d_math177;

    	let raw177_value = `\\sigma \\rightarrow \\infty
` + "";

    	let t335;
    	let d_math178;

    	let raw178_value = `\\mu
` + "";

    	let t336;
    	let t337;
    	let p53;
    	let t338;
    	let d_math179;

    	let raw179_value = `\\mathcal{X}
` + "";

    	let t339;
    	let d_math180;

    	let raw180_value = `|\\mu - x|
` + "";

    	let t340;
    	let d_math181;

    	let raw181_value = `\\mu
` + "";

    	let t341;
    	let d_math182;

    	let raw182_value = `\\mu
` + "";

    	let t342;
    	let t343;
    	let p54;
    	let t344;
    	let d_math183;

    	let raw183_value = `\\mathcal{X}
` + "";

    	let t345;
    	let d_math184;

    	let raw184_value = `\\mathcal{X}
` + "";

    	let t346;
    	let br3;
    	let d_math185;

    	let raw185_value = `\\mathcal{X}
` + "";

    	let t347;
    	let t348;
    	let p55;
    	let strong15;
    	let t350;
    	let p56;
    	let t351;
    	let d_math186;

    	let raw186_value = `\\mu
` + "";

    	let t352;
    	let d_math187;

    	let raw187_value = `x
` + "";

    	let t353;
    	let d_math188;

    	let raw188_value = `\\sigma
` + "";

    	let t354;
    	let d_math189;

    	let raw189_value = `\\mu_2
` + "";

    	let t355;
    	let d_math190;

    	let raw190_value = `f_1
` + "";

    	let t356;
    	let d_math191;

    	let raw191_value = `\\vec{\\phi_{\\mu_1}}
` + "";

    	let t357;
    	let d_math192;

    	let raw192_value = `\\vec{\\phi_{\\mu_1}}
` + "";

    	let t358;
    	let t359;
    	let p57;
    	let t360;
    	let d_math193;

    	let raw193_value = `\\alpha_i
` + "";

    	let t361;
    	let d_math194;

    	let raw194_value = `\\vec{\\phi_{\\mu_1}}
` + "";

    	let t362;
    	let d_math195;

    	let raw195_value = `\\vec{\\phi_{\\mu_1}}
` + "";

    	let t363;
    	let d_math196;

    	let raw196_value = `\\vec{\\phi_f}
` + "";

    	let t364;
    	let d_math197;

    	let raw197_value = `\\\\mathrm{disp}(\\\\mathrm{proj){\\\\vec{\\phi_f}}{\\\\vec{\\phi_{x_i}}}} = y_i
` + "";

    	let t365;
    	let d_math198;

    	let raw198_value = `x_i = \\mu_i
` + "";

    	let t366;
    	let d_math199;

    	let raw199_value = `\\vec{\\phi_{x_1}}
` + "";

    	let t367;
    	let d_math200;

    	let raw200_value = `\\vec{\\phi_{x_2}}
` + "";

    	let t368;
    	let d_math201;

    	let raw201_value = `\\alpha_1
` + "";

    	let t369;
    	let d_math202;

    	let raw202_value = `\\\\mathrm{disp}(\\\\mathrm{proj){\\\\vec{\\phi_f}}{\\\\vec{\\phi_{x_2}}}}
` + "";

    	let t370;
    	let t371;
    	let p58;
    	let t372;
    	let d_math203;

    	let raw203_value = `\\sigma
` + "";

    	let t373;
    	let d_math204;

    	let raw204_value = `\\alpha_i
` + "";

    	let t374;
    	let t375;
    	let p59;
    	let strong16;
    	let t377;
    	let p60;
    	let t378;
    	let d_math205;

    	let raw205_value = `f
` + "";

    	let t379;
    	let em13;
    	let t381;
    	let d_math206;

    	let raw206_value = `\\\\|f\\\\|
` + "";

    	let t382;
    	let d_math207;

    	let raw207_value = `\\\\|f\\\\|
` + "";

    	let t383;
    	let d_math208;

    	let raw208_value = `\\\\|f_\\parallel\\\\|
` + "";

    	let t384;
    	let d_math209;

    	let raw209_value = `\\\\|f_\\perp\\\\|
` + "";

    	let t385;
    	let t386;
    	let p61;
    	let t387;
    	let d_math210;

    	let raw210_value = `x
` + "";

    	let t388;
    	let d_math211;

    	let raw211_value = `\\alpha_i
` + "";

    	let t389;
    	let d_math212;

    	let raw212_value = `\\|f\\|
` + "";

    	let t390;
    	let d_math213;

    	let raw213_value = `(x_i, y_i)
` + "";

    	let t391;
    	let d_math214;

    	let raw214_value = `\\sigma
` + "";

    	let t392;
    	let t393;
    	let p62;
    	let t394;
    	let d_math215;

    	let raw215_value = `\\\\vec{\\phi_{\\mu_1}}
` + "";

    	let t395;
    	let d_math216;

    	let raw216_value = `\\\\vec{\\phi_{\\mu_2}}
` + "";

    	let t396;
    	let d_math217;

    	let raw217_value = `\\\\vec{\\phi_f}
` + "";

    	let t397;
    	let t398;
    	let p63;
    	let t399;
    	let em14;
    	let t401;
    	let d_math218;

    	let raw218_value = `y_i
` + "";

    	let t402;
    	let d_math219;

    	let raw219_value = `\\sigma
` + "";

    	let t403;
    	let t404;
    	let p64;
    	let t405;
    	let d_math220;

    	let raw220_value = `y_i
` + "";

    	let t406;
    	let t407;
    	let p65;
    	let strong17;
    	let t408;
    	let d_math221;

    	let raw221_value = `\\mu
` + "";

    	let t409;
    	let d_math222;

    	let raw222_value = `x
` + "";

    	let t410;
    	let t411;
    	let p66;
    	let t412;
    	let d_math223;

    	let raw223_value = `\\\\vec{\\phi_f}
` + "";

    	let t413;
    	let d_math224;

    	let raw224_value = `\\mu
` + "";

    	let t414;
    	let d_math225;

    	let raw225_value = `n
` + "";

    	let t415;
    	let d_math226;

    	let raw226_value = `\\mathbb{span}(\\\\vec{\\phi_{\\mu_i}})
` + "";

    	let t416;
    	let d_math227;

    	let raw227_value = `\\\\mathrm{proj}{\\\\vec{\\phi_f}}{\\mathbb{x-span}}
` + "";

    	let t417;
    	let d_math228;

    	let raw228_value = `x
` + "";

    	let t418;
    	let d_math229;

    	let raw229_value = `\\mathbb{span}(\\\\vec{\\phi_{x_i}})
` + "";

    	let t419;
    	let d_math230;

    	let raw230_value = `\\mu_i = x_i
` + "";

    	let t420;
    	let d_math231;

    	let raw231_value = `\\\\vec{\\phi_f} = \\\\vec{\\phi_{f_\\parallel}}
` + "";

    	let t421;
    	let d_math232;

    	let raw232_value = `\\\\vec{\\phi_{f_\\perp}} = \\\\vec{0}
` + "";

    	let t422;
    	let d_math233;

    	let raw233_value = `\\mu
` + "";

    	let t423;
    	let d_math234;

    	let raw234_value = `\\mu_i
` + "";

    	let t424;
    	let d_math235;

    	let raw235_value = `f
` + "";

    	let t425;
    	let br4;
    	let d_math236;

    	let raw236_value = `\\\\|f\\\\|
` + "";

    	let t426;
    	let d_math237;

    	let raw237_value = `\\\\vec{\\phi_f}
` + "";

    	let t427;
    	let d_math238;

    	let raw238_value = `\\mu
` + "";

    	let t428;
    	let d_math239;

    	let raw239_value = `\\\\vec{\\phi_f} = \\\\vec{\\phi_{f_\\parallel}} + \\\\vec{\\phi_{f_\\perp}}
` + "";

    	let t429;
    	let d_math240;

    	let raw240_value = `x
` + "";

    	let t430;
    	let d_math241;

    	let raw241_value = `\\\\|f\\\\|
` + "";

    	let t431;
    	let d_math242;

    	let raw242_value = `x
` + "";

    	let t432;
    	let t433;
    	let p67;
    	let t434;
    	let d_math243;

    	let raw243_value = `\\mu
` + "";

    	let t435;
    	let d_math244;

    	let raw244_value = `x
` + "";

    	let t436;
    	let d_math245;

    	let raw245_value = `x
` + "";

    	let t437;
    	let t438;
    	let h12;
    	let t440;
    	let p68;
    	let t441;
    	let d_math246;

    	let raw246_value = `\\mu
` + "";

    	let t442;
    	let d_math247;

    	let raw247_value = `\\\\vec{\\phi_{\\mu_1}}
` + "";

    	let t443;
    	let d_math248;

    	let raw248_value = `\\\\vec{\\phi_{\\mu_2}}
` + "";

    	let t444;
    	let d_math249;

    	let raw249_value = `\\\\vec{\\phi_f} = \\sum_i { \\alpha_i \\\\vec{\\phi_{\\mu_i}}}
` + "";

    	let t445;
    	let d_math250;

    	let raw250_value = `x
` + "";

    	let t446;
    	let d_math251;

    	let raw251_value = `\\\\vec{\\phi_{x_i}}
` + "";

    	let t447;
    	let d_math252;

    	let raw252_value = `\\mu_i = x_i
` + "";

    	let t448;
    	let d_math253;

    	let raw253_value = `\\\\vec{\\phi_f}
` + "";

    	let t449;
    	let d_math254;

    	let raw254_value = `\\\\vec{\\phi_{\\mu_i}}
` + "";

    	let t450;
    	let d_math255;

    	let raw255_value = `f(x_i)
` + "";

    	let t451;
    	let t452;
    	let p69;
    	let strong18;
    	let t453;
    	let d_math256;

    	let raw256_value = `\\\\vec{\\phi_{\\mu_1}}
` + "";

    	let t454;
    	let d_math257;

    	let raw257_value = `\\\\vec{\\phi_{\\mu_2}}
` + "";

    	let t455;
    	let d_math258;

    	let raw258_value = `\\mu_i
` + "";

    	let t456;
    	let t457;
    	let p70;
    	let strong19;
    	let t458;
    	let d_math259;

    	let raw259_value = `\\\\vec{\\phi_{\\mu_1}}
` + "";

    	let t459;
    	let d_math260;

    	let raw260_value = `\\\\vec{\\phi_{\\mu_2}}
` + "";

    	let t460;
    	let d_math261;

    	let raw261_value = `f(\\cdot)
` + "";

    	let t461;
    	let d_math262;

    	let raw262_value = `\\mu_i
` + "";

    	let t462;
    	let d_math263;

    	let raw263_value = `\\mu
` + "";

    	let t463;
    	let d_math264;

    	let raw264_value = `x
` + "";

    	let t464;
    	let d_math265;

    	let raw265_value = `\\\\vec{\\phi_{\\mu_i}}
` + "";

    	let t465;
    	let t466;
    	let p71;
    	let strong20;
    	let t467;
    	let d_math266;

    	let raw266_value = `\\\\vec{\\phi_{\\mu_1}}
` + "";

    	let t468;
    	let d_math267;

    	let raw267_value = `\\\\vec{\\phi_{\\mu_2}}
` + "";

    	let t469;
    	let d_math268;

    	let raw268_value = `f(\\cdot)
` + "";

    	let t470;
    	let d_math269;

    	let raw269_value = `\\mu_i
` + "";

    	let t471;
    	let d_math270;

    	let raw270_value = `\\mu
` + "";

    	let t472;
    	let d_math271;

    	let raw271_value = `x
` + "";

    	let t473;
    	let d_math272;

    	let raw272_value = `y
` + "";

    	let t474;
    	let t475;
    	let h25;
    	let t476;
    	let d_math273;
    	let raw273_value = `\\mu_i = x_i` + "";
    	let t477;
    	let t478;
    	let p72;
    	let t479;
    	let d_math274;

    	let raw274_value = `\\mu
` + "";

    	let t480;
    	let d_math275;

    	let raw275_value = `x
` + "";

    	let t481;
    	let d_math276;

    	let raw276_value = `\\mu
` + "";

    	let t482;
    	let t483;
    	let p73;
    	let t484;
    	let d_math277;

    	let raw277_value = `f
` + "";

    	let t485;
    	let d_math278;

    	let raw278_value = `\\\\vec{\\phi_f} = \\\\boldsymbol{\\alpha M}
` + "";

    	let t486;
    	let d_math279;

    	let raw279_value = `\\\\boldsymbol{M}
` + "";

    	let t487;
    	let d_math280;

    	let raw280_value = `\\\\vec{\\phi_{\\mu_i}}
` + "";

    	let t488;
    	let br5;
    	let d_math281;

    	let raw281_value = `f
` + "";

    	let t489;
    	let em15;
    	let t491;
    	let d_math282;

    	let raw282_value = `x_i
` + "";

    	let t492;
    	let d_math283;

    	let raw283_value = `\\\\boldsymbol{\\alpha M X}^T
` + "";

    	let t493;
    	let d_math284;

    	let raw284_value = `\\\\boldsymbol{X}
` + "";

    	let t494;
    	let d_math285;

    	let raw285_value = `\\\\vec{\\phi_{x_i}}
` + "";

    	let t495;
    	let d_math286;

    	let raw286_value = `\\\\boldsymbol{M} = \\\\boldsymbol{X}
` + "";

    	let t496;
    	let t497;
    	let p74;
    	let t498;
    	let d_math287;

    	let raw287_value = `\\\\boldsymbol{\\alpha M X}^T = \\\\boldsymbol{y}
` + "";

    	let t499;
    	let d_math288;

    	let raw288_value = `\\\\boldsymbol{\\alpha}
` + "";

    	let t500;
    	let t501;
    	let d_math289;

    	let raw289_value = `
\\begin{aligned}
\\\\boldsymbol{a} \\cdot \\\\boldsymbol{b} & = (\\\\mathrm{proj}{\\\\boldsymbol{a}}{\\\\boldsymbol{b}} + \\\\boldsymbol{a}_{\\\\small \\\\perp #2}}) \\cdot \\\\boldsymbol{b} & \\text{orthogonal decomposition}\\\\
& = \\\\mathrm{proj}{\\\\boldsymbol{a}}{\\\\boldsymbol{b}} \\cdot \\\\boldsymbol{b} + \\\\boldsymbol{a}_{\\\\small \\\\perp #2}} \\cdot \\\\boldsymbol{b} & \\text{linearity of dot product}\\\\
& = \\\\mathrm{proj}{\\\\boldsymbol{a}}{\\\\boldsymbol{b}} \\cdot \\\\boldsymbol{b} & \\text{zero orthogonal contribution} \\\\
\\end{aligned}
` + "";

    	let t502;
    	let p75;
    	let t504;
    	let d_math290;

    	let raw290_value = `
\\begin{aligned}
\\\\boldsymbol{\\alpha M X}^T & = \\\\boldsymbol{\\alpha} (\\\\mathrm{proj}{\\\\boldsymbol{M}}{\\texttt{span}(\\\\boldsymbol{X})} + \\\\boldsymbol{M}_{\\\\small \\\\perp #2}(\\\\boldsymbol{X})}) \\\\boldsymbol{X}^T \\\\
& = \\\\boldsymbol{\\alpha} \\\\mathrm{proj}{\\\\boldsymbol{M}}{\\texttt{span}(\\\\boldsymbol{X})} \\\\boldsymbol{X}^T
\\end{aligned}
` + "";

    	let t505;
    	let p76;
    	let d_math291;

    	let raw291_value = `\\\\mathrm{proj}{\\\\boldsymbol{M}}{}
` + "";

    	let t506;
    	let d_math292;

    	let raw292_value = `\\texttt{span}(\\\\boldsymbol{X})
` + "";

    	let t507;
    	let d_math293;

    	let raw293_value = `\\mu_i = x_i
` + "";

    	let t508;
    	let d_math294;

    	let raw294_value = `\\mu_i
` + "";

    	let t509;
    	let d_math295;

    	let raw295_value = `\\texttt{span}(\\\\boldsymbol{M}) = \\texttt{span}(\\\\boldsymbol{X})
` + "";

    	let t510;
    	let d_math296;

    	let raw296_value = `\\\\boldsymbol{y}
` + "";

    	let t511;
    	let d_math297;

    	let raw297_value = `\\mu_i
` + "";

    	let t512;
    	let t513;
    	let p77;
    	let t514;
    	let d_math298;

    	let raw298_value = `\\\\|\\\\vec{\\phi_f\\\\|}^2
` + "";

    	let t515;
    	let t516;
    	let d_math299;

    	let raw299_value = `
\\begin{aligned}
\\\\boldsymbol{\\alpha M X}^T & = \\\\boldsymbol{\\beta X X}^T = \\\\boldsymbol{y} &\\text{a $\\\\boldsymbol{\\beta}$ exists, by previous argument}\\\\
\\\\|\\\\vec{\\phi_f\\\\|}^2 & = \\\\boldsymbol{\\alpha M M}^T \\\\boldsymbol{\\alpha}^T \\\\
& = \\\\boldsymbol{\\alpha} (\\\\mathrm{proj}{\\\\boldsymbol{M}}{} + \\\\boldsymbol{M}_{\\\\small \\\\perp #2}{\\\\boldsymbol{M}}{} + \\\\boldsymbol{M}_{\\\\small \\\\perp #2}^T \\\\
& = \\\\boldsymbol{\\alpha} \\\\mathrm{proj}{\\\\boldsymbol{M}}{} \\\\mathrm{proj}{\\\\boldsymbol{M}}{}^T \\\\boldsymbol{\\alpha}^T
+ 2 \\\\boldsymbol{\\alpha} \\\\mathrm{proj}{\\\\boldsymbol{M}}{} \\\\boldsymbol{M}_{\\\\small \\\\perp #2}^T
+ \\\\boldsymbol{\\alpha} \\\\boldsymbol{M}_{\\\\small \\\\perp #2}}{}^T \\\\boldsymbol{\\alpha}^T \\\\
& \\ge \\\\boldsymbol{\\alpha} \\\\mathrm{proj}{\\\\boldsymbol{M}}{} \\\\mathrm{proj}{\\\\boldsymbol{M}}{}^T \\\\boldsymbol{\\alpha}^T \\\\[1em]
& = \\\\boldsymbol{\\beta X X}^T \\\\boldsymbol{\\beta}^T & \\text{by uniqueness of span}\\\\
\\end{aligned}
` + "";

    	let t517;
    	let h26;
    	let t519;
    	let p78;
    	let t520;
    	let d_math300;

    	let raw300_value = `f
` + "";

    	let t521;
    	let d_math301;

    	let raw301_value = `\\\\|\\\\vec{\\phi_f\\\\|}
` + "";

    	let t522;
    	let t523;
    	let p79;
    	let t524;
    	let d_math302;

    	let raw302_value = `a, b \\in \\mathcal{X}
` + "";

    	let t525;
    	let d_math303;

    	let raw303_value = `|f(a)|
` + "";

    	let t526;
    	let d_math304;

    	let raw304_value = `|f(a) - f(b)|
` + "";

    	let t527;
    	let t528;
    	let d_math305;

    	let raw305_value = `
\\begin{aligned}
f(a) & = \\\\vec{\\phi_f} \\cdot \\\\vec{\\phi_a} & \\text{definition of $f(x)$} \\\\
& = \\\\|\\\\vec{\\phi_f\\\\|} \\|\\\\vec{\\phi_a}\\| \\cos \\theta_{\\\\vec{\\phi_f},\\\\vec{\\phi_a}} & \\text{definition of dot product} \\\\
\\implies |f(a)| & \\le \\\\|\\\\vec{\\phi_f\\\\|}\\|\\\\vec{\\phi_a}\\| & \\text{Cauchy Schwarz inequality} \\\\[2em]
f(a) - f(b) & = \\\\vec{\\phi_f} \\cdot \\\\vec{\\phi_a} - \\\\vec{\\phi_f} \\cdot \\\\vec{\\phi_b} &\\text{definition of $f(x)$} \\\\
& = \\\\vec{\\phi_f} \\cdot (\\\\vec{\\phi_a} - \\\\vec{\\phi_b}) & \\text{bilinearity of dot product} \\\\
& = \\\\|\\\\vec{\\phi_f\\\\|} \\|\\\\vec{\\phi_a} - \\\\vec{\\phi_b}\\| \\cos \\theta_{\\\\vec{\\phi_f}, \\\\vec{\\phi_a} - \\\\vec{\\phi_b}} & \\text{definition of dot product} \\\\
\\implies |f(a) - f(b)| & \\le \\\\|\\\\vec{\\phi_f\\\\|} \\|\\\\vec{\\phi_a} - \\\\vec{\\phi_b}\\| & \\text{Cauchy Schwarz inequality} \\\\
\\end{aligned}
` + "";

    	let t529;
    	let p80;
    	let t530;
    	let d_math306;

    	let raw306_value = `f
` + "";

    	let t531;
    	let d_math307;

    	let raw307_value = `\\\\|\\\\vec{\\phi_f\\\\|}
` + "";

    	let t532;
    	let d_math308;

    	let raw308_value = `\\\\|\\\\vec{\\phi_a\\\\|}
` + "";

    	let t533;
    	let d_math309;

    	let raw309_value = `\\\\boldsymbol{\\phi}(\\cdot)
` + "";

    	let t534;
    	let d_math310;

    	let raw310_value = `\\\\|\\\\vec{\\phi_f\\\\|}
` + "";

    	let t535;
    	let d_math311;

    	let raw311_value = `f
` + "";

    	let t536;
    	let t537;
    	let p81;
    	let t538;
    	let d_math312;

    	let raw312_value = `\\\\|\\\\vec{\\phi_a\\\\| - \\v{\\phi_b}}
` + "";

    	let t539;
    	let d_math313;

    	let raw313_value = `\\\\|\\\\vec{\\phi_f\\\\|}
` + "";

    	let t540;
    	let t541;
    	let p82;
    	let t542;
    	let d_math314;

    	let raw314_value = `y_a
` + "";

    	let t543;
    	let d_math315;

    	let raw315_value = `y_b
` + "";

    	let t544;
    	let d_math316;

    	let raw316_value = `|f(a) - f(b)| = |y_a - y_b|
` + "";

    	let t545;
    	let d_math317;

    	let raw317_value = `\\|\\\\vec{\\phi_f}\\|
` + "";

    	let t546;
    	let d_math318;

    	let raw318_value = `\\|\\\\vec{\\phi_a} - \\\\vec{\\phi_b}\\|
` + "";

    	let t547;
    	let d_math319;

    	let raw319_value = `x
` + "";

    	let t548;
    	let t549;
    	let p83;
    	let t550;
    	let d_math320;

    	let raw320_value = `\\\\boldsymbol{\\phi}(\\cdot)
` + "";

    	let t551;
    	let d_math321;

    	let raw321_value = `\\\\boldsymbol{\\phi}(\\cdot)
` + "";

    	let t552;
    	let d_math322;

    	let raw322_value = `\\\\|\\\\vec{\\phi_a\\\\| - \\v{\\phi_b}}
` + "";

    	let t553;
    	let d_math323;

    	let raw323_value = `|y_a - y_b|
` + "";

    	let t554;
    	let d_math324;

    	let raw324_value = `(a, b) \\in \\mathcal{X}
` + "";

    	let t555;
    	let t556;
    	let h27;
    	let t558;
    	let p84;
    	let t559;
    	let d_math325;

    	let raw325_value = `\\\\boldsymbol{M} \\equiv \\\\boldsymbol{X}
` + "";

    	let t560;
    	let t561;
    	let d_math326;

    	let raw326_value = `
\\begin{aligned}
\\\\boldsymbol{X} & & \\text{matrix of rows of $\\\\vec{\\phi_{x_i}}$ as defined before} \\\\
\\\\vec{\\phi_f} & = \\\\boldsymbol{\\alpha X} & \\text{$f$'s parameter vector}\\\\
(f(x_i))_{(1..n)} &= \\\\boldsymbol{\\alpha X X}^T & \\text{$f$'s vector of evaluation } \\\\
\\end{aligned}
` + "";

    	let t562;
    	let p85;
    	let t563;
    	let d_math327;

    	let raw327_value = `\\\\boldsymbol{\\hat \\alpha}
` + "";

    	let t564;
    	let t565;
    	let d_math328;

    	let raw328_value = `
\\begin{aligned}
\\\\boldsymbol{\\hat{\\alpha}} & = \\min_{\\alpha} { \\\\|\\\\boldsymbol{\\alpha X X\\\\|^T - \\\\boldsymbol{y}}^2 }
\\end{aligned}
` + "";

    	let t566;
    	let p86;
    	let t568;
    	let d_math329;

    	let raw329_value = `
\\begin{aligned}
\\\\boldsymbol{\\hat{\\alpha}} & = \\min_{\\alpha} ( \\\\|\\\\boldsymbol{\\alpha X X\\\\|^T - \\\\boldsymbol{y}}^2 + \\lambda \\\\|\\\\boldsymbol{\\alpha X\\\\|}^2 ) & \\text{sum of squared error, regularized by norm of $\\\\vec{\\phi_f}$}\\\\
& = \\min_{\\alpha} ( \\\\|\\\\boldsymbol{\\alpha X X\\\\|^T - \\\\boldsymbol{y}}^2 + \\lambda \\\\boldsymbol{\\alpha X X}^T \\\\boldsymbol{\\alpha}^T )
\\end{aligned}
` + "";

    	let t569;
    	let p87;
    	let t571;
    	let d_math330;

    	let raw330_value = `
\\begin{aligned}
f(x) & = \\\\vec{\\phi_f} \\cdot \\\\vec{\\phi_x} \\\\
& = \\\\boldsymbol{\\hat{\\alpha} X} \\cdot \\\\vec{\\phi_x} \\\\
& = \\sum_i { \\hat{\\alpha}_i \\\\vec{\\phi_{x_i}} \\cdot \\\\vec{\\phi_x} } \\\\
\\end{aligned}
` + "";

    	let t572;
    	let p88;
    	let t573;
    	let d_math331;

    	let raw331_value = `\\mathcal{X}
` + "";

    	let t574;
    	let d_math332;

    	let raw332_value = `\\\\vec{\\phi_{x_i}} \\cdot \\\\vec{\\phi_{x_j}}
` + "";

    	let t575;
    	let d_math333;

    	let raw333_value = `\\\\boldsymbol{X X}^T
` + "";

    	let t576;
    	let t577;
    	let d_math334;

    	let raw334_value = `
\\begin{aligned}
k(x,x') & \\equiv \\\\vec{\\phi_x} \\cdot \\\\vec{\\phi_{x'}} & \\text{The kernel function} \\\\
\\\\boldsymbol{K} & \\equiv [ \\\\boldsymbol{K}_{ij} = k(x_i, x_j) ] & \\text{The Kernel matrix, metric matrix or Gram matrix} \\\\
& = \\\\boldsymbol{X X}^T & \\text{from above}
\\end{aligned}
` + "";

    	let t578;
    	let p89;
    	let t580;
    	let d_math335;

    	let raw335_value = `
\\begin{aligned}
\\\\boldsymbol{\\hat{\\alpha}} & = \\min_{\\alpha} ( \\\\|\\\\boldsymbol{\\alpha K\\\\|- \\\\boldsymbol{y}}^2 + \\lambda \\\\boldsymbol{\\alpha K} \\\\boldsymbol{\\alpha}^T )
\\end{aligned}
` + "";

    	let t581;
    	let p90;
    	let t583;
    	let d_math336;

    	let raw336_value = `
\\begin{aligned}
f(x) & = \\sum_i { \\hat{\\alpha}_i k(x_i, x) } \\\\
\\end{aligned}
` + "";

    	let t584;
    	let p91;
    	let t585;
    	let d_math337;

    	let raw337_value = `x
` + "";

    	let t586;
    	let d_math338;

    	let raw338_value = `\\\\boldsymbol{\\alpha}
` + "";

    	let t587;
    	let d_math339;

    	let raw339_value = `x_i
` + "";

    	let t588;
    	let d_math340;

    	let raw340_value = `k(x, x') \\equiv \\mathcal{N}(x; x', \\sigma) = \\mathcal{N}(x'; x, \\sigma)
` + "";

    	let t589;
    	let t590;
    	let h13;
    	let t592;
    	let p92;
    	let t593;
    	let d_math341;

    	let raw341_value = `\\mathcal{X} \\times \\mathbb{R}
` + "";

    	let t594;
    	let t595;
    	let p93;
    	let t596;
    	let d_math342;

    	let raw342_value = `x_i
` + "";

    	let t597;
    	let d_math343;

    	let raw343_value = `x_i
` + "";

    	let t598;
    	let d_math344;

    	let raw344_value = `y_i
` + "";

    	let t599;
    	let d_math345;

    	let raw345_value = `x_i
` + "";

    	let t600;
    	let t601;
    	let p94;
    	let t602;
    	let d_math346;

    	let raw346_value = `f_{x_i}(x) \\equiv \\\\vec{\\phi_{x_i}} \\cdot \\\\vec{\\phi_x}
` + "";

    	let t603;
    	let t604;
    	let ol2;
    	let li7;
    	let p95;
    	let t606;
    	let li8;
    	let p96;
    	let t608;
    	let li9;
    	let p97;
    	let t610;
    	let h14;
    	let t612;
    	let p98;
    	let t614;
    	let h28;
    	let t616;
    	let p99;
    	let t617;
    	let d_math347;

    	let raw347_value = `XX^T
` + "";

    	let t618;
    	let d_math348;

    	let raw348_value = `X
` + "";

    	let t619;
    	let d_math349;

    	let raw349_value = `X
` + "";

    	let t620;
    	let d_math350;

    	let raw350_value = `X
` + "";

    	let t621;
    	let d_math351;

    	let raw351_value = `XX^T
` + "";

    	let t622;
    	let d_math352;

    	let raw352_value = `\\alpha K \\alpha^T \\ge 0
` + "";

    	let t623;
    	let d_math353;

    	let raw353_value = `\\alpha
` + "";

    	let t624;
    	let d_math354;

    	let raw354_value = `K = XX^T
` + "";

    	let t625;
    	let d_math355;

    	let raw355_value = `X
` + "";

    	let t626;
    	let d_math356;

    	let raw356_value = `X
` + "";

    	let t627;
    	let d_math357;

    	let raw357_value = `\\alpha X
` + "";

    	let t628;
    	let d_math358;

    	let raw358_value = `\\alpha X X^T \\alpha^T
` + "";

    	let t629;
    	let t630;
    	let h29;
    	let t632;
    	let p100;
    	let t633;
    	let d_math359;

    	let raw359_value = `k(x, x') \\equiv \\\\vec{\\phi_x} \\cdot \\\\vec{\\phi_x'}
` + "";

    	let t634;
    	let t635;
    	let h210;
    	let t637;
    	let p101;
    	let t639;
    	let p102;
    	let t640;
    	let d_math360;

    	let raw360_value = `f_{x_i}(\\cdot): \\mathcal{X} \\mapsto \\mathbb{R}
` + "";

    	let t641;
    	let em16;
    	let t643;
    	let d_math361;

    	let raw361_value = `\\\\vec{\\phi_{x_i}}: \\mathbb{R}^\\infty \\equiv \\mathcal{F}
` + "";

    	let t644;
    	let em17;
    	let t646;
    	let d_math362;

    	let raw362_value = `K
` + "";

    	let t647;
    	let d_math363;

    	let raw363_value = `(\\\\vec{\\phi_{x_i}})
` + "";

    	let t648;
    	let d_math364;

    	let raw364_value = `x_i
` + "";

    	let t649;
    	let t650;
    	let p103;
    	let t651;
    	let d_math365;

    	let raw365_value = `f_{x_i}(\\cdot)
` + "";

    	let t652;
    	let d_math366;

    	let raw366_value = `x \\in \\mathcal{X}
` + "";

    	let t653;
    	let em18;
    	let t655;
    	let d_math367;

    	let raw367_value = `f_{x_i}(\\cdot): \\mathbb{R}^\\mathcal{X}
` + "";

    	let t656;
    	let d_math368;

    	let raw368_value = `\\mathbb{R}^3
` + "";

    	let t657;
    	let d_math369;

    	let raw369_value = `|\\mathcal{X}|
` + "";

    	let t658;
    	let em19;
    	let t660;
    	let em20;
    	let t662;
    	let d_math370;

    	let raw370_value = `\\mathbb{R}^\\mathcal{X}
` + "";

    	let t663;
    	let d_math371;

    	let raw371_value = `\\mathcal{H}
` + "";

    	let t664;
    	let d_math372;

    	let raw372_value = `\\langle f_{x_i}, f_{x_j} \\rangle \\equiv \\\\vec{\\phi_{x_i}} \\cdot \\\\vec{\\phi_{x_j}} \\equiv f_{x_i}(x_j) \\equiv f_{x_j}(x_i)
` + "";

    	let t665;
    	let t666;
    	let p104;
    	let t667;
    	let d_math373;

    	let raw373_value = `(f_{x_i})
` + "";

    	let t668;
    	let d_math374;

    	let raw374_value = `K:[K_{ij} = f_{x_i}(x_j)]
` + "";

    	let t669;
    	let d_math375;

    	let raw375_value = `KK^T = K
` + "";

    	let t670;
    	let a0;
    	let t672;
    	let t673;
    	let h211;
    	let t675;
    	let p105;
    	let t676;
    	let d_math376;

    	let raw376_value = `f_x \\in \\mathcal{H}
` + "";

    	let t677;
    	let d_math377;

    	let raw377_value = `x \\in \\mathcal{X}
` + "";

    	let t678;
    	let d_math378;

    	let raw378_value = `x
` + "";

    	let t679;
    	let em21;
    	let t681;
    	let d_math379;

    	let raw379_value = `\\mathcal{H}
` + "";

    	let t682;
    	let em22;
    	let t684;
    	let d_math380;

    	let raw380_value = `(f_{x_i})
` + "";

    	let t685;
    	let d_math381;

    	let raw381_value = `\\\\boldsymbol{M} = \\\\boldsymbol{X}
` + "";

    	let t686;
    	let a1;
    	let t688;
    	let h212;
    	let t690;
    	let p106;
    	let t692;
    	let h213;
    	let t694;
    	let h214;
    	let t696;
    	let h215;
    	let t698;
    	let p107;
    	let t700;
    	let h216;
    	let t702;
    	let p108;
    	let t704;
    	let p109;
    	let d_math382;

    	let raw382_value = `\\max\\limits_{\\alpha \\in \\mathbb{R}^n, \\beta \\in \\mathbb{R}^n} \\dfrac{\\alpha^T K_\\alpha K_\\beta \\beta}{(\\alpha^TK_\\alpha^2 \\alpha)^{\\frac{1}{2}} (\\beta^T K_\\beta^2 \\beta)^{\\frac{1}{2}} }
` + "";

    	let t705;
    	let p110;
    	let t706;
    	let a2;
    	let t708;
    	let h217;
    	let t710;
    	let p111;
    	let t711;
    	let em23;
    	let t713;
    	let d_math383;

    	let raw383_value = `f
` + "";

    	let t714;
    	let d_math384;

    	let raw384_value = `(x, y)
` + "";

    	let t715;
    	let d_math385;

    	let raw385_value = `\\mu = y f(x)
` + "";

    	let t716;
    	let d_math386;

    	let raw386_value = `\\phi(\\mu)
` + "";

    	let t717;
    	let t718;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t720;
    	let th1;
    	let d_math387;
    	let raw387_value = `\\phi(\\mu)` + "";
    	let t721;
    	let tbody;
    	let tr1;
    	let td0;
    	let t723;
    	let td1;
    	let d_math388;
    	let raw388_value = `\\log(1 + e^{-\\mu}` + "";
    	let t724;
    	let tr2;
    	let td2;
    	let t726;
    	let td3;
    	let d_math389;
    	let raw389_value = `\\max(1-\\mu, 0)` + "";
    	let t727;
    	let tr3;
    	let td4;
    	let t729;
    	let td5;
    	let d_math390;
    	let raw390_value = ` \\max(1-\\mu, 0)^2` + "";
    	let t730;
    	let tr4;
    	let td6;
    	let t732;
    	let td7;
    	let d_math391;
    	let raw391_value = `e^{-\\mu}` + "";
    	let t733;
    	let p112;
    	let t735;
    	let d_math392;

    	let raw392_value = `
\\begin{aligned}
& \\min_{f \\in \\mathcal{H}} { \\dfrac{1}{\\mu} \\sum { \\phi(y_i f(x_i)) + \\lambda \\|f\\|^2_{\\mathcal{H}} } } \\\\
f(x) & = \\sum { \\alpha_i K(x_i, x) } & \\text{By representer theorem}\\\\
& \\min_{\\alpha \\in \\mathbb{R}^n} { \\dfrac{1}{n} \\sum { \\phi(y_i [K\\alpha]_i) + \\lambda \\alpha^T K \\alpha } } & \\text{plugging in}\\\\
\\end{aligned}
` + "";

    	let t736;
    	let p113;
    	let t737;
    	let d_math393;

    	let raw393_value = `\\alpha
` + "";

    	let t738;
    	let t739;
    	let p114;
    	let d_math394;

    	let raw394_value = `f(x) = \\sum { \\alpha_i K(x_i, x) } = \\sum\\limits_{i \\in SV} { \\alpha_i K(x_i, x) }
` + "";

    	let t740;
    	let p115;
    	let t742;
    	let h218;
    	let t744;
    	let p116;
    	let t745;
    	let a3;
    	let t747;
    	let h219;
    	let t749;
    	let p117;
    	let t750;
    	let d_math395;

    	let raw395_value = `\\mathcal{X} \\times \\mathcal{Y}
` + "";

    	let t751;
    	let d_math396;

    	let raw396_value = `\\mathcal{X}
` + "";

    	let t752;
    	let em24;
    	let t754;
    	let d_math397;

    	let raw397_value = `\\mathcal{X}
` + "";

    	let t755;
    	let d_math398;

    	let raw398_value = `\\mathbb{R}^n
` + "";

    	let t756;
    	let d_math399;

    	let raw399_value = `\\mathcal{X}
` + "";

    	let t757;
    	let br6;
    	let d_math400;

    	let raw400_value = `\\mathcal{X}
` + "";

    	let t758;
    	let d_math401;

    	let raw401_value = `\\mathcal{X}
` + "";

    	let t759;
    	let d_math402;

    	let raw402_value = `\\mathbb{R}^n
` + "";

    	let t760;
    	let t761;
    	let p118;
    	let t762;
    	let d_math403;

    	let raw403_value = `\\mathbb{R}
` + "";

    	let t763;
    	let d_math404;

    	let raw404_value = `\\pi
` + "";

    	let t764;
    	let t765;
    	let p119;
    	let t766;
    	let d_math405;

    	let raw405_value = `K(a,b) \\gt K(a,a)
` + "";

    	let t767;
    	let d_math406;

    	let raw406_value = `a
` + "";

    	let t768;
    	let d_math407;

    	let raw407_value = `b
` + "";

    	let t769;
    	let d_math408;

    	let raw408_value = `K(\\cdot, \\cdot)
` + "";

    	let t770;
    	let d_math409;

    	let raw409_value = `a
` + "";

    	let t771;
    	let d_math410;

    	let raw410_value = `b
` + "";

    	let t772;
    	let t773;
    	let p120;
    	let t774;
    	let em25;
    	let t776;
    	let d_math411;

    	let raw411_value = `\\mathcal{X}
` + "";

    	let t777;
    	let t778;
    	let d_math412;

    	let raw412_value = `
\\begin{aligned}
a, b \\in \\mathcal{X} \\\\
K(a, b) & \\equiv \\\\|a\\\\| \\\\|b\\\\| \\cos\\\\theta_{ab} & \\text{The Kernel defines the value of the inner product} \\\\
\\implies \\\\|a\\\\| & = K(a,a)^{\\\\small {1 \\\\over 2}} \\\\
\\implies \\cos \\\\theta_{ab} & = \\dfrac{K(a, b)}{K(a, a)^\\frac{1}{2} K(b, b)^\\frac{1}{2}} \\\\[1em]
\\implies \\\\mathrm{dist}(a, b)^2 & = K(a, a) - 2K(a, b) + K(b, b) \\\\
\\end{aligned}
` + "";

    	const block = {
    		c: function create() {
    			h10 = element("h1");
    			h10.textContent = "Introduction";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "In this article, I introduce the main mathematical apparatus at the core of all Kernel Methods.  To me, the apparatus is best introduced as the inevitable consequence of three design goals, in the same way that a bicycle is the consequence of design goals (\"a thing the rider must be able to steer, sit on, accelerate, and stop\").";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "I take a somewhat unconventional approach by first considering a slightly wider class, and then show that a narrower class (still with multiple choices) is the most optimal.  The Kernel method is one choice in this narrower class.  While any choice within this narrower class provides exactly the same solution to a problem, the Kernel method is the only computable member of this class.  This should hopefully make the Kernel Method seem less contrived and arbitrary.";
    			t5 = space();
    			p2 = element("p");
    			p2.textContent = "There are two interactive visualizations in this article, using the 1-D Gaussian Kernel.  In writing it, I built a lot of intuition about these core concepts by fiddling with the two figures.";
    			t7 = space();
    			p3 = element("p");
    			p3.textContent = "All Kernel methods, such as Kernel Regression, Kernel SVM, PCA, CCA, K-means use the same mathematical apparatus at the core, but solve a different linear problem.  In this article, I use the simplest among these, the perfect-fit Kernel Regression, as a worked example.  Since it is perfect-fit, it has the drawback of not using regularization.  Instead, I introduce the concept of regularization through function norm reduction while considering the design of the Kernel Method itself.   Imperfect-fit (least squares) regression, and other variations serve to further decrease the function norm, or achieve other objectives such as classification.";
    			t9 = space();
    			p4 = element("p");
    			p4.textContent = "A core concept of Kernel Methods is he so-called \"feature space\" - a (possibly) infinite dimensional vector space, whose points correspond one-to-one with functions.  There is a distinct concept called the Reproducing Kernel Hilbert Space.  The RKHS is a more abstract concept; it is also a vector space whose points correspond to the points in the feature space, and the functions.  The feature space and the RKHS are distinct, but represent aspects of the same underlying mathematical object.  But often in the literature, they are spoken about interchangeably, which was a major source of confusion.  I only mention them here to help the reader avoid the same confusion.";
    			t11 = space();
    			p5 = element("p");
    			p5.textContent = "Kernel methods, particularly SVMs, were for a time a dominant model used in Machine Learning, but have been eclipsed by deep Neural networks trained by stochastic gradient descent.  More recently, it was recognized that NNs trained by SGD approximate Kernel methods, and this has led to increased interest and new applications.";
    			t13 = space();
    			h11 = element("h1");
    			h11.textContent = "An illustration of Kernel Regression";
    			t15 = space();
    			p6 = element("p");
    			t16 = text$1("In the interactive figure, data points \n");
    			d_math0 = element("d-math");
    			t17 = text$1(" are shown as black dots.  There is one Gaussian centered at each \n");
    			d_math1 = element("d-math");
    			t18 = text$1(".  The blue curve is a linear combination \n");
    			d_math2 = element("d-math");
    			t19 = text$1(" of these Gaussians.  Each slider controls one of the \n");
    			d_math3 = element("d-math");
    			t20 = text$1(".");
    			t21 = space();
    			p7 = element("p");
    			t22 = text$1("You can adjust the sliders to make the blue curve perfectly fit the \n");
    			d_math4 = element("d-math");
    			t23 = text$1(".  It may be surprising to note that a unique, perfect-fitting \n");
    			d_math5 = element("d-math");
    			t24 = text$1(" exists for any set of \n");
    			d_math6 = element("d-math");
    			t25 = text$1(" and for any number of points (click 'Add Points' and/or 'New Data' to adjust).");
    			t26 = space();
    			p8 = element("p");
    			t27 = text$1("To see why, note that each gray curve's set of values along the \n");
    			d_math7 = element("d-math");
    			t28 = text$1(" produces a vector, which I call the function's ");
    			em0 = element("em");
    			em0.textContent = "vector of evaluation";
    			t30 = text$1(".  Denoting the j'th curve as \n");
    			d_math8 = element("d-math");
    			t31 = text$1(", its vector of evaluation is \n");
    			d_math9 = element("d-math");
    			t32 = text$1(", where the order of components is always the order of the \n");
    			d_math10 = element("d-math");
    			t33 = text$1(".");
    			t34 = space();
    			p9 = element("p");
    			t35 = text$1("Note that there isn't any rule that the \n");
    			d_math11 = element("d-math");
    			t36 = text$1(" need be monotonically increasing.  They are simply given in some arbitrary order from the dataset. In the plot, they aren't labeled.  You can adjust the i'th slider and see which curve moves.  The point located horizontally at the peak of that curve is \n");
    			d_math12 = element("d-math");
    			t37 = text$1(".  Ultimately it doesn't matter for the purposes of illustration.  The important thing is that all the gray functions' vectors of evaluation are in the same order.");
    			t38 = space();
    			p10 = element("p");
    			p10.textContent = "Also note, although Gaussians are most often interpreted as probability distributions, in this article, there is no such interpretation, and there is no process of sampling from Gaussians.  We are simply using them as curves, like splines, to generate more complex shapes.  So, there is no requirement that they be normalized.";
    			t40 = space();
    			p11 = element("p");
    			t41 = text$1("Particularly for a collection of Gaussians all with the same \n");
    			d_math13 = element("d-math");
    			t42 = text$1(", the set of these \n");
    			d_math14 = element("d-math");
    			t43 = text$1(" vectors are linearly independent.  This is not at all obvious, but please accept it for now.  Then, by the linear algebra expansion theorem, they span \n");
    			d_math15 = element("d-math");
    			t44 = text$1(" and so can form any set of \n");
    			d_math16 = element("d-math");
    			t45 = text$1(".");
    			t46 = space();
    			p12 = element("p");
    			p12.textContent = "Explicitly:";
    			t48 = space();
    			d_math17 = element("d-math");
    			t49 = space();
    			p13 = element("p");
    			t50 = text$1("The \n");
    			d_math18 = element("d-math");
    			t51 = text$1(" that fits the data perfectly is found by inverting \n");
    			d_math19 = element("d-math");
    			t52 = text$1(", which is possible because \n");
    			d_math20 = element("d-math");
    			t53 = text$1(" is full-rank.  That is, its rows are linearly independent, due to the property of a collections of Gaussians of the same \n");
    			d_math21 = element("d-math");
    			t54 = text$1(".  Even though we are taking linear combinations of functions, it is only the vectors of evaluation \n");
    			d_math22 = element("d-math");
    			t55 = text$1(" which affect the choice of \n");
    			d_math23 = element("d-math");
    			t56 = text$1(".");
    			t57 = space();
    			p14 = element("p");
    			t58 = text$1("Of course, the whole purpose is for the curve to specify desirable values at other points, by some criterion.  But, so far the discussion is only concerned with how to make the curve have desired values at the \n");
    			d_math24 = element("d-math");
    			t59 = text$1(".");
    			t60 = space();
    			h20 = element("h2");
    			h20.textContent = "Some Observations";
    			t62 = space();
    			p15 = element("p");
    			strong0 = element("strong");
    			t63 = text$1("This method can fit any set of data in \n");
    			d_math25 = element("d-math");
    			t64 = text$1(".");
    			t65 = text$1("  Given a ");
    			em1 = element("em");
    			em1.textContent = "particular";
    			t67 = text$1(" set \n");
    			d_math26 = element("d-math");
    			t68 = text$1(", you could hand-pick a set of functions \n");
    			d_math27 = element("d-math");
    			t69 = text$1(" which happen to produce linearly independent vectors \n");
    			d_math28 = element("d-math");
    			t70 = text$1(" of evaluation on that particular data set.  However, the procedure shown above can fit any data set \n");
    			d_math29 = element("d-math");
    			t71 = text$1(".  This is useful because it would be laborious to have to hand-pick functions for each new data set.");
    			t72 = space();
    			p16 = element("p");
    			strong1 = element("strong");
    			t73 = text$1("There is nothing (yet) special about the Gaussians being centered at the \n");
    			d_math30 = element("d-math");
    			t74 = text$1(".  It turns out that ");
    			em2 = element("em");
    			em2.textContent = "any";
    			t76 = text$1(" choice of \n");
    			d_math31 = element("d-math");
    			t77 = text$1(" Gaussians will span \n");
    			d_math32 = element("d-math");
    			t78 = text$1(" when evaluated at any \n");
    			d_math33 = element("d-math");
    			t79 = text$1(" values.  There ");
    			em3 = element("em");
    			em3.textContent = "is";
    			t81 = text$1(" indeed something special about the Gaussians being centered at the \n");
    			d_math34 = element("d-math");
    			t82 = text$1(", but it has nothing to do with the ability to fit arbitrary data.");
    			t83 = space();
    			p17 = element("p");
    			strong2 = element("strong");
    			strong2.textContent = "Many functions have this infinite capacity";
    			t85 = text$1(".  Not just Gaussians, but many other families of functions have this capacity to perfectly fit any data, due to the vectors of evaluation being linearly independent.  Not only that, but families of functions can be found for many different domains, not just \n");
    			d_math35 = element("d-math");
    			t86 = text$1(" as shown above.   Both discrete and continuous domains, and of arbitrary dimensions.");
    			t87 = space();
    			p18 = element("p");
    			strong3 = element("strong");
    			strong3.textContent = "Linear independence is preserved under permutation of components";
    			t89 = text$1(".  The Gaussians are able to fit any data because they produce vectors that are linearly independent.  But, note that vectors that are linearly independent would still be so, after you permute their elements all in the same way.  For vectors, there is no meaning to the ordering of the elements.  To illustrate, click the 'scramble' button.  This remaps all points in \n");
    			d_math36 = element("d-math");
    			t90 = text$1(" in one-to-one fashion by reversing the order of every other interval of some fixed size.  Or think of it as re-ordering the components of the Gaussian \"vectors\" all in the same way, preserving their linear independence.  You can still toggle 'auto solve' and see that a unique solution exists.");
    			t91 = space();
    			p19 = element("p");
    			t92 = text$1("Of course, these permuted Gaussians don't have the same relationship with the original data, so there will be a different \n");
    			d_math37 = element("d-math");
    			t93 = text$1(" solution.  This is only to show that the continuity or shape of the original Gaussians is not what gives them this capacity to fit arbitrary data.");
    			t94 = space();
    			h21 = element("h2");
    			h21.textContent = "The three design choices underlying all Kernel methods";
    			t96 = space();
    			p20 = element("p");
    			p20.textContent = "Underlying all Kernel methods are three choices for how to construct the function to fit a given data set.  Like all machine learning methods, these chocies are guided by classic requirements.  First, the approach must be a \"universal approximator\", or as I call it, have arbitrary model capacity.  This means, the ability to perfectly fit any data set.  Second, it should be possible to regularize, meaning that the function gives useful interpolation behavior.  Finally, it should be computationally tractable.  The three design choices serve these requirements as you will see.";
    			t98 = space();
    			h30 = element("h3");
    			h30.textContent = "First design choice";
    			t100 = space();
    			p21 = element("p");
    			em4 = element("em");
    			strong4 = element("strong");
    			t101 = text$1("Set of functions indexed by \n");
    			d_math38 = element("d-math");
    			t102 = text$1(".  We specify a set of functions \n");
    			d_math39 = element("d-math");
    			t103 = text$1(", such that there is exactly one member of the set, \n");
    			d_math40 = element("d-math");
    			t104 = text$1(", corresponding to each element \n");
    			d_math41 = element("d-math");
    			t105 = text$1(".  We then use the subset of this set corresponding to our \n");
    			d_math42 = element("d-math");
    			t106 = text$1(" in the dataset to build a solution function as a linear combination of them.  The fact that the functions are already indexed by elements of the domain \n");
    			d_math43 = element("d-math");
    			t107 = text$1(" makes the choice automatic.  There is no hand-specifying a set of functions tailor made for each new data set.  This choice also serves the purpose of regularization, to be proved later.");
    			t108 = space();
    			h31 = element("h3");
    			h31.textContent = "Second design choice";
    			t110 = space();
    			p22 = element("p");
    			em5 = element("em");
    			strong5 = element("strong");
    			strong5.textContent = "Members of the set exhibit linearly independent vectors of evaluation";
    			t112 = text$1(". The members of the set have the following property:  For any value of \n");
    			d_math44 = element("d-math");
    			t113 = text$1(", and for any \n");
    			d_math45 = element("d-math");
    			t114 = text$1(" functions from the set, and for any choice of \n");
    			d_math46 = element("d-math");
    			t115 = text$1(" evaluation points in \n");
    			d_math47 = element("d-math");
    			t116 = text$1(", the set of \n");
    			d_math48 = element("d-math");
    			t117 = space();
    			em6 = element("em");
    			em6.textContent = "vectors of evaluation";
    			t119 = text$1(" of the chosen functions should be linearly independent.  A \"vector of evaluation\" as explained above is my term for the vector of function values in the order of data set points, \n");
    			d_math49 = element("d-math");
    			t120 = text$1(".  This design choice allows the approach to fit any data set, as argued above by appealing to the linear algebra expansion theorem.  This gives the approach arbitrary capacity.  As an aside, there are choices of families that don't have this property, but since we are speaking generally about the approach of Kernel methods, it is important that some families do exhibit this property.");
    			t121 = space();
    			h32 = element("h3");
    			h32.textContent = "Third design choice";
    			t123 = space();
    			p23 = element("p");
    			em7 = element("em");
    			strong6 = element("strong");
    			strong6.textContent = "The functions are in the form of dot products of feature vectors";
    			t125 = text$1(".  This is the biggest leap.  The members of the set are of the form:");
    			br0 = element("br");
    			d_math50 = element("d-math");
    			t126 = text$1(".  That is, each function is identified by a distinct \"parameter vector\" \n");
    			d_math51 = element("d-math");
    			t127 = text$1(", and the function is defined as the dot product between its parameter vector and some as-yet undefined vector-valued function of the input.  As I will show soon, this third choice provides a way to regularize the method, and makes finding the solution function readily computable.  It also maintains the first goal of having arbitrary capacity to fit any data.  For readers already familiar with literature on Kernel methods, the notion of a \"parameter vector\" is not conventional, but it is my device for motivating Kernels.");
    			t128 = space();
    			p24 = element("p");
    			t129 = text$1("To motivate these ideas and make the discussion more concrete, I first show that the Gaussian set of functions, all with the same \n");
    			d_math52 = element("d-math");
    			t130 = text$1(" and indexed over \n");
    			d_math53 = element("d-math");
    			t131 = text$1(", fit these three design choices.");
    			t132 = space();
    			h22 = element("h2");
    			h22.textContent = "Gaussians have a Dot-product form";
    			t134 = space();
    			p25 = element("p");
    			t135 = text$1("The values of the Gaussian function turn out to be a dot product between two infinite dimensional vectors.  The first vector is a vector-valued function of \n");
    			d_math54 = element("d-math");
    			t136 = text$1(", named as \n");
    			d_math55 = element("d-math");
    			t137 = text$1(".   The second, the same function of \n");
    			d_math56 = element("d-math");
    			t138 = text$1(", named as \n");
    			d_math57 = element("d-math");
    			t139 = text$1(".  Note that the \n");
    			d_math58 = element("d-math");
    			t140 = text$1(" parameter to a Gaussian will determine \n");
    			d_math59 = element("d-math");
    			t141 = text$1(" itself.");
    			br1 = element("br");
    			d_math60 = element("d-math");
    			t142 = text$1(" is not an argument like \n");
    			d_math61 = element("d-math");
    			t143 = text$1(" is.  So, below we write the function as \n");
    			d_math62 = element("d-math");
    			t144 = text$1(".");
    			t145 = space();
    			p26 = element("p");
    			t146 = text$1("To show this, we first show how the simpler formula \n");
    			d_math63 = element("d-math");
    			t147 = text$1(" can be written as a dot product.  Then, using this first result, we show that \n");
    			d_math64 = element("d-math");
    			t148 = text$1(" can also be written as a dot product.  The Gaussian is just a scaled version with a special choice for \n");
    			d_math65 = element("d-math");
    			t149 = text$1(".");
    			t150 = space();
    			d_math66 = element("d-math");
    			t151 = space();
    			p27 = element("p");
    			t152 = text$1("Now, using the first result for \n");
    			d_math67 = element("d-math");
    			t153 = text$1(", and letting \n");
    			d_math68 = element("d-math");
    			t154 = text$1(":");
    			t155 = space();
    			d_math69 = element("d-math");
    			t156 = space();
    			p28 = element("p");
    			t157 = text$1("So we have \n");
    			d_math70 = element("d-math");
    			t158 = text$1(" and all that remains is to scale both vectors by \n");
    			d_math71 = element("d-math");
    			t159 = space();
    			p29 = element("p");
    			t160 = text$1("In particular, the Gaussian \n");
    			d_math72 = element("d-math");
    			t161 = text$1(" is reinterpreted as a two-argument function \n");
    			d_math73 = element("d-math");
    			t162 = text$1(" parameterized by \n");
    			d_math74 = element("d-math");
    			t163 = text$1(", symmetric in the roles of \n");
    			d_math75 = element("d-math");
    			t164 = text$1(" and \n");
    			d_math76 = element("d-math");
    			t165 = text$1(", that is: \n");
    			d_math77 = element("d-math");
    			t166 = text$1(".  In the ");
    			em8 = element("em");
    			em8.textContent = "first design choice";
    			t168 = text$1(", \n");
    			d_math78 = element("d-math");
    			t169 = text$1(" plays the role of indexing the family of functions.  The ");
    			em9 = element("em");
    			em9.textContent = "third design choice";
    			t171 = text$1(" is proven.  The ");
    			em10 = element("em");
    			em10.textContent = "second design choice";
    			t173 = text$1(", that members of the family have arbitrary ability to produce linearly independent vectors of evaluation, has not been proven, but for the moment please accept it.");
    			t174 = space();
    			p30 = element("p");
    			t175 = text$1("Note that the height at the peak of every Gaussian, the location where \n");
    			d_math79 = element("d-math");
    			t176 = text$1(", is the value of \n");
    			d_math80 = element("d-math");
    			t177 = text$1(", implying every feature vector has the same norm since peak heights are the same for all \n");
    			d_math81 = element("d-math");
    			t178 = text$1(".  To simplify the example further, the family of functions used in the worked example are scaled so that peak height = 1.  In particular this means the values of the dot products are simply the cosine of the angle between the two feature vectors, \n");
    			d_math82 = element("d-math");
    			t179 = text$1(".");
    			t180 = space();
    			p31 = element("p");
    			t181 = text$1("The value of the Gaussian as \n");
    			d_math83 = element("d-math");
    			t182 = text$1(" moves far away from \n");
    			d_math84 = element("d-math");
    			t183 = text$1(" approaches zero.  This indicates the angle between the feature vectors asymptotically approaches \n");
    			d_math85 = element("d-math");
    			t184 = text$1(", but never reaches it.  The Gaussian is positive everywhere, therefore the angle ranges in \n");
    			d_math86 = element("d-math");
    			t185 = text$1(" in the infinite dimensional feature space.  In particular, considering three far points \n");
    			d_math87 = element("d-math");
    			t186 = text$1(", their corresponding feature vectors \n");
    			d_math88 = element("d-math");
    			t187 = text$1(" are nearly mutually orthogonal while still having acute angles between them.  In the infinite dimensional feature space, it is possible to have arbitrarily many of these.  The vectors occupy some \n");
    			d_math89 = element("d-math");
    			t188 = text$1("-tant of the space (like an octant in \n");
    			d_math90 = element("d-math");
    			t189 = text$1("), if you will.");
    			t190 = space();
    			h23 = element("h2");
    			h23.textContent = "The mapping between input and Feature Space";
    			t192 = space();
    			p32 = element("p");
    			t193 = text$1("There are two main aims of this article.  The first is to demonstrate that every aspect of Kernel methods is simply a consequence of the classic requirements acting through the three design choices.  The second is to use the worked example of the 1D Gaussian Kernel, and build the habit of simultaneously visualizing the shapes of the curves and their linear combinations in the data domain \n");
    			d_math91 = element("d-math");
    			t194 = text$1(", and their corresponding feature vectors in the feature space, visualizing angles, planes and lengths.");
    			t195 = space();
    			p33 = element("p");
    			p33.textContent = "The following is a list of some of the facts tying the input to the geometry of the feature space.  It can be used as a reference while interacting with the visualizations.";
    			t197 = space();
    			p34 = element("p");
    			t198 = text$1("Denoting the family of Gaussians (all with the same \n");
    			d_math92 = element("d-math");
    			t199 = text$1(") as \n");
    			d_math93 = element("d-math");
    			t200 = text$1(", and the feature space as \n");
    			d_math94 = element("d-math");
    			t201 = text$1(":");
    			t202 = space();
    			ol0 = element("ol");
    			li0 = element("li");
    			p35 = element("p");
    			strong7 = element("strong");
    			strong7.textContent = "Every input has a feature vector";
    			t204 = text$1(".  Every point ");
    			d_math95 = element("d-math");
    			t205 = text$1(" corresponds to a feature vector ");
    			d_math96 = element("d-math");
    			t206 = text$1(".");
    			t207 = space();
    			li1 = element("li");
    			p36 = element("p");
    			strong8 = element("strong");
    			strong8.textContent = "Every function has a feature vector";
    			t209 = text$1(".  Every function ");
    			d_math97 = element("d-math");
    			t210 = text$1(" corresponds to feature vector ");
    			d_math98 = element("d-math");
    			t211 = text$1(".");
    			t212 = space();
    			li2 = element("li");
    			p37 = element("p");
    			strong9 = element("strong");
    			strong9.textContent = "Every evaluation is a dot product of feature vectors";
    			t214 = text$1(".  The evaluation ");
    			d_math99 = element("d-math");
    			t215 = text$1(" corresponds to the dot product ");
    			d_math100 = element("d-math");
    			t216 = text$1(".  It this worked example, since the feature vectors are unit norm, it is the cosine of the angle of feature vectors ");
    			d_math101 = element("d-math");
    			t217 = text$1(" and ");
    			d_math102 = element("d-math");
    			t218 = text$1(".  For example, ");
    			d_math103 = element("d-math");
    			t219 = text$1(" at the peak, and ");
    			d_math104 = element("d-math");
    			t220 = text$1(" asymptotically towards ");
    			d_math105 = element("d-math");
    			t221 = text$1(" or ");
    			d_math106 = element("d-math");
    			t222 = text$1(".");
    			t223 = space();
    			p38 = element("p");
    			p38.textContent = "And, some consequences from this:";
    			t225 = space();
    			ol1 = element("ol");
    			li3 = element("li");
    			p39 = element("p");
    			strong10 = element("strong");
    			strong10.textContent = "A set of functions defines a linear subspace in feature space";
    			t227 = text$1(".  For short, one could call this subspace the ");
    			d_math107 = element("d-math");
    			t228 = text$1("-span.");
    			t229 = space();
    			li4 = element("li");
    			p40 = element("p");
    			strong11 = element("strong");
    			t230 = text$1("Every linear combination of those functions is a point in the ");
    			d_math108 = element("d-math");
    			t231 = text$1("-span");
    			t232 = text$1(".  The ");
    			d_math109 = element("d-math");
    			t233 = text$1(" linear combination of functions ");
    			d_math110 = element("d-math");
    			t234 = text$1(" corresponds to the ");
    			em11 = element("em");
    			em11.textContent = "same";
    			t236 = space();
    			d_math111 = element("d-math");
    			t237 = text$1(" linear combination of feature vectors ");
    			d_math112 = element("d-math");
    			t238 = text$1(".  Although the family functions all have the same feature vector length, in general a linear combination will not.  The goal is to find a single point in the ");
    			d_math113 = element("d-math");
    			t239 = text$1("-span which fits the data and has other desirable properties.");
    			t240 = space();
    			li5 = element("li");
    			p41 = element("p");
    			strong12 = element("strong");
    			strong12.textContent = "A set of inputs defines a linear subspace in feature space";
    			t242 = text$1(".  For short, one could call this subspace the ");
    			d_math114 = element("d-math");
    			t243 = text$1("-span.  It can be thought of as an empirical estimate of the data manifold.");
    			t244 = space();
    			li6 = element("li");
    			p42 = element("p");
    			strong13 = element("strong");
    			strong13.textContent = "A set of input labels defines a point in that linear subspace";
    			t246 = text$1(".  Every point ");
    			d_math115 = element("d-math");
    			t247 = text$1(" in the ");
    			d_math116 = element("d-math");
    			t248 = text$1("-span induces a tuple of dot-product values with the ");
    			d_math117 = element("d-math");
    			t249 = text$1(" of the ");
    			d_math118 = element("d-math");
    			t250 = text$1("-span, which also corresponds to its projection ");
    			d_math119 = element("d-math");
    			t251 = text$1(" onto the ");
    			d_math120 = element("d-math");
    			t252 = text$1("-span.  Those dot-product values correspond to the labels (");
    			d_math121 = element("d-math");
    			t253 = text$1(" values).");
    			t254 = space();
    			p43 = element("p");
    			t255 = text$1("As a spoiler, it will be shown that the \n");
    			d_math122 = element("d-math");
    			t256 = text$1("-span and \n");
    			d_math123 = element("d-math");
    			t257 = text$1("-span are chosen to be the same subspace.  The motivation for this choice will be made clear, but it is helpful to distinguish the two conceptually at first.");
    			t258 = space();
    			h24 = element("h2");
    			h24.textContent = "Interactive Figure 1";
    			t260 = space();
    			p44 = element("p");
    			t261 = text$1("Figure 1 has three coordinated panels with different views of the same information.  In the main plot at the top, each gray curve is an individual Gaussian with mean \n");
    			d_math124 = element("d-math");
    			t262 = text$1(" indicated by the triangle at the top edge.  They all share the same \n");
    			d_math125 = element("d-math");
    			t263 = text$1(", controlled by the slider.  Each gray curve is scaled by an \n");
    			d_math126 = element("d-math");
    			t264 = text$1(" shown in a slider to the right.");
    			t265 = space();
    			p45 = element("p");
    			t266 = text$1("You may drag any triangle to change \n");
    			d_math127 = element("d-math");
    			t267 = text$1(" and the corresponding gray curve will follow.  The \n");
    			d_math128 = element("d-math");
    			t268 = text$1(" points are shown as black circles.  You may change them as well.  If \n");
    			d_math129 = element("d-math");
    			t269 = text$1(" tracks \n");
    			d_math130 = element("d-math");
    			t270 = text$1(" is checked, the triangles will follow.");
    			t271 = space();
    			p46 = element("p");
    			t272 = text$1("The blue curve is simply the sum of the gray curves.  Its shape is thus controlled by choices of the \n");
    			d_math131 = element("d-math");
    			t273 = text$1(" and the \n");
    			d_math132 = element("d-math");
    			t274 = text$1(".  If auto solve is checked, the plot will set the \n");
    			d_math133 = element("d-math");
    			t275 = text$1(" to values to fit the \n");
    			d_math134 = element("d-math");
    			t276 = text$1(" data.  While the sliders have a limited range for manual adjustment, the 'auto solve' may set them to very large values positive or negative values depending on the data.");
    			t277 = space();
    			p47 = element("p");
    			t278 = text$1("The heatmap at the lower left is a complete space showing where the information in the main plot is situated.  It shows the values of all Gaussian curves of a particular \n");
    			d_math135 = element("d-math");
    			t279 = text$1(", (0 to 1, white to blue scale).  Each horizontal line shows one curve centered at a particular \n");
    			d_math136 = element("d-math");
    			t280 = text$1(", with \n");
    			d_math137 = element("d-math");
    			t281 = text$1(" increasing downwards.  While the gray curves show the \n");
    			d_math138 = element("d-math");
    			t282 = text$1("-scaled Gaussian, the heatmap shows these Gaussians unscaled so their peak height is 1.  In this worked example of 1D Gaussians, the heatmap depicts the entire family of functions indexed by points in the input domain \n");
    			d_math139 = element("d-math");
    			t283 = space();
    			p48 = element("p");
    			t284 = text$1("The red dots show the current locations of all combinations of \n");
    			d_math140 = element("d-math");
    			t285 = text$1(" and \n");
    			d_math141 = element("d-math");
    			t286 = text$1(".  The heatmap values at the dots in a particular row denote the ");
    			em12 = element("em");
    			em12.textContent = "vector of evaluation";
    			t288 = text$1(" of Gaussian at \n");
    			d_math142 = element("d-math");
    			t289 = text$1(" - that is, height of the gray curve if its \n");
    			d_math143 = element("d-math");
    			t290 = text$1(" were set to 1.  The matrix at the lower right shows these values, organized in the same way.  The same values can be seen as heights of the gray curves at each \n");
    			d_math144 = element("d-math");
    			t291 = text$1(".  Letting the matrix be \n");
    			d_math145 = element("d-math");
    			t292 = text$1(", the vector of evalution of the blue curve is just \n");
    			d_math146 = element("d-math");
    			t293 = text$1(".");
    			t294 = space();
    			p49 = element("p");
    			t295 = text$1("Notice that if all \n");
    			d_math147 = element("d-math");
    			t296 = text$1(" (check \n");
    			d_math148 = element("d-math");
    			t297 = text$1(" tracks \n");
    			d_math149 = element("d-math");
    			t298 = text$1("), then the diagonals of this matrix are equal to 1 since each unscaled curve has a peak height of 1 at \n");
    			d_math150 = element("d-math");
    			t299 = text$1(".  Furthermore the matrix is symmetric since \n");
    			d_math151 = element("d-math");
    			t300 = text$1(".  It is not symmetric when \n");
    			d_math152 = element("d-math");
    			t301 = text$1(" in general.");
    			t302 = space();
    			h33 = element("h3");
    			h33.textContent = "Some experiments";
    			t304 = space();
    			p50 = element("p");
    			t305 = text$1("Here are some experiments that I found are useful to build intuition.  In the experiments where \n");
    			d_math153 = element("d-math");
    			t306 = text$1(" is not the focus, I'll omit the mention of \n");
    			d_math154 = element("d-math");
    			t307 = text$1(" and abbreviate the feature vector notation \n");
    			d_math155 = element("d-math");
    			t308 = text$1(" as \n");
    			d_math156 = element("d-math");
    			t309 = text$1(".  For linear combinations of feature vectors, I'll use the name of the corresponding function.  For example, \n");
    			d_math157 = element("d-math");
    			t310 = text$1(", with feature vector \n");
    			d_math158 = element("d-math");
    			t311 = text$1(" will be simply notated \n");
    			d_math159 = element("d-math");
    			t312 = text$1(".");
    			t313 = space();
    			p51 = element("p");
    			strong14 = element("strong");
    			strong14.textContent = "Interpolation behavior from a single point";
    			t315 = text$1(".  Click 'Del Point' until there is a single gray curve.  With 'auto solve' checked, drag the black point up and down, and observe how the other values change.  Obviously, points x near \n");
    			d_math160 = element("d-math");
    			t316 = text$1(" change almost the same, while more distant points don't change much.  The central idea here is that height of the gray curve at arbitrary \n");
    			d_math161 = element("d-math");
    			t317 = text$1(" defines defines a kind of similarity with \n");
    			d_math162 = element("d-math");
    			t318 = text$1(".  The \n");
    			d_math163 = element("d-math");
    			t319 = text$1(" scaled gray curve corresponds to the scaled feature vector \n");
    			d_math164 = element("d-math");
    			t320 = text$1(".  Because the evaluations are dot products, and the dot product is linear in each argument, the values of the function at every \n");
    			d_math165 = element("d-math");
    			t321 = text$1(" scale as well.");
    			t322 = space();
    			p52 = element("p");
    			t323 = text$1("Now, if you shrink \n");
    			d_math166 = element("d-math");
    			t324 = text$1(", the similarity of a given point \n");
    			d_math167 = element("d-math");
    			t325 = text$1(" with \n");
    			d_math168 = element("d-math");
    			t326 = text$1(" goes down.  Shrinking \n");
    			d_math169 = element("d-math");
    			t327 = text$1(" results in the shape of the feature vectors changing, although their norm stays the same.  With a very low \n");
    			d_math170 = element("d-math");
    			t328 = text$1(", a smaller neighborhood of points are considered similar, and the rest of them don't move much when the value at \n");
    			d_math171 = element("d-math");
    			t329 = text$1(" is scaled.");
    			br2 = element("br");
    			d_math172 = element("d-math");
    			t330 = text$1(" thus controls the similarity between \n");
    			d_math173 = element("d-math");
    			t331 = text$1(" and \n");
    			d_math174 = element("d-math");
    			t332 = text$1(" in relation to euclidean distance \n");
    			d_math175 = element("d-math");
    			t333 = text$1(".  In the \n");
    			d_math176 = element("d-math");
    			t334 = text$1(" limit, the gray curve interpolates nothing.  In the \n");
    			d_math177 = element("d-math");
    			t335 = text$1(" limit, every point is considered identical with \n");
    			d_math178 = element("d-math");
    			t336 = text$1(".");
    			t337 = space();
    			p53 = element("p");
    			t338 = text$1("Now, check 'scramble'.  The shape of the curve is now the same except that every other unit interval in \n");
    			d_math179 = element("d-math");
    			t339 = text$1(" has been reversed.  This new shape is piecewise continuous.  Positioning the black point near a discontinuity and move it up and down, you can see that even points very close in \n");
    			d_math180 = element("d-math");
    			t340 = text$1(" distance are not as influenced.  The relation between influence of \n");
    			d_math181 = element("d-math");
    			t341 = text$1(" along the curve and euclidean distance from \n");
    			d_math182 = element("d-math");
    			t342 = text$1(" is no longer monotonic.");
    			t343 = space();
    			p54 = element("p");
    			t344 = text$1("The notion that a similarity measure on pairs of points in \n");
    			d_math183 = element("d-math");
    			t345 = text$1(" may not be related to the geometry of \n");
    			d_math184 = element("d-math");
    			t346 = text$1(" is a central idea in kernel methods.");
    			br3 = element("br");
    			d_math185 = element("d-math");
    			t347 = text$1(" need not be a continuous domain or even ordered in any way - the corresponding gray \"curves\" would not be curves in that case, but they would be capable of interpolating values assigned to points in the domain.  This gives kernel methods great flexibility.");
    			t348 = space();
    			p55 = element("p");
    			strong15 = element("strong");
    			strong15.textContent = "Interaction between Two Points";
    			t350 = space();
    			p56 = element("p");
    			t351 = text$1("Now increase to two points.  With '\n");
    			d_math186 = element("d-math");
    			t352 = text$1(" tracks \n");
    			d_math187 = element("d-math");
    			t353 = text$1("' and 'auto solve' checked, move the two data points well apart, and adjust \n");
    			d_math188 = element("d-math");
    			t354 = text$1(" so the two gray curves are well separated - that is, such that the height at \n");
    			d_math189 = element("d-math");
    			t355 = text$1(" of \n");
    			d_math190 = element("d-math");
    			t356 = text$1(" is near zero, and vice versa.  The off-diagonal elements of the matrix at the bottom right should be nearly white.  The feature vectors \n");
    			d_math191 = element("d-math");
    			t357 = text$1(" and \n");
    			d_math192 = element("d-math");
    			t358 = text$1(" corresponding to these two functions are approaching right angles with each other.");
    			t359 = space();
    			p57 = element("p");
    			t360 = text$1("Now drag one of the data points up and down.  You'll notice that only one of the \n");
    			d_math193 = element("d-math");
    			t361 = text$1(" components moves to solve the curve.  In feature space terms, \n");
    			d_math194 = element("d-math");
    			t362 = text$1(" and \n");
    			d_math195 = element("d-math");
    			t363 = text$1(" are nearly orthogonal.  The goal is to find some linear combination \n");
    			d_math196 = element("d-math");
    			t364 = text$1(" of them such that the signed length (displacement) of the projections \n");
    			d_math197 = element("d-math");
    			t365 = text$1(".   Since the \n");
    			d_math198 = element("d-math");
    			t366 = text$1(", \n");
    			d_math199 = element("d-math");
    			t367 = text$1(" and \n");
    			d_math200 = element("d-math");
    			t368 = text$1(" are the same.  So, scaling one component \n");
    			d_math201 = element("d-math");
    			t369 = text$1(" doesn't affect \n");
    			d_math202 = element("d-math");
    			t370 = text$1(" and vice versa.");
    			t371 = space();
    			p58 = element("p");
    			t372 = text$1("Now move the points closer together, or increase \n");
    			d_math203 = element("d-math");
    			t373 = text$1(", so that the off-diagonal elements are bluish.  Then, moving one of the points influences the other, and both \n");
    			d_math204 = element("d-math");
    			t374 = text$1(" need to be adjusted to find the solution.  A limited visualizatoin of this is available in the second interactive figure.");
    			t375 = space();
    			p59 = element("p");
    			strong16 = element("strong");
    			strong16.textContent = "Exploding Norm";
    			t377 = space();
    			p60 = element("p");
    			t378 = text$1("The blue curve \n");
    			d_math205 = element("d-math");
    			t379 = text$1("'s associated parameter vector's norm is also called the ");
    			em13 = element("em");
    			em13.textContent = "function norm";
    			t381 = text$1(", shown as \n");
    			d_math206 = element("d-math");
    			t382 = text$1(" below the main plot.  For the moment, let's consider only \n");
    			d_math207 = element("d-math");
    			t383 = text$1(" and ignore \n");
    			d_math208 = element("d-math");
    			t384 = text$1(" and \n");
    			d_math209 = element("d-math");
    			t385 = text$1(".");
    			t386 = space();
    			p61 = element("p");
    			t387 = text$1("If you move one of the points very close to the other in the \n");
    			d_math210 = element("d-math");
    			t388 = text$1(" direction, but differing in height, the slope of the curve explodes, as does the magnitude of the \n");
    			d_math211 = element("d-math");
    			t389 = text$1(" and \n");
    			d_math212 = element("d-math");
    			t390 = text$1(".  At a given setting for the \n");
    			d_math213 = element("d-math");
    			t391 = text$1(" with high norm, try reducing \n");
    			d_math214 = element("d-math");
    			t392 = text$1(" until the curves are again well separated, and the function norm will shrink.");
    			t393 = space();
    			p62 = element("p");
    			t394 = text$1("In feature space terms, this situation is the opposite of when \n");
    			d_math215 = element("d-math");
    			t395 = text$1(" and \n");
    			d_math216 = element("d-math");
    			t396 = text$1(" were nearly orthogonal.  Now, they are nearly parallel.  In order for some solution vector \n");
    			d_math217 = element("d-math");
    			t397 = text$1(" to achieve very different projection lengths against nearly parallel vectors, it has to be very long to exploit the slight difference in angle.");
    			t398 = space();
    			p63 = element("p");
    			t399 = text$1("In semantic terms, one interpretation is, an exploding norm indicates the individual component curves overestimate the degree of similarity of that pair of data points, relative to their ");
    			em14 = element("em");
    			em14.textContent = "actual";
    			t401 = text$1(" similarity which is a function of their \n");
    			d_math218 = element("d-math");
    			t402 = text$1(" values.  Adjusting \n");
    			d_math219 = element("d-math");
    			t403 = text$1(" remedies this problem, at the expense of less interpolation.");
    			t404 = space();
    			p64 = element("p");
    			t405 = text$1("Since this worked example is doing exact-fit linear regression, we aren't considering the possibility that the \n");
    			d_math220 = element("d-math");
    			t406 = text$1(" values may have noise.  If that is the case, the interpretation is more complicated.");
    			t407 = space();
    			p65 = element("p");
    			strong17 = element("strong");
    			t408 = text$1("Changing \n");
    			d_math221 = element("d-math");
    			t409 = text$1("-span away from \n");
    			d_math222 = element("d-math");
    			t410 = text$1("-span");
    			t411 = space();
    			p66 = element("p");
    			t412 = text$1("Recall that \n");
    			d_math223 = element("d-math");
    			t413 = text$1(" resides in the \n");
    			d_math224 = element("d-math");
    			t414 = text$1("-span, the \n");
    			d_math225 = element("d-math");
    			t415 = text$1("-dimensional linear subspace \n");
    			d_math226 = element("d-math");
    			t416 = text$1(".   and its projection, \n");
    			d_math227 = element("d-math");
    			t417 = text$1(" resides in the \n");
    			d_math228 = element("d-math");
    			t418 = text$1("-span, \n");
    			d_math229 = element("d-math");
    			t419 = text$1(".  Up until now, \n");
    			d_math230 = element("d-math");
    			t420 = text$1(" and the two spans coincide.  In that case, \n");
    			d_math231 = element("d-math");
    			t421 = text$1(", and \n");
    			d_math232 = element("d-math");
    			t422 = text$1(".\nIf you unlock '\n");
    			d_math233 = element("d-math");
    			t423 = text$1(" tracks x', you can drag the triangles (\n");
    			d_math234 = element("d-math");
    			t424 = text$1(") or the data points and the two spans are allowed to differ, and the orthogonal decomposition of \n");
    			d_math235 = element("d-math");
    			t425 = text$1(" starts to show.");
    			br4 = element("br");
    			d_math236 = element("d-math");
    			t426 = text$1(" still shows the length of \n");
    			d_math237 = element("d-math");
    			t427 = text$1(" which exists in the \n");
    			d_math238 = element("d-math");
    			t428 = text$1("-span, but the lengths of orthogonal decomposition \n");
    			d_math239 = element("d-math");
    			t429 = text$1(" taken relative to the \n");
    			d_math240 = element("d-math");
    			t430 = text$1("-span is also shown.  In the limit, the spans are nearly orthogonal, and the parallel component is extremely small, forcing \n");
    			d_math241 = element("d-math");
    			t431 = text$1(" to grow without bound in order to project onto the \n");
    			d_math242 = element("d-math");
    			t432 = text$1("-span any particular solution.");
    			t433 = space();
    			p67 = element("p");
    			t434 = text$1("As mentioned before, this experiment is only for didactic purposes since Kernel methods assign the \n");
    			d_math243 = element("d-math");
    			t435 = text$1("-span to the \n");
    			d_math244 = element("d-math");
    			t436 = text$1("-span.  But, it is worth noting that any new unseen data resides in general outside of the \n");
    			d_math245 = element("d-math");
    			t437 = text$1("-span which is derived from the dataset.  This is a good illustration of why off-manifold data is hard to predict.");
    			t438 = space();
    			h12 = element("h1");
    			h12.textContent = "Experiments to try with Figure 2";
    			t440 = space();
    			p68 = element("p");
    			t441 = text$1("Figure 2 left panel shows the same plot with just two functions.  The right panel shows the 2d \n");
    			d_math246 = element("d-math");
    			t442 = text$1("-span, with the gray vectors denoting \n");
    			d_math247 = element("d-math");
    			t443 = text$1(" and \n");
    			d_math248 = element("d-math");
    			t444 = text$1(", and the blue vector \n");
    			d_math249 = element("d-math");
    			t445 = text$1(".  The black dot on the right panel shows the parameter vector which fits the data.  Not shown are the \n");
    			d_math250 = element("d-math");
    			t446 = text$1("-span or the \n");
    			d_math251 = element("d-math");
    			t447 = text$1(".  However, when \n");
    			d_math252 = element("d-math");
    			t448 = text$1(", they coincide.  In this case, the black dotted lines show the length of the projection of \n");
    			d_math253 = element("d-math");
    			t449 = text$1(" onto each of the \n");
    			d_math254 = element("d-math");
    			t450 = text$1(", which equals \n");
    			d_math255 = element("d-math");
    			t451 = text$1(".  There are a few informative experiments to try.");
    			t452 = space();
    			p69 = element("p");
    			strong18 = element("strong");
    			t453 = text$1("Changing the angle between \n");
    			d_math256 = element("d-math");
    			t454 = text$1(" and \n");
    			d_math257 = element("d-math");
    			t455 = text$1(".  If you drag one of the \n");
    			d_math258 = element("d-math");
    			t456 = text$1(" close to the other one, notice the angle between the gray vectors change.  Dragging them apart causes the gray vectors to asymptotically approach right angles.");
    			t457 = space();
    			p70 = element("p");
    			strong19 = element("strong");
    			t458 = text$1("Nearly orthogonal \n");
    			d_math259 = element("d-math");
    			t459 = text$1(" and \n");
    			d_math260 = element("d-math");
    			t460 = text$1(" have independent contributions to the values of \n");
    			d_math261 = element("d-math");
    			t461 = text$1(" at each \n");
    			d_math262 = element("d-math");
    			t462 = text$1(".  With 'auto solve' and '\n");
    			d_math263 = element("d-math");
    			t463 = text$1(" tracks x' checked, on the left panel, drag the black dots well apart on the \n");
    			d_math264 = element("d-math");
    			t464 = text$1(" axis.  Then, drag one dot up and down, observing the motion of the blue arrow on the right panel.  It moves back and forth in the direction of one of the \n");
    			d_math265 = element("d-math");
    			t465 = text$1(" while its projection against the other gray arrow remains nearly constant.");
    			t466 = space();
    			p71 = element("p");
    			strong20 = element("strong");
    			t467 = text$1("Nearly parallel \n");
    			d_math266 = element("d-math");
    			t468 = text$1(" and \n");
    			d_math267 = element("d-math");
    			t469 = text$1(" have highly dependent contributions to the values of \n");
    			d_math268 = element("d-math");
    			t470 = text$1(" at each \n");
    			d_math269 = element("d-math");
    			t471 = text$1(".  With 'auto solve' and '\n");
    			d_math270 = element("d-math");
    			t472 = text$1(" tracks x' checked, on the left panel, drag the black dots close together on the \n");
    			d_math271 = element("d-math");
    			t473 = text$1(" axis.  Now, move one of the dots up and down.  Observe that as the \n");
    			d_math272 = element("d-math");
    			t474 = text$1(" values of the dots widen, the blue vector on the right panel must grow very long to achieve the differing projection lengths.");
    			t475 = space();
    			h25 = element("h2");
    			t476 = text$1("Proof that ");
    			d_math273 = element("d-math");
    			t477 = text$1(" is optimal");
    			t478 = space();
    			p72 = element("p");
    			t479 = text$1("Having highlighted the separate notions of the \n");
    			d_math274 = element("d-math");
    			t480 = text$1("-span and \n");
    			d_math275 = element("d-math");
    			t481 = text$1("-span for conceptual reasons, we now show that the optimal choice is to set the \n");
    			d_math276 = element("d-math");
    			t482 = text$1("-span equal to it.");
    			t483 = space();
    			p73 = element("p");
    			t484 = text$1("The matrix form for a function \n");
    			d_math277 = element("d-math");
    			t485 = text$1("'s associated parameter vector \n");
    			d_math278 = element("d-math");
    			t486 = text$1(", with \n");
    			d_math279 = element("d-math");
    			t487 = text$1(" the matrix of row vectors \n");
    			d_math280 = element("d-math");
    			t488 = text$1(".");
    			br5 = element("br");
    			d_math281 = element("d-math");
    			t489 = text$1("'s ");
    			em15 = element("em");
    			em15.textContent = "vector of evaluation";
    			t491 = text$1(" on the \n");
    			d_math282 = element("d-math");
    			t492 = text$1(" is then given by \n");
    			d_math283 = element("d-math");
    			t493 = text$1(", where \n");
    			d_math284 = element("d-math");
    			t494 = text$1(" is similarly the matrix of row vectors \n");
    			d_math285 = element("d-math");
    			t495 = text$1(".  We now show why \n");
    			d_math286 = element("d-math");
    			t496 = text$1(" is the optimal choice.");
    			t497 = space();
    			p74 = element("p");
    			t498 = text$1("Suppose \n");
    			d_math287 = element("d-math");
    			t499 = text$1(" for some \n");
    			d_math288 = element("d-math");
    			t500 = text$1(".  By the property of dot products:");
    			t501 = space();
    			d_math289 = element("d-math");
    			t502 = space();
    			p75 = element("p");
    			p75.textContent = "In matrix form:";
    			t504 = space();
    			d_math290 = element("d-math");
    			t505 = space();
    			p76 = element("p");
    			d_math291 = element("d-math");
    			t506 = text$1(" spans either the same subspace as \n");
    			d_math292 = element("d-math");
    			t507 = text$1(", or a subspace of it.  Thus, the choice of \n");
    			d_math293 = element("d-math");
    			t508 = text$1(" (or any choice of \n");
    			d_math294 = element("d-math");
    			t509 = text$1(" such that \n");
    			d_math295 = element("d-math");
    			t510 = text$1(") will be able to fit any set of labels \n");
    			d_math296 = element("d-math");
    			t511 = text$1(" that any other choice of \n");
    			d_math297 = element("d-math");
    			t512 = text$1(" can fit, but possibly more.");
    			t513 = space();
    			p77 = element("p");
    			t514 = text$1("Furthermore, as will be argued in the next section, any two functions having the same vector of evaluation, the one with smaller parameter norm is preferable.  The squared norm \n");
    			d_math298 = element("d-math");
    			t515 = text$1(" is given by:");
    			t516 = space();
    			d_math299 = element("d-math");
    			t517 = space();
    			h26 = element("h2");
    			h26.textContent = "Regularizing by Minimizing the Function Norm";
    			t519 = space();
    			p78 = element("p");
    			t520 = text$1("There are two properties a function \n");
    			d_math300 = element("d-math");
    			t521 = text$1(" has related to its parameter vector norm \n");
    			d_math301 = element("d-math");
    			t522 = text$1(".  The first is the overall magnitude (positive and negative) of its values.  The second is the magnitude of the difference between pairs of points, relative to how similar those points are by the measure of the family of functions.");
    			t523 = space();
    			p79 = element("p");
    			t524 = text$1("To illustrate, consider two arbitrary inputs \n");
    			d_math302 = element("d-math");
    			t525 = text$1(".  How do  the magnitudes of values \n");
    			d_math303 = element("d-math");
    			t526 = text$1(" and difference in values \n");
    			d_math304 = element("d-math");
    			t527 = text$1(" relate to the norm of its parameter vector?");
    			t528 = space();
    			d_math305 = element("d-math");
    			t529 = space();
    			p80 = element("p");
    			t530 = text$1("The first inequality tells us that the magnitude of values of the function \n");
    			d_math306 = element("d-math");
    			t531 = text$1(" is bounded by a fixed multiple of \n");
    			d_math307 = element("d-math");
    			t532 = text$1(".  The multiple itself, \n");
    			d_math308 = element("d-math");
    			t533 = text$1(" we have no control over - it is determined by the choice of \n");
    			d_math309 = element("d-math");
    			t534 = text$1(".  But by controlling \n");
    			d_math310 = element("d-math");
    			t535 = text$1(" we can control the range of values of \n");
    			d_math311 = element("d-math");
    			t536 = text$1(".");
    			t537 = space();
    			p81 = element("p");
    			t538 = text$1("The second inequality tells us that the absolute difference in value between any two points is proportional to \n");
    			d_math312 = element("d-math");
    			t539 = text$1(".  As the distance shrinks, the values will be equal.  By bounding \n");
    			d_math313 = element("d-math");
    			t540 = text$1(", we can control how sensitive the function could be to distance between input feature vectors.");
    			t541 = space();
    			p82 = element("p");
    			t542 = text$1("Conversely, if you demand the solution function fit a particular set of fixed \n");
    			d_math314 = element("d-math");
    			t543 = text$1(" and \n");
    			d_math315 = element("d-math");
    			t544 = text$1(" values, that is, \n");
    			d_math316 = element("d-math");
    			t545 = text$1(", then \n");
    			d_math317 = element("d-math");
    			t546 = text$1(" must grow to compensate for small \n");
    			d_math318 = element("d-math");
    			t547 = text$1(".  This is the behavior you observe by dragging one of the black dots close on the \n");
    			d_math319 = element("d-math");
    			t548 = text$1(" axis in 'auto solve' mode, while maintaining a fixed gap in height.  The norm of the function explodes.");
    			t549 = space();
    			p83 = element("p");
    			t550 = text$1("It also says something about the choice of \n");
    			d_math320 = element("d-math");
    			t551 = text$1(".  Ideally, we would like to choose a \n");
    			d_math321 = element("d-math");
    			t552 = text$1(" such that \n");
    			d_math322 = element("d-math");
    			t553 = text$1(" is roughy proportional to \n");
    			d_math323 = element("d-math");
    			t554 = text$1(" in the data set for all pairs \n");
    			d_math324 = element("d-math");
    			t555 = text$1(".");
    			t556 = space();
    			h27 = element("h2");
    			h27.textContent = "Finally, enter the Kernel";
    			t558 = space();
    			p84 = element("p");
    			t559 = text$1("Recall from the previous section that using \n");
    			d_math325 = element("d-math");
    			t560 = text$1(" as the set of parameter vectors ensures 1) the method has arbitrary fitting capacity and 2) the solution will be the lowest norm solution possible.  So we have the following:");
    			t561 = space();
    			d_math326 = element("d-math");
    			t562 = space();
    			p85 = element("p");
    			t563 = text$1("To find \n");
    			d_math327 = element("d-math");
    			t564 = text$1(", solve:");
    			t565 = space();
    			d_math328 = element("d-math");
    			t566 = space();
    			p86 = element("p");
    			p86.textContent = "This will minimize to zero if the assumptions above hold.  To compromise between a perfectly fitting function and the bounds the norm provides, instead solve:";
    			t568 = space();
    			d_math329 = element("d-math");
    			t569 = space();
    			p87 = element("p");
    			p87.textContent = "Finally, to evaluate the function on new data:";
    			t571 = space();
    			d_math330 = element("d-math");
    			t572 = space();
    			p88 = element("p");
    			t573 = text$1("So we see that the only quantities dependent on the \n");
    			d_math331 = element("d-math");
    			t574 = text$1(" data are dot products \n");
    			d_math332 = element("d-math");
    			t575 = text$1(", appearing in the \n");
    			d_math333 = element("d-math");
    			t576 = text$1(" terms or the solution function.  Finally, we define a function called the \"kernel\" as:");
    			t577 = space();
    			d_math334 = element("d-math");
    			t578 = space();
    			p89 = element("p");
    			p89.textContent = "Then, the general optimization formula simplifies to:";
    			t580 = space();
    			d_math335 = element("d-math");
    			t581 = space();
    			p90 = element("p");
    			p90.textContent = "and evaluating the solution function is now written as:";
    			t583 = space();
    			d_math336 = element("d-math");
    			t584 = space();
    			p91 = element("p");
    			t585 = text$1("Returning back to the plot, you can see that the blue curve evaluated at any given \n");
    			d_math337 = element("d-math");
    			t586 = text$1(" is the \n");
    			d_math338 = element("d-math");
    			t587 = text$1(" weighted sum of scaled gray curves - individual Gaussians with means equal to the \n");
    			d_math339 = element("d-math");
    			t588 = text$1("'s.  Since \n");
    			d_math340 = element("d-math");
    			t589 = text$1(", the expression above is precisely that.");
    			t590 = space();
    			h13 = element("h1");
    			h13.textContent = "Summary and Conclusion";
    			t592 = space();
    			p92 = element("p");
    			t593 = text$1("The Kernel Method allow discovering a function to fit an arbitrary data relationship \n");
    			d_math341 = element("d-math");
    			t594 = text$1(", while at the same time providing a computable means to bound the function's overall magnitude at individual inputs, and the magnitude of the difference at pairs of inputs.");
    			t595 = space();
    			p93 = element("p");
    			t596 = text$1("Kernel methods achieve this by automatically providing a library of functions, one for each \n");
    			d_math342 = element("d-math");
    			t597 = text$1(" in the data set.  When each is evaluated on the \n");
    			d_math343 = element("d-math");
    			t598 = text$1(", they provide linearly independent sets of values.  Thus a unique linear combination of these functions exists to fit any set of target values \n");
    			d_math344 = element("d-math");
    			t599 = text$1(" at the \n");
    			d_math345 = element("d-math");
    			t600 = text$1(".");
    			t601 = space();
    			p94 = element("p");
    			t602 = text$1("The functions are defined as dot products between \"feature vectors\": \n");
    			d_math346 = element("d-math");
    			t603 = text$1(".  This has three main benefits:");
    			t604 = space();
    			ol2 = element("ol");
    			li7 = element("li");
    			p95 = element("p");
    			p95.textContent = "It is possible to prove, using linear algebra alone, that a perfect-fitting solution exists and is of minimal norm.";
    			t606 = space();
    			li8 = element("li");
    			p96 = element("p");
    			p96.textContent = "For further regularization, the Cauchy Schwarz inequality shows the \"function norm\" provides bounds on magnitude of values and differences of pairs of values.";
    			t608 = space();
    			li9 = element("li");
    			p97 = element("p");
    			p97.textContent = "Data fitting and regularization are now purely linear problems, and the arsenal of linear optimization techniques can be applied.";
    			t610 = space();
    			h14 = element("h1");
    			h14.textContent = "Recommended reading and Notes";
    			t612 = space();
    			p98 = element("p");
    			p98.textContent = "In the above essay I intentionally avoided some of the terminology and names of theorems.  When I was learning about Kernel methods, I found that they seemed to hint at giving insight, but ultimately they did not.  Here are some of the concepts, linking them to the above, or a critique why I didn't include them in the main text.";
    			t614 = space();
    			h28 = element("h2");
    			h28.textContent = "Positive (semi)Definite matrices";
    			t616 = space();
    			p99 = element("p");
    			t617 = text$1("It turns out that all square matrices, if they can be written as the product \n");
    			d_math347 = element("d-math");
    			t618 = text$1(" for some \n");
    			d_math348 = element("d-math");
    			t619 = text$1(", are either positive definite (if all rows of \n");
    			d_math349 = element("d-math");
    			t620 = text$1(" are linearly independent), or positive semidefinite (if the rank of \n");
    			d_math350 = element("d-math");
    			t621 = text$1(" is less than its number of rows).  Since the central idea of Kernel methods is constructing functions as dot products, it seemed much more of essence to focus on the construction \n");
    			d_math351 = element("d-math");
    			t622 = text$1(" itself.  This also makes clear why the definition of p.s.d, namely that \n");
    			d_math352 = element("d-math");
    			t623 = text$1(" for all \n");
    			d_math353 = element("d-math");
    			t624 = text$1(" implies that \n");
    			d_math354 = element("d-math");
    			t625 = text$1(" for some \n");
    			d_math355 = element("d-math");
    			t626 = text$1(":  The \n");
    			d_math356 = element("d-math");
    			t627 = text$1(" are simply a basis in a subspace, \n");
    			d_math357 = element("d-math");
    			t628 = text$1(" is a vector, and \n");
    			d_math358 = element("d-math");
    			t629 = text$1(" is the dot product of the vector with itself - its length squared.");
    			t630 = space();
    			h29 = element("h2");
    			h29.textContent = "The Kernel Trick";
    			t632 = space();
    			p100 = element("p");
    			t633 = text$1("The \"kernel trick\" is the idea that a kernel function \n");
    			d_math359 = element("d-math");
    			t634 = text$1(" can be evaluated without actually evaluating the feature vectors and taking their dot product.  While this is important for computational efficiency, it ultimately is uninformative for the purposes of understanding Kernel methods.  Indeed, the Kernel trick doesn't magically allow one to compute exact Gaussian values - doing so would require an infinite amount of computation.  So, whether or not a given kernel has an infinite or finite dimensional feature space, and whether it is implemented approximately or exactly, doesn't really decide its usefulness as a kernel.  In short, the kernel trick is just one form of mathematical shortcut (if it exists), and doesn't really enlighten one as to the nature of Kernel methods.  One could use a Kernel that has only finite capacity and no known Kernel trick, and it could still be a valid Kernel.");
    			t635 = space();
    			h210 = element("h2");
    			h210.textContent = "Distinct between Feature Space and Reproducing Kernel Hilbert Space";
    			t637 = space();
    			p101 = element("p");
    			p101.textContent = "In my reading, I found the discussion of feature space and the 'Hilbert space' (from the RHKS) blurred together.  They are distinct mathematical entities.  Although more subtle results in Kernel research are proved with the help of the RKHS, I didn't feel the basics were much helped by them.  But, in the theory elements in the RKHS map one-to-one to elements in feature space and to functions in input space, so they are sometimes spoken of interchangeably.";
    			t639 = space();
    			p102 = element("p");
    			t640 = text$1("In an effort to disambiguate them, here is a summary.  In Kernel Methods, functions \n");
    			d_math360 = element("d-math");
    			t641 = space();
    			em16 = element("em");
    			em16.textContent = "correspond one-to-one";
    			t643 = text$1(" with feature vectors \n");
    			d_math361 = element("d-math");
    			t644 = text$1(", because of their definition as a dot product.  As any vector space, the feature space has an inner product defined on it, which is the simple dot product, and the ");
    			em17 = element("em");
    			em17.textContent = "kernel matrix";
    			t646 = space();
    			d_math362 = element("d-math");
    			t647 = text$1(" is the matrix of inner products on a basis \n");
    			d_math363 = element("d-math");
    			t648 = text$1(", the \n");
    			d_math364 = element("d-math");
    			t649 = text$1(" from the dataset, in this feature space.");
    			t650 = space();
    			p103 = element("p");
    			t651 = text$1("Separately from this, the function itself, \n");
    			d_math365 = element("d-math");
    			t652 = text$1(" associates one real value for each \n");
    			d_math366 = element("d-math");
    			t653 = text$1(".  This collection of values could be viewed as the components of ");
    			em18 = element("em");
    			em18.textContent = "another";
    			t655 = text$1(" infinite-dimensional vector.  In conventional notation, \n");
    			d_math367 = element("d-math");
    			t656 = text$1(".  This is like \n");
    			d_math368 = element("d-math");
    			t657 = text$1(",  but instead of 3 real components, \n");
    			d_math369 = element("d-math");
    			t658 = text$1(" components.  Then, the function is not merely ");
    			em19 = element("em");
    			em19.textContent = "corresponding to a vector";
    			t660 = text$1(" but ");
    			em20 = element("em");
    			em20.textContent = "is";
    			t662 = text$1(" a vector.  The space \n");
    			d_math370 = element("d-math");
    			t663 = text$1(" of such functions-as-vectors is known as the Hilbert Space \n");
    			d_math371 = element("d-math");
    			t664 = text$1(".  It has a specific inner product defined on it which links it up to the original feature space: \n");
    			d_math372 = element("d-math");
    			t665 = text$1(".");
    			t666 = space();
    			p104 = element("p");
    			t667 = text$1("Now that the Hilbert space has a set of basis vectors \n");
    			d_math373 = element("d-math");
    			t668 = text$1(", and an inner product, a Kernel matrix \n");
    			d_math374 = element("d-math");
    			t669 = text$1(" can be defined.  But now, note that the rows and columns of the Kernel matrix are vectors of values.  Unlike the feature space, where the rows of the kernel matrix were not of the same type as the vectors in the space itself, in the Hilbert space they are.  Therefore, \n");
    			d_math375 = element("d-math");
    			t670 = text$1(", because this is just a set of inner products between two rows.   This is what gives rise to the phrase \"Reproducing Kernel\".  See ");
    			a0 = element("a");
    			a0.textContent = "https://arxiv.org/pdf/1408.0952.pdf";
    			t672 = text$1(".");
    			t673 = space();
    			h211 = element("h2");
    			h211.textContent = "Representer Theorem";
    			t675 = space();
    			p105 = element("p");
    			t676 = text$1("In the parlance of RHKS theory, the point \n");
    			d_math376 = element("d-math");
    			t677 = text$1(" corresponding to a given \n");
    			d_math377 = element("d-math");
    			t678 = text$1(" is called \n");
    			d_math378 = element("d-math");
    			t679 = text$1("'s ");
    			em21 = element("em");
    			em21.textContent = "representer";
    			t681 = text$1(" of evaluation, and more generally, any point in \n");
    			d_math379 = element("d-math");
    			t682 = text$1(" is a ");
    			em22 = element("em");
    			em22.textContent = "representation";
    			t684 = text$1(" of some function in an abstract way.  So, the Representer Theorem asserts that an optimal solution to a data fitting problem exists in the span of the representers of the data.  That is, in the span of \n");
    			d_math380 = element("d-math");
    			t685 = text$1(".  The section on this article proving through orthogonal decomposition, that setting \n");
    			d_math381 = element("d-math");
    			t686 = text$1(" results in the minimum norm solution without any loss of expressive power, is a simplified version of this theorem.  For more detail, see:  ");
    			a1 = element("a");
    			a1.textContent = "https://alex.smola.org/papers/2001/SchHerSmo01.pdf";
    			t688 = space();
    			h212 = element("h2");
    			h212.textContent = "Part 2 - Examples of linear problems";
    			t690 = space();
    			p106 = element("p");
    			p106.textContent = "Kernel methods are used for PCA, CCA, K-means, Regression, separating hyperplanes (SVM).  All of these involve finding an optimal point in a space using linear optimization methods.  If possible, show how the inner product is used in some of these formulas.";
    			t692 = space();
    			h213 = element("h2");
    			h213.textContent = "Kernel Ridge Regression";
    			t694 = space();
    			h214 = element("h2");
    			h214.textContent = "Kernel Linear Regression";
    			t696 = space();
    			h215 = element("h2");
    			h215.textContent = "Kernel PCA";
    			t698 = space();
    			p107 = element("p");
    			p107.textContent = "Mairal Lecture 9";
    			t700 = space();
    			h216 = element("h2");
    			h216.textContent = "Kernel K-means and CCA";
    			t702 = space();
    			p108 = element("p");
    			p108.textContent = "Mairal Lecture 10";
    			t704 = space();
    			p109 = element("p");
    			d_math382 = element("d-math");
    			t705 = space();
    			p110 = element("p");
    			t706 = text$1("See Gong and Lazebnik:  ");
    			a2 = element("a");
    			a2.textContent = "https://arxiv.org/pdf/1212.4522.pdf";
    			t708 = space();
    			h217 = element("h2");
    			h217.textContent = "Large Margin Classifiers";
    			t710 = space();
    			p111 = element("p");
    			t711 = text$1("In binary classification, the ");
    			em23 = element("em");
    			em23.textContent = "margin";
    			t713 = text$1(" of the function \n");
    			d_math383 = element("d-math");
    			t714 = text$1(" for \n");
    			d_math384 = element("d-math");
    			t715 = text$1(" is \n");
    			d_math385 = element("d-math");
    			t716 = text$1(".  The loss is a decreasing function of the margin: \n");
    			d_math386 = element("d-math");
    			t717 = text$1(".");
    			t718 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Method";
    			t720 = space();
    			th1 = element("th");
    			d_math387 = element("d-math");
    			t721 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "Kernel Logistic Regression";
    			t723 = space();
    			td1 = element("td");
    			d_math388 = element("d-math");
    			t724 = space();
    			tr2 = element("tr");
    			td2 = element("td");
    			td2.textContent = "1-SVM (hinge loss)";
    			t726 = space();
    			td3 = element("td");
    			d_math389 = element("d-math");
    			t727 = space();
    			tr3 = element("tr");
    			td4 = element("td");
    			td4.textContent = "2-SVM";
    			t729 = space();
    			td5 = element("td");
    			d_math390 = element("d-math");
    			t730 = space();
    			tr4 = element("tr");
    			td6 = element("td");
    			td6.textContent = "Boosting";
    			t732 = space();
    			td7 = element("td");
    			d_math391 = element("d-math");
    			t733 = space();
    			p112 = element("p");
    			p112.textContent = "In all these, we solve:";
    			t735 = space();
    			d_math392 = element("d-math");
    			t736 = space();
    			p113 = element("p");
    			t737 = text$1("The idea of support vectors is to make \n");
    			d_math393 = element("d-math");
    			t738 = text$1(" sparse, and only non-zero components for samples that are hard to classify (close to the separating hyperplane):");
    			t739 = space();
    			p114 = element("p");
    			d_math394 = element("d-math");
    			t740 = space();
    			p115 = element("p");
    			p115.textContent = "Kernel Logistic Regression is a large-margin classifier.";
    			t742 = space();
    			h218 = element("h2");
    			h218.textContent = "Neural Tangent Kernel";
    			t744 = space();
    			p116 = element("p");
    			t745 = text$1("See ");
    			a3 = element("a");
    			a3.textContent = "https://arxiv.org/abs/1806.07572";
    			t747 = space();
    			h219 = element("h2");
    			h219.textContent = "Geometric Considerations of choice of Kernel";
    			t749 = space();
    			p117 = element("p");
    			t750 = text$1("To apply a Kernel method to data \n");
    			d_math395 = element("d-math");
    			t751 = text$1(" is to adopt the assumption that there is a metric defined on the input domain \n");
    			d_math396 = element("d-math");
    			t752 = text$1(".  ");
    			em24 = element("em");
    			em24.textContent = "Metric";
    			t754 = text$1(" means a definition of distances and angles between any two points in \n");
    			d_math397 = element("d-math");
    			t755 = text$1(".  This idea in itself is remarkable.  Although we are used to thinking of the vectors in \n");
    			d_math398 = element("d-math");
    			t756 = text$1(" as having lengths, and pairs of vectors having an angle between them, this idea is even more general.  It does not require \n");
    			d_math399 = element("d-math");
    			t757 = text$1(" to have any particular structure at all.");
    			br6 = element("br");
    			d_math400 = element("d-math");
    			t758 = text$1(" may be continuous or discrete, or mixed.  And it can have any natural ordering of its elements, or none.  And, even if \n");
    			d_math401 = element("d-math");
    			t759 = text$1(" is naturally ordered, such as \n");
    			d_math402 = element("d-math");
    			t760 = text$1(", the metric need not be consistent with that ordering at all.");
    			t761 = space();
    			p118 = element("p");
    			t762 = text$1("Indeed, the very notion of \"ordering\" itself is a weak concept once you go past one dimension.  Ordering of elements in \n");
    			d_math403 = element("d-math");
    			t763 = text$1(" is simply a result of a notion of the length of each element.  Although, the angle is always either zero or \n");
    			d_math404 = element("d-math");
    			t764 = text$1(".");
    			t765 = space();
    			p119 = element("p");
    			t766 = text$1("But, this is worth meditating on, because it is precisely this notion which is the foundation of kernel methods.  A Kernel merely quantifies this intuitive notion.  Most discussions about Kernels say they are a measure of \"similarity\" between two points.  However, I don't like that word since it has no standing in geometry.  It is possible, for instance for \n");
    			d_math405 = element("d-math");
    			t767 = text$1(" for some \n");
    			d_math406 = element("d-math");
    			t768 = text$1(" and \n");
    			d_math407 = element("d-math");
    			t769 = text$1(".  If we called \n");
    			d_math408 = element("d-math");
    			t770 = text$1(" a \"similarity measure\", then \n");
    			d_math409 = element("d-math");
    			t771 = text$1(" would be more similar to \n");
    			d_math410 = element("d-math");
    			t772 = text$1(" than to itself.");
    			t773 = space();
    			p120 = element("p");
    			t774 = text$1("Rather, a kernel defines the ");
    			em25 = element("em");
    			em25.textContent = "inner product";
    			t776 = text$1(" on a set \n");
    			d_math411 = element("d-math");
    			t777 = text$1(", and the notions of length and angle follow indirectly from that:");
    			t778 = space();
    			d_math412 = element("d-math");
    			attr_dev(h10, "id", "introduction");
    			add_location(h10, file$a, 0, 0, 0);
    			add_location(p0, file$a, 1, 0, 40);
    			add_location(p1, file$a, 2, 0, 388);
    			add_location(p2, file$a, 3, 0, 864);
    			add_location(p3, file$a, 4, 0, 1063);
    			add_location(p4, file$a, 5, 0, 1719);
    			add_location(p5, file$a, 6, 0, 2410);
    			attr_dev(h11, "id", "an-illustration-of-kernel-regression");
    			add_location(h11, file$a, 7, 0, 2745);
    			add_location(d_math0, file$a, 9, 0, 2876);
    			add_location(d_math1, file$a, 11, 0, 2981);
    			add_location(d_math2, file$a, 13, 0, 3055);
    			add_location(d_math3, file$a, 15, 0, 3169);
    			add_location(p6, file$a, 8, 0, 2833);
    			add_location(d_math4, file$a, 18, 0, 3284);
    			add_location(d_math5, file$a, 20, 0, 3379);
    			add_location(d_math6, file$a, 22, 0, 3438);
    			add_location(p7, file$a, 17, 0, 3212);
    			add_location(d_math7, file$a, 25, 0, 3648);
    			add_location(em0, file$a, 26, 63, 3731);
    			add_location(d_math8, file$a, 27, 0, 3795);
    			add_location(d_math9, file$a, 29, 0, 3860);
    			add_location(d_math10, file$a, 31, 0, 3987);
    			add_location(p8, file$a, 24, 0, 3576);
    			add_location(d_math11, file$a, 34, 0, 4095);
    			add_location(d_math12, file$a, 36, 0, 4389);
    			add_location(p9, file$a, 33, 0, 4047);
    			add_location(p10, file$a, 38, 0, 4603);
    			add_location(d_math13, file$a, 40, 0, 5002);
    			add_location(d_math14, file$a, 42, 0, 5057);
    			add_location(d_math15, file$a, 44, 0, 5239);
    			add_location(d_math16, file$a, 46, 0, 5309);
    			add_location(p11, file$a, 39, 0, 4937);
    			add_location(p12, file$a, 48, 0, 5348);
    			set_custom_element_data(d_math17, "block", "");
    			add_location(d_math17, file$a, 49, 0, 5367);
    			add_location(d_math18, file$a, 60, 0, 5806);
    			add_location(d_math19, file$a, 62, 0, 5910);
    			add_location(d_math20, file$a, 64, 0, 5984);
    			add_location(d_math21, file$a, 66, 0, 6152);
    			add_location(d_math22, file$a, 68, 0, 6288);
    			add_location(d_math23, file$a, 70, 0, 6374);
    			add_location(p13, file$a, 59, 0, 5798);
    			add_location(d_math24, file$a, 73, 0, 6645);
    			add_location(p14, file$a, 72, 0, 6431);
    			attr_dev(h20, "id", "some-observations");
    			add_location(h20, file$a, 75, 0, 6682);
    			add_location(d_math25, file$a, 77, 0, 6783);
    			add_location(strong0, file$a, 76, 3, 6735);
    			add_location(em1, file$a, 78, 31, 6862);
    			add_location(d_math26, file$a, 79, 0, 6887);
    			add_location(d_math27, file$a, 81, 0, 6960);
    			add_location(d_math28, file$a, 83, 0, 7054);
    			add_location(d_math29, file$a, 85, 0, 7194);
    			add_location(p15, file$a, 76, 0, 6732);
    			add_location(d_math30, file$a, 88, 0, 7423);
    			add_location(strong1, file$a, 87, 3, 7341);
    			add_location(em2, file$a, 89, 41, 7484);
    			add_location(d_math31, file$a, 90, 0, 7508);
    			add_location(d_math32, file$a, 92, 0, 7559);
    			add_location(d_math33, file$a, 94, 0, 7624);
    			add_location(em3, file$a, 95, 27, 7669);
    			add_location(d_math34, file$a, 96, 0, 7749);
    			add_location(p16, file$a, 87, 0, 7338);
    			add_location(strong2, file$a, 98, 3, 7854);
    			add_location(d_math35, file$a, 99, 0, 8173);
    			add_location(p17, file$a, 98, 0, 7851);
    			add_location(strong3, file$a, 101, 3, 8305);
    			add_location(d_math36, file$a, 102, 0, 8763);
    			add_location(p18, file$a, 101, 0, 8302);
    			add_location(d_math37, file$a, 105, 0, 9250);
    			add_location(p19, file$a, 104, 0, 9120);
    			attr_dev(h21, "id", "the-three-design-choices-underlying-all-kernel-methods");
    			add_location(h21, file$a, 107, 0, 9453);
    			add_location(p20, file$a, 108, 0, 9577);
    			attr_dev(h30, "id", "first-design-choice");
    			add_location(h30, file$a, 109, 0, 10175);
    			add_location(d_math38, file$a, 111, 0, 10273);
    			add_location(strong4, file$a, 110, 7, 10236);
    			add_location(em4, file$a, 110, 3, 10232);
    			add_location(d_math39, file$a, 113, 0, 10361);
    			add_location(d_math40, file$a, 115, 0, 10481);
    			add_location(d_math41, file$a, 117, 0, 10545);
    			add_location(d_math42, file$a, 119, 0, 10654);
    			add_location(d_math43, file$a, 121, 0, 10839);
    			add_location(p21, file$a, 110, 0, 10229);
    			attr_dev(h31, "id", "second-design-choice");
    			add_location(h31, file$a, 123, 0, 11071);
    			add_location(strong5, file$a, 124, 7, 11134);
    			add_location(em5, file$a, 124, 3, 11130);
    			add_location(d_math44, file$a, 125, 0, 11298);
    			add_location(d_math45, file$a, 127, 0, 11342);
    			add_location(d_math46, file$a, 129, 0, 11419);
    			add_location(d_math47, file$a, 131, 0, 11471);
    			add_location(d_math48, file$a, 133, 0, 11525);
    			add_location(em6, file$a, 134, 12, 11555);
    			add_location(d_math49, file$a, 135, 0, 11776);
    			add_location(p22, file$a, 124, 0, 11127);
    			attr_dev(h32, "id", "third-design-choice");
    			add_location(h32, file$a, 137, 0, 12239);
    			add_location(strong6, file$a, 138, 7, 12300);
    			add_location(em7, file$a, 138, 3, 12296);
    			add_location(br0, file$a, 138, 162, 12455);
    			add_location(d_math50, file$a, 138, 166, 12459);
    			add_location(d_math51, file$a, 140, 0, 12636);
    			add_location(p23, file$a, 138, 0, 12293);
    			add_location(d_math52, file$a, 143, 0, 13357);
    			add_location(d_math53, file$a, 145, 0, 13411);
    			add_location(p24, file$a, 142, 0, 13223);
    			attr_dev(h22, "id", "gaussians-have-a-dot-product-form");
    			add_location(h22, file$a, 147, 0, 13499);
    			add_location(d_math54, file$a, 149, 0, 13741);
    			add_location(d_math55, file$a, 151, 0, 13785);
    			add_location(d_math56, file$a, 153, 0, 13869);
    			add_location(d_math57, file$a, 155, 0, 13910);
    			add_location(d_math58, file$a, 157, 0, 13971);
    			add_location(d_math59, file$a, 159, 0, 14047);
    			add_location(br1, file$a, 160, 19, 14103);
    			add_location(d_math60, file$a, 160, 23, 14107);
    			add_location(d_math61, file$a, 162, 0, 14168);
    			add_location(d_math62, file$a, 164, 0, 14242);
    			add_location(p25, file$a, 148, 0, 13581);
    			add_location(d_math63, file$a, 167, 0, 14360);
    			add_location(d_math64, file$a, 169, 0, 14475);
    			add_location(d_math65, file$a, 171, 0, 14648);
    			add_location(p26, file$a, 166, 0, 14304);
    			set_custom_element_data(d_math66, "block", "");
    			add_location(d_math66, file$a, 173, 0, 14683);
    			add_location(d_math67, file$a, 184, 0, 15414);
    			add_location(d_math68, file$a, 186, 0, 15464);
    			add_location(p27, file$a, 183, 0, 15378);
    			set_custom_element_data(d_math69, "block", "");
    			add_location(d_math69, file$a, 188, 0, 15506);
    			add_location(d_math70, file$a, 200, 0, 16381);
    			add_location(d_math71, file$a, 202, 0, 16512);
    			add_location(p28, file$a, 199, 0, 16366);
    			add_location(d_math72, file$a, 205, 0, 16653);
    			add_location(d_math73, file$a, 207, 0, 16757);
    			add_location(d_math74, file$a, 209, 0, 16814);
    			add_location(d_math75, file$a, 211, 0, 16878);
    			add_location(d_math76, file$a, 213, 0, 16913);
    			add_location(d_math77, file$a, 215, 0, 16957);
    			add_location(em8, file$a, 216, 21, 17055);
    			add_location(d_math78, file$a, 217, 0, 17086);
    			add_location(em9, file$a, 218, 69, 17194);
    			add_location(em10, file$a, 218, 114, 17239);
    			add_location(p29, file$a, 204, 0, 16621);
    			add_location(d_math79, file$a, 220, 0, 17512);
    			add_location(d_math80, file$a, 222, 0, 17567);
    			add_location(d_math81, file$a, 224, 0, 17790);
    			add_location(d_math82, file$a, 226, 0, 18068);
    			add_location(p30, file$a, 219, 0, 17437);
    			add_location(d_math83, file$a, 229, 0, 18186);
    			add_location(d_math84, file$a, 231, 0, 18237);
    			add_location(d_math85, file$a, 233, 0, 18368);
    			add_location(d_math86, file$a, 235, 0, 18498);
    			add_location(d_math87, file$a, 237, 0, 18637);
    			add_location(d_math88, file$a, 239, 0, 18717);
    			add_location(d_math89, file$a, 241, 0, 18998);
    			add_location(d_math90, file$a, 243, 0, 19072);
    			add_location(p31, file$a, 228, 0, 18153);
    			attr_dev(h23, "id", "the-mapping-between-input-and-feature-space");
    			add_location(h23, file$a, 245, 0, 19133);
    			add_location(d_math91, file$a, 247, 0, 19630);
    			add_location(p32, file$a, 246, 0, 19235);
    			add_location(p33, file$a, 249, 0, 19799);
    			add_location(d_math92, file$a, 251, 0, 20035);
    			add_location(d_math93, file$a, 253, 0, 20076);
    			add_location(d_math94, file$a, 255, 0, 20156);
    			add_location(p34, file$a, 250, 0, 19979);
    			add_location(strong7, file$a, 258, 7, 20222);
    			add_location(d_math95, file$a, 258, 71, 20286);
    			add_location(d_math96, file$a, 258, 150, 20365);
    			add_location(p35, file$a, 258, 4, 20219);
    			add_location(li0, file$a, 258, 0, 20215);
    			add_location(strong8, file$a, 260, 7, 20460);
    			add_location(d_math97, file$a, 260, 77, 20530);
    			add_location(d_math98, file$a, 260, 183, 20636);
    			add_location(p36, file$a, 260, 4, 20457);
    			add_location(li1, file$a, 260, 0, 20453);
    			add_location(strong9, file$a, 262, 7, 20736);
    			add_location(d_math99, file$a, 262, 94, 20823);
    			add_location(d_math100, file$a, 262, 166, 20895);
    			add_location(d_math101, file$a, 262, 369, 21098);
    			add_location(d_math102, file$a, 262, 421, 21150);
    			add_location(d_math103, file$a, 262, 479, 21208);
    			add_location(d_math104, file$a, 262, 535, 21264);
    			add_location(d_math105, file$a, 262, 616, 21345);
    			add_location(d_math106, file$a, 262, 656, 21385);
    			add_location(p37, file$a, 262, 4, 20733);
    			add_location(li2, file$a, 262, 0, 20729);
    			add_location(ol0, file$a, 257, 0, 20210);
    			add_location(p38, file$a, 265, 0, 21439);
    			add_location(strong10, file$a, 267, 7, 21502);
    			add_location(d_math107, file$a, 267, 132, 21627);
    			add_location(p39, file$a, 267, 4, 21499);
    			add_location(li3, file$a, 267, 0, 21495);
    			add_location(d_math108, file$a, 269, 77, 21752);
    			add_location(strong11, file$a, 269, 7, 21682);
    			add_location(d_math109, file$a, 269, 129, 21804);
    			add_location(d_math110, file$a, 269, 203, 21878);
    			add_location(em11, file$a, 269, 298, 21973);
    			add_location(d_math111, file$a, 269, 312, 21987);
    			add_location(d_math112, file$a, 269, 392, 22067);
    			add_location(d_math113, file$a, 269, 606, 22281);
    			add_location(p40, file$a, 269, 4, 21679);
    			add_location(li4, file$a, 269, 0, 21675);
    			add_location(strong12, file$a, 271, 7, 22391);
    			add_location(d_math114, file$a, 271, 129, 22513);
    			add_location(p41, file$a, 271, 4, 22388);
    			add_location(li5, file$a, 271, 0, 22384);
    			add_location(strong13, file$a, 273, 7, 22634);
    			add_location(d_math115, file$a, 273, 100, 22727);
    			add_location(d_math116, file$a, 273, 136, 22763);
    			add_location(d_math117, file$a, 273, 220, 22847);
    			add_location(d_math118, file$a, 273, 280, 22907);
    			add_location(d_math119, file$a, 273, 356, 22983);
    			add_location(d_math120, file$a, 273, 405, 23032);
    			add_location(d_math121, file$a, 273, 492, 23119);
    			add_location(p42, file$a, 273, 4, 22631);
    			add_location(li6, file$a, 273, 0, 22627);
    			attr_dev(ol1, "start", "4");
    			add_location(ol1, file$a, 266, 0, 21480);
    			add_location(d_math122, file$a, 277, 0, 23219);
    			add_location(d_math123, file$a, 279, 0, 23262);
    			add_location(p43, file$a, 276, 0, 23175);
    			attr_dev(h24, "id", "interactive-figure-1");
    			add_location(h24, file$a, 281, 0, 23453);
    			add_location(d_math124, file$a, 283, 0, 23679);
    			add_location(d_math125, file$a, 285, 0, 23783);
    			add_location(d_math126, file$a, 287, 0, 23880);
    			add_location(p44, file$a, 282, 0, 23509);
    			add_location(d_math127, file$a, 290, 0, 23994);
    			add_location(d_math128, file$a, 292, 0, 24081);
    			add_location(d_math129, file$a, 294, 0, 24190);
    			add_location(d_math130, file$a, 296, 0, 24231);
    			add_location(p45, file$a, 289, 0, 23954);
    			add_location(d_math131, file$a, 299, 0, 24409);
    			add_location(d_math132, file$a, 301, 0, 24456);
    			add_location(d_math133, file$a, 303, 0, 24542);
    			add_location(d_math134, file$a, 305, 0, 24602);
    			add_location(p46, file$a, 298, 0, 24304);
    			add_location(d_math135, file$a, 308, 0, 24998);
    			add_location(d_math136, file$a, 310, 0, 25130);
    			add_location(d_math137, file$a, 312, 0, 25170);
    			add_location(d_math138, file$a, 314, 0, 25258);
    			add_location(d_math139, file$a, 316, 0, 25514);
    			add_location(p47, file$a, 307, 0, 24824);
    			add_location(d_math140, file$a, 319, 0, 25626);
    			add_location(d_math141, file$a, 321, 0, 25666);
    			add_location(em12, file$a, 322, 76, 25762);
    			add_location(d_math142, file$a, 323, 0, 25808);
    			add_location(d_math143, file$a, 325, 0, 25887);
    			add_location(d_math144, file$a, 327, 0, 26086);
    			add_location(d_math145, file$a, 329, 0, 26143);
    			add_location(d_math146, file$a, 331, 0, 26235);
    			add_location(p48, file$a, 318, 0, 25559);
    			add_location(d_math147, file$a, 334, 0, 26311);
    			add_location(d_math148, file$a, 336, 0, 26360);
    			add_location(d_math149, file$a, 338, 0, 26401);
    			add_location(d_math150, file$a, 340, 0, 26535);
    			add_location(d_math151, file$a, 342, 0, 26621);
    			add_location(d_math152, file$a, 344, 0, 26741);
    			add_location(p49, file$a, 333, 0, 26288);
    			attr_dev(h33, "id", "some-experiments");
    			add_location(h33, file$a, 346, 0, 26801);
    			add_location(d_math153, file$a, 348, 0, 26949);
    			add_location(d_math154, file$a, 350, 0, 27033);
    			add_location(d_math155, file$a, 352, 0, 27113);
    			add_location(d_math156, file$a, 354, 0, 27169);
    			add_location(d_math157, file$a, 356, 0, 27326);
    			add_location(d_math158, file$a, 358, 0, 27413);
    			add_location(d_math159, file$a, 360, 0, 27510);
    			add_location(p50, file$a, 347, 0, 26849);
    			add_location(strong14, file$a, 362, 3, 27561);
    			add_location(d_math160, file$a, 363, 0, 27823);
    			add_location(d_math161, file$a, 365, 0, 27999);
    			add_location(d_math162, file$a, 367, 0, 28072);
    			add_location(d_math163, file$a, 369, 0, 28114);
    			add_location(d_math164, file$a, 371, 0, 28212);
    			add_location(d_math165, file$a, 373, 0, 28408);
    			add_location(p51, file$a, 362, 0, 27558);
    			add_location(d_math166, file$a, 376, 0, 28480);
    			add_location(d_math167, file$a, 378, 0, 28550);
    			add_location(d_math168, file$a, 380, 0, 28586);
    			add_location(d_math169, file$a, 382, 0, 28644);
    			add_location(d_math170, file$a, 384, 0, 28788);
    			add_location(d_math171, file$a, 386, 0, 28942);
    			add_location(br2, file$a, 387, 22, 28987);
    			add_location(d_math172, file$a, 387, 26, 28991);
    			add_location(d_math173, file$a, 389, 0, 29065);
    			add_location(d_math174, file$a, 391, 0, 29105);
    			add_location(d_math175, file$a, 393, 0, 29170);
    			add_location(d_math176, file$a, 395, 0, 29221);
    			add_location(d_math177, file$a, 397, 0, 29325);
    			add_location(d_math178, file$a, 399, 0, 29431);
    			add_location(p52, file$a, 375, 0, 28457);
    			add_location(d_math179, file$a, 402, 0, 29585);
    			add_location(d_math180, file$a, 404, 0, 29805);
    			add_location(d_math181, file$a, 406, 0, 29912);
    			add_location(d_math182, file$a, 408, 0, 29990);
    			add_location(p53, file$a, 401, 0, 29469);
    			add_location(d_math183, file$a, 411, 0, 30114);
    			add_location(d_math184, file$a, 413, 0, 30194);
    			add_location(br3, file$a, 414, 48, 30271);
    			add_location(d_math185, file$a, 414, 52, 30275);
    			add_location(p54, file$a, 410, 0, 30051);
    			add_location(strong15, file$a, 416, 3, 30590);
    			add_location(p55, file$a, 416, 0, 30587);
    			add_location(d_math186, file$a, 418, 0, 30685);
    			add_location(d_math187, file$a, 420, 0, 30726);
    			add_location(d_math188, file$a, 422, 0, 30844);
    			add_location(d_math189, file$a, 424, 0, 30958);
    			add_location(d_math190, file$a, 426, 0, 30997);
    			add_location(d_math191, file$a, 428, 0, 31166);
    			add_location(d_math192, file$a, 430, 0, 31221);
    			add_location(p56, file$a, 417, 0, 30642);
    			add_location(d_math193, file$a, 433, 0, 31447);
    			add_location(d_math194, file$a, 435, 0, 31548);
    			add_location(d_math195, file$a, 437, 0, 31603);
    			add_location(d_math196, file$a, 439, 0, 31722);
    			add_location(d_math197, file$a, 441, 0, 31836);
    			add_location(d_math198, file$a, 443, 0, 31959);
    			add_location(d_math199, file$a, 445, 0, 32002);
    			add_location(d_math200, file$a, 447, 0, 32054);
    			add_location(d_math201, file$a, 449, 0, 32143);
    			add_location(d_math202, file$a, 451, 0, 32201);
    			add_location(p57, file$a, 432, 0, 31358);
    			add_location(d_math203, file$a, 454, 0, 32379);
    			add_location(d_math204, file$a, 456, 0, 32526);
    			add_location(p58, file$a, 453, 0, 32326);
    			add_location(strong16, file$a, 458, 3, 32693);
    			add_location(p59, file$a, 458, 0, 32690);
    			add_location(d_math205, file$a, 460, 0, 32748);
    			add_location(em13, file$a, 461, 76, 32842);
    			add_location(d_math206, file$a, 462, 0, 32876);
    			add_location(d_math207, file$a, 464, 0, 32979);
    			add_location(d_math208, file$a, 466, 0, 33031);
    			add_location(d_math209, file$a, 468, 0, 33087);
    			add_location(p60, file$a, 459, 0, 32729);
    			add_location(d_math210, file$a, 471, 0, 33204);
    			add_location(d_math211, file$a, 473, 0, 33333);
    			add_location(d_math212, file$a, 475, 0, 33376);
    			add_location(d_math213, file$a, 477, 0, 33442);
    			add_location(d_math214, file$a, 479, 0, 33511);
    			add_location(p61, file$a, 470, 0, 33139);
    			add_location(d_math215, file$a, 482, 0, 33696);
    			add_location(d_math216, file$a, 484, 0, 33753);
    			add_location(d_math217, file$a, 486, 0, 33897);
    			add_location(p62, file$a, 481, 0, 33629);
    			add_location(em14, file$a, 488, 190, 34280);
    			add_location(d_math218, file$a, 489, 0, 34337);
    			add_location(d_math219, file$a, 491, 0, 34389);
    			add_location(p63, file$a, 488, 0, 34090);
    			add_location(d_math220, file$a, 494, 0, 34609);
    			add_location(p64, file$a, 493, 0, 34490);
    			add_location(d_math221, file$a, 497, 0, 34751);
    			add_location(d_math222, file$a, 499, 0, 34800);
    			add_location(strong17, file$a, 496, 3, 34733);
    			add_location(p65, file$a, 496, 0, 34730);
    			add_location(d_math223, file$a, 502, 0, 34864);
    			add_location(d_math224, file$a, 504, 0, 34925);
    			add_location(d_math225, file$a, 506, 0, 34969);
    			add_location(d_math226, file$a, 508, 0, 35028);
    			add_location(d_math227, file$a, 510, 0, 35120);
    			add_location(d_math228, file$a, 512, 0, 35217);
    			add_location(d_math229, file$a, 514, 0, 35254);
    			add_location(d_math230, file$a, 516, 0, 35336);
    			add_location(d_math231, file$a, 518, 0, 35421);
    			add_location(d_math232, file$a, 520, 0, 35504);
    			add_location(d_math233, file$a, 523, 0, 35592);
    			add_location(d_math234, file$a, 525, 0, 35669);
    			add_location(d_math235, file$a, 527, 0, 35802);
    			add_location(br4, file$a, 528, 27, 35847);
    			add_location(d_math236, file$a, 528, 31, 35851);
    			add_location(d_math237, file$a, 530, 0, 35918);
    			add_location(d_math238, file$a, 532, 0, 35984);
    			add_location(d_math239, file$a, 534, 0, 36068);
    			add_location(d_math240, file$a, 536, 0, 36196);
    			add_location(d_math241, file$a, 538, 0, 36350);
    			add_location(d_math242, file$a, 540, 0, 36442);
    			add_location(p66, file$a, 501, 0, 34848);
    			add_location(d_math243, file$a, 543, 0, 36609);
    			add_location(d_math244, file$a, 545, 0, 36655);
    			add_location(d_math245, file$a, 547, 0, 36776);
    			add_location(p67, file$a, 542, 0, 36506);
    			attr_dev(h12, "id", "experiments-to-try-with-figure-2");
    			add_location(h12, file$a, 549, 0, 36924);
    			add_location(d_math246, file$a, 551, 0, 37103);
    			add_location(d_math247, file$a, 553, 0, 37174);
    			add_location(d_math248, file$a, 555, 0, 37231);
    			add_location(d_math249, file$a, 557, 0, 37305);
    			add_location(d_math250, file$a, 559, 0, 37500);
    			add_location(d_math251, file$a, 561, 0, 37543);
    			add_location(d_math252, file$a, 563, 0, 37609);
    			add_location(d_math253, file$a, 565, 0, 37742);
    			add_location(d_math254, file$a, 567, 0, 37805);
    			add_location(d_math255, file$a, 569, 0, 37872);
    			add_location(p68, file$a, 550, 0, 37004);
    			add_location(d_math256, file$a, 572, 0, 38000);
    			add_location(d_math257, file$a, 574, 0, 38057);
    			add_location(strong18, file$a, 571, 3, 37964);
    			add_location(d_math258, file$a, 576, 0, 38144);
    			add_location(p69, file$a, 571, 0, 37961);
    			add_location(d_math259, file$a, 579, 0, 38373);
    			add_location(d_math260, file$a, 581, 0, 38430);
    			add_location(d_math261, file$a, 583, 0, 38531);
    			add_location(d_math262, file$a, 585, 0, 38578);
    			add_location(strong19, file$a, 578, 3, 38346);
    			add_location(d_math263, file$a, 587, 0, 38660);
    			add_location(d_math264, file$a, 589, 0, 38774);
    			add_location(d_math265, file$a, 591, 0, 38959);
    			add_location(p70, file$a, 578, 0, 38343);
    			add_location(d_math266, file$a, 594, 0, 39118);
    			add_location(d_math267, file$a, 596, 0, 39175);
    			add_location(d_math268, file$a, 598, 0, 39281);
    			add_location(d_math269, file$a, 600, 0, 39328);
    			add_location(strong20, file$a, 593, 3, 39093);
    			add_location(d_math270, file$a, 602, 0, 39410);
    			add_location(d_math271, file$a, 604, 0, 39528);
    			add_location(d_math272, file$a, 606, 0, 39626);
    			add_location(p71, file$a, 593, 0, 39090);
    			add_location(d_math273, file$a, 608, 57, 39843);
    			attr_dev(h25, "id", "proof-that-html-mu_i--x_i-is-optimal");
    			add_location(h25, file$a, 608, 0, 39786);
    			add_location(d_math274, file$a, 610, 0, 39950);
    			add_location(d_math275, file$a, 612, 0, 39993);
    			add_location(d_math276, file$a, 614, 0, 40103);
    			add_location(p72, file$a, 609, 0, 39899);
    			add_location(d_math277, file$a, 617, 0, 40193);
    			add_location(d_math278, file$a, 619, 0, 40258);
    			add_location(d_math279, file$a, 621, 0, 40338);
    			add_location(d_math280, file$a, 623, 0, 40411);
    			add_location(br5, file$a, 624, 12, 40463);
    			add_location(d_math281, file$a, 624, 16, 40467);
    			add_location(em15, file$a, 625, 18, 40503);
    			add_location(d_math282, file$a, 626, 0, 40541);
    			add_location(d_math283, file$a, 628, 0, 40591);
    			add_location(d_math284, file$a, 630, 0, 40657);
    			add_location(d_math285, file$a, 632, 0, 40743);
    			add_location(d_math286, file$a, 634, 0, 40811);
    			add_location(p73, file$a, 616, 0, 40158);
    			add_location(d_math287, file$a, 637, 0, 40916);
    			add_location(d_math288, file$a, 639, 0, 41004);
    			add_location(p74, file$a, 636, 0, 40904);
    			set_custom_element_data(d_math289, "block", "");
    			add_location(d_math289, file$a, 641, 0, 41095);
    			add_location(p75, file$a, 650, 0, 41698);
    			set_custom_element_data(d_math290, "block", "");
    			add_location(d_math290, file$a, 651, 0, 41721);
    			add_location(d_math291, file$a, 659, 3, 42132);
    			add_location(d_math292, file$a, 661, 0, 42233);
    			add_location(d_math293, file$a, 663, 0, 42339);
    			add_location(d_math294, file$a, 665, 0, 42399);
    			add_location(d_math295, file$a, 667, 0, 42445);
    			add_location(d_math296, file$a, 669, 0, 42583);
    			add_location(d_math297, file$a, 671, 0, 42655);
    			add_location(p76, file$a, 659, 0, 42129);
    			add_location(d_math298, file$a, 674, 0, 42903);
    			add_location(p77, file$a, 673, 0, 42722);
    			set_custom_element_data(d_math299, "block", "");
    			add_location(d_math299, file$a, 676, 0, 42977);
    			attr_dev(h26, "id", "regularizing-by-minimizing-the-function-norm");
    			add_location(h26, file$a, 690, 0, 44060);
    			add_location(d_math300, file$a, 692, 0, 44204);
    			add_location(d_math301, file$a, 694, 0, 44276);
    			add_location(p78, file$a, 691, 0, 44164);
    			add_location(d_math302, file$a, 697, 0, 44616);
    			add_location(d_math303, file$a, 699, 0, 44703);
    			add_location(d_math304, file$a, 701, 0, 44764);
    			add_location(p79, file$a, 696, 0, 44567);
    			set_custom_element_data(d_math305, "block", "");
    			add_location(d_math305, file$a, 703, 0, 44854);
    			add_location(d_math306, file$a, 717, 0, 45920);
    			add_location(d_math307, file$a, 719, 0, 45985);
    			add_location(d_math308, file$a, 721, 0, 46064);
    			add_location(d_math309, file$a, 723, 0, 46180);
    			add_location(d_math310, file$a, 725, 0, 46260);
    			add_location(d_math311, file$a, 727, 0, 46354);
    			add_location(p80, file$a, 716, 0, 45841);
    			add_location(d_math312, file$a, 730, 0, 46504);
    			add_location(d_math313, file$a, 732, 0, 46641);
    			add_location(p81, file$a, 729, 0, 46389);
    			add_location(d_math314, file$a, 735, 0, 46877);
    			add_location(d_math315, file$a, 737, 0, 46914);
    			add_location(d_math316, file$a, 739, 0, 46964);
    			add_location(d_math317, file$a, 741, 0, 47027);
    			add_location(d_math318, file$a, 743, 0, 47113);
    			add_location(d_math319, file$a, 745, 0, 47266);
    			add_location(p82, file$a, 734, 0, 46795);
    			add_location(d_math320, file$a, 748, 0, 47459);
    			add_location(d_math321, file$a, 750, 0, 47555);
    			add_location(d_math322, file$a, 752, 0, 47624);
    			add_location(d_math323, file$a, 754, 0, 47721);
    			add_location(d_math324, file$a, 756, 0, 47792);
    			add_location(p83, file$a, 747, 0, 47412);
    			attr_dev(h27, "id", "finally-enter-the-kernel");
    			add_location(h27, file$a, 758, 0, 47850);
    			add_location(d_math325, file$a, 760, 0, 47963);
    			add_location(p84, file$a, 759, 0, 47915);
    			set_custom_element_data(d_math326, "block", "");
    			add_location(d_math326, file$a, 762, 0, 48214);
    			add_location(d_math327, file$a, 772, 0, 48567);
    			add_location(p85, file$a, 771, 0, 48555);
    			set_custom_element_data(d_math328, "block", "");
    			add_location(d_math328, file$a, 774, 0, 48637);
    			add_location(p86, file$a, 781, 0, 48823);
    			set_custom_element_data(d_math329, "block", "");
    			add_location(d_math329, file$a, 782, 0, 48989);
    			add_location(p87, file$a, 790, 0, 49455);
    			set_custom_element_data(d_math330, "block", "");
    			add_location(d_math330, file$a, 791, 0, 49509);
    			add_location(d_math331, file$a, 801, 0, 49838);
    			add_location(d_math332, file$a, 803, 0, 49902);
    			add_location(d_math333, file$a, 805, 0, 49998);
    			add_location(p88, file$a, 800, 0, 49782);
    			set_custom_element_data(d_math334, "block", "");
    			add_location(d_math334, file$a, 807, 0, 50149);
    			add_location(p89, file$a, 816, 0, 50494);
    			set_custom_element_data(d_math335, "block", "");
    			add_location(d_math335, file$a, 817, 0, 50555);
    			add_location(p90, file$a, 824, 0, 50799);
    			set_custom_element_data(d_math336, "block", "");
    			add_location(d_math336, file$a, 825, 0, 50862);
    			add_location(d_math337, file$a, 833, 0, 51071);
    			add_location(d_math338, file$a, 835, 0, 51109);
    			add_location(d_math339, file$a, 837, 0, 51244);
    			add_location(d_math340, file$a, 839, 0, 51291);
    			add_location(p91, file$a, 832, 0, 50984);
    			attr_dev(h13, "id", "summary-and-conclusion");
    			add_location(h13, file$a, 841, 0, 51441);
    			add_location(d_math341, file$a, 843, 0, 51590);
    			add_location(p92, file$a, 842, 0, 51501);
    			add_location(d_math342, file$a, 846, 0, 51928);
    			add_location(d_math343, file$a, 848, 0, 52009);
    			add_location(d_math344, file$a, 850, 0, 52185);
    			add_location(d_math345, file$a, 852, 0, 52225);
    			add_location(p93, file$a, 845, 0, 51832);
    			add_location(d_math346, file$a, 855, 0, 52345);
    			add_location(p94, file$a, 854, 0, 52262);
    			add_location(p95, file$a, 858, 4, 52482);
    			add_location(li7, file$a, 858, 0, 52478);
    			add_location(p96, file$a, 860, 4, 52615);
    			add_location(li8, file$a, 860, 0, 52611);
    			add_location(p97, file$a, 862, 4, 52801);
    			add_location(li9, file$a, 862, 0, 52797);
    			add_location(ol2, file$a, 857, 0, 52473);
    			attr_dev(h14, "id", "recommended-reading-and-notes");
    			add_location(h14, file$a, 865, 0, 52950);
    			add_location(p98, file$a, 866, 0, 53024);
    			attr_dev(h28, "id", "positive-semidefinite-matrices");
    			add_location(h28, file$a, 867, 0, 53366);
    			add_location(d_math347, file$a, 869, 0, 53525);
    			add_location(d_math348, file$a, 871, 0, 53568);
    			add_location(d_math349, file$a, 873, 0, 53645);
    			add_location(d_math350, file$a, 875, 0, 53744);
    			add_location(d_math351, file$a, 877, 0, 53954);
    			add_location(d_math352, file$a, 879, 0, 54060);
    			add_location(d_math353, file$a, 881, 0, 54124);
    			add_location(d_math354, file$a, 883, 0, 54174);
    			add_location(d_math355, file$a, 885, 0, 54221);
    			add_location(d_math356, file$a, 887, 0, 54258);
    			add_location(d_math357, file$a, 889, 0, 54323);
    			add_location(d_math358, file$a, 891, 0, 54379);
    			add_location(p99, file$a, 868, 0, 53444);
    			attr_dev(h29, "id", "the-kernel-trick");
    			add_location(h29, file$a, 893, 0, 54502);
    			add_location(d_math359, file$a, 895, 0, 54618);
    			add_location(p100, file$a, 894, 0, 54550);
    			attr_dev(h210, "id", "distinct-between-feature-space-and-reproducing-kernel-hilbert-space");
    			add_location(h210, file$a, 897, 0, 55567);
    			add_location(p101, file$a, 898, 0, 55717);
    			add_location(d_math360, file$a, 900, 0, 56284);
    			add_location(em16, file$a, 901, 12, 56363);
    			add_location(d_math361, file$a, 902, 0, 56416);
    			add_location(em17, file$a, 903, 176, 56671);
    			add_location(d_math362, file$a, 904, 0, 56695);
    			add_location(d_math363, file$a, 906, 0, 56769);
    			add_location(d_math364, file$a, 908, 0, 56826);
    			add_location(p102, file$a, 899, 0, 56196);
    			add_location(d_math365, file$a, 911, 0, 56950);
    			add_location(d_math366, file$a, 913, 0, 57030);
    			add_location(em18, file$a, 914, 77, 57143);
    			add_location(d_math367, file$a, 915, 0, 57217);
    			add_location(d_math368, file$a, 917, 0, 57303);
    			add_location(d_math369, file$a, 919, 0, 57382);
    			add_location(em19, file$a, 920, 58, 57471);
    			add_location(em20, file$a, 920, 97, 57510);
    			add_location(d_math370, file$a, 921, 0, 57544);
    			add_location(d_math371, file$a, 923, 0, 57657);
    			add_location(d_math372, file$a, 925, 0, 57796);
    			add_location(p103, file$a, 910, 0, 56903);
    			add_location(d_math373, file$a, 928, 0, 58021);
    			add_location(d_math374, file$a, 930, 0, 58099);
    			add_location(d_math375, file$a, 932, 0, 58423);
    			attr_dev(a0, "href", "https://arxiv.org/pdf/1408.0952.pdf");
    			add_location(a0, file$a, 933, 153, 58601);
    			add_location(p104, file$a, 927, 0, 57963);
    			attr_dev(h211, "id", "representer-theorem");
    			add_location(h211, file$a, 934, 0, 58692);
    			add_location(d_math376, file$a, 936, 0, 58792);
    			add_location(d_math377, file$a, 938, 0, 58868);
    			add_location(d_math378, file$a, 940, 0, 58927);
    			add_location(em21, file$a, 941, 18, 58963);
    			add_location(d_math379, file$a, 942, 0, 59033);
    			add_location(em22, file$a, 943, 17, 59079);
    			add_location(d_math380, file$a, 944, 0, 59306);
    			add_location(d_math381, file$a, 946, 0, 59430);
    			attr_dev(a1, "href", "https://alex.smola.org/papers/2001/SchHerSmo01.pdf");
    			add_location(a1, file$a, 947, 152, 59636);
    			add_location(p105, file$a, 935, 0, 58746);
    			attr_dev(h212, "id", "part-2---examples-of-linear-problems");
    			add_location(h212, file$a, 948, 0, 59756);
    			add_location(p106, file$a, 949, 0, 59844);
    			attr_dev(h213, "id", "kernel-ridge-regression");
    			add_location(h213, file$a, 950, 0, 60109);
    			attr_dev(h214, "id", "kernel-linear-regression");
    			add_location(h214, file$a, 951, 0, 60171);
    			attr_dev(h215, "id", "kernel-pca");
    			add_location(h215, file$a, 952, 0, 60235);
    			add_location(p107, file$a, 953, 0, 60271);
    			attr_dev(h216, "id", "kernel-k-means-and-cca");
    			add_location(h216, file$a, 954, 0, 60295);
    			add_location(p108, file$a, 955, 0, 60355);
    			add_location(d_math382, file$a, 956, 3, 60383);
    			add_location(p109, file$a, 956, 0, 60380);
    			attr_dev(a2, "href", "https://arxiv.org/pdf/1212.4522.pdf");
    			add_location(a2, file$a, 958, 27, 60649);
    			add_location(p110, file$a, 958, 0, 60622);
    			attr_dev(h217, "id", "large-margin-classifiers");
    			add_location(h217, file$a, 959, 0, 60739);
    			add_location(em23, file$a, 960, 33, 60836);
    			add_location(d_math383, file$a, 961, 0, 60869);
    			add_location(d_math384, file$a, 963, 0, 60904);
    			add_location(d_math385, file$a, 965, 0, 60943);
    			add_location(d_math386, file$a, 967, 0, 61037);
    			add_location(p111, file$a, 960, 0, 60803);
    			add_location(th0, file$a, 972, 0, 61103);
    			add_location(d_math387, file$a, 973, 4, 61123);
    			add_location(th1, file$a, 973, 0, 61119);
    			add_location(tr0, file$a, 971, 0, 61098);
    			add_location(thead, file$a, 970, 0, 61090);
    			add_location(td0, file$a, 977, 0, 61194);
    			add_location(d_math388, file$a, 978, 4, 61234);
    			add_location(td1, file$a, 978, 0, 61230);
    			add_location(tr1, file$a, 976, 7, 61189);
    			add_location(td2, file$a, 981, 0, 61297);
    			add_location(d_math389, file$a, 982, 4, 61329);
    			add_location(td3, file$a, 982, 0, 61325);
    			add_location(tr2, file$a, 980, 0, 61292);
    			add_location(td4, file$a, 985, 0, 61389);
    			add_location(d_math390, file$a, 986, 4, 61408);
    			add_location(td5, file$a, 986, 0, 61404);
    			add_location(tr3, file$a, 984, 0, 61384);
    			add_location(td6, file$a, 989, 0, 61471);
    			add_location(d_math391, file$a, 990, 4, 61493);
    			add_location(td7, file$a, 990, 0, 61489);
    			add_location(tr4, file$a, 988, 0, 61466);
    			add_location(tbody, file$a, 976, 0, 61182);
    			add_location(table, file$a, 969, 0, 61082);
    			add_location(p112, file$a, 993, 0, 61558);
    			set_custom_element_data(d_math392, "block", "");
    			add_location(d_math392, file$a, 994, 0, 61589);
    			add_location(d_math393, file$a, 1004, 0, 62043);
    			add_location(p113, file$a, 1003, 0, 62000);
    			add_location(d_math394, file$a, 1006, 3, 62199);
    			add_location(p114, file$a, 1006, 0, 62196);
    			add_location(p115, file$a, 1008, 0, 62320);
    			attr_dev(h218, "id", "neural-tangent-kernel");
    			add_location(h218, file$a, 1009, 0, 62384);
    			attr_dev(a3, "href", "https://arxiv.org/abs/1806.07572");
    			add_location(a3, file$a, 1010, 7, 62449);
    			add_location(p116, file$a, 1010, 0, 62442);
    			attr_dev(h219, "id", "geometric-considerations-of-choice-of-kernel");
    			add_location(h219, file$a, 1011, 0, 62533);
    			add_location(d_math395, file$a, 1013, 0, 62674);
    			add_location(d_math396, file$a, 1015, 0, 62815);
    			add_location(em24, file$a, 1016, 14, 62858);
    			add_location(d_math397, file$a, 1017, 0, 62944);
    			add_location(d_math398, file$a, 1019, 0, 63075);
    			add_location(d_math399, file$a, 1021, 0, 63241);
    			add_location(br6, file$a, 1022, 52, 63322);
    			add_location(d_math400, file$a, 1022, 56, 63326);
    			add_location(d_math401, file$a, 1024, 0, 63487);
    			add_location(d_math402, file$a, 1026, 0, 63559);
    			add_location(p117, file$a, 1012, 0, 62637);
    			add_location(d_math403, file$a, 1029, 0, 63801);
    			add_location(d_math404, file$a, 1031, 0, 63950);
    			add_location(p118, file$a, 1028, 0, 63667);
    			add_location(d_math405, file$a, 1034, 0, 64366);
    			add_location(d_math406, file$a, 1036, 0, 64423);
    			add_location(d_math407, file$a, 1038, 0, 64458);
    			add_location(d_math408, file$a, 1040, 0, 64504);
    			add_location(d_math409, file$a, 1042, 0, 64590);
    			add_location(d_math410, file$a, 1044, 0, 64646);
    			add_location(p119, file$a, 1033, 0, 63988);
    			add_location(em25, file$a, 1046, 32, 64728);
    			add_location(d_math411, file$a, 1047, 0, 64761);
    			add_location(p120, file$a, 1046, 0, 64696);
    			set_custom_element_data(d_math412, "block", "");
    			add_location(d_math412, file$a, 1049, 0, 64872);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h10, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, p3, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, p4, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, p5, anchor);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, h11, anchor);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, p6, anchor);
    			append_dev(p6, t16);
    			append_dev(p6, d_math0);
    			d_math0.innerHTML = raw0_value;
    			append_dev(p6, t17);
    			append_dev(p6, d_math1);
    			d_math1.innerHTML = raw1_value;
    			append_dev(p6, t18);
    			append_dev(p6, d_math2);
    			d_math2.innerHTML = raw2_value;
    			append_dev(p6, t19);
    			append_dev(p6, d_math3);
    			d_math3.innerHTML = raw3_value;
    			append_dev(p6, t20);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, p7, anchor);
    			append_dev(p7, t22);
    			append_dev(p7, d_math4);
    			d_math4.innerHTML = raw4_value;
    			append_dev(p7, t23);
    			append_dev(p7, d_math5);
    			d_math5.innerHTML = raw5_value;
    			append_dev(p7, t24);
    			append_dev(p7, d_math6);
    			d_math6.innerHTML = raw6_value;
    			append_dev(p7, t25);
    			insert_dev(target, t26, anchor);
    			insert_dev(target, p8, anchor);
    			append_dev(p8, t27);
    			append_dev(p8, d_math7);
    			d_math7.innerHTML = raw7_value;
    			append_dev(p8, t28);
    			append_dev(p8, em0);
    			append_dev(p8, t30);
    			append_dev(p8, d_math8);
    			d_math8.innerHTML = raw8_value;
    			append_dev(p8, t31);
    			append_dev(p8, d_math9);
    			d_math9.innerHTML = raw9_value;
    			append_dev(p8, t32);
    			append_dev(p8, d_math10);
    			d_math10.innerHTML = raw10_value;
    			append_dev(p8, t33);
    			insert_dev(target, t34, anchor);
    			insert_dev(target, p9, anchor);
    			append_dev(p9, t35);
    			append_dev(p9, d_math11);
    			d_math11.innerHTML = raw11_value;
    			append_dev(p9, t36);
    			append_dev(p9, d_math12);
    			d_math12.innerHTML = raw12_value;
    			append_dev(p9, t37);
    			insert_dev(target, t38, anchor);
    			insert_dev(target, p10, anchor);
    			insert_dev(target, t40, anchor);
    			insert_dev(target, p11, anchor);
    			append_dev(p11, t41);
    			append_dev(p11, d_math13);
    			d_math13.innerHTML = raw13_value;
    			append_dev(p11, t42);
    			append_dev(p11, d_math14);
    			d_math14.innerHTML = raw14_value;
    			append_dev(p11, t43);
    			append_dev(p11, d_math15);
    			d_math15.innerHTML = raw15_value;
    			append_dev(p11, t44);
    			append_dev(p11, d_math16);
    			d_math16.innerHTML = raw16_value;
    			append_dev(p11, t45);
    			insert_dev(target, t46, anchor);
    			insert_dev(target, p12, anchor);
    			insert_dev(target, t48, anchor);
    			insert_dev(target, d_math17, anchor);
    			d_math17.innerHTML = raw17_value;
    			insert_dev(target, t49, anchor);
    			insert_dev(target, p13, anchor);
    			append_dev(p13, t50);
    			append_dev(p13, d_math18);
    			d_math18.innerHTML = raw18_value;
    			append_dev(p13, t51);
    			append_dev(p13, d_math19);
    			d_math19.innerHTML = raw19_value;
    			append_dev(p13, t52);
    			append_dev(p13, d_math20);
    			d_math20.innerHTML = raw20_value;
    			append_dev(p13, t53);
    			append_dev(p13, d_math21);
    			d_math21.innerHTML = raw21_value;
    			append_dev(p13, t54);
    			append_dev(p13, d_math22);
    			d_math22.innerHTML = raw22_value;
    			append_dev(p13, t55);
    			append_dev(p13, d_math23);
    			d_math23.innerHTML = raw23_value;
    			append_dev(p13, t56);
    			insert_dev(target, t57, anchor);
    			insert_dev(target, p14, anchor);
    			append_dev(p14, t58);
    			append_dev(p14, d_math24);
    			d_math24.innerHTML = raw24_value;
    			append_dev(p14, t59);
    			insert_dev(target, t60, anchor);
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t62, anchor);
    			insert_dev(target, p15, anchor);
    			append_dev(p15, strong0);
    			append_dev(strong0, t63);
    			append_dev(strong0, d_math25);
    			d_math25.innerHTML = raw25_value;
    			append_dev(strong0, t64);
    			append_dev(p15, t65);
    			append_dev(p15, em1);
    			append_dev(p15, t67);
    			append_dev(p15, d_math26);
    			d_math26.innerHTML = raw26_value;
    			append_dev(p15, t68);
    			append_dev(p15, d_math27);
    			d_math27.innerHTML = raw27_value;
    			append_dev(p15, t69);
    			append_dev(p15, d_math28);
    			d_math28.innerHTML = raw28_value;
    			append_dev(p15, t70);
    			append_dev(p15, d_math29);
    			d_math29.innerHTML = raw29_value;
    			append_dev(p15, t71);
    			insert_dev(target, t72, anchor);
    			insert_dev(target, p16, anchor);
    			append_dev(p16, strong1);
    			append_dev(strong1, t73);
    			append_dev(strong1, d_math30);
    			d_math30.innerHTML = raw30_value;
    			append_dev(p16, t74);
    			append_dev(p16, em2);
    			append_dev(p16, t76);
    			append_dev(p16, d_math31);
    			d_math31.innerHTML = raw31_value;
    			append_dev(p16, t77);
    			append_dev(p16, d_math32);
    			d_math32.innerHTML = raw32_value;
    			append_dev(p16, t78);
    			append_dev(p16, d_math33);
    			d_math33.innerHTML = raw33_value;
    			append_dev(p16, t79);
    			append_dev(p16, em3);
    			append_dev(p16, t81);
    			append_dev(p16, d_math34);
    			d_math34.innerHTML = raw34_value;
    			append_dev(p16, t82);
    			insert_dev(target, t83, anchor);
    			insert_dev(target, p17, anchor);
    			append_dev(p17, strong2);
    			append_dev(p17, t85);
    			append_dev(p17, d_math35);
    			d_math35.innerHTML = raw35_value;
    			append_dev(p17, t86);
    			insert_dev(target, t87, anchor);
    			insert_dev(target, p18, anchor);
    			append_dev(p18, strong3);
    			append_dev(p18, t89);
    			append_dev(p18, d_math36);
    			d_math36.innerHTML = raw36_value;
    			append_dev(p18, t90);
    			insert_dev(target, t91, anchor);
    			insert_dev(target, p19, anchor);
    			append_dev(p19, t92);
    			append_dev(p19, d_math37);
    			d_math37.innerHTML = raw37_value;
    			append_dev(p19, t93);
    			insert_dev(target, t94, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t96, anchor);
    			insert_dev(target, p20, anchor);
    			insert_dev(target, t98, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t100, anchor);
    			insert_dev(target, p21, anchor);
    			append_dev(p21, em4);
    			append_dev(em4, strong4);
    			append_dev(strong4, t101);
    			append_dev(strong4, d_math38);
    			d_math38.innerHTML = raw38_value;
    			append_dev(p21, t102);
    			append_dev(p21, d_math39);
    			d_math39.innerHTML = raw39_value;
    			append_dev(p21, t103);
    			append_dev(p21, d_math40);
    			d_math40.innerHTML = raw40_value;
    			append_dev(p21, t104);
    			append_dev(p21, d_math41);
    			d_math41.innerHTML = raw41_value;
    			append_dev(p21, t105);
    			append_dev(p21, d_math42);
    			d_math42.innerHTML = raw42_value;
    			append_dev(p21, t106);
    			append_dev(p21, d_math43);
    			d_math43.innerHTML = raw43_value;
    			append_dev(p21, t107);
    			insert_dev(target, t108, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t110, anchor);
    			insert_dev(target, p22, anchor);
    			append_dev(p22, em5);
    			append_dev(em5, strong5);
    			append_dev(p22, t112);
    			append_dev(p22, d_math44);
    			d_math44.innerHTML = raw44_value;
    			append_dev(p22, t113);
    			append_dev(p22, d_math45);
    			d_math45.innerHTML = raw45_value;
    			append_dev(p22, t114);
    			append_dev(p22, d_math46);
    			d_math46.innerHTML = raw46_value;
    			append_dev(p22, t115);
    			append_dev(p22, d_math47);
    			d_math47.innerHTML = raw47_value;
    			append_dev(p22, t116);
    			append_dev(p22, d_math48);
    			d_math48.innerHTML = raw48_value;
    			append_dev(p22, t117);
    			append_dev(p22, em6);
    			append_dev(p22, t119);
    			append_dev(p22, d_math49);
    			d_math49.innerHTML = raw49_value;
    			append_dev(p22, t120);
    			insert_dev(target, t121, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t123, anchor);
    			insert_dev(target, p23, anchor);
    			append_dev(p23, em7);
    			append_dev(em7, strong6);
    			append_dev(p23, t125);
    			append_dev(p23, br0);
    			append_dev(p23, d_math50);
    			d_math50.innerHTML = raw50_value;
    			append_dev(p23, t126);
    			append_dev(p23, d_math51);
    			d_math51.innerHTML = raw51_value;
    			append_dev(p23, t127);
    			insert_dev(target, t128, anchor);
    			insert_dev(target, p24, anchor);
    			append_dev(p24, t129);
    			append_dev(p24, d_math52);
    			d_math52.innerHTML = raw52_value;
    			append_dev(p24, t130);
    			append_dev(p24, d_math53);
    			d_math53.innerHTML = raw53_value;
    			append_dev(p24, t131);
    			insert_dev(target, t132, anchor);
    			insert_dev(target, h22, anchor);
    			insert_dev(target, t134, anchor);
    			insert_dev(target, p25, anchor);
    			append_dev(p25, t135);
    			append_dev(p25, d_math54);
    			d_math54.innerHTML = raw54_value;
    			append_dev(p25, t136);
    			append_dev(p25, d_math55);
    			d_math55.innerHTML = raw55_value;
    			append_dev(p25, t137);
    			append_dev(p25, d_math56);
    			d_math56.innerHTML = raw56_value;
    			append_dev(p25, t138);
    			append_dev(p25, d_math57);
    			d_math57.innerHTML = raw57_value;
    			append_dev(p25, t139);
    			append_dev(p25, d_math58);
    			d_math58.innerHTML = raw58_value;
    			append_dev(p25, t140);
    			append_dev(p25, d_math59);
    			d_math59.innerHTML = raw59_value;
    			append_dev(p25, t141);
    			append_dev(p25, br1);
    			append_dev(p25, d_math60);
    			d_math60.innerHTML = raw60_value;
    			append_dev(p25, t142);
    			append_dev(p25, d_math61);
    			d_math61.innerHTML = raw61_value;
    			append_dev(p25, t143);
    			append_dev(p25, d_math62);
    			d_math62.innerHTML = raw62_value;
    			append_dev(p25, t144);
    			insert_dev(target, t145, anchor);
    			insert_dev(target, p26, anchor);
    			append_dev(p26, t146);
    			append_dev(p26, d_math63);
    			d_math63.innerHTML = raw63_value;
    			append_dev(p26, t147);
    			append_dev(p26, d_math64);
    			d_math64.innerHTML = raw64_value;
    			append_dev(p26, t148);
    			append_dev(p26, d_math65);
    			d_math65.innerHTML = raw65_value;
    			append_dev(p26, t149);
    			insert_dev(target, t150, anchor);
    			insert_dev(target, d_math66, anchor);
    			d_math66.innerHTML = raw66_value;
    			insert_dev(target, t151, anchor);
    			insert_dev(target, p27, anchor);
    			append_dev(p27, t152);
    			append_dev(p27, d_math67);
    			d_math67.innerHTML = raw67_value;
    			append_dev(p27, t153);
    			append_dev(p27, d_math68);
    			d_math68.innerHTML = raw68_value;
    			append_dev(p27, t154);
    			insert_dev(target, t155, anchor);
    			insert_dev(target, d_math69, anchor);
    			d_math69.innerHTML = raw69_value;
    			insert_dev(target, t156, anchor);
    			insert_dev(target, p28, anchor);
    			append_dev(p28, t157);
    			append_dev(p28, d_math70);
    			d_math70.innerHTML = raw70_value;
    			append_dev(p28, t158);
    			append_dev(p28, d_math71);
    			d_math71.innerHTML = raw71_value;
    			insert_dev(target, t159, anchor);
    			insert_dev(target, p29, anchor);
    			append_dev(p29, t160);
    			append_dev(p29, d_math72);
    			d_math72.innerHTML = raw72_value;
    			append_dev(p29, t161);
    			append_dev(p29, d_math73);
    			d_math73.innerHTML = raw73_value;
    			append_dev(p29, t162);
    			append_dev(p29, d_math74);
    			d_math74.innerHTML = raw74_value;
    			append_dev(p29, t163);
    			append_dev(p29, d_math75);
    			d_math75.innerHTML = raw75_value;
    			append_dev(p29, t164);
    			append_dev(p29, d_math76);
    			d_math76.innerHTML = raw76_value;
    			append_dev(p29, t165);
    			append_dev(p29, d_math77);
    			d_math77.innerHTML = raw77_value;
    			append_dev(p29, t166);
    			append_dev(p29, em8);
    			append_dev(p29, t168);
    			append_dev(p29, d_math78);
    			d_math78.innerHTML = raw78_value;
    			append_dev(p29, t169);
    			append_dev(p29, em9);
    			append_dev(p29, t171);
    			append_dev(p29, em10);
    			append_dev(p29, t173);
    			insert_dev(target, t174, anchor);
    			insert_dev(target, p30, anchor);
    			append_dev(p30, t175);
    			append_dev(p30, d_math79);
    			d_math79.innerHTML = raw79_value;
    			append_dev(p30, t176);
    			append_dev(p30, d_math80);
    			d_math80.innerHTML = raw80_value;
    			append_dev(p30, t177);
    			append_dev(p30, d_math81);
    			d_math81.innerHTML = raw81_value;
    			append_dev(p30, t178);
    			append_dev(p30, d_math82);
    			d_math82.innerHTML = raw82_value;
    			append_dev(p30, t179);
    			insert_dev(target, t180, anchor);
    			insert_dev(target, p31, anchor);
    			append_dev(p31, t181);
    			append_dev(p31, d_math83);
    			d_math83.innerHTML = raw83_value;
    			append_dev(p31, t182);
    			append_dev(p31, d_math84);
    			d_math84.innerHTML = raw84_value;
    			append_dev(p31, t183);
    			append_dev(p31, d_math85);
    			d_math85.innerHTML = raw85_value;
    			append_dev(p31, t184);
    			append_dev(p31, d_math86);
    			d_math86.innerHTML = raw86_value;
    			append_dev(p31, t185);
    			append_dev(p31, d_math87);
    			d_math87.innerHTML = raw87_value;
    			append_dev(p31, t186);
    			append_dev(p31, d_math88);
    			d_math88.innerHTML = raw88_value;
    			append_dev(p31, t187);
    			append_dev(p31, d_math89);
    			d_math89.innerHTML = raw89_value;
    			append_dev(p31, t188);
    			append_dev(p31, d_math90);
    			d_math90.innerHTML = raw90_value;
    			append_dev(p31, t189);
    			insert_dev(target, t190, anchor);
    			insert_dev(target, h23, anchor);
    			insert_dev(target, t192, anchor);
    			insert_dev(target, p32, anchor);
    			append_dev(p32, t193);
    			append_dev(p32, d_math91);
    			d_math91.innerHTML = raw91_value;
    			append_dev(p32, t194);
    			insert_dev(target, t195, anchor);
    			insert_dev(target, p33, anchor);
    			insert_dev(target, t197, anchor);
    			insert_dev(target, p34, anchor);
    			append_dev(p34, t198);
    			append_dev(p34, d_math92);
    			d_math92.innerHTML = raw92_value;
    			append_dev(p34, t199);
    			append_dev(p34, d_math93);
    			d_math93.innerHTML = raw93_value;
    			append_dev(p34, t200);
    			append_dev(p34, d_math94);
    			d_math94.innerHTML = raw94_value;
    			append_dev(p34, t201);
    			insert_dev(target, t202, anchor);
    			insert_dev(target, ol0, anchor);
    			append_dev(ol0, li0);
    			append_dev(li0, p35);
    			append_dev(p35, strong7);
    			append_dev(p35, t204);
    			append_dev(p35, d_math95);
    			d_math95.innerHTML = raw95_value;
    			append_dev(p35, t205);
    			append_dev(p35, d_math96);
    			d_math96.innerHTML = raw96_value;
    			append_dev(p35, t206);
    			append_dev(ol0, t207);
    			append_dev(ol0, li1);
    			append_dev(li1, p36);
    			append_dev(p36, strong8);
    			append_dev(p36, t209);
    			append_dev(p36, d_math97);
    			d_math97.innerHTML = raw97_value;
    			append_dev(p36, t210);
    			append_dev(p36, d_math98);
    			d_math98.innerHTML = raw98_value;
    			append_dev(p36, t211);
    			append_dev(ol0, t212);
    			append_dev(ol0, li2);
    			append_dev(li2, p37);
    			append_dev(p37, strong9);
    			append_dev(p37, t214);
    			append_dev(p37, d_math99);
    			d_math99.innerHTML = raw99_value;
    			append_dev(p37, t215);
    			append_dev(p37, d_math100);
    			d_math100.innerHTML = raw100_value;
    			append_dev(p37, t216);
    			append_dev(p37, d_math101);
    			d_math101.innerHTML = raw101_value;
    			append_dev(p37, t217);
    			append_dev(p37, d_math102);
    			d_math102.innerHTML = raw102_value;
    			append_dev(p37, t218);
    			append_dev(p37, d_math103);
    			d_math103.innerHTML = raw103_value;
    			append_dev(p37, t219);
    			append_dev(p37, d_math104);
    			d_math104.innerHTML = raw104_value;
    			append_dev(p37, t220);
    			append_dev(p37, d_math105);
    			d_math105.innerHTML = raw105_value;
    			append_dev(p37, t221);
    			append_dev(p37, d_math106);
    			d_math106.innerHTML = raw106_value;
    			append_dev(p37, t222);
    			insert_dev(target, t223, anchor);
    			insert_dev(target, p38, anchor);
    			insert_dev(target, t225, anchor);
    			insert_dev(target, ol1, anchor);
    			append_dev(ol1, li3);
    			append_dev(li3, p39);
    			append_dev(p39, strong10);
    			append_dev(p39, t227);
    			append_dev(p39, d_math107);
    			d_math107.innerHTML = raw107_value;
    			append_dev(p39, t228);
    			append_dev(ol1, t229);
    			append_dev(ol1, li4);
    			append_dev(li4, p40);
    			append_dev(p40, strong11);
    			append_dev(strong11, t230);
    			append_dev(strong11, d_math108);
    			d_math108.innerHTML = raw108_value;
    			append_dev(strong11, t231);
    			append_dev(p40, t232);
    			append_dev(p40, d_math109);
    			d_math109.innerHTML = raw109_value;
    			append_dev(p40, t233);
    			append_dev(p40, d_math110);
    			d_math110.innerHTML = raw110_value;
    			append_dev(p40, t234);
    			append_dev(p40, em11);
    			append_dev(p40, t236);
    			append_dev(p40, d_math111);
    			d_math111.innerHTML = raw111_value;
    			append_dev(p40, t237);
    			append_dev(p40, d_math112);
    			d_math112.innerHTML = raw112_value;
    			append_dev(p40, t238);
    			append_dev(p40, d_math113);
    			d_math113.innerHTML = raw113_value;
    			append_dev(p40, t239);
    			append_dev(ol1, t240);
    			append_dev(ol1, li5);
    			append_dev(li5, p41);
    			append_dev(p41, strong12);
    			append_dev(p41, t242);
    			append_dev(p41, d_math114);
    			d_math114.innerHTML = raw114_value;
    			append_dev(p41, t243);
    			append_dev(ol1, t244);
    			append_dev(ol1, li6);
    			append_dev(li6, p42);
    			append_dev(p42, strong13);
    			append_dev(p42, t246);
    			append_dev(p42, d_math115);
    			d_math115.innerHTML = raw115_value;
    			append_dev(p42, t247);
    			append_dev(p42, d_math116);
    			d_math116.innerHTML = raw116_value;
    			append_dev(p42, t248);
    			append_dev(p42, d_math117);
    			d_math117.innerHTML = raw117_value;
    			append_dev(p42, t249);
    			append_dev(p42, d_math118);
    			d_math118.innerHTML = raw118_value;
    			append_dev(p42, t250);
    			append_dev(p42, d_math119);
    			d_math119.innerHTML = raw119_value;
    			append_dev(p42, t251);
    			append_dev(p42, d_math120);
    			d_math120.innerHTML = raw120_value;
    			append_dev(p42, t252);
    			append_dev(p42, d_math121);
    			d_math121.innerHTML = raw121_value;
    			append_dev(p42, t253);
    			insert_dev(target, t254, anchor);
    			insert_dev(target, p43, anchor);
    			append_dev(p43, t255);
    			append_dev(p43, d_math122);
    			d_math122.innerHTML = raw122_value;
    			append_dev(p43, t256);
    			append_dev(p43, d_math123);
    			d_math123.innerHTML = raw123_value;
    			append_dev(p43, t257);
    			insert_dev(target, t258, anchor);
    			insert_dev(target, h24, anchor);
    			insert_dev(target, t260, anchor);
    			insert_dev(target, p44, anchor);
    			append_dev(p44, t261);
    			append_dev(p44, d_math124);
    			d_math124.innerHTML = raw124_value;
    			append_dev(p44, t262);
    			append_dev(p44, d_math125);
    			d_math125.innerHTML = raw125_value;
    			append_dev(p44, t263);
    			append_dev(p44, d_math126);
    			d_math126.innerHTML = raw126_value;
    			append_dev(p44, t264);
    			insert_dev(target, t265, anchor);
    			insert_dev(target, p45, anchor);
    			append_dev(p45, t266);
    			append_dev(p45, d_math127);
    			d_math127.innerHTML = raw127_value;
    			append_dev(p45, t267);
    			append_dev(p45, d_math128);
    			d_math128.innerHTML = raw128_value;
    			append_dev(p45, t268);
    			append_dev(p45, d_math129);
    			d_math129.innerHTML = raw129_value;
    			append_dev(p45, t269);
    			append_dev(p45, d_math130);
    			d_math130.innerHTML = raw130_value;
    			append_dev(p45, t270);
    			insert_dev(target, t271, anchor);
    			insert_dev(target, p46, anchor);
    			append_dev(p46, t272);
    			append_dev(p46, d_math131);
    			d_math131.innerHTML = raw131_value;
    			append_dev(p46, t273);
    			append_dev(p46, d_math132);
    			d_math132.innerHTML = raw132_value;
    			append_dev(p46, t274);
    			append_dev(p46, d_math133);
    			d_math133.innerHTML = raw133_value;
    			append_dev(p46, t275);
    			append_dev(p46, d_math134);
    			d_math134.innerHTML = raw134_value;
    			append_dev(p46, t276);
    			insert_dev(target, t277, anchor);
    			insert_dev(target, p47, anchor);
    			append_dev(p47, t278);
    			append_dev(p47, d_math135);
    			d_math135.innerHTML = raw135_value;
    			append_dev(p47, t279);
    			append_dev(p47, d_math136);
    			d_math136.innerHTML = raw136_value;
    			append_dev(p47, t280);
    			append_dev(p47, d_math137);
    			d_math137.innerHTML = raw137_value;
    			append_dev(p47, t281);
    			append_dev(p47, d_math138);
    			d_math138.innerHTML = raw138_value;
    			append_dev(p47, t282);
    			append_dev(p47, d_math139);
    			d_math139.innerHTML = raw139_value;
    			insert_dev(target, t283, anchor);
    			insert_dev(target, p48, anchor);
    			append_dev(p48, t284);
    			append_dev(p48, d_math140);
    			d_math140.innerHTML = raw140_value;
    			append_dev(p48, t285);
    			append_dev(p48, d_math141);
    			d_math141.innerHTML = raw141_value;
    			append_dev(p48, t286);
    			append_dev(p48, em12);
    			append_dev(p48, t288);
    			append_dev(p48, d_math142);
    			d_math142.innerHTML = raw142_value;
    			append_dev(p48, t289);
    			append_dev(p48, d_math143);
    			d_math143.innerHTML = raw143_value;
    			append_dev(p48, t290);
    			append_dev(p48, d_math144);
    			d_math144.innerHTML = raw144_value;
    			append_dev(p48, t291);
    			append_dev(p48, d_math145);
    			d_math145.innerHTML = raw145_value;
    			append_dev(p48, t292);
    			append_dev(p48, d_math146);
    			d_math146.innerHTML = raw146_value;
    			append_dev(p48, t293);
    			insert_dev(target, t294, anchor);
    			insert_dev(target, p49, anchor);
    			append_dev(p49, t295);
    			append_dev(p49, d_math147);
    			d_math147.innerHTML = raw147_value;
    			append_dev(p49, t296);
    			append_dev(p49, d_math148);
    			d_math148.innerHTML = raw148_value;
    			append_dev(p49, t297);
    			append_dev(p49, d_math149);
    			d_math149.innerHTML = raw149_value;
    			append_dev(p49, t298);
    			append_dev(p49, d_math150);
    			d_math150.innerHTML = raw150_value;
    			append_dev(p49, t299);
    			append_dev(p49, d_math151);
    			d_math151.innerHTML = raw151_value;
    			append_dev(p49, t300);
    			append_dev(p49, d_math152);
    			d_math152.innerHTML = raw152_value;
    			append_dev(p49, t301);
    			insert_dev(target, t302, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t304, anchor);
    			insert_dev(target, p50, anchor);
    			append_dev(p50, t305);
    			append_dev(p50, d_math153);
    			d_math153.innerHTML = raw153_value;
    			append_dev(p50, t306);
    			append_dev(p50, d_math154);
    			d_math154.innerHTML = raw154_value;
    			append_dev(p50, t307);
    			append_dev(p50, d_math155);
    			d_math155.innerHTML = raw155_value;
    			append_dev(p50, t308);
    			append_dev(p50, d_math156);
    			d_math156.innerHTML = raw156_value;
    			append_dev(p50, t309);
    			append_dev(p50, d_math157);
    			d_math157.innerHTML = raw157_value;
    			append_dev(p50, t310);
    			append_dev(p50, d_math158);
    			d_math158.innerHTML = raw158_value;
    			append_dev(p50, t311);
    			append_dev(p50, d_math159);
    			d_math159.innerHTML = raw159_value;
    			append_dev(p50, t312);
    			insert_dev(target, t313, anchor);
    			insert_dev(target, p51, anchor);
    			append_dev(p51, strong14);
    			append_dev(p51, t315);
    			append_dev(p51, d_math160);
    			d_math160.innerHTML = raw160_value;
    			append_dev(p51, t316);
    			append_dev(p51, d_math161);
    			d_math161.innerHTML = raw161_value;
    			append_dev(p51, t317);
    			append_dev(p51, d_math162);
    			d_math162.innerHTML = raw162_value;
    			append_dev(p51, t318);
    			append_dev(p51, d_math163);
    			d_math163.innerHTML = raw163_value;
    			append_dev(p51, t319);
    			append_dev(p51, d_math164);
    			d_math164.innerHTML = raw164_value;
    			append_dev(p51, t320);
    			append_dev(p51, d_math165);
    			d_math165.innerHTML = raw165_value;
    			append_dev(p51, t321);
    			insert_dev(target, t322, anchor);
    			insert_dev(target, p52, anchor);
    			append_dev(p52, t323);
    			append_dev(p52, d_math166);
    			d_math166.innerHTML = raw166_value;
    			append_dev(p52, t324);
    			append_dev(p52, d_math167);
    			d_math167.innerHTML = raw167_value;
    			append_dev(p52, t325);
    			append_dev(p52, d_math168);
    			d_math168.innerHTML = raw168_value;
    			append_dev(p52, t326);
    			append_dev(p52, d_math169);
    			d_math169.innerHTML = raw169_value;
    			append_dev(p52, t327);
    			append_dev(p52, d_math170);
    			d_math170.innerHTML = raw170_value;
    			append_dev(p52, t328);
    			append_dev(p52, d_math171);
    			d_math171.innerHTML = raw171_value;
    			append_dev(p52, t329);
    			append_dev(p52, br2);
    			append_dev(p52, d_math172);
    			d_math172.innerHTML = raw172_value;
    			append_dev(p52, t330);
    			append_dev(p52, d_math173);
    			d_math173.innerHTML = raw173_value;
    			append_dev(p52, t331);
    			append_dev(p52, d_math174);
    			d_math174.innerHTML = raw174_value;
    			append_dev(p52, t332);
    			append_dev(p52, d_math175);
    			d_math175.innerHTML = raw175_value;
    			append_dev(p52, t333);
    			append_dev(p52, d_math176);
    			d_math176.innerHTML = raw176_value;
    			append_dev(p52, t334);
    			append_dev(p52, d_math177);
    			d_math177.innerHTML = raw177_value;
    			append_dev(p52, t335);
    			append_dev(p52, d_math178);
    			d_math178.innerHTML = raw178_value;
    			append_dev(p52, t336);
    			insert_dev(target, t337, anchor);
    			insert_dev(target, p53, anchor);
    			append_dev(p53, t338);
    			append_dev(p53, d_math179);
    			d_math179.innerHTML = raw179_value;
    			append_dev(p53, t339);
    			append_dev(p53, d_math180);
    			d_math180.innerHTML = raw180_value;
    			append_dev(p53, t340);
    			append_dev(p53, d_math181);
    			d_math181.innerHTML = raw181_value;
    			append_dev(p53, t341);
    			append_dev(p53, d_math182);
    			d_math182.innerHTML = raw182_value;
    			append_dev(p53, t342);
    			insert_dev(target, t343, anchor);
    			insert_dev(target, p54, anchor);
    			append_dev(p54, t344);
    			append_dev(p54, d_math183);
    			d_math183.innerHTML = raw183_value;
    			append_dev(p54, t345);
    			append_dev(p54, d_math184);
    			d_math184.innerHTML = raw184_value;
    			append_dev(p54, t346);
    			append_dev(p54, br3);
    			append_dev(p54, d_math185);
    			d_math185.innerHTML = raw185_value;
    			append_dev(p54, t347);
    			insert_dev(target, t348, anchor);
    			insert_dev(target, p55, anchor);
    			append_dev(p55, strong15);
    			insert_dev(target, t350, anchor);
    			insert_dev(target, p56, anchor);
    			append_dev(p56, t351);
    			append_dev(p56, d_math186);
    			d_math186.innerHTML = raw186_value;
    			append_dev(p56, t352);
    			append_dev(p56, d_math187);
    			d_math187.innerHTML = raw187_value;
    			append_dev(p56, t353);
    			append_dev(p56, d_math188);
    			d_math188.innerHTML = raw188_value;
    			append_dev(p56, t354);
    			append_dev(p56, d_math189);
    			d_math189.innerHTML = raw189_value;
    			append_dev(p56, t355);
    			append_dev(p56, d_math190);
    			d_math190.innerHTML = raw190_value;
    			append_dev(p56, t356);
    			append_dev(p56, d_math191);
    			d_math191.innerHTML = raw191_value;
    			append_dev(p56, t357);
    			append_dev(p56, d_math192);
    			d_math192.innerHTML = raw192_value;
    			append_dev(p56, t358);
    			insert_dev(target, t359, anchor);
    			insert_dev(target, p57, anchor);
    			append_dev(p57, t360);
    			append_dev(p57, d_math193);
    			d_math193.innerHTML = raw193_value;
    			append_dev(p57, t361);
    			append_dev(p57, d_math194);
    			d_math194.innerHTML = raw194_value;
    			append_dev(p57, t362);
    			append_dev(p57, d_math195);
    			d_math195.innerHTML = raw195_value;
    			append_dev(p57, t363);
    			append_dev(p57, d_math196);
    			d_math196.innerHTML = raw196_value;
    			append_dev(p57, t364);
    			append_dev(p57, d_math197);
    			d_math197.innerHTML = raw197_value;
    			append_dev(p57, t365);
    			append_dev(p57, d_math198);
    			d_math198.innerHTML = raw198_value;
    			append_dev(p57, t366);
    			append_dev(p57, d_math199);
    			d_math199.innerHTML = raw199_value;
    			append_dev(p57, t367);
    			append_dev(p57, d_math200);
    			d_math200.innerHTML = raw200_value;
    			append_dev(p57, t368);
    			append_dev(p57, d_math201);
    			d_math201.innerHTML = raw201_value;
    			append_dev(p57, t369);
    			append_dev(p57, d_math202);
    			d_math202.innerHTML = raw202_value;
    			append_dev(p57, t370);
    			insert_dev(target, t371, anchor);
    			insert_dev(target, p58, anchor);
    			append_dev(p58, t372);
    			append_dev(p58, d_math203);
    			d_math203.innerHTML = raw203_value;
    			append_dev(p58, t373);
    			append_dev(p58, d_math204);
    			d_math204.innerHTML = raw204_value;
    			append_dev(p58, t374);
    			insert_dev(target, t375, anchor);
    			insert_dev(target, p59, anchor);
    			append_dev(p59, strong16);
    			insert_dev(target, t377, anchor);
    			insert_dev(target, p60, anchor);
    			append_dev(p60, t378);
    			append_dev(p60, d_math205);
    			d_math205.innerHTML = raw205_value;
    			append_dev(p60, t379);
    			append_dev(p60, em13);
    			append_dev(p60, t381);
    			append_dev(p60, d_math206);
    			d_math206.innerHTML = raw206_value;
    			append_dev(p60, t382);
    			append_dev(p60, d_math207);
    			d_math207.innerHTML = raw207_value;
    			append_dev(p60, t383);
    			append_dev(p60, d_math208);
    			d_math208.innerHTML = raw208_value;
    			append_dev(p60, t384);
    			append_dev(p60, d_math209);
    			d_math209.innerHTML = raw209_value;
    			append_dev(p60, t385);
    			insert_dev(target, t386, anchor);
    			insert_dev(target, p61, anchor);
    			append_dev(p61, t387);
    			append_dev(p61, d_math210);
    			d_math210.innerHTML = raw210_value;
    			append_dev(p61, t388);
    			append_dev(p61, d_math211);
    			d_math211.innerHTML = raw211_value;
    			append_dev(p61, t389);
    			append_dev(p61, d_math212);
    			d_math212.innerHTML = raw212_value;
    			append_dev(p61, t390);
    			append_dev(p61, d_math213);
    			d_math213.innerHTML = raw213_value;
    			append_dev(p61, t391);
    			append_dev(p61, d_math214);
    			d_math214.innerHTML = raw214_value;
    			append_dev(p61, t392);
    			insert_dev(target, t393, anchor);
    			insert_dev(target, p62, anchor);
    			append_dev(p62, t394);
    			append_dev(p62, d_math215);
    			d_math215.innerHTML = raw215_value;
    			append_dev(p62, t395);
    			append_dev(p62, d_math216);
    			d_math216.innerHTML = raw216_value;
    			append_dev(p62, t396);
    			append_dev(p62, d_math217);
    			d_math217.innerHTML = raw217_value;
    			append_dev(p62, t397);
    			insert_dev(target, t398, anchor);
    			insert_dev(target, p63, anchor);
    			append_dev(p63, t399);
    			append_dev(p63, em14);
    			append_dev(p63, t401);
    			append_dev(p63, d_math218);
    			d_math218.innerHTML = raw218_value;
    			append_dev(p63, t402);
    			append_dev(p63, d_math219);
    			d_math219.innerHTML = raw219_value;
    			append_dev(p63, t403);
    			insert_dev(target, t404, anchor);
    			insert_dev(target, p64, anchor);
    			append_dev(p64, t405);
    			append_dev(p64, d_math220);
    			d_math220.innerHTML = raw220_value;
    			append_dev(p64, t406);
    			insert_dev(target, t407, anchor);
    			insert_dev(target, p65, anchor);
    			append_dev(p65, strong17);
    			append_dev(strong17, t408);
    			append_dev(strong17, d_math221);
    			d_math221.innerHTML = raw221_value;
    			append_dev(strong17, t409);
    			append_dev(strong17, d_math222);
    			d_math222.innerHTML = raw222_value;
    			append_dev(strong17, t410);
    			insert_dev(target, t411, anchor);
    			insert_dev(target, p66, anchor);
    			append_dev(p66, t412);
    			append_dev(p66, d_math223);
    			d_math223.innerHTML = raw223_value;
    			append_dev(p66, t413);
    			append_dev(p66, d_math224);
    			d_math224.innerHTML = raw224_value;
    			append_dev(p66, t414);
    			append_dev(p66, d_math225);
    			d_math225.innerHTML = raw225_value;
    			append_dev(p66, t415);
    			append_dev(p66, d_math226);
    			d_math226.innerHTML = raw226_value;
    			append_dev(p66, t416);
    			append_dev(p66, d_math227);
    			d_math227.innerHTML = raw227_value;
    			append_dev(p66, t417);
    			append_dev(p66, d_math228);
    			d_math228.innerHTML = raw228_value;
    			append_dev(p66, t418);
    			append_dev(p66, d_math229);
    			d_math229.innerHTML = raw229_value;
    			append_dev(p66, t419);
    			append_dev(p66, d_math230);
    			d_math230.innerHTML = raw230_value;
    			append_dev(p66, t420);
    			append_dev(p66, d_math231);
    			d_math231.innerHTML = raw231_value;
    			append_dev(p66, t421);
    			append_dev(p66, d_math232);
    			d_math232.innerHTML = raw232_value;
    			append_dev(p66, t422);
    			append_dev(p66, d_math233);
    			d_math233.innerHTML = raw233_value;
    			append_dev(p66, t423);
    			append_dev(p66, d_math234);
    			d_math234.innerHTML = raw234_value;
    			append_dev(p66, t424);
    			append_dev(p66, d_math235);
    			d_math235.innerHTML = raw235_value;
    			append_dev(p66, t425);
    			append_dev(p66, br4);
    			append_dev(p66, d_math236);
    			d_math236.innerHTML = raw236_value;
    			append_dev(p66, t426);
    			append_dev(p66, d_math237);
    			d_math237.innerHTML = raw237_value;
    			append_dev(p66, t427);
    			append_dev(p66, d_math238);
    			d_math238.innerHTML = raw238_value;
    			append_dev(p66, t428);
    			append_dev(p66, d_math239);
    			d_math239.innerHTML = raw239_value;
    			append_dev(p66, t429);
    			append_dev(p66, d_math240);
    			d_math240.innerHTML = raw240_value;
    			append_dev(p66, t430);
    			append_dev(p66, d_math241);
    			d_math241.innerHTML = raw241_value;
    			append_dev(p66, t431);
    			append_dev(p66, d_math242);
    			d_math242.innerHTML = raw242_value;
    			append_dev(p66, t432);
    			insert_dev(target, t433, anchor);
    			insert_dev(target, p67, anchor);
    			append_dev(p67, t434);
    			append_dev(p67, d_math243);
    			d_math243.innerHTML = raw243_value;
    			append_dev(p67, t435);
    			append_dev(p67, d_math244);
    			d_math244.innerHTML = raw244_value;
    			append_dev(p67, t436);
    			append_dev(p67, d_math245);
    			d_math245.innerHTML = raw245_value;
    			append_dev(p67, t437);
    			insert_dev(target, t438, anchor);
    			insert_dev(target, h12, anchor);
    			insert_dev(target, t440, anchor);
    			insert_dev(target, p68, anchor);
    			append_dev(p68, t441);
    			append_dev(p68, d_math246);
    			d_math246.innerHTML = raw246_value;
    			append_dev(p68, t442);
    			append_dev(p68, d_math247);
    			d_math247.innerHTML = raw247_value;
    			append_dev(p68, t443);
    			append_dev(p68, d_math248);
    			d_math248.innerHTML = raw248_value;
    			append_dev(p68, t444);
    			append_dev(p68, d_math249);
    			d_math249.innerHTML = raw249_value;
    			append_dev(p68, t445);
    			append_dev(p68, d_math250);
    			d_math250.innerHTML = raw250_value;
    			append_dev(p68, t446);
    			append_dev(p68, d_math251);
    			d_math251.innerHTML = raw251_value;
    			append_dev(p68, t447);
    			append_dev(p68, d_math252);
    			d_math252.innerHTML = raw252_value;
    			append_dev(p68, t448);
    			append_dev(p68, d_math253);
    			d_math253.innerHTML = raw253_value;
    			append_dev(p68, t449);
    			append_dev(p68, d_math254);
    			d_math254.innerHTML = raw254_value;
    			append_dev(p68, t450);
    			append_dev(p68, d_math255);
    			d_math255.innerHTML = raw255_value;
    			append_dev(p68, t451);
    			insert_dev(target, t452, anchor);
    			insert_dev(target, p69, anchor);
    			append_dev(p69, strong18);
    			append_dev(strong18, t453);
    			append_dev(strong18, d_math256);
    			d_math256.innerHTML = raw256_value;
    			append_dev(strong18, t454);
    			append_dev(strong18, d_math257);
    			d_math257.innerHTML = raw257_value;
    			append_dev(p69, t455);
    			append_dev(p69, d_math258);
    			d_math258.innerHTML = raw258_value;
    			append_dev(p69, t456);
    			insert_dev(target, t457, anchor);
    			insert_dev(target, p70, anchor);
    			append_dev(p70, strong19);
    			append_dev(strong19, t458);
    			append_dev(strong19, d_math259);
    			d_math259.innerHTML = raw259_value;
    			append_dev(strong19, t459);
    			append_dev(strong19, d_math260);
    			d_math260.innerHTML = raw260_value;
    			append_dev(strong19, t460);
    			append_dev(strong19, d_math261);
    			d_math261.innerHTML = raw261_value;
    			append_dev(strong19, t461);
    			append_dev(strong19, d_math262);
    			d_math262.innerHTML = raw262_value;
    			append_dev(p70, t462);
    			append_dev(p70, d_math263);
    			d_math263.innerHTML = raw263_value;
    			append_dev(p70, t463);
    			append_dev(p70, d_math264);
    			d_math264.innerHTML = raw264_value;
    			append_dev(p70, t464);
    			append_dev(p70, d_math265);
    			d_math265.innerHTML = raw265_value;
    			append_dev(p70, t465);
    			insert_dev(target, t466, anchor);
    			insert_dev(target, p71, anchor);
    			append_dev(p71, strong20);
    			append_dev(strong20, t467);
    			append_dev(strong20, d_math266);
    			d_math266.innerHTML = raw266_value;
    			append_dev(strong20, t468);
    			append_dev(strong20, d_math267);
    			d_math267.innerHTML = raw267_value;
    			append_dev(strong20, t469);
    			append_dev(strong20, d_math268);
    			d_math268.innerHTML = raw268_value;
    			append_dev(strong20, t470);
    			append_dev(strong20, d_math269);
    			d_math269.innerHTML = raw269_value;
    			append_dev(p71, t471);
    			append_dev(p71, d_math270);
    			d_math270.innerHTML = raw270_value;
    			append_dev(p71, t472);
    			append_dev(p71, d_math271);
    			d_math271.innerHTML = raw271_value;
    			append_dev(p71, t473);
    			append_dev(p71, d_math272);
    			d_math272.innerHTML = raw272_value;
    			append_dev(p71, t474);
    			insert_dev(target, t475, anchor);
    			insert_dev(target, h25, anchor);
    			append_dev(h25, t476);
    			append_dev(h25, d_math273);
    			d_math273.innerHTML = raw273_value;
    			append_dev(h25, t477);
    			insert_dev(target, t478, anchor);
    			insert_dev(target, p72, anchor);
    			append_dev(p72, t479);
    			append_dev(p72, d_math274);
    			d_math274.innerHTML = raw274_value;
    			append_dev(p72, t480);
    			append_dev(p72, d_math275);
    			d_math275.innerHTML = raw275_value;
    			append_dev(p72, t481);
    			append_dev(p72, d_math276);
    			d_math276.innerHTML = raw276_value;
    			append_dev(p72, t482);
    			insert_dev(target, t483, anchor);
    			insert_dev(target, p73, anchor);
    			append_dev(p73, t484);
    			append_dev(p73, d_math277);
    			d_math277.innerHTML = raw277_value;
    			append_dev(p73, t485);
    			append_dev(p73, d_math278);
    			d_math278.innerHTML = raw278_value;
    			append_dev(p73, t486);
    			append_dev(p73, d_math279);
    			d_math279.innerHTML = raw279_value;
    			append_dev(p73, t487);
    			append_dev(p73, d_math280);
    			d_math280.innerHTML = raw280_value;
    			append_dev(p73, t488);
    			append_dev(p73, br5);
    			append_dev(p73, d_math281);
    			d_math281.innerHTML = raw281_value;
    			append_dev(p73, t489);
    			append_dev(p73, em15);
    			append_dev(p73, t491);
    			append_dev(p73, d_math282);
    			d_math282.innerHTML = raw282_value;
    			append_dev(p73, t492);
    			append_dev(p73, d_math283);
    			d_math283.innerHTML = raw283_value;
    			append_dev(p73, t493);
    			append_dev(p73, d_math284);
    			d_math284.innerHTML = raw284_value;
    			append_dev(p73, t494);
    			append_dev(p73, d_math285);
    			d_math285.innerHTML = raw285_value;
    			append_dev(p73, t495);
    			append_dev(p73, d_math286);
    			d_math286.innerHTML = raw286_value;
    			append_dev(p73, t496);
    			insert_dev(target, t497, anchor);
    			insert_dev(target, p74, anchor);
    			append_dev(p74, t498);
    			append_dev(p74, d_math287);
    			d_math287.innerHTML = raw287_value;
    			append_dev(p74, t499);
    			append_dev(p74, d_math288);
    			d_math288.innerHTML = raw288_value;
    			append_dev(p74, t500);
    			insert_dev(target, t501, anchor);
    			insert_dev(target, d_math289, anchor);
    			d_math289.innerHTML = raw289_value;
    			insert_dev(target, t502, anchor);
    			insert_dev(target, p75, anchor);
    			insert_dev(target, t504, anchor);
    			insert_dev(target, d_math290, anchor);
    			d_math290.innerHTML = raw290_value;
    			insert_dev(target, t505, anchor);
    			insert_dev(target, p76, anchor);
    			append_dev(p76, d_math291);
    			d_math291.innerHTML = raw291_value;
    			append_dev(p76, t506);
    			append_dev(p76, d_math292);
    			d_math292.innerHTML = raw292_value;
    			append_dev(p76, t507);
    			append_dev(p76, d_math293);
    			d_math293.innerHTML = raw293_value;
    			append_dev(p76, t508);
    			append_dev(p76, d_math294);
    			d_math294.innerHTML = raw294_value;
    			append_dev(p76, t509);
    			append_dev(p76, d_math295);
    			d_math295.innerHTML = raw295_value;
    			append_dev(p76, t510);
    			append_dev(p76, d_math296);
    			d_math296.innerHTML = raw296_value;
    			append_dev(p76, t511);
    			append_dev(p76, d_math297);
    			d_math297.innerHTML = raw297_value;
    			append_dev(p76, t512);
    			insert_dev(target, t513, anchor);
    			insert_dev(target, p77, anchor);
    			append_dev(p77, t514);
    			append_dev(p77, d_math298);
    			d_math298.innerHTML = raw298_value;
    			append_dev(p77, t515);
    			insert_dev(target, t516, anchor);
    			insert_dev(target, d_math299, anchor);
    			d_math299.innerHTML = raw299_value;
    			insert_dev(target, t517, anchor);
    			insert_dev(target, h26, anchor);
    			insert_dev(target, t519, anchor);
    			insert_dev(target, p78, anchor);
    			append_dev(p78, t520);
    			append_dev(p78, d_math300);
    			d_math300.innerHTML = raw300_value;
    			append_dev(p78, t521);
    			append_dev(p78, d_math301);
    			d_math301.innerHTML = raw301_value;
    			append_dev(p78, t522);
    			insert_dev(target, t523, anchor);
    			insert_dev(target, p79, anchor);
    			append_dev(p79, t524);
    			append_dev(p79, d_math302);
    			d_math302.innerHTML = raw302_value;
    			append_dev(p79, t525);
    			append_dev(p79, d_math303);
    			d_math303.innerHTML = raw303_value;
    			append_dev(p79, t526);
    			append_dev(p79, d_math304);
    			d_math304.innerHTML = raw304_value;
    			append_dev(p79, t527);
    			insert_dev(target, t528, anchor);
    			insert_dev(target, d_math305, anchor);
    			d_math305.innerHTML = raw305_value;
    			insert_dev(target, t529, anchor);
    			insert_dev(target, p80, anchor);
    			append_dev(p80, t530);
    			append_dev(p80, d_math306);
    			d_math306.innerHTML = raw306_value;
    			append_dev(p80, t531);
    			append_dev(p80, d_math307);
    			d_math307.innerHTML = raw307_value;
    			append_dev(p80, t532);
    			append_dev(p80, d_math308);
    			d_math308.innerHTML = raw308_value;
    			append_dev(p80, t533);
    			append_dev(p80, d_math309);
    			d_math309.innerHTML = raw309_value;
    			append_dev(p80, t534);
    			append_dev(p80, d_math310);
    			d_math310.innerHTML = raw310_value;
    			append_dev(p80, t535);
    			append_dev(p80, d_math311);
    			d_math311.innerHTML = raw311_value;
    			append_dev(p80, t536);
    			insert_dev(target, t537, anchor);
    			insert_dev(target, p81, anchor);
    			append_dev(p81, t538);
    			append_dev(p81, d_math312);
    			d_math312.innerHTML = raw312_value;
    			append_dev(p81, t539);
    			append_dev(p81, d_math313);
    			d_math313.innerHTML = raw313_value;
    			append_dev(p81, t540);
    			insert_dev(target, t541, anchor);
    			insert_dev(target, p82, anchor);
    			append_dev(p82, t542);
    			append_dev(p82, d_math314);
    			d_math314.innerHTML = raw314_value;
    			append_dev(p82, t543);
    			append_dev(p82, d_math315);
    			d_math315.innerHTML = raw315_value;
    			append_dev(p82, t544);
    			append_dev(p82, d_math316);
    			d_math316.innerHTML = raw316_value;
    			append_dev(p82, t545);
    			append_dev(p82, d_math317);
    			d_math317.innerHTML = raw317_value;
    			append_dev(p82, t546);
    			append_dev(p82, d_math318);
    			d_math318.innerHTML = raw318_value;
    			append_dev(p82, t547);
    			append_dev(p82, d_math319);
    			d_math319.innerHTML = raw319_value;
    			append_dev(p82, t548);
    			insert_dev(target, t549, anchor);
    			insert_dev(target, p83, anchor);
    			append_dev(p83, t550);
    			append_dev(p83, d_math320);
    			d_math320.innerHTML = raw320_value;
    			append_dev(p83, t551);
    			append_dev(p83, d_math321);
    			d_math321.innerHTML = raw321_value;
    			append_dev(p83, t552);
    			append_dev(p83, d_math322);
    			d_math322.innerHTML = raw322_value;
    			append_dev(p83, t553);
    			append_dev(p83, d_math323);
    			d_math323.innerHTML = raw323_value;
    			append_dev(p83, t554);
    			append_dev(p83, d_math324);
    			d_math324.innerHTML = raw324_value;
    			append_dev(p83, t555);
    			insert_dev(target, t556, anchor);
    			insert_dev(target, h27, anchor);
    			insert_dev(target, t558, anchor);
    			insert_dev(target, p84, anchor);
    			append_dev(p84, t559);
    			append_dev(p84, d_math325);
    			d_math325.innerHTML = raw325_value;
    			append_dev(p84, t560);
    			insert_dev(target, t561, anchor);
    			insert_dev(target, d_math326, anchor);
    			d_math326.innerHTML = raw326_value;
    			insert_dev(target, t562, anchor);
    			insert_dev(target, p85, anchor);
    			append_dev(p85, t563);
    			append_dev(p85, d_math327);
    			d_math327.innerHTML = raw327_value;
    			append_dev(p85, t564);
    			insert_dev(target, t565, anchor);
    			insert_dev(target, d_math328, anchor);
    			d_math328.innerHTML = raw328_value;
    			insert_dev(target, t566, anchor);
    			insert_dev(target, p86, anchor);
    			insert_dev(target, t568, anchor);
    			insert_dev(target, d_math329, anchor);
    			d_math329.innerHTML = raw329_value;
    			insert_dev(target, t569, anchor);
    			insert_dev(target, p87, anchor);
    			insert_dev(target, t571, anchor);
    			insert_dev(target, d_math330, anchor);
    			d_math330.innerHTML = raw330_value;
    			insert_dev(target, t572, anchor);
    			insert_dev(target, p88, anchor);
    			append_dev(p88, t573);
    			append_dev(p88, d_math331);
    			d_math331.innerHTML = raw331_value;
    			append_dev(p88, t574);
    			append_dev(p88, d_math332);
    			d_math332.innerHTML = raw332_value;
    			append_dev(p88, t575);
    			append_dev(p88, d_math333);
    			d_math333.innerHTML = raw333_value;
    			append_dev(p88, t576);
    			insert_dev(target, t577, anchor);
    			insert_dev(target, d_math334, anchor);
    			d_math334.innerHTML = raw334_value;
    			insert_dev(target, t578, anchor);
    			insert_dev(target, p89, anchor);
    			insert_dev(target, t580, anchor);
    			insert_dev(target, d_math335, anchor);
    			d_math335.innerHTML = raw335_value;
    			insert_dev(target, t581, anchor);
    			insert_dev(target, p90, anchor);
    			insert_dev(target, t583, anchor);
    			insert_dev(target, d_math336, anchor);
    			d_math336.innerHTML = raw336_value;
    			insert_dev(target, t584, anchor);
    			insert_dev(target, p91, anchor);
    			append_dev(p91, t585);
    			append_dev(p91, d_math337);
    			d_math337.innerHTML = raw337_value;
    			append_dev(p91, t586);
    			append_dev(p91, d_math338);
    			d_math338.innerHTML = raw338_value;
    			append_dev(p91, t587);
    			append_dev(p91, d_math339);
    			d_math339.innerHTML = raw339_value;
    			append_dev(p91, t588);
    			append_dev(p91, d_math340);
    			d_math340.innerHTML = raw340_value;
    			append_dev(p91, t589);
    			insert_dev(target, t590, anchor);
    			insert_dev(target, h13, anchor);
    			insert_dev(target, t592, anchor);
    			insert_dev(target, p92, anchor);
    			append_dev(p92, t593);
    			append_dev(p92, d_math341);
    			d_math341.innerHTML = raw341_value;
    			append_dev(p92, t594);
    			insert_dev(target, t595, anchor);
    			insert_dev(target, p93, anchor);
    			append_dev(p93, t596);
    			append_dev(p93, d_math342);
    			d_math342.innerHTML = raw342_value;
    			append_dev(p93, t597);
    			append_dev(p93, d_math343);
    			d_math343.innerHTML = raw343_value;
    			append_dev(p93, t598);
    			append_dev(p93, d_math344);
    			d_math344.innerHTML = raw344_value;
    			append_dev(p93, t599);
    			append_dev(p93, d_math345);
    			d_math345.innerHTML = raw345_value;
    			append_dev(p93, t600);
    			insert_dev(target, t601, anchor);
    			insert_dev(target, p94, anchor);
    			append_dev(p94, t602);
    			append_dev(p94, d_math346);
    			d_math346.innerHTML = raw346_value;
    			append_dev(p94, t603);
    			insert_dev(target, t604, anchor);
    			insert_dev(target, ol2, anchor);
    			append_dev(ol2, li7);
    			append_dev(li7, p95);
    			append_dev(ol2, t606);
    			append_dev(ol2, li8);
    			append_dev(li8, p96);
    			append_dev(ol2, t608);
    			append_dev(ol2, li9);
    			append_dev(li9, p97);
    			insert_dev(target, t610, anchor);
    			insert_dev(target, h14, anchor);
    			insert_dev(target, t612, anchor);
    			insert_dev(target, p98, anchor);
    			insert_dev(target, t614, anchor);
    			insert_dev(target, h28, anchor);
    			insert_dev(target, t616, anchor);
    			insert_dev(target, p99, anchor);
    			append_dev(p99, t617);
    			append_dev(p99, d_math347);
    			d_math347.innerHTML = raw347_value;
    			append_dev(p99, t618);
    			append_dev(p99, d_math348);
    			d_math348.innerHTML = raw348_value;
    			append_dev(p99, t619);
    			append_dev(p99, d_math349);
    			d_math349.innerHTML = raw349_value;
    			append_dev(p99, t620);
    			append_dev(p99, d_math350);
    			d_math350.innerHTML = raw350_value;
    			append_dev(p99, t621);
    			append_dev(p99, d_math351);
    			d_math351.innerHTML = raw351_value;
    			append_dev(p99, t622);
    			append_dev(p99, d_math352);
    			d_math352.innerHTML = raw352_value;
    			append_dev(p99, t623);
    			append_dev(p99, d_math353);
    			d_math353.innerHTML = raw353_value;
    			append_dev(p99, t624);
    			append_dev(p99, d_math354);
    			d_math354.innerHTML = raw354_value;
    			append_dev(p99, t625);
    			append_dev(p99, d_math355);
    			d_math355.innerHTML = raw355_value;
    			append_dev(p99, t626);
    			append_dev(p99, d_math356);
    			d_math356.innerHTML = raw356_value;
    			append_dev(p99, t627);
    			append_dev(p99, d_math357);
    			d_math357.innerHTML = raw357_value;
    			append_dev(p99, t628);
    			append_dev(p99, d_math358);
    			d_math358.innerHTML = raw358_value;
    			append_dev(p99, t629);
    			insert_dev(target, t630, anchor);
    			insert_dev(target, h29, anchor);
    			insert_dev(target, t632, anchor);
    			insert_dev(target, p100, anchor);
    			append_dev(p100, t633);
    			append_dev(p100, d_math359);
    			d_math359.innerHTML = raw359_value;
    			append_dev(p100, t634);
    			insert_dev(target, t635, anchor);
    			insert_dev(target, h210, anchor);
    			insert_dev(target, t637, anchor);
    			insert_dev(target, p101, anchor);
    			insert_dev(target, t639, anchor);
    			insert_dev(target, p102, anchor);
    			append_dev(p102, t640);
    			append_dev(p102, d_math360);
    			d_math360.innerHTML = raw360_value;
    			append_dev(p102, t641);
    			append_dev(p102, em16);
    			append_dev(p102, t643);
    			append_dev(p102, d_math361);
    			d_math361.innerHTML = raw361_value;
    			append_dev(p102, t644);
    			append_dev(p102, em17);
    			append_dev(p102, t646);
    			append_dev(p102, d_math362);
    			d_math362.innerHTML = raw362_value;
    			append_dev(p102, t647);
    			append_dev(p102, d_math363);
    			d_math363.innerHTML = raw363_value;
    			append_dev(p102, t648);
    			append_dev(p102, d_math364);
    			d_math364.innerHTML = raw364_value;
    			append_dev(p102, t649);
    			insert_dev(target, t650, anchor);
    			insert_dev(target, p103, anchor);
    			append_dev(p103, t651);
    			append_dev(p103, d_math365);
    			d_math365.innerHTML = raw365_value;
    			append_dev(p103, t652);
    			append_dev(p103, d_math366);
    			d_math366.innerHTML = raw366_value;
    			append_dev(p103, t653);
    			append_dev(p103, em18);
    			append_dev(p103, t655);
    			append_dev(p103, d_math367);
    			d_math367.innerHTML = raw367_value;
    			append_dev(p103, t656);
    			append_dev(p103, d_math368);
    			d_math368.innerHTML = raw368_value;
    			append_dev(p103, t657);
    			append_dev(p103, d_math369);
    			d_math369.innerHTML = raw369_value;
    			append_dev(p103, t658);
    			append_dev(p103, em19);
    			append_dev(p103, t660);
    			append_dev(p103, em20);
    			append_dev(p103, t662);
    			append_dev(p103, d_math370);
    			d_math370.innerHTML = raw370_value;
    			append_dev(p103, t663);
    			append_dev(p103, d_math371);
    			d_math371.innerHTML = raw371_value;
    			append_dev(p103, t664);
    			append_dev(p103, d_math372);
    			d_math372.innerHTML = raw372_value;
    			append_dev(p103, t665);
    			insert_dev(target, t666, anchor);
    			insert_dev(target, p104, anchor);
    			append_dev(p104, t667);
    			append_dev(p104, d_math373);
    			d_math373.innerHTML = raw373_value;
    			append_dev(p104, t668);
    			append_dev(p104, d_math374);
    			d_math374.innerHTML = raw374_value;
    			append_dev(p104, t669);
    			append_dev(p104, d_math375);
    			d_math375.innerHTML = raw375_value;
    			append_dev(p104, t670);
    			append_dev(p104, a0);
    			append_dev(p104, t672);
    			insert_dev(target, t673, anchor);
    			insert_dev(target, h211, anchor);
    			insert_dev(target, t675, anchor);
    			insert_dev(target, p105, anchor);
    			append_dev(p105, t676);
    			append_dev(p105, d_math376);
    			d_math376.innerHTML = raw376_value;
    			append_dev(p105, t677);
    			append_dev(p105, d_math377);
    			d_math377.innerHTML = raw377_value;
    			append_dev(p105, t678);
    			append_dev(p105, d_math378);
    			d_math378.innerHTML = raw378_value;
    			append_dev(p105, t679);
    			append_dev(p105, em21);
    			append_dev(p105, t681);
    			append_dev(p105, d_math379);
    			d_math379.innerHTML = raw379_value;
    			append_dev(p105, t682);
    			append_dev(p105, em22);
    			append_dev(p105, t684);
    			append_dev(p105, d_math380);
    			d_math380.innerHTML = raw380_value;
    			append_dev(p105, t685);
    			append_dev(p105, d_math381);
    			d_math381.innerHTML = raw381_value;
    			append_dev(p105, t686);
    			append_dev(p105, a1);
    			insert_dev(target, t688, anchor);
    			insert_dev(target, h212, anchor);
    			insert_dev(target, t690, anchor);
    			insert_dev(target, p106, anchor);
    			insert_dev(target, t692, anchor);
    			insert_dev(target, h213, anchor);
    			insert_dev(target, t694, anchor);
    			insert_dev(target, h214, anchor);
    			insert_dev(target, t696, anchor);
    			insert_dev(target, h215, anchor);
    			insert_dev(target, t698, anchor);
    			insert_dev(target, p107, anchor);
    			insert_dev(target, t700, anchor);
    			insert_dev(target, h216, anchor);
    			insert_dev(target, t702, anchor);
    			insert_dev(target, p108, anchor);
    			insert_dev(target, t704, anchor);
    			insert_dev(target, p109, anchor);
    			append_dev(p109, d_math382);
    			d_math382.innerHTML = raw382_value;
    			insert_dev(target, t705, anchor);
    			insert_dev(target, p110, anchor);
    			append_dev(p110, t706);
    			append_dev(p110, a2);
    			insert_dev(target, t708, anchor);
    			insert_dev(target, h217, anchor);
    			insert_dev(target, t710, anchor);
    			insert_dev(target, p111, anchor);
    			append_dev(p111, t711);
    			append_dev(p111, em23);
    			append_dev(p111, t713);
    			append_dev(p111, d_math383);
    			d_math383.innerHTML = raw383_value;
    			append_dev(p111, t714);
    			append_dev(p111, d_math384);
    			d_math384.innerHTML = raw384_value;
    			append_dev(p111, t715);
    			append_dev(p111, d_math385);
    			d_math385.innerHTML = raw385_value;
    			append_dev(p111, t716);
    			append_dev(p111, d_math386);
    			d_math386.innerHTML = raw386_value;
    			append_dev(p111, t717);
    			insert_dev(target, t718, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t720);
    			append_dev(tr0, th1);
    			append_dev(th1, d_math387);
    			d_math387.innerHTML = raw387_value;
    			append_dev(table, t721);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t723);
    			append_dev(tr1, td1);
    			append_dev(td1, d_math388);
    			d_math388.innerHTML = raw388_value;
    			append_dev(tbody, t724);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td2);
    			append_dev(tr2, t726);
    			append_dev(tr2, td3);
    			append_dev(td3, d_math389);
    			d_math389.innerHTML = raw389_value;
    			append_dev(tbody, t727);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td4);
    			append_dev(tr3, t729);
    			append_dev(tr3, td5);
    			append_dev(td5, d_math390);
    			d_math390.innerHTML = raw390_value;
    			append_dev(tbody, t730);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td6);
    			append_dev(tr4, t732);
    			append_dev(tr4, td7);
    			append_dev(td7, d_math391);
    			d_math391.innerHTML = raw391_value;
    			insert_dev(target, t733, anchor);
    			insert_dev(target, p112, anchor);
    			insert_dev(target, t735, anchor);
    			insert_dev(target, d_math392, anchor);
    			d_math392.innerHTML = raw392_value;
    			insert_dev(target, t736, anchor);
    			insert_dev(target, p113, anchor);
    			append_dev(p113, t737);
    			append_dev(p113, d_math393);
    			d_math393.innerHTML = raw393_value;
    			append_dev(p113, t738);
    			insert_dev(target, t739, anchor);
    			insert_dev(target, p114, anchor);
    			append_dev(p114, d_math394);
    			d_math394.innerHTML = raw394_value;
    			insert_dev(target, t740, anchor);
    			insert_dev(target, p115, anchor);
    			insert_dev(target, t742, anchor);
    			insert_dev(target, h218, anchor);
    			insert_dev(target, t744, anchor);
    			insert_dev(target, p116, anchor);
    			append_dev(p116, t745);
    			append_dev(p116, a3);
    			insert_dev(target, t747, anchor);
    			insert_dev(target, h219, anchor);
    			insert_dev(target, t749, anchor);
    			insert_dev(target, p117, anchor);
    			append_dev(p117, t750);
    			append_dev(p117, d_math395);
    			d_math395.innerHTML = raw395_value;
    			append_dev(p117, t751);
    			append_dev(p117, d_math396);
    			d_math396.innerHTML = raw396_value;
    			append_dev(p117, t752);
    			append_dev(p117, em24);
    			append_dev(p117, t754);
    			append_dev(p117, d_math397);
    			d_math397.innerHTML = raw397_value;
    			append_dev(p117, t755);
    			append_dev(p117, d_math398);
    			d_math398.innerHTML = raw398_value;
    			append_dev(p117, t756);
    			append_dev(p117, d_math399);
    			d_math399.innerHTML = raw399_value;
    			append_dev(p117, t757);
    			append_dev(p117, br6);
    			append_dev(p117, d_math400);
    			d_math400.innerHTML = raw400_value;
    			append_dev(p117, t758);
    			append_dev(p117, d_math401);
    			d_math401.innerHTML = raw401_value;
    			append_dev(p117, t759);
    			append_dev(p117, d_math402);
    			d_math402.innerHTML = raw402_value;
    			append_dev(p117, t760);
    			insert_dev(target, t761, anchor);
    			insert_dev(target, p118, anchor);
    			append_dev(p118, t762);
    			append_dev(p118, d_math403);
    			d_math403.innerHTML = raw403_value;
    			append_dev(p118, t763);
    			append_dev(p118, d_math404);
    			d_math404.innerHTML = raw404_value;
    			append_dev(p118, t764);
    			insert_dev(target, t765, anchor);
    			insert_dev(target, p119, anchor);
    			append_dev(p119, t766);
    			append_dev(p119, d_math405);
    			d_math405.innerHTML = raw405_value;
    			append_dev(p119, t767);
    			append_dev(p119, d_math406);
    			d_math406.innerHTML = raw406_value;
    			append_dev(p119, t768);
    			append_dev(p119, d_math407);
    			d_math407.innerHTML = raw407_value;
    			append_dev(p119, t769);
    			append_dev(p119, d_math408);
    			d_math408.innerHTML = raw408_value;
    			append_dev(p119, t770);
    			append_dev(p119, d_math409);
    			d_math409.innerHTML = raw409_value;
    			append_dev(p119, t771);
    			append_dev(p119, d_math410);
    			d_math410.innerHTML = raw410_value;
    			append_dev(p119, t772);
    			insert_dev(target, t773, anchor);
    			insert_dev(target, p120, anchor);
    			append_dev(p120, t774);
    			append_dev(p120, em25);
    			append_dev(p120, t776);
    			append_dev(p120, d_math411);
    			d_math411.innerHTML = raw411_value;
    			append_dev(p120, t777);
    			insert_dev(target, t778, anchor);
    			insert_dev(target, d_math412, anchor);
    			d_math412.innerHTML = raw412_value;
    		},
    		p: noop$5,
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h10);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(p4);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(p5);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(h11);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(p6);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(p7);
    			if (detaching) detach_dev(t26);
    			if (detaching) detach_dev(p8);
    			if (detaching) detach_dev(t34);
    			if (detaching) detach_dev(p9);
    			if (detaching) detach_dev(t38);
    			if (detaching) detach_dev(p10);
    			if (detaching) detach_dev(t40);
    			if (detaching) detach_dev(p11);
    			if (detaching) detach_dev(t46);
    			if (detaching) detach_dev(p12);
    			if (detaching) detach_dev(t48);
    			if (detaching) detach_dev(d_math17);
    			if (detaching) detach_dev(t49);
    			if (detaching) detach_dev(p13);
    			if (detaching) detach_dev(t57);
    			if (detaching) detach_dev(p14);
    			if (detaching) detach_dev(t60);
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t62);
    			if (detaching) detach_dev(p15);
    			if (detaching) detach_dev(t72);
    			if (detaching) detach_dev(p16);
    			if (detaching) detach_dev(t83);
    			if (detaching) detach_dev(p17);
    			if (detaching) detach_dev(t87);
    			if (detaching) detach_dev(p18);
    			if (detaching) detach_dev(t91);
    			if (detaching) detach_dev(p19);
    			if (detaching) detach_dev(t94);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t96);
    			if (detaching) detach_dev(p20);
    			if (detaching) detach_dev(t98);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t100);
    			if (detaching) detach_dev(p21);
    			if (detaching) detach_dev(t108);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t110);
    			if (detaching) detach_dev(p22);
    			if (detaching) detach_dev(t121);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t123);
    			if (detaching) detach_dev(p23);
    			if (detaching) detach_dev(t128);
    			if (detaching) detach_dev(p24);
    			if (detaching) detach_dev(t132);
    			if (detaching) detach_dev(h22);
    			if (detaching) detach_dev(t134);
    			if (detaching) detach_dev(p25);
    			if (detaching) detach_dev(t145);
    			if (detaching) detach_dev(p26);
    			if (detaching) detach_dev(t150);
    			if (detaching) detach_dev(d_math66);
    			if (detaching) detach_dev(t151);
    			if (detaching) detach_dev(p27);
    			if (detaching) detach_dev(t155);
    			if (detaching) detach_dev(d_math69);
    			if (detaching) detach_dev(t156);
    			if (detaching) detach_dev(p28);
    			if (detaching) detach_dev(t159);
    			if (detaching) detach_dev(p29);
    			if (detaching) detach_dev(t174);
    			if (detaching) detach_dev(p30);
    			if (detaching) detach_dev(t180);
    			if (detaching) detach_dev(p31);
    			if (detaching) detach_dev(t190);
    			if (detaching) detach_dev(h23);
    			if (detaching) detach_dev(t192);
    			if (detaching) detach_dev(p32);
    			if (detaching) detach_dev(t195);
    			if (detaching) detach_dev(p33);
    			if (detaching) detach_dev(t197);
    			if (detaching) detach_dev(p34);
    			if (detaching) detach_dev(t202);
    			if (detaching) detach_dev(ol0);
    			if (detaching) detach_dev(t223);
    			if (detaching) detach_dev(p38);
    			if (detaching) detach_dev(t225);
    			if (detaching) detach_dev(ol1);
    			if (detaching) detach_dev(t254);
    			if (detaching) detach_dev(p43);
    			if (detaching) detach_dev(t258);
    			if (detaching) detach_dev(h24);
    			if (detaching) detach_dev(t260);
    			if (detaching) detach_dev(p44);
    			if (detaching) detach_dev(t265);
    			if (detaching) detach_dev(p45);
    			if (detaching) detach_dev(t271);
    			if (detaching) detach_dev(p46);
    			if (detaching) detach_dev(t277);
    			if (detaching) detach_dev(p47);
    			if (detaching) detach_dev(t283);
    			if (detaching) detach_dev(p48);
    			if (detaching) detach_dev(t294);
    			if (detaching) detach_dev(p49);
    			if (detaching) detach_dev(t302);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t304);
    			if (detaching) detach_dev(p50);
    			if (detaching) detach_dev(t313);
    			if (detaching) detach_dev(p51);
    			if (detaching) detach_dev(t322);
    			if (detaching) detach_dev(p52);
    			if (detaching) detach_dev(t337);
    			if (detaching) detach_dev(p53);
    			if (detaching) detach_dev(t343);
    			if (detaching) detach_dev(p54);
    			if (detaching) detach_dev(t348);
    			if (detaching) detach_dev(p55);
    			if (detaching) detach_dev(t350);
    			if (detaching) detach_dev(p56);
    			if (detaching) detach_dev(t359);
    			if (detaching) detach_dev(p57);
    			if (detaching) detach_dev(t371);
    			if (detaching) detach_dev(p58);
    			if (detaching) detach_dev(t375);
    			if (detaching) detach_dev(p59);
    			if (detaching) detach_dev(t377);
    			if (detaching) detach_dev(p60);
    			if (detaching) detach_dev(t386);
    			if (detaching) detach_dev(p61);
    			if (detaching) detach_dev(t393);
    			if (detaching) detach_dev(p62);
    			if (detaching) detach_dev(t398);
    			if (detaching) detach_dev(p63);
    			if (detaching) detach_dev(t404);
    			if (detaching) detach_dev(p64);
    			if (detaching) detach_dev(t407);
    			if (detaching) detach_dev(p65);
    			if (detaching) detach_dev(t411);
    			if (detaching) detach_dev(p66);
    			if (detaching) detach_dev(t433);
    			if (detaching) detach_dev(p67);
    			if (detaching) detach_dev(t438);
    			if (detaching) detach_dev(h12);
    			if (detaching) detach_dev(t440);
    			if (detaching) detach_dev(p68);
    			if (detaching) detach_dev(t452);
    			if (detaching) detach_dev(p69);
    			if (detaching) detach_dev(t457);
    			if (detaching) detach_dev(p70);
    			if (detaching) detach_dev(t466);
    			if (detaching) detach_dev(p71);
    			if (detaching) detach_dev(t475);
    			if (detaching) detach_dev(h25);
    			if (detaching) detach_dev(t478);
    			if (detaching) detach_dev(p72);
    			if (detaching) detach_dev(t483);
    			if (detaching) detach_dev(p73);
    			if (detaching) detach_dev(t497);
    			if (detaching) detach_dev(p74);
    			if (detaching) detach_dev(t501);
    			if (detaching) detach_dev(d_math289);
    			if (detaching) detach_dev(t502);
    			if (detaching) detach_dev(p75);
    			if (detaching) detach_dev(t504);
    			if (detaching) detach_dev(d_math290);
    			if (detaching) detach_dev(t505);
    			if (detaching) detach_dev(p76);
    			if (detaching) detach_dev(t513);
    			if (detaching) detach_dev(p77);
    			if (detaching) detach_dev(t516);
    			if (detaching) detach_dev(d_math299);
    			if (detaching) detach_dev(t517);
    			if (detaching) detach_dev(h26);
    			if (detaching) detach_dev(t519);
    			if (detaching) detach_dev(p78);
    			if (detaching) detach_dev(t523);
    			if (detaching) detach_dev(p79);
    			if (detaching) detach_dev(t528);
    			if (detaching) detach_dev(d_math305);
    			if (detaching) detach_dev(t529);
    			if (detaching) detach_dev(p80);
    			if (detaching) detach_dev(t537);
    			if (detaching) detach_dev(p81);
    			if (detaching) detach_dev(t541);
    			if (detaching) detach_dev(p82);
    			if (detaching) detach_dev(t549);
    			if (detaching) detach_dev(p83);
    			if (detaching) detach_dev(t556);
    			if (detaching) detach_dev(h27);
    			if (detaching) detach_dev(t558);
    			if (detaching) detach_dev(p84);
    			if (detaching) detach_dev(t561);
    			if (detaching) detach_dev(d_math326);
    			if (detaching) detach_dev(t562);
    			if (detaching) detach_dev(p85);
    			if (detaching) detach_dev(t565);
    			if (detaching) detach_dev(d_math328);
    			if (detaching) detach_dev(t566);
    			if (detaching) detach_dev(p86);
    			if (detaching) detach_dev(t568);
    			if (detaching) detach_dev(d_math329);
    			if (detaching) detach_dev(t569);
    			if (detaching) detach_dev(p87);
    			if (detaching) detach_dev(t571);
    			if (detaching) detach_dev(d_math330);
    			if (detaching) detach_dev(t572);
    			if (detaching) detach_dev(p88);
    			if (detaching) detach_dev(t577);
    			if (detaching) detach_dev(d_math334);
    			if (detaching) detach_dev(t578);
    			if (detaching) detach_dev(p89);
    			if (detaching) detach_dev(t580);
    			if (detaching) detach_dev(d_math335);
    			if (detaching) detach_dev(t581);
    			if (detaching) detach_dev(p90);
    			if (detaching) detach_dev(t583);
    			if (detaching) detach_dev(d_math336);
    			if (detaching) detach_dev(t584);
    			if (detaching) detach_dev(p91);
    			if (detaching) detach_dev(t590);
    			if (detaching) detach_dev(h13);
    			if (detaching) detach_dev(t592);
    			if (detaching) detach_dev(p92);
    			if (detaching) detach_dev(t595);
    			if (detaching) detach_dev(p93);
    			if (detaching) detach_dev(t601);
    			if (detaching) detach_dev(p94);
    			if (detaching) detach_dev(t604);
    			if (detaching) detach_dev(ol2);
    			if (detaching) detach_dev(t610);
    			if (detaching) detach_dev(h14);
    			if (detaching) detach_dev(t612);
    			if (detaching) detach_dev(p98);
    			if (detaching) detach_dev(t614);
    			if (detaching) detach_dev(h28);
    			if (detaching) detach_dev(t616);
    			if (detaching) detach_dev(p99);
    			if (detaching) detach_dev(t630);
    			if (detaching) detach_dev(h29);
    			if (detaching) detach_dev(t632);
    			if (detaching) detach_dev(p100);
    			if (detaching) detach_dev(t635);
    			if (detaching) detach_dev(h210);
    			if (detaching) detach_dev(t637);
    			if (detaching) detach_dev(p101);
    			if (detaching) detach_dev(t639);
    			if (detaching) detach_dev(p102);
    			if (detaching) detach_dev(t650);
    			if (detaching) detach_dev(p103);
    			if (detaching) detach_dev(t666);
    			if (detaching) detach_dev(p104);
    			if (detaching) detach_dev(t673);
    			if (detaching) detach_dev(h211);
    			if (detaching) detach_dev(t675);
    			if (detaching) detach_dev(p105);
    			if (detaching) detach_dev(t688);
    			if (detaching) detach_dev(h212);
    			if (detaching) detach_dev(t690);
    			if (detaching) detach_dev(p106);
    			if (detaching) detach_dev(t692);
    			if (detaching) detach_dev(h213);
    			if (detaching) detach_dev(t694);
    			if (detaching) detach_dev(h214);
    			if (detaching) detach_dev(t696);
    			if (detaching) detach_dev(h215);
    			if (detaching) detach_dev(t698);
    			if (detaching) detach_dev(p107);
    			if (detaching) detach_dev(t700);
    			if (detaching) detach_dev(h216);
    			if (detaching) detach_dev(t702);
    			if (detaching) detach_dev(p108);
    			if (detaching) detach_dev(t704);
    			if (detaching) detach_dev(p109);
    			if (detaching) detach_dev(t705);
    			if (detaching) detach_dev(p110);
    			if (detaching) detach_dev(t708);
    			if (detaching) detach_dev(h217);
    			if (detaching) detach_dev(t710);
    			if (detaching) detach_dev(p111);
    			if (detaching) detach_dev(t718);
    			if (detaching) detach_dev(table);
    			if (detaching) detach_dev(t733);
    			if (detaching) detach_dev(p112);
    			if (detaching) detach_dev(t735);
    			if (detaching) detach_dev(d_math392);
    			if (detaching) detach_dev(t736);
    			if (detaching) detach_dev(p113);
    			if (detaching) detach_dev(t739);
    			if (detaching) detach_dev(p114);
    			if (detaching) detach_dev(t740);
    			if (detaching) detach_dev(p115);
    			if (detaching) detach_dev(t742);
    			if (detaching) detach_dev(h218);
    			if (detaching) detach_dev(t744);
    			if (detaching) detach_dev(p116);
    			if (detaching) detach_dev(t747);
    			if (detaching) detach_dev(h219);
    			if (detaching) detach_dev(t749);
    			if (detaching) detach_dev(p117);
    			if (detaching) detach_dev(t761);
    			if (detaching) detach_dev(p118);
    			if (detaching) detach_dev(t765);
    			if (detaching) detach_dev(p119);
    			if (detaching) detach_dev(t773);
    			if (detaching) detach_dev(p120);
    			if (detaching) detach_dev(t778);
    			if (detaching) detach_dev(d_math412);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Kernel_methods', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Kernel_methods> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Kernel_methods extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Kernel_methods",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$5) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$5) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$5;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const toString$1 = Object.prototype.toString;

    function isAnyArray(object) {
      return toString$1.call(object).endsWith('Array]');
    }

    function max$4(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isAnyArray(input)) {
        throw new TypeError('input must be an array');
      }

      if (input.length === 0) {
        throw new TypeError('input must not be empty');
      }

      var _options$fromIndex = options.fromIndex,
          fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
          _options$toIndex = options.toIndex,
          toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

      if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error('fromIndex must be a positive integer smaller than length');
      }

      if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
      }

      var maxValue = input[fromIndex];

      for (var i = fromIndex + 1; i < toIndex; i++) {
        if (input[i] > maxValue) maxValue = input[i];
      }

      return maxValue;
    }

    function min$3(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isAnyArray(input)) {
        throw new TypeError('input must be an array');
      }

      if (input.length === 0) {
        throw new TypeError('input must not be empty');
      }

      var _options$fromIndex = options.fromIndex,
          fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
          _options$toIndex = options.toIndex,
          toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

      if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error('fromIndex must be a positive integer smaller than length');
      }

      if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
      }

      var minValue = input[fromIndex];

      for (var i = fromIndex + 1; i < toIndex; i++) {
        if (input[i] < minValue) minValue = input[i];
      }

      return minValue;
    }

    function rescale(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isAnyArray(input)) {
        throw new TypeError('input must be an array');
      } else if (input.length === 0) {
        throw new TypeError('input must not be empty');
      }

      var output;

      if (options.output !== undefined) {
        if (!isAnyArray(options.output)) {
          throw new TypeError('output option must be an array if specified');
        }

        output = options.output;
      } else {
        output = new Array(input.length);
      }

      var currentMin = min$3(input);
      var currentMax = max$4(input);

      if (currentMin === currentMax) {
        throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
      }

      var _options$min = options.min,
          minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,
          _options$max = options.max,
          maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;

      if (minValue >= maxValue) {
        throw new RangeError('min option must be smaller than max option');
      }

      var factor = (maxValue - minValue) / (currentMax - currentMin);

      for (var i = 0; i < input.length; i++) {
        output[i] = (input[i] - currentMin) * factor + minValue;
      }

      return output;
    }

    /**
     * @class LuDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs
     * @param {Matrix} matrix
     */
    class LuDecomposition {
      constructor(matrix) {
        matrix = WrapperMatrix2D.checkMatrix(matrix);

        var lu = matrix.clone();
        var rows = lu.rows;
        var columns = lu.columns;
        var pivotVector = new Array(rows);
        var pivotSign = 1;
        var i, j, k, p, s, t, v;
        var LUcolj, kmax;

        for (i = 0; i < rows; i++) {
          pivotVector[i] = i;
        }

        LUcolj = new Array(rows);

        for (j = 0; j < columns; j++) {
          for (i = 0; i < rows; i++) {
            LUcolj[i] = lu.get(i, j);
          }

          for (i = 0; i < rows; i++) {
            kmax = Math.min(i, j);
            s = 0;
            for (k = 0; k < kmax; k++) {
              s += lu.get(i, k) * LUcolj[k];
            }
            LUcolj[i] -= s;
            lu.set(i, j, LUcolj[i]);
          }

          p = j;
          for (i = j + 1; i < rows; i++) {
            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
              p = i;
            }
          }

          if (p !== j) {
            for (k = 0; k < columns; k++) {
              t = lu.get(p, k);
              lu.set(p, k, lu.get(j, k));
              lu.set(j, k, t);
            }

            v = pivotVector[p];
            pivotVector[p] = pivotVector[j];
            pivotVector[j] = v;

            pivotSign = -pivotSign;
          }

          if (j < rows && lu.get(j, j) !== 0) {
            for (i = j + 1; i < rows; i++) {
              lu.set(i, j, lu.get(i, j) / lu.get(j, j));
            }
          }
        }

        this.LU = lu;
        this.pivotVector = pivotVector;
        this.pivotSign = pivotSign;
      }

      /**
       *
       * @return {boolean}
       */
      isSingular() {
        var data = this.LU;
        var col = data.columns;
        for (var j = 0; j < col; j++) {
          if (data[j][j] === 0) {
            return true;
          }
        }
        return false;
      }

      /**
       *
       * @param {Matrix} value
       * @return {Matrix}
       */
      solve(value) {
        value = Matrix.checkMatrix(value);

        var lu = this.LU;
        var rows = lu.rows;

        if (rows !== value.rows) {
          throw new Error('Invalid matrix dimensions');
        }
        if (this.isSingular()) {
          throw new Error('LU matrix is singular');
        }

        var count = value.columns;
        var X = value.subMatrixRow(this.pivotVector, 0, count - 1);
        var columns = lu.columns;
        var i, j, k;

        for (k = 0; k < columns; k++) {
          for (i = k + 1; i < columns; i++) {
            for (j = 0; j < count; j++) {
              X[i][j] -= X[k][j] * lu[i][k];
            }
          }
        }
        for (k = columns - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            X[k][j] /= lu[k][k];
          }
          for (i = 0; i < k; i++) {
            for (j = 0; j < count; j++) {
              X[i][j] -= X[k][j] * lu[i][k];
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {number}
       */
      get determinant() {
        var data = this.LU;
        if (!data.isSquare()) {
          throw new Error('Matrix must be square');
        }
        var determinant = this.pivotSign;
        var col = data.columns;
        for (var j = 0; j < col; j++) {
          determinant *= data[j][j];
        }
        return determinant;
      }

      /**
       *
       * @return {Matrix}
       */
      get lowerTriangularMatrix() {
        var data = this.LU;
        var rows = data.rows;
        var columns = data.columns;
        var X = new Matrix(rows, columns);
        for (var i = 0; i < rows; i++) {
          for (var j = 0; j < columns; j++) {
            if (i > j) {
              X[i][j] = data[i][j];
            } else if (i === j) {
              X[i][j] = 1;
            } else {
              X[i][j] = 0;
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {Matrix}
       */
      get upperTriangularMatrix() {
        var data = this.LU;
        var rows = data.rows;
        var columns = data.columns;
        var X = new Matrix(rows, columns);
        for (var i = 0; i < rows; i++) {
          for (var j = 0; j < columns; j++) {
            if (i <= j) {
              X[i][j] = data[i][j];
            } else {
              X[i][j] = 0;
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {Array<number>}
       */
      get pivotPermutationVector() {
        return this.pivotVector.slice();
      }
    }

    function hypotenuse(a, b) {
      var r = 0;
      if (Math.abs(a) > Math.abs(b)) {
        r = b / a;
        return Math.abs(a) * Math.sqrt(1 + r * r);
      }
      if (b !== 0) {
        r = a / b;
        return Math.abs(b) * Math.sqrt(1 + r * r);
      }
      return 0;
    }

    function getFilled2DArray(rows, columns, value) {
      var array = new Array(rows);
      for (var i = 0; i < rows; i++) {
        array[i] = new Array(columns);
        for (var j = 0; j < columns; j++) {
          array[i][j] = value;
        }
      }
      return array;
    }

    /**
     * @class SingularValueDecomposition
     * @see https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs
     * @param {Matrix} value
     * @param {object} [options]
     * @param {boolean} [options.computeLeftSingularVectors=true]
     * @param {boolean} [options.computeRightSingularVectors=true]
     * @param {boolean} [options.autoTranspose=false]
     */
    class SingularValueDecomposition {
      constructor(value, options = {}) {
        value = WrapperMatrix2D.checkMatrix(value);

        var m = value.rows;
        var n = value.columns;

        const {
          computeLeftSingularVectors = true,
          computeRightSingularVectors = true,
          autoTranspose = false
        } = options;

        var wantu = Boolean(computeLeftSingularVectors);
        var wantv = Boolean(computeRightSingularVectors);

        var swapped = false;
        var a;
        if (m < n) {
          if (!autoTranspose) {
            a = value.clone();
            // eslint-disable-next-line no-console
            console.warn(
              'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose'
            );
          } else {
            a = value.transpose();
            m = a.rows;
            n = a.columns;
            swapped = true;
            var aux = wantu;
            wantu = wantv;
            wantv = aux;
          }
        } else {
          a = value.clone();
        }

        var nu = Math.min(m, n);
        var ni = Math.min(m + 1, n);
        var s = new Array(ni);
        var U = getFilled2DArray(m, nu, 0);
        var V = getFilled2DArray(n, n, 0);

        var e = new Array(n);
        var work = new Array(m);

        var si = new Array(ni);
        for (let i = 0; i < ni; i++) si[i] = i;

        var nct = Math.min(m - 1, n);
        var nrt = Math.max(0, Math.min(n - 2, m));
        var mrc = Math.max(nct, nrt);

        for (let k = 0; k < mrc; k++) {
          if (k < nct) {
            s[k] = 0;
            for (let i = k; i < m; i++) {
              s[k] = hypotenuse(s[k], a[i][k]);
            }
            if (s[k] !== 0) {
              if (a[k][k] < 0) {
                s[k] = -s[k];
              }
              for (let i = k; i < m; i++) {
                a[i][k] /= s[k];
              }
              a[k][k] += 1;
            }
            s[k] = -s[k];
          }

          for (let j = k + 1; j < n; j++) {
            if (k < nct && s[k] !== 0) {
              let t = 0;
              for (let i = k; i < m; i++) {
                t += a[i][k] * a[i][j];
              }
              t = -t / a[k][k];
              for (let i = k; i < m; i++) {
                a[i][j] += t * a[i][k];
              }
            }
            e[j] = a[k][j];
          }

          if (wantu && k < nct) {
            for (let i = k; i < m; i++) {
              U[i][k] = a[i][k];
            }
          }

          if (k < nrt) {
            e[k] = 0;
            for (let i = k + 1; i < n; i++) {
              e[k] = hypotenuse(e[k], e[i]);
            }
            if (e[k] !== 0) {
              if (e[k + 1] < 0) {
                e[k] = 0 - e[k];
              }
              for (let i = k + 1; i < n; i++) {
                e[i] /= e[k];
              }
              e[k + 1] += 1;
            }
            e[k] = -e[k];
            if (k + 1 < m && e[k] !== 0) {
              for (let i = k + 1; i < m; i++) {
                work[i] = 0;
              }
              for (let i = k + 1; i < m; i++) {
                for (let j = k + 1; j < n; j++) {
                  work[i] += e[j] * a[i][j];
                }
              }
              for (let j = k + 1; j < n; j++) {
                let t = -e[j] / e[k + 1];
                for (let i = k + 1; i < m; i++) {
                  a[i][j] += t * work[i];
                }
              }
            }
            if (wantv) {
              for (let i = k + 1; i < n; i++) {
                V[i][k] = e[i];
              }
            }
          }
        }

        let p = Math.min(n, m + 1);
        if (nct < n) {
          s[nct] = a[nct][nct];
        }
        if (m < p) {
          s[p - 1] = 0;
        }
        if (nrt + 1 < p) {
          e[nrt] = a[nrt][p - 1];
        }
        e[p - 1] = 0;

        if (wantu) {
          for (let j = nct; j < nu; j++) {
            for (let i = 0; i < m; i++) {
              U[i][j] = 0;
            }
            U[j][j] = 1;
          }
          for (let k = nct - 1; k >= 0; k--) {
            if (s[k] !== 0) {
              for (let j = k + 1; j < nu; j++) {
                let t = 0;
                for (let i = k; i < m; i++) {
                  t += U[i][k] * U[i][j];
                }
                t = -t / U[k][k];
                for (let i = k; i < m; i++) {
                  U[i][j] += t * U[i][k];
                }
              }
              for (let i = k; i < m; i++) {
                U[i][k] = -U[i][k];
              }
              U[k][k] = 1 + U[k][k];
              for (let i = 0; i < k - 1; i++) {
                U[i][k] = 0;
              }
            } else {
              for (let i = 0; i < m; i++) {
                U[i][k] = 0;
              }
              U[k][k] = 1;
            }
          }
        }

        if (wantv) {
          for (let k = n - 1; k >= 0; k--) {
            if (k < nrt && e[k] !== 0) {
              for (let j = k + 1; j < n; j++) {
                let t = 0;
                for (let i = k + 1; i < n; i++) {
                  t += V[i][k] * V[i][j];
                }
                t = -t / V[k + 1][k];
                for (let i = k + 1; i < n; i++) {
                  V[i][j] += t * V[i][k];
                }
              }
            }
            for (let i = 0; i < n; i++) {
              V[i][k] = 0;
            }
            V[k][k] = 1;
          }
        }

        var pp = p - 1;
        var eps = Number.EPSILON;
        while (p > 0) {
          let k, kase;
          for (k = p - 2; k >= -1; k--) {
            if (k === -1) {
              break;
            }
            const alpha =
              Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
            if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
              e[k] = 0;
              break;
            }
          }
          if (k === p - 2) {
            kase = 4;
          } else {
            let ks;
            for (ks = p - 1; ks >= k; ks--) {
              if (ks === k) {
                break;
              }
              let t =
                (ks !== p ? Math.abs(e[ks]) : 0) +
                (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
              if (Math.abs(s[ks]) <= eps * t) {
                s[ks] = 0;
                break;
              }
            }
            if (ks === k) {
              kase = 3;
            } else if (ks === p - 1) {
              kase = 1;
            } else {
              kase = 2;
              k = ks;
            }
          }

          k++;

          switch (kase) {
            case 1: {
              let f = e[p - 2];
              e[p - 2] = 0;
              for (let j = p - 2; j >= k; j--) {
                let t = hypotenuse(s[j], f);
                let cs = s[j] / t;
                let sn = f / t;
                s[j] = t;
                if (j !== k) {
                  f = -sn * e[j - 1];
                  e[j - 1] = cs * e[j - 1];
                }
                if (wantv) {
                  for (let i = 0; i < n; i++) {
                    t = cs * V[i][j] + sn * V[i][p - 1];
                    V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
                    V[i][j] = t;
                  }
                }
              }
              break;
            }
            case 2: {
              let f = e[k - 1];
              e[k - 1] = 0;
              for (let j = k; j < p; j++) {
                let t = hypotenuse(s[j], f);
                let cs = s[j] / t;
                let sn = f / t;
                s[j] = t;
                f = -sn * e[j];
                e[j] = cs * e[j];
                if (wantu) {
                  for (let i = 0; i < m; i++) {
                    t = cs * U[i][j] + sn * U[i][k - 1];
                    U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
                    U[i][j] = t;
                  }
                }
              }
              break;
            }
            case 3: {
              const scale = Math.max(
                Math.abs(s[p - 1]),
                Math.abs(s[p - 2]),
                Math.abs(e[p - 2]),
                Math.abs(s[k]),
                Math.abs(e[k])
              );
              const sp = s[p - 1] / scale;
              const spm1 = s[p - 2] / scale;
              const epm1 = e[p - 2] / scale;
              const sk = s[k] / scale;
              const ek = e[k] / scale;
              const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
              const c = sp * epm1 * (sp * epm1);
              let shift = 0;
              if (b !== 0 || c !== 0) {
                if (b < 0) {
                  shift = 0 - Math.sqrt(b * b + c);
                } else {
                  shift = Math.sqrt(b * b + c);
                }
                shift = c / (b + shift);
              }
              let f = (sk + sp) * (sk - sp) + shift;
              let g = sk * ek;
              for (let j = k; j < p - 1; j++) {
                let t = hypotenuse(f, g);
                if (t === 0) t = Number.MIN_VALUE;
                let cs = f / t;
                let sn = g / t;
                if (j !== k) {
                  e[j - 1] = t;
                }
                f = cs * s[j] + sn * e[j];
                e[j] = cs * e[j] - sn * s[j];
                g = sn * s[j + 1];
                s[j + 1] = cs * s[j + 1];
                if (wantv) {
                  for (let i = 0; i < n; i++) {
                    t = cs * V[i][j] + sn * V[i][j + 1];
                    V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
                    V[i][j] = t;
                  }
                }
                t = hypotenuse(f, g);
                if (t === 0) t = Number.MIN_VALUE;
                cs = f / t;
                sn = g / t;
                s[j] = t;
                f = cs * e[j] + sn * s[j + 1];
                s[j + 1] = -sn * e[j] + cs * s[j + 1];
                g = sn * e[j + 1];
                e[j + 1] = cs * e[j + 1];
                if (wantu && j < m - 1) {
                  for (let i = 0; i < m; i++) {
                    t = cs * U[i][j] + sn * U[i][j + 1];
                    U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
                    U[i][j] = t;
                  }
                }
              }
              e[p - 2] = f;
              break;
            }
            case 4: {
              if (s[k] <= 0) {
                s[k] = s[k] < 0 ? -s[k] : 0;
                if (wantv) {
                  for (let i = 0; i <= pp; i++) {
                    V[i][k] = -V[i][k];
                  }
                }
              }
              while (k < pp) {
                if (s[k] >= s[k + 1]) {
                  break;
                }
                let t = s[k];
                s[k] = s[k + 1];
                s[k + 1] = t;
                if (wantv && k < n - 1) {
                  for (let i = 0; i < n; i++) {
                    t = V[i][k + 1];
                    V[i][k + 1] = V[i][k];
                    V[i][k] = t;
                  }
                }
                if (wantu && k < m - 1) {
                  for (let i = 0; i < m; i++) {
                    t = U[i][k + 1];
                    U[i][k + 1] = U[i][k];
                    U[i][k] = t;
                  }
                }
                k++;
              }
              p--;
              break;
            }
            // no default
          }
        }

        if (swapped) {
          var tmp = V;
          V = U;
          U = tmp;
        }

        this.m = m;
        this.n = n;
        this.s = s;
        this.U = U;
        this.V = V;
      }

      /**
       * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).
       * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
       * var svd = SingularValueDecomposition(A);
       * var x = svd.solve(b);
       * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
       * @return {Matrix} - The vector x
       */
      solve(value) {
        var Y = value;
        var e = this.threshold;
        var scols = this.s.length;
        var Ls = Matrix.zeros(scols, scols);

        for (let i = 0; i < scols; i++) {
          if (Math.abs(this.s[i]) <= e) {
            Ls[i][i] = 0;
          } else {
            Ls[i][i] = 1 / this.s[i];
          }
        }

        var U = this.U;
        var V = this.rightSingularVectors;

        var VL = V.mmul(Ls);
        var vrows = V.rows;
        var urows = U.length;
        var VLU = Matrix.zeros(vrows, urows);

        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < urows; j++) {
            let sum = 0;
            for (let k = 0; k < scols; k++) {
              sum += VL[i][k] * U[j][k];
            }
            VLU[i][j] = sum;
          }
        }

        return VLU.mmul(Y);
      }

      /**
       *
       * @param {Array<number>} value
       * @return {Matrix}
       */
      solveForDiagonal(value) {
        return this.solve(Matrix.diag(value));
      }

      /**
       * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :
       * var svd = SingularValueDecomposition(A);
       * var inverseA = svd.inverse();
       * @return {Matrix} - The approximation of the inverse of the matrix
       */
      inverse() {
        var V = this.V;
        var e = this.threshold;
        var vrows = V.length;
        var vcols = V[0].length;
        var X = new Matrix(vrows, this.s.length);

        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < vcols; j++) {
            if (Math.abs(this.s[j]) > e) {
              X[i][j] = V[i][j] / this.s[j];
            } else {
              X[i][j] = 0;
            }
          }
        }

        var U = this.U;

        var urows = U.length;
        var ucols = U[0].length;
        var Y = new Matrix(vrows, urows);

        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < urows; j++) {
            let sum = 0;
            for (let k = 0; k < ucols; k++) {
              sum += X[i][k] * U[j][k];
            }
            Y[i][j] = sum;
          }
        }

        return Y;
      }

      /**
       *
       * @return {number}
       */
      get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
      }

      /**
       *
       * @return {number}
       */
      get norm2() {
        return this.s[0];
      }

      /**
       *
       * @return {number}
       */
      get rank() {
        var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
        var r = 0;
        var s = this.s;
        for (var i = 0, ii = s.length; i < ii; i++) {
          if (s[i] > tol) {
            r++;
          }
        }
        return r;
      }

      /**
       *
       * @return {Array<number>}
       */
      get diagonal() {
        return this.s;
      }

      /**
       *
       * @return {number}
       */
      get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
      }

      /**
       *
       * @return {Matrix}
       */
      get leftSingularVectors() {
        if (!Matrix.isMatrix(this.U)) {
          this.U = new Matrix(this.U);
        }
        return this.U;
      }

      /**
       *
       * @return {Matrix}
       */
      get rightSingularVectors() {
        if (!Matrix.isMatrix(this.V)) {
          this.V = new Matrix(this.V);
        }
        return this.V;
      }

      /**
       *
       * @return {Matrix}
       */
      get diagonalMatrix() {
        return Matrix.diag(this.s);
      }
    }

    /**
     * @private
     * Check that a row index is not out of bounds
     * @param {Matrix} matrix
     * @param {number} index
     * @param {boolean} [outer]
     */
    function checkRowIndex(matrix, index, outer) {
      var max = outer ? matrix.rows : matrix.rows - 1;
      if (index < 0 || index > max) {
        throw new RangeError('Row index out of range');
      }
    }

    /**
     * @private
     * Check that a column index is not out of bounds
     * @param {Matrix} matrix
     * @param {number} index
     * @param {boolean} [outer]
     */
    function checkColumnIndex(matrix, index, outer) {
      var max = outer ? matrix.columns : matrix.columns - 1;
      if (index < 0 || index > max) {
        throw new RangeError('Column index out of range');
      }
    }

    /**
     * @private
     * Check that the provided vector is an array with the right length
     * @param {Matrix} matrix
     * @param {Array|Matrix} vector
     * @return {Array}
     * @throws {RangeError}
     */
    function checkRowVector(matrix, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix.columns) {
        throw new RangeError(
          'vector size must be the same as the number of columns'
        );
      }
      return vector;
    }

    /**
     * @private
     * Check that the provided vector is an array with the right length
     * @param {Matrix} matrix
     * @param {Array|Matrix} vector
     * @return {Array}
     * @throws {RangeError}
     */
    function checkColumnVector(matrix, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix.rows) {
        throw new RangeError('vector size must be the same as the number of rows');
      }
      return vector;
    }

    function checkIndices(matrix, rowIndices, columnIndices) {
      return {
        row: checkRowIndices(matrix, rowIndices),
        column: checkColumnIndices(matrix, columnIndices)
      };
    }

    function checkRowIndices(matrix, rowIndices) {
      if (typeof rowIndices !== 'object') {
        throw new TypeError('unexpected type for row indices');
      }

      var rowOut = rowIndices.some((r) => {
        return r < 0 || r >= matrix.rows;
      });

      if (rowOut) {
        throw new RangeError('row indices are out of range');
      }

      if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

      return rowIndices;
    }

    function checkColumnIndices(matrix, columnIndices) {
      if (typeof columnIndices !== 'object') {
        throw new TypeError('unexpected type for column indices');
      }

      var columnOut = columnIndices.some((c) => {
        return c < 0 || c >= matrix.columns;
      });

      if (columnOut) {
        throw new RangeError('column indices are out of range');
      }
      if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

      return columnIndices;
    }

    function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
      if (arguments.length !== 5) {
        throw new RangeError('expected 4 arguments');
      }
      checkNumber('startRow', startRow);
      checkNumber('endRow', endRow);
      checkNumber('startColumn', startColumn);
      checkNumber('endColumn', endColumn);
      if (
        startRow > endRow ||
        startColumn > endColumn ||
        startRow < 0 ||
        startRow >= matrix.rows ||
        endRow < 0 ||
        endRow >= matrix.rows ||
        startColumn < 0 ||
        startColumn >= matrix.columns ||
        endColumn < 0 ||
        endColumn >= matrix.columns
      ) {
        throw new RangeError('Submatrix indices are out of range');
      }
    }

    function sumByRow(matrix) {
      var sum = Matrix.zeros(matrix.rows, 1);
      for (var i = 0; i < matrix.rows; ++i) {
        for (var j = 0; j < matrix.columns; ++j) {
          sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));
        }
      }
      return sum;
    }

    function sumByColumn(matrix) {
      var sum = Matrix.zeros(1, matrix.columns);
      for (var i = 0; i < matrix.rows; ++i) {
        for (var j = 0; j < matrix.columns; ++j) {
          sum.set(0, j, sum.get(0, j) + matrix.get(i, j));
        }
      }
      return sum;
    }

    function sumAll(matrix) {
      var v = 0;
      for (var i = 0; i < matrix.rows; i++) {
        for (var j = 0; j < matrix.columns; j++) {
          v += matrix.get(i, j);
        }
      }
      return v;
    }

    function checkNumber(name, value) {
      if (typeof value !== 'number') {
        throw new TypeError(`${name} must be a number`);
      }
    }

    class BaseView extends AbstractMatrix() {
      constructor(matrix, rows, columns) {
        super();
        this.matrix = matrix;
        this.rows = rows;
        this.columns = columns;
      }

      static get [Symbol.species]() {
        return Matrix;
      }
    }

    class MatrixTransposeView extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.columns, matrix.rows);
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(columnIndex, rowIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(columnIndex, rowIndex);
      }
    }

    class MatrixRowView extends BaseView {
      constructor(matrix, row) {
        super(matrix, 1, matrix.columns);
        this.row = row;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.row, columnIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(this.row, columnIndex);
      }
    }

    class MatrixSubView extends BaseView {
      constructor(matrix, startRow, endRow, startColumn, endColumn) {
        checkRange(matrix, startRow, endRow, startColumn, endColumn);
        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
        this.startRow = startRow;
        this.startColumn = startColumn;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.startRow + rowIndex,
          this.startColumn + columnIndex,
          value
        );
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.startRow + rowIndex,
          this.startColumn + columnIndex
        );
      }
    }

    class MatrixSelectionView extends BaseView {
      constructor(matrix, rowIndices, columnIndices) {
        var indices = checkIndices(matrix, rowIndices, columnIndices);
        super(matrix, indices.row.length, indices.column.length);
        this.rowIndices = indices.row;
        this.columnIndices = indices.column;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex],
          value
        );
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex]
        );
      }
    }

    class MatrixRowSelectionView extends BaseView {
      constructor(matrix, rowIndices) {
        rowIndices = checkRowIndices(matrix, rowIndices);
        super(matrix, rowIndices.length, matrix.columns);
        this.rowIndices = rowIndices;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
      }
    }

    class MatrixColumnSelectionView extends BaseView {
      constructor(matrix, columnIndices) {
        columnIndices = checkColumnIndices(matrix, columnIndices);
        super(matrix, matrix.rows, columnIndices.length);
        this.columnIndices = columnIndices;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
      }
    }

    class MatrixColumnView extends BaseView {
      constructor(matrix, column) {
        super(matrix, matrix.rows, 1);
        this.column = column;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.column, value);
        return this;
      }

      get(rowIndex) {
        return this.matrix.get(rowIndex, this.column);
      }
    }

    class MatrixFlipRowView extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
      }
    }

    class MatrixFlipColumnView extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
      }
    }

    function AbstractMatrix(superCtor) {
      if (superCtor === undefined) superCtor = Object;

      /**
       * Real matrix
       * @class Matrix
       * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,
       * 2D array containing the data or Matrix instance to clone
       * @param {number} [nColumns] - Number of columns of the new matrix
       */
      class Matrix extends superCtor {
        static get [Symbol.species]() {
          return this;
        }

        /**
         * Constructs a Matrix with the chosen dimensions from a 1D array
         * @param {number} newRows - Number of rows
         * @param {number} newColumns - Number of columns
         * @param {Array} newData - A 1D array containing data for the matrix
         * @return {Matrix} - The new matrix
         */
        static from1DArray(newRows, newColumns, newData) {
          var length = newRows * newColumns;
          if (length !== newData.length) {
            throw new RangeError('Data length does not match given dimensions');
          }
          var newMatrix = new this(newRows, newColumns);
          for (var row = 0; row < newRows; row++) {
            for (var column = 0; column < newColumns; column++) {
              newMatrix.set(row, column, newData[row * newColumns + column]);
            }
          }
          return newMatrix;
        }

        /**
             * Creates a row vector, a matrix with only one row.
             * @param {Array} newData - A 1D array containing data for the vector
             * @return {Matrix} - The new matrix
             */
        static rowVector(newData) {
          var vector = new this(1, newData.length);
          for (var i = 0; i < newData.length; i++) {
            vector.set(0, i, newData[i]);
          }
          return vector;
        }

        /**
             * Creates a column vector, a matrix with only one column.
             * @param {Array} newData - A 1D array containing data for the vector
             * @return {Matrix} - The new matrix
             */
        static columnVector(newData) {
          var vector = new this(newData.length, 1);
          for (var i = 0; i < newData.length; i++) {
            vector.set(i, 0, newData[i]);
          }
          return vector;
        }

        /**
             * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @return {Matrix} - The new matrix
             */
        static empty(rows, columns) {
          return new this(rows, columns);
        }

        /**
             * Creates a matrix with the given dimensions. Values will be set to zero.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @return {Matrix} - The new matrix
             */
        static zeros(rows, columns) {
          return this.empty(rows, columns).fill(0);
        }

        /**
             * Creates a matrix with the given dimensions. Values will be set to one.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @return {Matrix} - The new matrix
             */
        static ones(rows, columns) {
          return this.empty(rows, columns).fill(1);
        }

        /**
             * Creates a matrix with the given dimensions. Values will be randomly set.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @param {function} [rng=Math.random] - Random number generator
             * @return {Matrix} The new matrix
             */
        static rand(rows, columns, rng) {
          if (rng === undefined) rng = Math.random;
          var matrix = this.empty(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              matrix.set(i, j, rng());
            }
          }
          return matrix;
        }

        /**
             * Creates a matrix with the given dimensions. Values will be random integers.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @param {number} [maxValue=1000] - Maximum value
             * @param {function} [rng=Math.random] - Random number generator
             * @return {Matrix} The new matrix
             */
        static randInt(rows, columns, maxValue, rng) {
          if (maxValue === undefined) maxValue = 1000;
          if (rng === undefined) rng = Math.random;
          var matrix = this.empty(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              var value = Math.floor(rng() * maxValue);
              matrix.set(i, j, value);
            }
          }
          return matrix;
        }

        /**
             * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.
             * @param {number} rows - Number of rows
             * @param {number} [columns=rows] - Number of columns
             * @param {number} [value=1] - Value to fill the diagonal with
             * @return {Matrix} - The new identity matrix
             */
        static eye(rows, columns, value) {
          if (columns === undefined) columns = rows;
          if (value === undefined) value = 1;
          var min = Math.min(rows, columns);
          var matrix = this.zeros(rows, columns);
          for (var i = 0; i < min; i++) {
            matrix.set(i, i, value);
          }
          return matrix;
        }

        /**
             * Creates a diagonal matrix based on the given array.
             * @param {Array} data - Array containing the data for the diagonal
             * @param {number} [rows] - Number of rows (Default: data.length)
             * @param {number} [columns] - Number of columns (Default: rows)
             * @return {Matrix} - The new diagonal matrix
             */
        static diag(data, rows, columns) {
          var l = data.length;
          if (rows === undefined) rows = l;
          if (columns === undefined) columns = rows;
          var min = Math.min(l, rows, columns);
          var matrix = this.zeros(rows, columns);
          for (var i = 0; i < min; i++) {
            matrix.set(i, i, data[i]);
          }
          return matrix;
        }

        /**
             * Returns a matrix whose elements are the minimum between matrix1 and matrix2
             * @param {Matrix} matrix1
             * @param {Matrix} matrix2
             * @return {Matrix}
             */
        static min(matrix1, matrix2) {
          matrix1 = this.checkMatrix(matrix1);
          matrix2 = this.checkMatrix(matrix2);
          var rows = matrix1.rows;
          var columns = matrix1.columns;
          var result = new this(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
            }
          }
          return result;
        }

        /**
             * Returns a matrix whose elements are the maximum between matrix1 and matrix2
             * @param {Matrix} matrix1
             * @param {Matrix} matrix2
             * @return {Matrix}
             */
        static max(matrix1, matrix2) {
          matrix1 = this.checkMatrix(matrix1);
          matrix2 = this.checkMatrix(matrix2);
          var rows = matrix1.rows;
          var columns = matrix1.columns;
          var result = new this(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
            }
          }
          return result;
        }

        /**
             * Check that the provided value is a Matrix and tries to instantiate one if not
             * @param {*} value - The value to check
             * @return {Matrix}
             */
        static checkMatrix(value) {
          return Matrix.isMatrix(value) ? value : new this(value);
        }

        /**
             * Returns true if the argument is a Matrix, false otherwise
             * @param {*} value - The value to check
             * @return {boolean}
             */
        static isMatrix(value) {
          return (value != null) && (value.klass === 'Matrix');
        }

        /**
             * @prop {number} size - The number of elements in the matrix.
             */
        get size() {
          return this.rows * this.columns;
        }

        /**
             * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.
             * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)
             * @return {Matrix} this
             */
        apply(callback) {
          if (typeof callback !== 'function') {
            throw new TypeError('callback must be a function');
          }
          var ii = this.rows;
          var jj = this.columns;
          for (var i = 0; i < ii; i++) {
            for (var j = 0; j < jj; j++) {
              callback.call(this, i, j);
            }
          }
          return this;
        }

        /**
             * Returns a new 1D array filled row by row with the matrix values
             * @return {Array}
             */
        to1DArray() {
          var array = new Array(this.size);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              array[i * this.columns + j] = this.get(i, j);
            }
          }
          return array;
        }

        /**
             * Returns a 2D array containing a copy of the data
             * @return {Array}
             */
        to2DArray() {
          var copy = new Array(this.rows);
          for (var i = 0; i < this.rows; i++) {
            copy[i] = new Array(this.columns);
            for (var j = 0; j < this.columns; j++) {
              copy[i][j] = this.get(i, j);
            }
          }
          return copy;
        }

        /**
             * @return {boolean} true if the matrix has one row
             */
        isRowVector() {
          return this.rows === 1;
        }

        /**
             * @return {boolean} true if the matrix has one column
             */
        isColumnVector() {
          return this.columns === 1;
        }

        /**
             * @return {boolean} true if the matrix has one row or one column
             */
        isVector() {
          return (this.rows === 1) || (this.columns === 1);
        }

        /**
             * @return {boolean} true if the matrix has the same number of rows and columns
             */
        isSquare() {
          return this.rows === this.columns;
        }

        /**
             * @return {boolean} true if the matrix is square and has the same values on both sides of the diagonal
             */
        isSymmetric() {
          if (this.isSquare()) {
            for (var i = 0; i < this.rows; i++) {
              for (var j = 0; j <= i; j++) {
                if (this.get(i, j) !== this.get(j, i)) {
                  return false;
                }
              }
            }
            return true;
          }
          return false;
        }

        /**
              * @return true if the matrix is in echelon form
              */
        isEchelonForm() {
          let i = 0;
          let j = 0;
          let previousColumn = -1;
          let isEchelonForm = true;
          let checked = false;
          while ((i < this.rows) && (isEchelonForm)) {
            j = 0;
            checked = false;
            while ((j < this.columns) && (checked === false)) {
              if (this.get(i, j) === 0) {
                j++;
              } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
                checked = true;
                previousColumn = j;
              } else {
                isEchelonForm = false;
                checked = true;
              }
            }
            i++;
          }
          return isEchelonForm;
        }

        /**
                 * @return true if the matrix is in reduced echelon form
                 */
        isReducedEchelonForm() {
          let i = 0;
          let j = 0;
          let previousColumn = -1;
          let isReducedEchelonForm = true;
          let checked = false;
          while ((i < this.rows) && (isReducedEchelonForm)) {
            j = 0;
            checked = false;
            while ((j < this.columns) && (checked === false)) {
              if (this.get(i, j) === 0) {
                j++;
              } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
                checked = true;
                previousColumn = j;
              } else {
                isReducedEchelonForm = false;
                checked = true;
              }
            }
            for (let k = j + 1; k < this.rows; k++) {
              if (this.get(i, k) !== 0) {
                isReducedEchelonForm = false;
              }
            }
            i++;
          }
          return isReducedEchelonForm;
        }

        /**
             * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1
             * @abstract
             * @param {number} rowIndex - Index of the row
             * @param {number} columnIndex - Index of the column
             * @param {number} value - The new value for the element
             * @return {Matrix} this
             */
        set(rowIndex, columnIndex, value) { // eslint-disable-line no-unused-vars
          throw new Error('set method is unimplemented');
        }

        /**
             * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]
             * @abstract
             * @param {number} rowIndex - Index of the row
             * @param {number} columnIndex - Index of the column
             * @return {number}
             */
        get(rowIndex, columnIndex) { // eslint-disable-line no-unused-vars
          throw new Error('get method is unimplemented');
        }

        /**
             * Creates a new matrix that is a repetition of the current matrix. New matrix has rowRep times the number of
             * rows of the matrix, and colRep times the number of columns of the matrix
             * @param {number} rowRep - Number of times the rows should be repeated
             * @param {number} colRep - Number of times the columns should be re
             * @return {Matrix}
             * @example
             * var matrix = new Matrix([[1,2]]);
             * matrix.repeat(2); // [[1,2],[1,2]]
             */
        repeat(rowRep, colRep) {
          rowRep = rowRep || 1;
          colRep = colRep || 1;
          var matrix = new this.constructor[Symbol.species](this.rows * rowRep, this.columns * colRep);
          for (var i = 0; i < rowRep; i++) {
            for (var j = 0; j < colRep; j++) {
              matrix.setSubMatrix(this, this.rows * i, this.columns * j);
            }
          }
          return matrix;
        }

        /**
             * Fills the matrix with a given value. All elements will be set to this value.
             * @param {number} value - New value
             * @return {Matrix} this
             */
        fill(value) {
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, value);
            }
          }
          return this;
        }

        /**
             * Negates the matrix. All elements will be multiplied by (-1)
             * @return {Matrix} this
             */
        neg() {
          return this.mulS(-1);
        }

        /**
             * Returns a new array from the given row index
             * @param {number} index - Row index
             * @return {Array}
             */
        getRow(index) {
          checkRowIndex(this, index);
          var row = new Array(this.columns);
          for (var i = 0; i < this.columns; i++) {
            row[i] = this.get(index, i);
          }
          return row;
        }

        /**
             * Returns a new row vector from the given row index
             * @param {number} index - Row index
             * @return {Matrix}
             */
        getRowVector(index) {
          return this.constructor.rowVector(this.getRow(index));
        }

        /**
             * Sets a row at the given index
             * @param {number} index - Row index
             * @param {Array|Matrix} array - Array or vector
             * @return {Matrix} this
             */
        setRow(index, array) {
          checkRowIndex(this, index);
          array = checkRowVector(this, array);
          for (var i = 0; i < this.columns; i++) {
            this.set(index, i, array[i]);
          }
          return this;
        }

        /**
             * Swaps two rows
             * @param {number} row1 - First row index
             * @param {number} row2 - Second row index
             * @return {Matrix} this
             */
        swapRows(row1, row2) {
          checkRowIndex(this, row1);
          checkRowIndex(this, row2);
          for (var i = 0; i < this.columns; i++) {
            var temp = this.get(row1, i);
            this.set(row1, i, this.get(row2, i));
            this.set(row2, i, temp);
          }
          return this;
        }

        /**
             * Returns a new array from the given column index
             * @param {number} index - Column index
             * @return {Array}
             */
        getColumn(index) {
          checkColumnIndex(this, index);
          var column = new Array(this.rows);
          for (var i = 0; i < this.rows; i++) {
            column[i] = this.get(i, index);
          }
          return column;
        }

        /**
             * Returns a new column vector from the given column index
             * @param {number} index - Column index
             * @return {Matrix}
             */
        getColumnVector(index) {
          return this.constructor.columnVector(this.getColumn(index));
        }

        /**
             * Sets a column at the given index
             * @param {number} index - Column index
             * @param {Array|Matrix} array - Array or vector
             * @return {Matrix} this
             */
        setColumn(index, array) {
          checkColumnIndex(this, index);
          array = checkColumnVector(this, array);
          for (var i = 0; i < this.rows; i++) {
            this.set(i, index, array[i]);
          }
          return this;
        }

        /**
             * Swaps two columns
             * @param {number} column1 - First column index
             * @param {number} column2 - Second column index
             * @return {Matrix} this
             */
        swapColumns(column1, column2) {
          checkColumnIndex(this, column1);
          checkColumnIndex(this, column2);
          for (var i = 0; i < this.rows; i++) {
            var temp = this.get(i, column1);
            this.set(i, column1, this.get(i, column2));
            this.set(i, column2, temp);
          }
          return this;
        }

        /**
             * Adds the values of a vector to each row
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        addRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) + vector[j]);
            }
          }
          return this;
        }

        /**
             * Subtracts the values of a vector from each row
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        subRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) - vector[j]);
            }
          }
          return this;
        }

        /**
             * Multiplies the values of a vector with each row
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        mulRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) * vector[j]);
            }
          }
          return this;
        }

        /**
             * Divides the values of each row by those of a vector
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        divRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) / vector[j]);
            }
          }
          return this;
        }

        /**
             * Adds the values of a vector to each column
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        addColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) + vector[i]);
            }
          }
          return this;
        }

        /**
             * Subtracts the values of a vector from each column
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        subColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) - vector[i]);
            }
          }
          return this;
        }

        /**
             * Multiplies the values of a vector with each column
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        mulColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) * vector[i]);
            }
          }
          return this;
        }

        /**
             * Divides the values of each column by those of a vector
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        divColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) / vector[i]);
            }
          }
          return this;
        }

        /**
             * Multiplies the values of a row with a scalar
             * @param {number} index - Row index
             * @param {number} value
             * @return {Matrix} this
             */
        mulRow(index, value) {
          checkRowIndex(this, index);
          for (var i = 0; i < this.columns; i++) {
            this.set(index, i, this.get(index, i) * value);
          }
          return this;
        }

        /**
             * Multiplies the values of a column with a scalar
             * @param {number} index - Column index
             * @param {number} value
             * @return {Matrix} this
             */
        mulColumn(index, value) {
          checkColumnIndex(this, index);
          for (var i = 0; i < this.rows; i++) {
            this.set(i, index, this.get(i, index) * value);
          }
          return this;
        }

        /**
             * Returns the maximum value of the matrix
             * @return {number}
             */
        max() {
          var v = this.get(0, 0);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) > v) {
                v = this.get(i, j);
              }
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value
             * @return {Array}
             */
        maxIndex() {
          var v = this.get(0, 0);
          var idx = [0, 0];
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) > v) {
                v = this.get(i, j);
                idx[0] = i;
                idx[1] = j;
              }
            }
          }
          return idx;
        }

        /**
             * Returns the minimum value of the matrix
             * @return {number}
             */
        min() {
          var v = this.get(0, 0);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) < v) {
                v = this.get(i, j);
              }
            }
          }
          return v;
        }

        /**
             * Returns the index of the minimum value
             * @return {Array}
             */
        minIndex() {
          var v = this.get(0, 0);
          var idx = [0, 0];
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) < v) {
                v = this.get(i, j);
                idx[0] = i;
                idx[1] = j;
              }
            }
          }
          return idx;
        }

        /**
             * Returns the maximum value of one row
             * @param {number} row - Row index
             * @return {number}
             */
        maxRow(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) > v) {
              v = this.get(row, i);
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value of one row
             * @param {number} row - Row index
             * @return {Array}
             */
        maxRowIndex(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          var idx = [row, 0];
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) > v) {
              v = this.get(row, i);
              idx[1] = i;
            }
          }
          return idx;
        }

        /**
             * Returns the minimum value of one row
             * @param {number} row - Row index
             * @return {number}
             */
        minRow(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) < v) {
              v = this.get(row, i);
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value of one row
             * @param {number} row - Row index
             * @return {Array}
             */
        minRowIndex(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          var idx = [row, 0];
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) < v) {
              v = this.get(row, i);
              idx[1] = i;
            }
          }
          return idx;
        }

        /**
             * Returns the maximum value of one column
             * @param {number} column - Column index
             * @return {number}
             */
        maxColumn(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) > v) {
              v = this.get(i, column);
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value of one column
             * @param {number} column - Column index
             * @return {Array}
             */
        maxColumnIndex(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          var idx = [0, column];
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) > v) {
              v = this.get(i, column);
              idx[0] = i;
            }
          }
          return idx;
        }

        /**
             * Returns the minimum value of one column
             * @param {number} column - Column index
             * @return {number}
             */
        minColumn(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) < v) {
              v = this.get(i, column);
            }
          }
          return v;
        }

        /**
             * Returns the index of the minimum value of one column
             * @param {number} column - Column index
             * @return {Array}
             */
        minColumnIndex(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          var idx = [0, column];
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) < v) {
              v = this.get(i, column);
              idx[0] = i;
            }
          }
          return idx;
        }

        /**
             * Returns an array containing the diagonal values of the matrix
             * @return {Array}
             */
        diag() {
          var min = Math.min(this.rows, this.columns);
          var diag = new Array(min);
          for (var i = 0; i < min; i++) {
            diag[i] = this.get(i, i);
          }
          return diag;
        }

        /**
             * Returns the sum by the argument given, if no argument given,
             * it returns the sum of all elements of the matrix.
             * @param {string} by - sum by 'row' or 'column'.
             * @return {Matrix|number}
             */
        sum(by) {
          switch (by) {
            case 'row':
              return sumByRow(this);
            case 'column':
              return sumByColumn(this);
            default:
              return sumAll(this);
          }
        }

        /**
             * Returns the mean of all elements of the matrix
             * @return {number}
             */
        mean() {
          return this.sum() / this.size;
        }

        /**
             * Returns the product of all elements of the matrix
             * @return {number}
             */
        prod() {
          var prod = 1;
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              prod *= this.get(i, j);
            }
          }
          return prod;
        }

        /**
             * Returns the norm of a matrix.
             * @param {string} type - "frobenius" (default) or "max" return resp. the Frobenius norm and the max norm.
             * @return {number}
             */
        norm(type = 'frobenius') {
          var result = 0;
          if (type === 'max') {
            return this.max();
          } else if (type === 'frobenius') {
            for (var i = 0; i < this.rows; i++) {
              for (var j = 0; j < this.columns; j++) {
                result = result + this.get(i, j) * this.get(i, j);
              }
            }
            return Math.sqrt(result);
          } else {
            throw new RangeError(`unknown norm type: ${type}`);
          }
        }

        /**
             * Computes the cumulative sum of the matrix elements (in place, row by row)
             * @return {Matrix} this
             */
        cumulativeSum() {
          var sum = 0;
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              sum += this.get(i, j);
              this.set(i, j, sum);
            }
          }
          return this;
        }

        /**
             * Computes the dot (scalar) product between the matrix and another
             * @param {Matrix} vector2 vector
             * @return {number}
             */
        dot(vector2) {
          if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
          var vector1 = this.to1DArray();
          if (vector1.length !== vector2.length) {
            throw new RangeError('vectors do not have the same size');
          }
          var dot = 0;
          for (var i = 0; i < vector1.length; i++) {
            dot += vector1[i] * vector2[i];
          }
          return dot;
        }

        /**
             * Returns the matrix product between this and other
             * @param {Matrix} other
             * @return {Matrix}
             */
        mmul(other) {
          other = this.constructor.checkMatrix(other);
          if (this.columns !== other.rows) {
            // eslint-disable-next-line no-console
            console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
          }

          var m = this.rows;
          var n = this.columns;
          var p = other.columns;

          var result = new this.constructor[Symbol.species](m, p);

          var Bcolj = new Array(n);
          for (var j = 0; j < p; j++) {
            for (var k = 0; k < n; k++) {
              Bcolj[k] = other.get(k, j);
            }

            for (var i = 0; i < m; i++) {
              var s = 0;
              for (k = 0; k < n; k++) {
                s += this.get(i, k) * Bcolj[k];
              }

              result.set(i, j, s);
            }
          }
          return result;
        }

        strassen2x2(other) {
          var result = new this.constructor[Symbol.species](2, 2);
          const a11 = this.get(0, 0);
          const b11 = other.get(0, 0);
          const a12 = this.get(0, 1);
          const b12 = other.get(0, 1);
          const a21 = this.get(1, 0);
          const b21 = other.get(1, 0);
          const a22 = this.get(1, 1);
          const b22 = other.get(1, 1);

          // Compute intermediate values.
          const m1 = (a11 + a22) * (b11 + b22);
          const m2 = (a21 + a22) * b11;
          const m3 = a11 * (b12 - b22);
          const m4 = a22 * (b21 - b11);
          const m5 = (a11 + a12) * b22;
          const m6 = (a21 - a11) * (b11 + b12);
          const m7 = (a12 - a22) * (b21 + b22);

          // Combine intermediate values into the output.
          const c00 = m1 + m4 - m5 + m7;
          const c01 = m3 + m5;
          const c10 = m2 + m4;
          const c11 = m1 - m2 + m3 + m6;

          result.set(0, 0, c00);
          result.set(0, 1, c01);
          result.set(1, 0, c10);
          result.set(1, 1, c11);
          return result;
        }

        strassen3x3(other) {
          var result = new this.constructor[Symbol.species](3, 3);

          const a00 = this.get(0, 0);
          const a01 = this.get(0, 1);
          const a02 = this.get(0, 2);
          const a10 = this.get(1, 0);
          const a11 = this.get(1, 1);
          const a12 = this.get(1, 2);
          const a20 = this.get(2, 0);
          const a21 = this.get(2, 1);
          const a22 = this.get(2, 2);

          const b00 = other.get(0, 0);
          const b01 = other.get(0, 1);
          const b02 = other.get(0, 2);
          const b10 = other.get(1, 0);
          const b11 = other.get(1, 1);
          const b12 = other.get(1, 2);
          const b20 = other.get(2, 0);
          const b21 = other.get(2, 1);
          const b22 = other.get(2, 2);

          const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
          const m2 = (a00 - a10) * (-b01 + b11);
          const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
          const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
          const m5 = (a10 + a11) * (-b00 + b01);
          const m6 = a00 * b00;
          const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
          const m8 = (-a00 + a20) * (b02 - b12);
          const m9 = (a20 + a21) * (-b00 + b02);
          const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
          const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
          const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
          const m13 = (a02 - a22) * (b11 - b21);
          const m14 = a02 * b20;
          const m15 = (a21 + a22) * (-b20 + b21);
          const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
          const m17 = (a02 - a12) * (b12 - b22);
          const m18 = (a11 + a12) * (-b20 + b22);
          const m19 = a01 * b10;
          const m20 = a12 * b21;
          const m21 = a10 * b02;
          const m22 = a20 * b01;
          const m23 = a22 * b22;

          const c00 = m6 + m14 + m19;
          const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
          const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
          const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
          const c11 = m2 + m4 + m5 + m6 + m20;
          const c12 = m14 + m16 + m17 + m18 + m21;
          const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
          const c21 = m12 + m13 + m14 + m15 + m22;
          const c22 = m6 + m7 + m8 + m9 + m23;

          result.set(0, 0, c00);
          result.set(0, 1, c01);
          result.set(0, 2, c02);
          result.set(1, 0, c10);
          result.set(1, 1, c11);
          result.set(1, 2, c12);
          result.set(2, 0, c20);
          result.set(2, 1, c21);
          result.set(2, 2, c22);
          return result;
        }

        /**
             * Returns the matrix product between x and y. More efficient than mmul(other) only when we multiply squared matrix and when the size of the matrix is > 1000.
             * @param {Matrix} y
             * @return {Matrix}
             */
        mmulStrassen(y) {
          var x = this.clone();
          var r1 = x.rows;
          var c1 = x.columns;
          var r2 = y.rows;
          var c2 = y.columns;
          if (c1 !== r2) {
            // eslint-disable-next-line no-console
            console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);
          }

          // Put a matrix into the top left of a matrix of zeros.
          // `rows` and `cols` are the dimensions of the output matrix.
          function embed(mat, rows, cols) {
            var r = mat.rows;
            var c = mat.columns;
            if ((r === rows) && (c === cols)) {
              return mat;
            } else {
              var resultat = Matrix.zeros(rows, cols);
              resultat = resultat.setSubMatrix(mat, 0, 0);
              return resultat;
            }
          }


          // Make sure both matrices are the same size.
          // This is exclusively for simplicity:
          // this algorithm can be implemented with matrices of different sizes.

          var r = Math.max(r1, r2);
          var c = Math.max(c1, c2);
          x = embed(x, r, c);
          y = embed(y, r, c);

          // Our recursive multiplication function.
          function blockMult(a, b, rows, cols) {
            // For small matrices, resort to naive multiplication.
            if (rows <= 512 || cols <= 512) {
              return a.mmul(b); // a is equivalent to this
            }

            // Apply dynamic padding.
            if ((rows % 2 === 1) && (cols % 2 === 1)) {
              a = embed(a, rows + 1, cols + 1);
              b = embed(b, rows + 1, cols + 1);
            } else if (rows % 2 === 1) {
              a = embed(a, rows + 1, cols);
              b = embed(b, rows + 1, cols);
            } else if (cols % 2 === 1) {
              a = embed(a, rows, cols + 1);
              b = embed(b, rows, cols + 1);
            }

            var halfRows = parseInt(a.rows / 2, 10);
            var halfCols = parseInt(a.columns / 2, 10);
            // Subdivide input matrices.
            var a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
            var b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);

            var a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
            var b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);

            var a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
            var b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);

            var a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
            var b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);

            // Compute intermediate values.
            var m1 = blockMult(Matrix.add(a11, a22), Matrix.add(b11, b22), halfRows, halfCols);
            var m2 = blockMult(Matrix.add(a21, a22), b11, halfRows, halfCols);
            var m3 = blockMult(a11, Matrix.sub(b12, b22), halfRows, halfCols);
            var m4 = blockMult(a22, Matrix.sub(b21, b11), halfRows, halfCols);
            var m5 = blockMult(Matrix.add(a11, a12), b22, halfRows, halfCols);
            var m6 = blockMult(Matrix.sub(a21, a11), Matrix.add(b11, b12), halfRows, halfCols);
            var m7 = blockMult(Matrix.sub(a12, a22), Matrix.add(b21, b22), halfRows, halfCols);

            // Combine intermediate values into the output.
            var c11 = Matrix.add(m1, m4);
            c11.sub(m5);
            c11.add(m7);
            var c12 = Matrix.add(m3, m5);
            var c21 = Matrix.add(m2, m4);
            var c22 = Matrix.sub(m1, m2);
            c22.add(m3);
            c22.add(m6);

            // Crop output to the desired size (undo dynamic padding).
            var resultat = Matrix.zeros(2 * c11.rows, 2 * c11.columns);
            resultat = resultat.setSubMatrix(c11, 0, 0);
            resultat = resultat.setSubMatrix(c12, c11.rows, 0);
            resultat = resultat.setSubMatrix(c21, 0, c11.columns);
            resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);
            return resultat.subMatrix(0, rows - 1, 0, cols - 1);
          }
          return blockMult(x, y, r, c);
        }

        /**
             * Returns a row-by-row scaled matrix
             * @param {number} [min=0] - Minimum scaled value
             * @param {number} [max=1] - Maximum scaled value
             * @return {Matrix} - The scaled matrix
             */
        scaleRows(min, max) {
          min = min === undefined ? 0 : min;
          max = max === undefined ? 1 : max;
          if (min >= max) {
            throw new RangeError('min should be strictly smaller than max');
          }
          var newMatrix = this.constructor.empty(this.rows, this.columns);
          for (var i = 0; i < this.rows; i++) {
            var scaled = rescale(this.getRow(i), { min, max });
            newMatrix.setRow(i, scaled);
          }
          return newMatrix;
        }

        /**
             * Returns a new column-by-column scaled matrix
             * @param {number} [min=0] - Minimum scaled value
             * @param {number} [max=1] - Maximum scaled value
             * @return {Matrix} - The new scaled matrix
             * @example
             * var matrix = new Matrix([[1,2],[-1,0]]);
             * var scaledMatrix = matrix.scaleColumns(); // [[1,1],[0,0]]
             */
        scaleColumns(min, max) {
          min = min === undefined ? 0 : min;
          max = max === undefined ? 1 : max;
          if (min >= max) {
            throw new RangeError('min should be strictly smaller than max');
          }
          var newMatrix = this.constructor.empty(this.rows, this.columns);
          for (var i = 0; i < this.columns; i++) {
            var scaled = rescale(this.getColumn(i), {
              min: min,
              max: max
            });
            newMatrix.setColumn(i, scaled);
          }
          return newMatrix;
        }


        /**
             * Returns the Kronecker product (also known as tensor product) between this and other
             * See https://en.wikipedia.org/wiki/Kronecker_product
             * @param {Matrix} other
             * @return {Matrix}
             */
        kroneckerProduct(other) {
          other = this.constructor.checkMatrix(other);

          var m = this.rows;
          var n = this.columns;
          var p = other.rows;
          var q = other.columns;

          var result = new this.constructor[Symbol.species](m * p, n * q);
          for (var i = 0; i < m; i++) {
            for (var j = 0; j < n; j++) {
              for (var k = 0; k < p; k++) {
                for (var l = 0; l < q; l++) {
                  result[p * i + k][q * j + l] = this.get(i, j) * other.get(k, l);
                }
              }
            }
          }
          return result;
        }

        /**
             * Transposes the matrix and returns a new one containing the result
             * @return {Matrix}
             */
        transpose() {
          var result = new this.constructor[Symbol.species](this.columns, this.rows);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              result.set(j, i, this.get(i, j));
            }
          }
          return result;
        }

        /**
             * Sorts the rows (in place)
             * @param {function} compareFunction - usual Array.prototype.sort comparison function
             * @return {Matrix} this
             */
        sortRows(compareFunction) {
          if (compareFunction === undefined) compareFunction = compareNumbers;
          for (var i = 0; i < this.rows; i++) {
            this.setRow(i, this.getRow(i).sort(compareFunction));
          }
          return this;
        }

        /**
             * Sorts the columns (in place)
             * @param {function} compareFunction - usual Array.prototype.sort comparison function
             * @return {Matrix} this
             */
        sortColumns(compareFunction) {
          if (compareFunction === undefined) compareFunction = compareNumbers;
          for (var i = 0; i < this.columns; i++) {
            this.setColumn(i, this.getColumn(i).sort(compareFunction));
          }
          return this;
        }

        /**
             * Returns a subset of the matrix
             * @param {number} startRow - First row index
             * @param {number} endRow - Last row index
             * @param {number} startColumn - First column index
             * @param {number} endColumn - Last column index
             * @return {Matrix}
             */
        subMatrix(startRow, endRow, startColumn, endColumn) {
          checkRange(this, startRow, endRow, startColumn, endColumn);
          var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, endColumn - startColumn + 1);
          for (var i = startRow; i <= endRow; i++) {
            for (var j = startColumn; j <= endColumn; j++) {
              newMatrix[i - startRow][j - startColumn] = this.get(i, j);
            }
          }
          return newMatrix;
        }

        /**
             * Returns a subset of the matrix based on an array of row indices
             * @param {Array} indices - Array containing the row indices
             * @param {number} [startColumn = 0] - First column index
             * @param {number} [endColumn = this.columns-1] - Last column index
             * @return {Matrix}
             */
        subMatrixRow(indices, startColumn, endColumn) {
          if (startColumn === undefined) startColumn = 0;
          if (endColumn === undefined) endColumn = this.columns - 1;
          if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
            throw new RangeError('Argument out of range');
          }

          var newMatrix = new this.constructor[Symbol.species](indices.length, endColumn - startColumn + 1);
          for (var i = 0; i < indices.length; i++) {
            for (var j = startColumn; j <= endColumn; j++) {
              if (indices[i] < 0 || indices[i] >= this.rows) {
                throw new RangeError(`Row index out of range: ${indices[i]}`);
              }
              newMatrix.set(i, j - startColumn, this.get(indices[i], j));
            }
          }
          return newMatrix;
        }

        /**
             * Returns a subset of the matrix based on an array of column indices
             * @param {Array} indices - Array containing the column indices
             * @param {number} [startRow = 0] - First row index
             * @param {number} [endRow = this.rows-1] - Last row index
             * @return {Matrix}
             */
        subMatrixColumn(indices, startRow, endRow) {
          if (startRow === undefined) startRow = 0;
          if (endRow === undefined) endRow = this.rows - 1;
          if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {
            throw new RangeError('Argument out of range');
          }

          var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, indices.length);
          for (var i = 0; i < indices.length; i++) {
            for (var j = startRow; j <= endRow; j++) {
              if (indices[i] < 0 || indices[i] >= this.columns) {
                throw new RangeError(`Column index out of range: ${indices[i]}`);
              }
              newMatrix.set(j - startRow, i, this.get(j, indices[i]));
            }
          }
          return newMatrix;
        }

        /**
             * Set a part of the matrix to the given sub-matrix
             * @param {Matrix|Array< Array >} matrix - The source matrix from which to extract values.
             * @param {number} startRow - The index of the first row to set
             * @param {number} startColumn - The index of the first column to set
             * @return {Matrix}
             */
        setSubMatrix(matrix, startRow, startColumn) {
          matrix = this.constructor.checkMatrix(matrix);
          var endRow = startRow + matrix.rows - 1;
          var endColumn = startColumn + matrix.columns - 1;
          checkRange(this, startRow, endRow, startColumn, endColumn);
          for (var i = 0; i < matrix.rows; i++) {
            for (var j = 0; j < matrix.columns; j++) {
              this[startRow + i][startColumn + j] = matrix.get(i, j);
            }
          }
          return this;
        }

        /**
             * Return a new matrix based on a selection of rows and columns
             * @param {Array<number>} rowIndices - The row indices to select. Order matters and an index can be more than once.
             * @param {Array<number>} columnIndices - The column indices to select. Order matters and an index can be use more than once.
             * @return {Matrix} The new matrix
             */
        selection(rowIndices, columnIndices) {
          var indices = checkIndices(this, rowIndices, columnIndices);
          var newMatrix = new this.constructor[Symbol.species](rowIndices.length, columnIndices.length);
          for (var i = 0; i < indices.row.length; i++) {
            var rowIndex = indices.row[i];
            for (var j = 0; j < indices.column.length; j++) {
              var columnIndex = indices.column[j];
              newMatrix[i][j] = this.get(rowIndex, columnIndex);
            }
          }
          return newMatrix;
        }

        /**
             * Returns the trace of the matrix (sum of the diagonal elements)
             * @return {number}
             */
        trace() {
          var min = Math.min(this.rows, this.columns);
          var trace = 0;
          for (var i = 0; i < min; i++) {
            trace += this.get(i, i);
          }
          return trace;
        }

        /*
             Matrix views
             */

        /**
             * Returns a view of the transposition of the matrix
             * @return {MatrixTransposeView}
             */
        transposeView() {
          return new MatrixTransposeView(this);
        }

        /**
             * Returns a view of the row vector with the given index
             * @param {number} row - row index of the vector
             * @return {MatrixRowView}
             */
        rowView(row) {
          checkRowIndex(this, row);
          return new MatrixRowView(this, row);
        }

        /**
             * Returns a view of the column vector with the given index
             * @param {number} column - column index of the vector
             * @return {MatrixColumnView}
             */
        columnView(column) {
          checkColumnIndex(this, column);
          return new MatrixColumnView(this, column);
        }

        /**
             * Returns a view of the matrix flipped in the row axis
             * @return {MatrixFlipRowView}
             */
        flipRowView() {
          return new MatrixFlipRowView(this);
        }

        /**
             * Returns a view of the matrix flipped in the column axis
             * @return {MatrixFlipColumnView}
             */
        flipColumnView() {
          return new MatrixFlipColumnView(this);
        }

        /**
             * Returns a view of a submatrix giving the index boundaries
             * @param {number} startRow - first row index of the submatrix
             * @param {number} endRow - last row index of the submatrix
             * @param {number} startColumn - first column index of the submatrix
             * @param {number} endColumn - last column index of the submatrix
             * @return {MatrixSubView}
             */
        subMatrixView(startRow, endRow, startColumn, endColumn) {
          return new MatrixSubView(this, startRow, endRow, startColumn, endColumn);
        }

        /**
             * Returns a view of the cross of the row indices and the column indices
             * @example
             * // resulting vector is [[2], [2]]
             * var matrix = new Matrix([[1,2,3], [4,5,6]]).selectionView([0, 0], [1])
             * @param {Array<number>} rowIndices
             * @param {Array<number>} columnIndices
             * @return {MatrixSelectionView}
             */
        selectionView(rowIndices, columnIndices) {
          return new MatrixSelectionView(this, rowIndices, columnIndices);
        }

        /**
             * Returns a view of the row indices
             * @example
             * // resulting vector is [[1,2,3], [1,2,3]]
             * var matrix = new Matrix([[1,2,3], [4,5,6]]).rowSelectionView([0, 0])
             * @param {Array<number>} rowIndices
             * @return {MatrixRowSelectionView}
             */
        rowSelectionView(rowIndices) {
          return new MatrixRowSelectionView(this, rowIndices);
        }

        /**
             * Returns a view of the column indices
             * @example
             * // resulting vector is [[2, 2], [5, 5]]
             * var matrix = new Matrix([[1,2,3], [4,5,6]]).columnSelectionView([1, 1])
             * @param {Array<number>} columnIndices
             * @return {MatrixColumnSelectionView}
             */
        columnSelectionView(columnIndices) {
          return new MatrixColumnSelectionView(this, columnIndices);
        }


        /**
            * Calculates and returns the determinant of a matrix as a Number
            * @example
            *   new Matrix([[1,2,3], [4,5,6]]).det()
            * @return {number}
            */
        det() {
          if (this.isSquare()) {
            var a, b, c, d;
            if (this.columns === 2) {
              // 2 x 2 matrix
              a = this.get(0, 0);
              b = this.get(0, 1);
              c = this.get(1, 0);
              d = this.get(1, 1);

              return a * d - (b * c);
            } else if (this.columns === 3) {
              // 3 x 3 matrix
              var subMatrix0, subMatrix1, subMatrix2;
              subMatrix0 = this.selectionView([1, 2], [1, 2]);
              subMatrix1 = this.selectionView([1, 2], [0, 2]);
              subMatrix2 = this.selectionView([1, 2], [0, 1]);
              a = this.get(0, 0);
              b = this.get(0, 1);
              c = this.get(0, 2);

              return a * subMatrix0.det() - b * subMatrix1.det() + c * subMatrix2.det();
            } else {
              // general purpose determinant using the LU decomposition
              return new LuDecomposition(this).determinant;
            }
          } else {
            throw Error('Determinant can only be calculated for a square matrix.');
          }
        }

        /**
             * Returns inverse of a matrix if it exists or the pseudoinverse
             * @param {number} threshold - threshold for taking inverse of singular values (default = 1e-15)
             * @return {Matrix} the (pseudo)inverted matrix.
             */
        pseudoInverse(threshold) {
          if (threshold === undefined) threshold = Number.EPSILON;
          var svdSolution = new SingularValueDecomposition(this, { autoTranspose: true });

          var U = svdSolution.leftSingularVectors;
          var V = svdSolution.rightSingularVectors;
          var s = svdSolution.diagonal;

          for (var i = 0; i < s.length; i++) {
            if (Math.abs(s[i]) > threshold) {
              s[i] = 1.0 / s[i];
            } else {
              s[i] = 0.0;
            }
          }

          // convert list to diagonal
          s = this.constructor[Symbol.species].diag(s);
          return V.mmul(s.mmul(U.transposeView()));
        }

        /**
             * Creates an exact and independent copy of the matrix
             * @return {Matrix}
             */
        clone() {
          var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);
          for (var row = 0; row < this.rows; row++) {
            for (var column = 0; column < this.columns; column++) {
              newMatrix.set(row, column, this.get(row, column));
            }
          }
          return newMatrix;
        }
      }

      Matrix.prototype.klass = 'Matrix';

      function compareNumbers(a, b) {
        return a - b;
      }

      /*
         Synonyms
         */

      Matrix.random = Matrix.rand;
      Matrix.diagonal = Matrix.diag;
      Matrix.prototype.diagonal = Matrix.prototype.diag;
      Matrix.identity = Matrix.eye;
      Matrix.prototype.negate = Matrix.prototype.neg;
      Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;
      Matrix.prototype.determinant = Matrix.prototype.det;

      /*
         Add dynamically instance and static methods for mathematical operations
         */

      var inplaceOperator = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;

      var inplaceOperatorScalar = `
(function %name%S(value) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) %op% value);
        }
    }
    return this;
})
`;

      var inplaceOperatorMatrix = `
(function %name%M(matrix) {
    matrix = this.constructor.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
        this.columns !== matrix.columns) {
        throw new RangeError('Matrices dimensions must be equal');
    }
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));
        }
    }
    return this;
})
`;

      var staticOperator = `
(function %name%(matrix, value) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%(value);
})
`;

      var inplaceMethod = `
(function %name%() {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j)));
        }
    }
    return this;
})
`;

      var staticMethod = `
(function %name%(matrix) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%();
})
`;

      var inplaceMethodWithArgs = `
(function %name%(%args%) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), %args%));
        }
    }
    return this;
})
`;

      var staticMethodWithArgs = `
(function %name%(matrix, %args%) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%(%args%);
})
`;


      var inplaceMethodWithOneArgScalar = `
(function %name%S(value) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), value));
        }
    }
    return this;
})
`;
      var inplaceMethodWithOneArgMatrix = `
(function %name%M(matrix) {
    matrix = this.constructor.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
        this.columns !== matrix.columns) {
        throw new RangeError('Matrices dimensions must be equal');
    }
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));
        }
    }
    return this;
})
`;

      var inplaceMethodWithOneArg = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;

      var staticMethodWithOneArg = staticMethodWithArgs;

      var operators = [
        // Arithmetic operators
        ['+', 'add'],
        ['-', 'sub', 'subtract'],
        ['*', 'mul', 'multiply'],
        ['/', 'div', 'divide'],
        ['%', 'mod', 'modulus'],
        // Bitwise operators
        ['&', 'and'],
        ['|', 'or'],
        ['^', 'xor'],
        ['<<', 'leftShift'],
        ['>>', 'signPropagatingRightShift'],
        ['>>>', 'rightShift', 'zeroFillRightShift']
      ];

      var i;
      var eval2 = eval; // eslint-disable-line no-eval
      for (var operator of operators) {
        var inplaceOp = eval2(fillTemplateFunction(inplaceOperator, { name: operator[1], op: operator[0] }));
        var inplaceOpS = eval2(fillTemplateFunction(inplaceOperatorScalar, { name: `${operator[1]}S`, op: operator[0] }));
        var inplaceOpM = eval2(fillTemplateFunction(inplaceOperatorMatrix, { name: `${operator[1]}M`, op: operator[0] }));
        var staticOp = eval2(fillTemplateFunction(staticOperator, { name: operator[1] }));
        for (i = 1; i < operator.length; i++) {
          Matrix.prototype[operator[i]] = inplaceOp;
          Matrix.prototype[`${operator[i]}S`] = inplaceOpS;
          Matrix.prototype[`${operator[i]}M`] = inplaceOpM;
          Matrix[operator[i]] = staticOp;
        }
      }

      var methods = [['~', 'not']];

      [
        'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil',
        'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p',
        'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'
      ].forEach(function (mathMethod) {
        methods.push([`Math.${mathMethod}`, mathMethod]);
      });

      for (var method of methods) {
        var inplaceMeth = eval2(fillTemplateFunction(inplaceMethod, { name: method[1], method: method[0] }));
        var staticMeth = eval2(fillTemplateFunction(staticMethod, { name: method[1] }));
        for (i = 1; i < method.length; i++) {
          Matrix.prototype[method[i]] = inplaceMeth;
          Matrix[method[i]] = staticMeth;
        }
      }

      var methodsWithArgs = [['Math.pow', 1, 'pow']];

      for (var methodWithArg of methodsWithArgs) {
        var args = 'arg0';
        for (i = 1; i < methodWithArg[1]; i++) {
          args += `, arg${i}`;
        }
        if (methodWithArg[1] !== 1) {
          var inplaceMethWithArgs = eval2(fillTemplateFunction(inplaceMethodWithArgs, {
            name: methodWithArg[2],
            method: methodWithArg[0],
            args: args
          }));
          var staticMethWithArgs = eval2(fillTemplateFunction(staticMethodWithArgs, { name: methodWithArg[2], args: args }));
          for (i = 2; i < methodWithArg.length; i++) {
            Matrix.prototype[methodWithArg[i]] = inplaceMethWithArgs;
            Matrix[methodWithArg[i]] = staticMethWithArgs;
          }
        } else {
          var tmplVar = {
            name: methodWithArg[2],
            args: args,
            method: methodWithArg[0]
          };
          var inplaceMethod2 = eval2(fillTemplateFunction(inplaceMethodWithOneArg, tmplVar));
          var inplaceMethodS = eval2(fillTemplateFunction(inplaceMethodWithOneArgScalar, tmplVar));
          var inplaceMethodM = eval2(fillTemplateFunction(inplaceMethodWithOneArgMatrix, tmplVar));
          var staticMethod2 = eval2(fillTemplateFunction(staticMethodWithOneArg, tmplVar));
          for (i = 2; i < methodWithArg.length; i++) {
            Matrix.prototype[methodWithArg[i]] = inplaceMethod2;
            Matrix.prototype[`${methodWithArg[i]}M`] = inplaceMethodM;
            Matrix.prototype[`${methodWithArg[i]}S`] = inplaceMethodS;
            Matrix[methodWithArg[i]] = staticMethod2;
          }
        }
      }

      function fillTemplateFunction(template, values) {
        for (var value in values) {
          template = template.replace(new RegExp(`%${value}%`, 'g'), values[value]);
        }
        return template;
      }

      return Matrix;
    }

    class Matrix extends AbstractMatrix(Array) {
      constructor(nRows, nColumns) {
        var i;
        if (arguments.length === 1 && typeof nRows === 'number') {
          return new Array(nRows);
        }
        if (Matrix.isMatrix(nRows)) {
          return nRows.clone();
        } else if (Number.isInteger(nRows) && nRows > 0) {
          // Create an empty matrix
          super(nRows);
          if (Number.isInteger(nColumns) && nColumns > 0) {
            for (i = 0; i < nRows; i++) {
              this[i] = new Array(nColumns);
            }
          } else {
            throw new TypeError('nColumns must be a positive integer');
          }
        } else if (Array.isArray(nRows)) {
          // Copy the values from the 2D array
          const matrix = nRows;
          nRows = matrix.length;
          nColumns = matrix[0].length;
          if (typeof nColumns !== 'number' || nColumns === 0) {
            throw new TypeError(
              'Data must be a 2D array with at least one element'
            );
          }
          super(nRows);
          for (i = 0; i < nRows; i++) {
            if (matrix[i].length !== nColumns) {
              throw new RangeError('Inconsistent array dimensions');
            }
            this[i] = [].concat(matrix[i]);
          }
        } else {
          throw new TypeError(
            'First argument must be a positive number or an array'
          );
        }
        this.rows = nRows;
        this.columns = nColumns;
        return this;
      }

      set(rowIndex, columnIndex, value) {
        this[rowIndex][columnIndex] = value;
        return this;
      }

      get(rowIndex, columnIndex) {
        return this[rowIndex][columnIndex];
      }

      /**
       * Removes a row from the given index
       * @param {number} index - Row index
       * @return {Matrix} this
       */
      removeRow(index) {
        checkRowIndex(this, index);
        if (this.rows === 1) {
          throw new RangeError('A matrix cannot have less than one row');
        }
        this.splice(index, 1);
        this.rows -= 1;
        return this;
      }

      /**
       * Adds a row at the given index
       * @param {number} [index = this.rows] - Row index
       * @param {Array|Matrix} array - Array or vector
       * @return {Matrix} this
       */
      addRow(index, array) {
        if (array === undefined) {
          array = index;
          index = this.rows;
        }
        checkRowIndex(this, index, true);
        array = checkRowVector(this, array);
        this.splice(index, 0, array);
        this.rows += 1;
        return this;
      }

      /**
       * Removes a column from the given index
       * @param {number} index - Column index
       * @return {Matrix} this
       */
      removeColumn(index) {
        checkColumnIndex(this, index);
        if (this.columns === 1) {
          throw new RangeError('A matrix cannot have less than one column');
        }
        for (var i = 0; i < this.rows; i++) {
          this[i].splice(index, 1);
        }
        this.columns -= 1;
        return this;
      }

      /**
       * Adds a column at the given index
       * @param {number} [index = this.columns] - Column index
       * @param {Array|Matrix} array - Array or vector
       * @return {Matrix} this
       */
      addColumn(index, array) {
        if (typeof array === 'undefined') {
          array = index;
          index = this.columns;
        }
        checkColumnIndex(this, index, true);
        array = checkColumnVector(this, array);
        for (var i = 0; i < this.rows; i++) {
          this[i].splice(index, 0, array[i]);
        }
        this.columns += 1;
        return this;
      }
    }

    class WrapperMatrix1D extends AbstractMatrix() {
      /**
       * @class WrapperMatrix1D
       * @param {Array<number>} data
       * @param {object} [options]
       * @param {object} [options.rows = 1]
       */
      constructor(data, options = {}) {
        const { rows = 1 } = options;

        if (data.length % rows !== 0) {
          throw new Error('the data length is not divisible by the number of rows');
        }
        super();
        this.rows = rows;
        this.columns = data.length / rows;
        this.data = data;
      }

      set(rowIndex, columnIndex, value) {
        var index = this._calculateIndex(rowIndex, columnIndex);
        this.data[index] = value;
        return this;
      }

      get(rowIndex, columnIndex) {
        var index = this._calculateIndex(rowIndex, columnIndex);
        return this.data[index];
      }

      _calculateIndex(row, column) {
        return row * this.columns + column;
      }

      static get [Symbol.species]() {
        return Matrix;
      }
    }

    class WrapperMatrix2D extends AbstractMatrix() {
      /**
       * @class WrapperMatrix2D
       * @param {Array<Array<number>>} data
       */
      constructor(data) {
        super();
        this.data = data;
        this.rows = data.length;
        this.columns = data[0].length;
      }

      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }

      static get [Symbol.species]() {
        return Matrix;
      }
    }

    /**
     * @class QrDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs
     * @param {Matrix} value
     */
    class QrDecomposition {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);

        var qr = value.clone();
        var m = value.rows;
        var n = value.columns;
        var rdiag = new Array(n);
        var i, j, k, s;

        for (k = 0; k < n; k++) {
          var nrm = 0;
          for (i = k; i < m; i++) {
            nrm = hypotenuse(nrm, qr.get(i, k));
          }
          if (nrm !== 0) {
            if (qr.get(k, k) < 0) {
              nrm = -nrm;
            }
            for (i = k; i < m; i++) {
              qr.set(i, k, qr.get(i, k) / nrm);
            }
            qr.set(k, k, qr.get(k, k) + 1);
            for (j = k + 1; j < n; j++) {
              s = 0;
              for (i = k; i < m; i++) {
                s += qr.get(i, k) * qr.get(i, j);
              }
              s = -s / qr.get(k, k);
              for (i = k; i < m; i++) {
                qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
              }
            }
          }
          rdiag[k] = -nrm;
        }

        this.QR = qr;
        this.Rdiag = rdiag;
      }

      /**
       * Solve a problem of least square (Ax=b) by using the QR decomposition. Useful when A is rectangular, but not working when A is singular.
       * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
       * var qr = QrDecomposition(A);
       * var x = qr.solve(b);
       * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
       * @return {Matrix} - The vector x
       */
      solve(value) {
        value = Matrix.checkMatrix(value);

        var qr = this.QR;
        var m = qr.rows;

        if (value.rows !== m) {
          throw new Error('Matrix row dimensions must agree');
        }
        if (!this.isFullRank()) {
          throw new Error('Matrix is rank deficient');
        }

        var count = value.columns;
        var X = value.clone();
        var n = qr.columns;
        var i, j, k, s;

        for (k = 0; k < n; k++) {
          for (j = 0; j < count; j++) {
            s = 0;
            for (i = k; i < m; i++) {
              s += qr[i][k] * X[i][j];
            }
            s = -s / qr[k][k];
            for (i = k; i < m; i++) {
              X[i][j] += s * qr[i][k];
            }
          }
        }
        for (k = n - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            X[k][j] /= this.Rdiag[k];
          }
          for (i = 0; i < k; i++) {
            for (j = 0; j < count; j++) {
              X[i][j] -= X[k][j] * qr[i][k];
            }
          }
        }

        return X.subMatrix(0, n - 1, 0, count - 1);
      }

      /**
       *
       * @return {boolean}
       */
      isFullRank() {
        var columns = this.QR.columns;
        for (var i = 0; i < columns; i++) {
          if (this.Rdiag[i] === 0) {
            return false;
          }
        }
        return true;
      }

      /**
       *
       * @return {Matrix}
       */
      get upperTriangularMatrix() {
        var qr = this.QR;
        var n = qr.columns;
        var X = new Matrix(n, n);
        var i, j;
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            if (i < j) {
              X[i][j] = qr[i][j];
            } else if (i === j) {
              X[i][j] = this.Rdiag[i];
            } else {
              X[i][j] = 0;
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {Matrix}
       */
      get orthogonalMatrix() {
        var qr = this.QR;
        var rows = qr.rows;
        var columns = qr.columns;
        var X = new Matrix(rows, columns);
        var i, j, k, s;

        for (k = columns - 1; k >= 0; k--) {
          for (i = 0; i < rows; i++) {
            X[i][k] = 0;
          }
          X[k][k] = 1;
          for (j = k; j < columns; j++) {
            if (qr[k][k] !== 0) {
              s = 0;
              for (i = k; i < rows; i++) {
                s += qr[i][k] * X[i][j];
              }

              s = -s / qr[k][k];

              for (i = k; i < rows; i++) {
                X[i][j] += s * qr[i][k];
              }
            }
          }
        }
        return X;
      }
    }

    /**
     * Computes the inverse of a Matrix
     * @param {Matrix} matrix
     * @param {boolean} [useSVD=false]
     * @return {Matrix}
     */
    function inverse(matrix, useSVD = false) {
      matrix = WrapperMatrix2D.checkMatrix(matrix);
      if (useSVD) {
        return new SingularValueDecomposition(matrix).inverse();
      } else {
        return solve(matrix, Matrix.eye(matrix.rows));
      }
    }

    /**
     *
     * @param {Matrix} leftHandSide
     * @param {Matrix} rightHandSide
     * @param {boolean} [useSVD = false]
     * @return {Matrix}
     */
    function solve(leftHandSide, rightHandSide, useSVD = false) {
      leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
      rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
      if (useSVD) {
        return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);
      } else {
        return leftHandSide.isSquare()
          ? new LuDecomposition(leftHandSide).solve(rightHandSide)
          : new QrDecomposition(leftHandSide).solve(rightHandSide);
      }
    }

    /**
     * @class EigenvalueDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs
     * @param {Matrix} matrix
     * @param {object} [options]
     * @param {boolean} [options.assumeSymmetric=false]
     */
    class EigenvalueDecomposition {
      constructor(matrix, options = {}) {
        const { assumeSymmetric = false } = options;

        matrix = WrapperMatrix2D.checkMatrix(matrix);
        if (!matrix.isSquare()) {
          throw new Error('Matrix is not a square matrix');
        }

        var n = matrix.columns;
        var V = getFilled2DArray(n, n, 0);
        var d = new Array(n);
        var e = new Array(n);
        var value = matrix;
        var i, j;

        var isSymmetric = false;
        if (assumeSymmetric) {
          isSymmetric = true;
        } else {
          isSymmetric = matrix.isSymmetric();
        }

        if (isSymmetric) {
          for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
              V[i][j] = value.get(i, j);
            }
          }
          tred2(n, e, d, V);
          tql2(n, e, d, V);
        } else {
          var H = getFilled2DArray(n, n, 0);
          var ort = new Array(n);
          for (j = 0; j < n; j++) {
            for (i = 0; i < n; i++) {
              H[i][j] = value.get(i, j);
            }
          }
          orthes(n, H, ort, V);
          hqr2(n, e, d, V, H);
        }

        this.n = n;
        this.e = e;
        this.d = d;
        this.V = V;
      }

      /**
       *
       * @return {Array<number>}
       */
      get realEigenvalues() {
        return this.d;
      }

      /**
       *
       * @return {Array<number>}
       */
      get imaginaryEigenvalues() {
        return this.e;
      }

      /**
       *
       * @return {Matrix}
       */
      get eigenvectorMatrix() {
        if (!Matrix.isMatrix(this.V)) {
          this.V = new Matrix(this.V);
        }
        return this.V;
      }

      /**
       *
       * @return {Matrix}
       */
      get diagonalMatrix() {
        var n = this.n;
        var e = this.e;
        var d = this.d;
        var X = new Matrix(n, n);
        var i, j;
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            X[i][j] = 0;
          }
          X[i][i] = d[i];
          if (e[i] > 0) {
            X[i][i + 1] = e[i];
          } else if (e[i] < 0) {
            X[i][i - 1] = e[i];
          }
        }
        return X;
      }
    }

    function tred2(n, e, d, V) {
      var f, g, h, i, j, k, hh, scale;

      for (j = 0; j < n; j++) {
        d[j] = V[n - 1][j];
      }

      for (i = n - 1; i > 0; i--) {
        scale = 0;
        h = 0;
        for (k = 0; k < i; k++) {
          scale = scale + Math.abs(d[k]);
        }

        if (scale === 0) {
          e[i] = d[i - 1];
          for (j = 0; j < i; j++) {
            d[j] = V[i - 1][j];
            V[i][j] = 0;
            V[j][i] = 0;
          }
        } else {
          for (k = 0; k < i; k++) {
            d[k] /= scale;
            h += d[k] * d[k];
          }

          f = d[i - 1];
          g = Math.sqrt(h);
          if (f > 0) {
            g = -g;
          }

          e[i] = scale * g;
          h = h - f * g;
          d[i - 1] = f - g;
          for (j = 0; j < i; j++) {
            e[j] = 0;
          }

          for (j = 0; j < i; j++) {
            f = d[j];
            V[j][i] = f;
            g = e[j] + V[j][j] * f;
            for (k = j + 1; k <= i - 1; k++) {
              g += V[k][j] * d[k];
              e[k] += V[k][j] * f;
            }
            e[j] = g;
          }

          f = 0;
          for (j = 0; j < i; j++) {
            e[j] /= h;
            f += e[j] * d[j];
          }

          hh = f / (h + h);
          for (j = 0; j < i; j++) {
            e[j] -= hh * d[j];
          }

          for (j = 0; j < i; j++) {
            f = d[j];
            g = e[j];
            for (k = j; k <= i - 1; k++) {
              V[k][j] -= f * e[k] + g * d[k];
            }
            d[j] = V[i - 1][j];
            V[i][j] = 0;
          }
        }
        d[i] = h;
      }

      for (i = 0; i < n - 1; i++) {
        V[n - 1][i] = V[i][i];
        V[i][i] = 1;
        h = d[i + 1];
        if (h !== 0) {
          for (k = 0; k <= i; k++) {
            d[k] = V[k][i + 1] / h;
          }

          for (j = 0; j <= i; j++) {
            g = 0;
            for (k = 0; k <= i; k++) {
              g += V[k][i + 1] * V[k][j];
            }
            for (k = 0; k <= i; k++) {
              V[k][j] -= g * d[k];
            }
          }
        }

        for (k = 0; k <= i; k++) {
          V[k][i + 1] = 0;
        }
      }

      for (j = 0; j < n; j++) {
        d[j] = V[n - 1][j];
        V[n - 1][j] = 0;
      }

      V[n - 1][n - 1] = 1;
      e[0] = 0;
    }

    function tql2(n, e, d, V) {
      var g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2;

      for (i = 1; i < n; i++) {
        e[i - 1] = e[i];
      }

      e[n - 1] = 0;

      var f = 0;
      var tst1 = 0;
      var eps = Number.EPSILON;

      for (l = 0; l < n; l++) {
        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
        m = l;
        while (m < n) {
          if (Math.abs(e[m]) <= eps * tst1) {
            break;
          }
          m++;
        }

        if (m > l) {
          do {

            g = d[l];
            p = (d[l + 1] - g) / (2 * e[l]);
            r = hypotenuse(p, 1);
            if (p < 0) {
              r = -r;
            }

            d[l] = e[l] / (p + r);
            d[l + 1] = e[l] * (p + r);
            dl1 = d[l + 1];
            h = g - d[l];
            for (i = l + 2; i < n; i++) {
              d[i] -= h;
            }

            f = f + h;

            p = d[m];
            c = 1;
            c2 = c;
            c3 = c;
            el1 = e[l + 1];
            s = 0;
            s2 = 0;
            for (i = m - 1; i >= l; i--) {
              c3 = c2;
              c2 = c;
              s2 = s;
              g = c * e[i];
              h = c * p;
              r = hypotenuse(p, e[i]);
              e[i + 1] = s * r;
              s = e[i] / r;
              c = p / r;
              p = c * d[i] - s * g;
              d[i + 1] = h + s * (c * g + s * d[i]);

              for (k = 0; k < n; k++) {
                h = V[k][i + 1];
                V[k][i + 1] = s * V[k][i] + c * h;
                V[k][i] = c * V[k][i] - s * h;
              }
            }

            p = -s * s2 * c3 * el1 * e[l] / dl1;
            e[l] = s * p;
            d[l] = c * p;
          } while (Math.abs(e[l]) > eps * tst1);
        }
        d[l] = d[l] + f;
        e[l] = 0;
      }

      for (i = 0; i < n - 1; i++) {
        k = i;
        p = d[i];
        for (j = i + 1; j < n; j++) {
          if (d[j] < p) {
            k = j;
            p = d[j];
          }
        }

        if (k !== i) {
          d[k] = d[i];
          d[i] = p;
          for (j = 0; j < n; j++) {
            p = V[j][i];
            V[j][i] = V[j][k];
            V[j][k] = p;
          }
        }
      }
    }

    function orthes(n, H, ort, V) {
      var low = 0;
      var high = n - 1;
      var f, g, h, i, j, m;
      var scale;

      for (m = low + 1; m <= high - 1; m++) {
        scale = 0;
        for (i = m; i <= high; i++) {
          scale = scale + Math.abs(H[i][m - 1]);
        }

        if (scale !== 0) {
          h = 0;
          for (i = high; i >= m; i--) {
            ort[i] = H[i][m - 1] / scale;
            h += ort[i] * ort[i];
          }

          g = Math.sqrt(h);
          if (ort[m] > 0) {
            g = -g;
          }

          h = h - ort[m] * g;
          ort[m] = ort[m] - g;

          for (j = m; j < n; j++) {
            f = 0;
            for (i = high; i >= m; i--) {
              f += ort[i] * H[i][j];
            }

            f = f / h;
            for (i = m; i <= high; i++) {
              H[i][j] -= f * ort[i];
            }
          }

          for (i = 0; i <= high; i++) {
            f = 0;
            for (j = high; j >= m; j--) {
              f += ort[j] * H[i][j];
            }

            f = f / h;
            for (j = m; j <= high; j++) {
              H[i][j] -= f * ort[j];
            }
          }

          ort[m] = scale * ort[m];
          H[m][m - 1] = scale * g;
        }
      }

      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          V[i][j] = i === j ? 1 : 0;
        }
      }

      for (m = high - 1; m >= low + 1; m--) {
        if (H[m][m - 1] !== 0) {
          for (i = m + 1; i <= high; i++) {
            ort[i] = H[i][m - 1];
          }

          for (j = m; j <= high; j++) {
            g = 0;
            for (i = m; i <= high; i++) {
              g += ort[i] * V[i][j];
            }

            g = g / ort[m] / H[m][m - 1];
            for (i = m; i <= high; i++) {
              V[i][j] += g * ort[i];
            }
          }
        }
      }
    }

    function hqr2(nn, e, d, V, H) {
      var n = nn - 1;
      var low = 0;
      var high = nn - 1;
      var eps = Number.EPSILON;
      var exshift = 0;
      var norm = 0;
      var p = 0;
      var q = 0;
      var r = 0;
      var s = 0;
      var z = 0;
      var iter = 0;
      var i, j, k, l, m, t, w, x, y;
      var ra, sa, vr, vi;
      var notlast, cdivres;

      for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
          d[i] = H[i][i];
          e[i] = 0;
        }

        for (j = Math.max(i - 1, 0); j < nn; j++) {
          norm = norm + Math.abs(H[i][j]);
        }
      }

      while (n >= low) {
        l = n;
        while (l > low) {
          s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);
          if (s === 0) {
            s = norm;
          }
          if (Math.abs(H[l][l - 1]) < eps * s) {
            break;
          }
          l--;
        }

        if (l === n) {
          H[n][n] = H[n][n] + exshift;
          d[n] = H[n][n];
          e[n] = 0;
          n--;
          iter = 0;
        } else if (l === n - 1) {
          w = H[n][n - 1] * H[n - 1][n];
          p = (H[n - 1][n - 1] - H[n][n]) / 2;
          q = p * p + w;
          z = Math.sqrt(Math.abs(q));
          H[n][n] = H[n][n] + exshift;
          H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;
          x = H[n][n];

          if (q >= 0) {
            z = p >= 0 ? p + z : p - z;
            d[n - 1] = x + z;
            d[n] = d[n - 1];
            if (z !== 0) {
              d[n] = x - w / z;
            }
            e[n - 1] = 0;
            e[n] = 0;
            x = H[n][n - 1];
            s = Math.abs(x) + Math.abs(z);
            p = x / s;
            q = z / s;
            r = Math.sqrt(p * p + q * q);
            p = p / r;
            q = q / r;

            for (j = n - 1; j < nn; j++) {
              z = H[n - 1][j];
              H[n - 1][j] = q * z + p * H[n][j];
              H[n][j] = q * H[n][j] - p * z;
            }

            for (i = 0; i <= n; i++) {
              z = H[i][n - 1];
              H[i][n - 1] = q * z + p * H[i][n];
              H[i][n] = q * H[i][n] - p * z;
            }

            for (i = low; i <= high; i++) {
              z = V[i][n - 1];
              V[i][n - 1] = q * z + p * V[i][n];
              V[i][n] = q * V[i][n] - p * z;
            }
          } else {
            d[n - 1] = x + p;
            d[n] = x + p;
            e[n - 1] = z;
            e[n] = -z;
          }

          n = n - 2;
          iter = 0;
        } else {
          x = H[n][n];
          y = 0;
          w = 0;
          if (l < n) {
            y = H[n - 1][n - 1];
            w = H[n][n - 1] * H[n - 1][n];
          }

          if (iter === 10) {
            exshift += x;
            for (i = low; i <= n; i++) {
              H[i][i] -= x;
            }
            s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);
            x = y = 0.75 * s;
            w = -0.4375 * s * s;
          }

          if (iter === 30) {
            s = (y - x) / 2;
            s = s * s + w;
            if (s > 0) {
              s = Math.sqrt(s);
              if (y < x) {
                s = -s;
              }
              s = x - w / ((y - x) / 2 + s);
              for (i = low; i <= n; i++) {
                H[i][i] -= s;
              }
              exshift += s;
              x = y = w = 0.964;
            }
          }

          iter = iter + 1;

          m = n - 2;
          while (m >= l) {
            z = H[m][m];
            r = x - z;
            s = y - z;
            p = (r * s - w) / H[m + 1][m] + H[m][m + 1];
            q = H[m + 1][m + 1] - z - r - s;
            r = H[m + 2][m + 1];
            s = Math.abs(p) + Math.abs(q) + Math.abs(r);
            p = p / s;
            q = q / s;
            r = r / s;
            if (m === l) {
              break;
            }
            if (
              Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) <
              eps *
                (Math.abs(p) *
                  (Math.abs(H[m - 1][m - 1]) +
                    Math.abs(z) +
                    Math.abs(H[m + 1][m + 1])))
            ) {
              break;
            }
            m--;
          }

          for (i = m + 2; i <= n; i++) {
            H[i][i - 2] = 0;
            if (i > m + 2) {
              H[i][i - 3] = 0;
            }
          }

          for (k = m; k <= n - 1; k++) {
            notlast = k !== n - 1;
            if (k !== m) {
              p = H[k][k - 1];
              q = H[k + 1][k - 1];
              r = notlast ? H[k + 2][k - 1] : 0;
              x = Math.abs(p) + Math.abs(q) + Math.abs(r);
              if (x !== 0) {
                p = p / x;
                q = q / x;
                r = r / x;
              }
            }

            if (x === 0) {
              break;
            }

            s = Math.sqrt(p * p + q * q + r * r);
            if (p < 0) {
              s = -s;
            }

            if (s !== 0) {
              if (k !== m) {
                H[k][k - 1] = -s * x;
              } else if (l !== m) {
                H[k][k - 1] = -H[k][k - 1];
              }

              p = p + s;
              x = p / s;
              y = q / s;
              z = r / s;
              q = q / p;
              r = r / p;

              for (j = k; j < nn; j++) {
                p = H[k][j] + q * H[k + 1][j];
                if (notlast) {
                  p = p + r * H[k + 2][j];
                  H[k + 2][j] = H[k + 2][j] - p * z;
                }

                H[k][j] = H[k][j] - p * x;
                H[k + 1][j] = H[k + 1][j] - p * y;
              }

              for (i = 0; i <= Math.min(n, k + 3); i++) {
                p = x * H[i][k] + y * H[i][k + 1];
                if (notlast) {
                  p = p + z * H[i][k + 2];
                  H[i][k + 2] = H[i][k + 2] - p * r;
                }

                H[i][k] = H[i][k] - p;
                H[i][k + 1] = H[i][k + 1] - p * q;
              }

              for (i = low; i <= high; i++) {
                p = x * V[i][k] + y * V[i][k + 1];
                if (notlast) {
                  p = p + z * V[i][k + 2];
                  V[i][k + 2] = V[i][k + 2] - p * r;
                }

                V[i][k] = V[i][k] - p;
                V[i][k + 1] = V[i][k + 1] - p * q;
              }
            }
          }
        }
      }

      if (norm === 0) {
        return;
      }

      for (n = nn - 1; n >= 0; n--) {
        p = d[n];
        q = e[n];

        if (q === 0) {
          l = n;
          H[n][n] = 1;
          for (i = n - 1; i >= 0; i--) {
            w = H[i][i] - p;
            r = 0;
            for (j = l; j <= n; j++) {
              r = r + H[i][j] * H[j][n];
            }

            if (e[i] < 0) {
              z = w;
              s = r;
            } else {
              l = i;
              if (e[i] === 0) {
                H[i][n] = w !== 0 ? -r / w : -r / (eps * norm);
              } else {
                x = H[i][i + 1];
                y = H[i + 1][i];
                q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
                t = (x * s - z * r) / q;
                H[i][n] = t;
                H[i + 1][n] =
                  Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z;
              }

              t = Math.abs(H[i][n]);
              if (eps * t * t > 1) {
                for (j = i; j <= n; j++) {
                  H[j][n] = H[j][n] / t;
                }
              }
            }
          }
        } else if (q < 0) {
          l = n - 1;

          if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {
            H[n - 1][n - 1] = q / H[n][n - 1];
            H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];
          } else {
            cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);
            H[n - 1][n - 1] = cdivres[0];
            H[n - 1][n] = cdivres[1];
          }

          H[n][n - 1] = 0;
          H[n][n] = 1;
          for (i = n - 2; i >= 0; i--) {
            ra = 0;
            sa = 0;
            for (j = l; j <= n; j++) {
              ra = ra + H[i][j] * H[j][n - 1];
              sa = sa + H[i][j] * H[j][n];
            }

            w = H[i][i] - p;

            if (e[i] < 0) {
              z = w;
              r = ra;
              s = sa;
            } else {
              l = i;
              if (e[i] === 0) {
                cdivres = cdiv(-ra, -sa, w, q);
                H[i][n - 1] = cdivres[0];
                H[i][n] = cdivres[1];
              } else {
                x = H[i][i + 1];
                y = H[i + 1][i];
                vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
                vi = (d[i] - p) * 2 * q;
                if (vr === 0 && vi === 0) {
                  vr =
                    eps *
                    norm *
                    (Math.abs(w) +
                      Math.abs(q) +
                      Math.abs(x) +
                      Math.abs(y) +
                      Math.abs(z));
                }
                cdivres = cdiv(
                  x * r - z * ra + q * sa,
                  x * s - z * sa - q * ra,
                  vr,
                  vi
                );
                H[i][n - 1] = cdivres[0];
                H[i][n] = cdivres[1];
                if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
                  H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;
                  H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;
                } else {
                  cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);
                  H[i + 1][n - 1] = cdivres[0];
                  H[i + 1][n] = cdivres[1];
                }
              }

              t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));
              if (eps * t * t > 1) {
                for (j = i; j <= n; j++) {
                  H[j][n - 1] = H[j][n - 1] / t;
                  H[j][n] = H[j][n] / t;
                }
              }
            }
          }
        }
      }

      for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
          for (j = i; j < nn; j++) {
            V[i][j] = H[i][j];
          }
        }
      }

      for (j = nn - 1; j >= low; j--) {
        for (i = low; i <= high; i++) {
          z = 0;
          for (k = low; k <= Math.min(j, high); k++) {
            z = z + V[i][k] * H[k][j];
          }
          V[i][j] = z;
        }
      }
    }

    function cdiv(xr, xi, yr, yi) {
      var r, d;
      if (Math.abs(yr) > Math.abs(yi)) {
        r = yi / yr;
        d = yr + r * yi;
        return [(xr + r * xi) / d, (xi - r * xr) / d];
      } else {
        r = yr / yi;
        d = yi + r * yr;
        return [(r * xr + xi) / d, (r * xi - xr) / d];
      }
    }

    /**
     * @class CholeskyDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs
     * @param {Matrix} value
     */
    class CholeskyDecomposition {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        if (!value.isSymmetric()) {
          throw new Error('Matrix is not symmetric');
        }

        var a = value;
        var dimension = a.rows;
        var l = new Matrix(dimension, dimension);
        var positiveDefinite = true;
        var i, j, k;

        for (j = 0; j < dimension; j++) {
          var Lrowj = l[j];
          var d = 0;
          for (k = 0; k < j; k++) {
            var Lrowk = l[k];
            var s = 0;
            for (i = 0; i < k; i++) {
              s += Lrowk[i] * Lrowj[i];
            }
            Lrowj[k] = s = (a.get(j, k) - s) / l[k][k];
            d = d + s * s;
          }

          d = a.get(j, j) - d;

          positiveDefinite &= d > 0;
          l[j][j] = Math.sqrt(Math.max(d, 0));
          for (k = j + 1; k < dimension; k++) {
            l[j][k] = 0;
          }
        }

        if (!positiveDefinite) {
          throw new Error('Matrix is not positive definite');
        }

        this.L = l;
      }

      /**
       *
       * @param {Matrix} value
       * @return {Matrix}
       */
      solve(value) {
        value = WrapperMatrix2D.checkMatrix(value);

        var l = this.L;
        var dimension = l.rows;

        if (value.rows !== dimension) {
          throw new Error('Matrix dimensions do not match');
        }

        var count = value.columns;
        var B = value.clone();
        var i, j, k;

        for (k = 0; k < dimension; k++) {
          for (j = 0; j < count; j++) {
            for (i = 0; i < k; i++) {
              B[k][j] -= B[i][j] * l[k][i];
            }
            B[k][j] /= l[k][k];
          }
        }

        for (k = dimension - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            for (i = k + 1; i < dimension; i++) {
              B[k][j] -= B[i][j] * l[i][k];
            }
            B[k][j] /= l[k][k];
          }
        }

        return B;
      }

      /**
       *
       * @return {Matrix}
       */
      get lowerTriangularMatrix() {
        return this.L;
      }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var func$3 = Symbol('func');
    var validate = Symbol('validate');

    var symbols$1 = {
    	func: func$3,
    	validate: validate
    };

    const { func: func$2 } = symbols$1;

    const numberPredicates = {
      positive: (value) => (value > 0),
      negative: (value) => (value < 0),
      nonNegative: (value) => (value >= 0),
      integer: (value) => (value === (value | 0)),

      [func$2]: {
        is: (fn) => fn,
        eq: (v) => (value) => (value === v),
        gt: (v) => (value) => (value > v),
        gte: (v) => (value) => (value >= v),
        lt: (v) => (value) => (value < v),
        lte: (v) => (value) => (value <= v)
      }
    };

    var number$4 = {
      predicates: numberPredicates,
      validator: (value) => {
        return typeof value === 'number'
      }
    };

    const { func: func$1 } = symbols$1;

    const stringPredicates = {
      empty: (value) => (value === ''),
      nonEmpty: (value) => (value !== ''),

      [func$1]: {
        is: (fn) => fn,
        eq: (v) => (value) => (value === v),
        length: (v) => (value) => (value.length === v),
        minLength: (v) => (value) => (value.length >= v),
        maxLength: (v) => (value) => (value.length <= v),
        matches: (v) => (value) => v.test(value),
        startsWith: (v) => (value) => value.startsWith(v),
        endsWith: (v) => (value) => value.endsWith(v)
      }
    };

    var string = {
      predicates: stringPredicates,
      validator: (value) => {
        return typeof value === 'string'
      }
    };

    const { func } = symbols$1;

    const objectPredicates = {
      plain: (value) => {
        if (typeof value !== 'object') return false

        const proto = Object.getPrototypeOf(value);
        return proto === null || proto === Object.getPrototypeOf({})
      },
      empty: (value) => Object.keys(value).length === 0,
      nonEmpty: (value) => Object.keys(value).length > 0,

      [func]: {
        is: (fn) => fn,
        instanceOf: (v) => (value) => (value instanceof v)
      }
    };

    var object$2 = {
      predicates: objectPredicates,
      validator: (value) => {
        return typeof value === 'object'
      }
    };

    const typePredicates = {
      number: number$4,
      string,
      object: object$2
    };

    const createOw = ({
      validators = [],
      predicates = typePredicates,
      type = null
    } = { }) => {
      const ow = new Proxy(function () { }, {
        get: (obj, key) => {
          if (key === symbols$1.validate) {
            return (value, label = 'argument') => {
              if (!type) {
                return new Error('missing required type specifier')
              }

              for (let i = 0; i < validators.length; ++i) {
                const validator = validators[i];
                const result = validator.fn(value);

                if (!result) {
                  if (i === 0) {
                    throw new Error(`Expected ${label} \`${value}\` to be of type \`${type}\`, but received type \`${typeof value}\``)
                  } else {
                    throw new Error(`Expected ${type} \`${label}\` \`${value}\` failed predicate \`${validator.key}\``)
                  }
                }
              }
            }
          }

          const predicate = predicates[key];

          if (predicate) {
            if (typeof predicate === 'function') {
              validators.push({
                key,
                fn: predicate
              });

              return ow
            } else {
              return createOw({
                type: key,
                validators: [
                  {
                    key,
                    fn: predicate.validator
                  }
                ],
                predicates: predicate.predicates
              })
            }
          } else {
            const fn = predicates[symbols$1.func] && predicates[symbols$1.func][key];

            if (fn) {
              return new Proxy(function () { }, {
                get: () => {
                  throw new Error(`invalid use of functional predicate "${key}"`)
                },

                apply: (obj, thisArg, args) => {
                  validators.push({
                    key,
                    fn: fn(...args)
                  });

                  return ow
                }
              })
            } else {
              if (key === 'default' || key === '__esModule') {
                return ow
              }

              return ow
              // throw new Error(`unrecognized predicate "${key}"`)
            }
          }
        },

        apply: (obj, thisArg, args) => {
          if (args.length !== 2 && args.length !== 3) {
            throw new Error('invalid number of arguments to "ow"')
          } else {
            args[1][symbols$1.validate](args[0], args[2]);
          }
        }
      });

      return ow
    };

    var owLite = createOw();

    var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var RNG = function () {
      function RNG() {
        _classCallCheck$1(this, RNG);
      }

      _createClass$1(RNG, [{
        key: 'next',
        value: function next() {
          throw new Error('RNG.next must be overridden');
        }
      }, {
        key: 'seed',
        value: function seed(_seed, opts) {
          throw new Error('RNG.seed must be overridden');
        }
      }, {
        key: 'clone',
        value: function clone(seed, opts) {
          throw new Error('RNG.clone must be overridden');
        }
      }, {
        key: '_seed',
        value: function _seed(seed, opts) {
          // TODO: add entropy and stuff

          if (seed === (seed | 0)) {
            return seed;
          } else {
            var strSeed = '' + seed;
            var s = 0;

            for (var k = 0; k < strSeed.length; ++k) {
              s ^= strSeed.charCodeAt(k) | 0;
            }

            return s;
          }
        }
      }, {
        key: 'name',
        get: function get() {
          throw new Error('RNG.name must be overridden');
        }
      }]);

      return RNG;
    }();

    var _default$g = RNG;


    var rng = /*#__PURE__*/Object.defineProperty({
    	default: _default$g
    }, '__esModule', {value: true});

    var alea = createCommonjsModule(function (module) {
    // A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
    // http://baagoe.com/en/RandomMusings/javascript/
    // https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
    // Original work is under MIT license -

    // Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.



    (function(global, module, define) {

    function Alea(seed) {
      var me = this, mash = Mash();

      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };

      // Apply the seeding algorithm from Baagoe.
      me.c = 1;
      me.s0 = mash(' ');
      me.s1 = mash(' ');
      me.s2 = mash(' ');
      me.s0 -= mash(seed);
      if (me.s0 < 0) { me.s0 += 1; }
      me.s1 -= mash(seed);
      if (me.s1 < 0) { me.s1 += 1; }
      me.s2 -= mash(seed);
      if (me.s2 < 0) { me.s2 += 1; }
      mash = null;
    }

    function copy(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }

    function impl(seed, opts) {
      var xg = new Alea(seed),
          state = opts && opts.state,
          prng = xg.next;
      prng.int32 = function() { return (xg.next() * 0x100000000) | 0; };
      prng.double = function() {
        return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
      };
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    function Mash() {
      var n = 0xefc8249d;

      var mash = function(data) {
        data = String(data);
        for (var i = 0; i < data.length; i++) {
          n += data.charCodeAt(i);
          var h = 0.02519603282416938 * n;
          n = h >>> 0;
          h -= n;
          h *= n;
          n = h >>> 0;
          h -= n;
          n += h * 0x100000000; // 2^32
        }
        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
      };

      return mash;
    }


    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.alea = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xor128 = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xor128" prng algorithm by
    // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;

      // Set up generator function.
      me.next = function() {
        var t = me.x ^ (me.x << 11);
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
      };

      if (seed === (seed | 0)) {
        // Integer seed.
        me.x = seed;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }

    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }

    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xor128 = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xorwow = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xorwow" prng algorithm by
    // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      // Set up generator function.
      me.next = function() {
        var t = (me.x ^ (me.x >>> 2));
        me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
        return (me.d = (me.d + 362437 | 0)) +
           (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
      };

      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;

      if (seed === (seed | 0)) {
        // Integer seed.
        me.x = seed;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }

    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }

    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xorwow = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xorshift7 = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xorshift7" algorithm by
    // Franois Panneton and Pierre L'ecuyer:
    // "On the Xorgshift Random Number Generators"
    // http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this;

      // Set up generator function.
      me.next = function() {
        // Update xor generator.
        var X = me.x, i = me.i, t, v;
        t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
        t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
        t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
        t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
        t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
        X[i] = v;
        me.i = (i + 1) & 7;
        return v;
      };

      function init(me, seed) {
        var j, X = [];

        if (seed === (seed | 0)) {
          // Seed state array using a 32-bit integer.
          X[0] = seed;
        } else {
          // Seed state using a string.
          seed = '' + seed;
          for (j = 0; j < seed.length; ++j) {
            X[j & 7] = (X[j & 7] << 15) ^
                (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
          }
        }
        // Enforce an array length of 8, not all zeroes.
        while (X.length < 8) X.push(0);
        for (j = 0; j < 8 && X[j] === 0; ++j);
        if (j == 8) X[7] = -1;

        me.x = X;
        me.i = 0;

        // Discard an initial 256 values.
        for (j = 256; j > 0; --j) {
          me.next();
        }
      }

      init(me, seed);
    }

    function copy(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }

    function impl(seed, opts) {
      if (seed == null) seed = +(new Date);
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.x) copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xorshift7 = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xor4096 = createCommonjsModule(function (module) {
    // A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
    //
    // This fast non-cryptographic random number generator is designed for
    // use in Monte-Carlo algorithms. It combines a long-period xorshift
    // generator with a Weyl generator, and it passes all common batteries
    // of stasticial tests for randomness while consuming only a few nanoseconds
    // for each prng generated.  For background on the generator, see Brent's
    // paper: "Some long-period random number generators using shifts and xors."
    // http://arxiv.org/pdf/1004.3115v1.pdf
    //
    // Usage:
    //
    // var xor4096 = require('xor4096');
    // random = xor4096(1);                        // Seed with int32 or string.
    // assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
    // assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
    //
    // For nonzero numeric keys, this impelementation provides a sequence
    // identical to that by Brent's xorgens 3 implementaion in C.  This
    // implementation also provides for initalizing the generator with
    // string seeds, or for saving and restoring the state of the generator.
    //
    // On Chrome, this prng benchmarks about 2.1 times slower than
    // Javascript's built-in Math.random().

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this;

      // Set up generator function.
      me.next = function() {
        var w = me.w,
            X = me.X, i = me.i, t, v;
        // Update Weyl generator.
        me.w = w = (w + 0x61c88647) | 0;
        // Update xor generator.
        v = X[(i + 34) & 127];
        t = X[i = ((i + 1) & 127)];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        // Update Xor generator array state.
        v = X[i] = v ^ t;
        me.i = i;
        // Result is the combination.
        return (v + (w ^ (w >>> 16))) | 0;
      };

      function init(me, seed) {
        var t, v, i, j, w, X = [], limit = 128;
        if (seed === (seed | 0)) {
          // Numeric seeds initialize v, which is used to generates X.
          v = seed;
          seed = null;
        } else {
          // String seeds are mixed into v and X one character at a time.
          seed = seed + '\0';
          v = 0;
          limit = Math.max(limit, seed.length);
        }
        // Initialize circular array and weyl value.
        for (i = 0, j = -32; j < limit; ++j) {
          // Put the unicode characters into the array, and shuffle them.
          if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
          // After 32 shuffles, take v as the starting w value.
          if (j === 0) w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = (w + 0x61c88647) | 0;     // Weyl.
            t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
            i = (0 == t) ? i + 1 : 0;     // Count zeroes.
          }
        }
        // We have detected all zeroes; make the key nonzero.
        if (i >= 128) {
          X[(seed && seed.length || 0) & 127] = -1;
        }
        // Run the generator 512 times to further mix the state before using it.
        // Factoring this as a function slows the main generator, so it is just
        // unrolled here.  The weyl generator is not advanced while warming up.
        i = 127;
        for (j = 4 * 128; j > 0; --j) {
          v = X[(i + 34) & 127];
          t = X[i = ((i + 1) & 127)];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i] = v ^ t;
        }
        // Storing state as object members is faster than using closure variables.
        me.w = w;
        me.X = X;
        me.i = i;
      }

      init(me, seed);
    }

    function copy(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null) seed = +(new Date);
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.X) copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xor4096 = impl;
    }

    })(
      commonjsGlobal,                                     // window object or global
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var tychei = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "Tyche-i" prng algorithm by
    // Samuel Neves and Filipe Araujo.
    // See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      // Set up generator function.
      me.next = function() {
        var b = me.b, c = me.c, d = me.d, a = me.a;
        b = (b << 25) ^ (b >>> 7) ^ c;
        c = (c - d) | 0;
        d = (d << 24) ^ (d >>> 8) ^ a;
        a = (a - b) | 0;
        me.b = b = (b << 20) ^ (b >>> 12) ^ c;
        me.c = c = (c - d) | 0;
        me.d = (d << 16) ^ (c >>> 16) ^ a;
        return me.a = (a - b) | 0;
      };

      /* The following is non-inverted tyche, which has better internal
       * bit diffusion, but which is about 25% slower than tyche-i in JS.
      me.next = function() {
        var a = me.a, b = me.b, c = me.c, d = me.d;
        a = (me.a + me.b | 0) >>> 0;
        d = me.d ^ a; d = d << 16 ^ d >>> 16;
        c = me.c + d | 0;
        b = me.b ^ c; b = b << 12 ^ d >>> 20;
        me.a = a = a + b | 0;
        d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
        me.c = c = c + d | 0;
        b = b ^ c;
        return me.b = (b << 7 ^ b >>> 25);
      }
      */

      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;

      if (seed === Math.floor(seed)) {
        // Integer seed.
        me.a = (seed / 0x100000000) | 0;
        me.b = seed | 0;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }

    function copy(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.tychei = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

    /*
    Copyright 2019 David Bau.

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    */

    var seedrandom$1 = createCommonjsModule(function (module) {
    (function (global, pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //

    var width = 256,        // each RC4 output is 0 <= x < 256
        chunks = 6,         // at least six RC4 outputs for each double
        digits = 52,        // there are 52 significant digits in a double
        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks),
        significance = math.pow(2, digits),
        overflow = significance * 2,
        mask = width - 1,
        nodecrypto;         // node.js crypto module, initialized at the bottom.

    //
    // seedrandom()
    // This is the seedrandom function described above.
    //
    function seedrandom(seed, options, callback) {
      var key = [];
      options = (options == true) ? { entropy: true } : (options || {});

      // Flatten the seed string or build one from local entropy if needed.
      var shortseed = mixkey(flatten(
        options.entropy ? [seed, tostring(pool)] :
        (seed == null) ? autoseed() : seed, 3), key);

      // Use the seed to initialize an ARC4 generator.
      var arc4 = new ARC4(key);

      // This function returns a random double in [0, 1) that contains
      // randomness in every bit of the mantissa of the IEEE 754 value.
      var prng = function() {
        var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
            d = startdenom,                 //   and denominator d = 2 ^ 48.
            x = 0;                          //   and no 'extra last byte'.
        while (n < significance) {          // Fill up all significant digits by
          n = (n + x) * width;              //   shifting numerator and
          d *= width;                       //   denominator and generating a
          x = arc4.g(1);                    //   new least-significant-byte.
        }
        while (n >= overflow) {             // To avoid rounding up, before adding
          n /= 2;                           //   last byte, shift everything
          d /= 2;                           //   right using integer math until
          x >>>= 1;                         //   we have exactly the desired bits.
        }
        return (n + x) / d;                 // Form the number within [0, 1).
      };

      prng.int32 = function() { return arc4.g(4) | 0; };
      prng.quick = function() { return arc4.g(4) / 0x100000000; };
      prng.double = prng;

      // Mix the randomness into accumulated entropy.
      mixkey(tostring(arc4.S), pool);

      // Calling convention: what to return as a function of prng, seed, is_math.
      return (options.pass || callback ||
          function(prng, seed, is_math_call, state) {
            if (state) {
              // Load the arc4 state from the given state if it has an S array.
              if (state.S) { copy(state, arc4); }
              // Only provide the .state method if requested via options.state.
              prng.state = function() { return copy(arc4, {}); };
            }

            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) { math[rngname] = prng; return seed; }

            // Otherwise, it is a newer calling convention, so return the
            // prng directly.
            else return prng;
          })(
      prng,
      shortseed,
      'global' in options ? options.global : (this == math),
      options.state);
    }

    //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
    function ARC4(key) {
      var t, keylen = key.length,
          me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

      // The empty key [] is treated as [0].
      if (!keylen) { key = [keylen++]; }

      // Set up S using the standard key scheduling algorithm.
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0; i < width; i++) {
        s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
        s[j] = t;
      }

      // The "g" method returns the next (count) outputs as one number.
      (me.g = function(count) {
        // Using instance members instead of closure state nearly doubles speed.
        var t, r = 0,
            i = me.i, j = me.j, s = me.S;
        while (count--) {
          t = s[i = mask & (i + 1)];
          r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
        }
        me.i = i; me.j = j;
        return r;
        // For robust unpredictability, the function call below automatically
        // discards an initial batch of values.  This is called RC4-drop[256].
        // See http://google.com/search?q=rsa+fluhrer+response&btnI
      })(width);
    }

    //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //
    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //
    function flatten(obj, depth) {
      var result = [], typ = (typeof obj), prop;
      if (depth && typ == 'object') {
        for (prop in obj) {
          try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
        }
      }
      return (result.length ? result : typ == 'string' ? obj : obj + '\0');
    }

    //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //
    function mixkey(seed, key) {
      var stringseed = seed + '', smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] =
          mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
      }
      return tostring(key);
    }

    //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          // The use of 'out' to remember randomBytes makes tight minified code.
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global.crypto || global.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e) {
        var browser = global.navigator,
            plugins = browser && browser.plugins;
        return [+new Date, global, plugins, global.screen, tostring(pool)];
      }
    }

    //
    // tostring()
    // Converts an array of charcodes to a string
    //
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }

    //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //
    mixkey(math.random(), pool);

    //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //
    if (module.exports) {
      module.exports = seedrandom;
      // When in node.js, try using crypto package for autoseeding.
      try {
        nodecrypto = require$$0;
      } catch (ex) {}
    } else {
      // When included as a plain script, set up Math.seedrandom global.
      math['seed' + rngname] = seedrandom;
    }


    // End anonymous scope, and pass initial values.
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      (typeof self !== 'undefined') ? self : commonjsGlobal,
      [],     // pool: entropy pool starts empty
      Math    // math: package containing random, pow, and seedrandom
    );
    });

    // A library of seedable RNGs implemented in Javascript.
    //
    // Usage:
    //
    // var seedrandom = require('seedrandom');
    // var random = seedrandom(1); // or any seed.
    // var x = random();       // 0 <= x < 1.  Every bit is random.
    // var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

    // alea, a 53-bit multiply-with-carry generator by Johannes Baage.
    // Period: ~2^116
    // Reported to pass all BigCrush tests.


    // xor128, a pure xor-shift generator by George Marsaglia.
    // Period: 2^128-1.
    // Reported to fail: MatrixRank and LinearComp.


    // xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
    // Period: 2^192-2^32
    // Reported to fail: CollisionOver, SimpPoker, and LinearComp.


    // xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
    // a different approach: it adds robustness by allowing more shifts
    // than Marsaglia's original three.  It is a 7-shift generator
    // with 256 bits, that passes BigCrush with no systmatic failures.
    // Period 2^256-1.
    // No systematic BigCrush failures reported.


    // xor4096, by Richard Brent, is a 4096-bit xor-shift with a
    // very long period that also adds a Weyl generator. It also passes
    // BigCrush with no systematic failures.  Its long period may
    // be useful if you have many generators and need to avoid
    // collisions.
    // Period: 2^4128-2^32.
    // No systematic BigCrush failures reported.


    // Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
    // number generator derived from ChaCha, a modern stream cipher.
    // https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
    // Period: ~2^127
    // No systematic BigCrush failures reported.


    // The original ARC4-based prng included in this library.
    // Period: ~2^1600


    seedrandom$1.alea = alea;
    seedrandom$1.xor128 = xor128;
    seedrandom$1.xorwow = xorwow;
    seedrandom$1.xorshift7 = xorshift7;
    seedrandom$1.xor4096 = xor4096;
    seedrandom$1.tychei = tychei;

    var seedrandom = seedrandom$1;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



    var _owLite2$b = _interopRequireDefault$c(owLite);



    var _rng2$1 = _interopRequireDefault$c(rng);

    function _interopRequireDefault$c(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var RNGFunction = function (_RNG) {
      _inherits(RNGFunction, _RNG);

      function RNGFunction(thunk, opts) {
        _classCallCheck(this, RNGFunction);

        var _this = _possibleConstructorReturn(this, (RNGFunction.__proto__ || Object.getPrototypeOf(RNGFunction)).call(this));

        _this.seed(thunk, opts);
        return _this;
      }

      _createClass(RNGFunction, [{
        key: 'next',
        value: function next() {
          return this._rng();
        }
      }, {
        key: 'seed',
        value: function seed(thunk) {
          (0, _owLite2$b.default)(thunk, _owLite2$b.default.function);
          this._rng = thunk;
        }
      }, {
        key: 'clone',
        value: function clone() {
          for (var _len = arguments.length, opts = Array(_len), _key = 0; _key < _len; _key++) {
            opts[_key] = arguments[_key];
          }

          return new (Function.prototype.bind.apply(RNGFunction, [null].concat([this._rng], opts)))();
        }
      }, {
        key: 'name',
        get: function get() {
          return 'function';
        }
      }]);

      return RNGFunction;
    }(_rng2$1.default);

    var _default$f = RNGFunction;


    var _function = /*#__PURE__*/Object.defineProperty({
    	default: _default$f
    }, '__esModule', {value: true});

    var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



    var _seedrandom2 = _interopRequireDefault$b(seedrandom);



    var _rng2 = _interopRequireDefault$b(rng);



    var _function2 = _interopRequireDefault$b(_function);

    function _interopRequireDefault$b(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    var _default$e = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _args$ = args[0],
          arg0 = _args$ === undefined ? 'default' : _args$,
          rest = args.slice(1);


      switch (typeof arg0 === 'undefined' ? 'undefined' : _typeof$1(arg0)) {
        case 'object':
          if (arg0 instanceof _rng2.default) {
            return arg0;
          }
          break;

        case 'function':
          return new _function2.default(arg0);

        case 'string':
        case 'number':
          return new _function2.default(_seedrandom2.default.apply(undefined, _toConsumableArray(rest)));
      }

      throw new Error('invalid RNG "' + arg0 + '"');
    };


    var rngFactory = /*#__PURE__*/Object.defineProperty({
    	default: _default$e
    }, '__esModule', {value: true});

    var _owLite2$a = _interopRequireDefault$a(owLite);

    function _interopRequireDefault$a(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$d = function (random, min, max) {
      if (max === undefined) {
        max = min === undefined ? 1 : min;
        min = 0;
      }

      (0, _owLite2$a.default)(min, _owLite2$a.default.number);
      (0, _owLite2$a.default)(max, _owLite2$a.default.number);

      return function () {
        return random.next() * (max - min) + min;
      };
    };


    var uniform$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$d
    }, '__esModule', {value: true});

    var _owLite2$9 = _interopRequireDefault$9(owLite);

    function _interopRequireDefault$9(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$c = function (random, min, max) {
      if (max === undefined) {
        max = min === undefined ? 1 : min;
        min = 0;
      }

      (0, _owLite2$9.default)(min, _owLite2$9.default.number.integer);
      (0, _owLite2$9.default)(max, _owLite2$9.default.number.integer);

      return function () {
        return random.next() * (max - min + 1) + min | 0;
      };
    };


    var uniformInt = /*#__PURE__*/Object.defineProperty({
    	default: _default$c
    }, '__esModule', {value: true});

    var _default$b = function (random) {
      return function () {
        return random.next() >= 0.5;
      };
    };


    var uniformBoolean = /*#__PURE__*/Object.defineProperty({
    	default: _default$b
    }, '__esModule', {value: true});

    var _owLite2$8 = _interopRequireDefault$8(owLite);

    function _interopRequireDefault$8(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$a = function (random) {
      var mu = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var sigma = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      (0, _owLite2$8.default)(mu, _owLite2$8.default.number);
      (0, _owLite2$8.default)(sigma, _owLite2$8.default.number);

      return function () {
        var x = void 0,
            y = void 0,
            r = void 0;

        do {
          x = random.next() * 2 - 1;
          y = random.next() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);

        return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
      };
    };


    var normal$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$a
    }, '__esModule', {value: true});

    var _default$9 = function (random) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var normal = random.normal.apply(random, args);

      return function () {
        return Math.exp(normal());
      };
    };


    var logNormal$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$9
    }, '__esModule', {value: true});

    var _owLite2$7 = _interopRequireDefault$7(owLite);

    function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$8 = function (random) {
      var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

      (0, _owLite2$7.default)(p, _owLite2$7.default.number.gte(0).lt(1));

      return function () {
        return random.next() + p | 0;
      };
    };


    var bernoulli$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$8
    }, '__esModule', {value: true});

    var _owLite2$6 = _interopRequireDefault$6(owLite);

    function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$7 = function (random) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;

      (0, _owLite2$6.default)(n, _owLite2$6.default.number.positive.integer);
      (0, _owLite2$6.default)(p, _owLite2$6.default.number.gte(0).lte(1));

      return function () {
        var i = 0;
        var x = 0;

        while (i++ < n) {
          x += random.next() < p;
        }

        return x;
      };
    };


    var binomial$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$7
    }, '__esModule', {value: true});

    var _owLite2$5 = _interopRequireDefault$5(owLite);

    function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$6 = function (random) {
      var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

      (0, _owLite2$5.default)(p, _owLite2$5.default.number.gt(0).lte(1));
      var invLogP = 1.0 / Math.log(1.0 - p);

      return function () {
        return 1 + Math.log(random.next()) * invLogP | 0;
      };
    };


    var geometric$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$6
    }, '__esModule', {value: true});

    var _owLite2$4 = _interopRequireDefault$4(owLite);

    function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var logFactorialTable = [0.0, 0.0, 0.69314718055994529, 1.7917594692280550, 3.1780538303479458, 4.7874917427820458, 6.5792512120101012, 8.5251613610654147, 10.604602902745251, 12.801827480081469];

    var logFactorial = function logFactorial(k) {
      return logFactorialTable[k];
    };

    var logSqrt2PI = 0.91893853320467267;

    var _default$5 = function (random) {
      var lambda = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$4.default)(lambda, _owLite2$4.default.number.positive);

      if (lambda < 10) {
        // inversion method
        var expMean = Math.exp(-lambda);

        return function () {
          var p = expMean;
          var x = 0;
          var u = random.next();

          while (u > p) {
            u = u - p;
            p = lambda * p / ++x;
          }

          return x;
        };
      } else {
        // generative method
        var smu = Math.sqrt(lambda);
        var b = 0.931 + 2.53 * smu;
        var a = -0.059 + 0.02483 * b;
        var invAlpha = 1.1239 + 1.1328 / (b - 3.4);
        var vR = 0.9277 - 3.6224 / (b - 2);

        return function () {
          while (true) {
            var u = void 0;
            var v = random.next();

            if (v <= 0.86 * vR) {
              u = v / vR - 0.43;
              return Math.floor((2 * a / (0.5 - Math.abs(u)) + b) * u + lambda + 0.445);
            }

            if (v >= vR) {
              u = random.next() - 0.5;
            } else {
              u = v / vR - 0.93;
              u = (u < 0 ? -0.5 : 0.5) - u;
              v = random.next() * vR;
            }

            var us = 0.5 - Math.abs(u);
            if (us < 0.013 && v > us) {
              continue;
            }

            var k = Math.floor((2 * a / us + b) * u + lambda + 0.445) | 0;
            v = v * invAlpha / (a / (us * us) + b);

            if (k >= 10) {
              var t = (k + 0.5) * Math.log(lambda / k) - lambda - logSqrt2PI + k - (1 / 12.0 - (1 / 360.0 - 1 / (1260.0 * k * k)) / (k * k)) / k;

              if (Math.log(v * smu) <= t) {
                return k;
              }
            } else if (k >= 0) {
              if (Math.log(v) <= k * Math.log(lambda) - lambda - logFactorial(k)) {
                return k;
              }
            }
          }
        };
      }
    };


    var poisson$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$5
    }, '__esModule', {value: true});

    var _owLite2$3 = _interopRequireDefault$3(owLite);

    function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$4 = function (random) {
      var lambda = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$3.default)(lambda, _owLite2$3.default.number.positive);

      return function () {
        return -Math.log(1 - random.next()) / lambda;
      };
    };


    var exponential$2 = /*#__PURE__*/Object.defineProperty({
    	default: _default$4
    }, '__esModule', {value: true});

    var _owLite2$2 = _interopRequireDefault$2(owLite);

    function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$3 = function (random) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$2.default)(n, _owLite2$2.default.number.integer.gte(0));

      return function () {
        var sum = 0;
        for (var i = 0; i < n; ++i) {
          sum += random.next();
        }

        return sum;
      };
    };


    var irwinHall$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$3
    }, '__esModule', {value: true});

    var _owLite2$1 = _interopRequireDefault$1(owLite);

    function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$2 = function (random) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$1.default)(n, _owLite2$1.default.number.integer.positive);
      var irwinHall = random.irwinHall(n);

      return function () {
        return irwinHall() / n;
      };
    };


    var bates$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$2
    }, '__esModule', {value: true});

    var _owLite2 = _interopRequireDefault(owLite);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$1 = function (random) {
      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2.default)(alpha, _owLite2.default.number.gte(0));
      var invAlpha = 1.0 / alpha;

      return function () {
        return 1.0 / Math.pow(1.0 - random.next(), invAlpha);
      };
    };


    var pareto$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$1
    }, '__esModule', {value: true});

    var random$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RNGFactory = exports.RNG = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



    var _owLite2 = _interopRequireDefault(owLite);



    var _rng2 = _interopRequireDefault(rng);



    var _rngFactory2 = _interopRequireDefault(rngFactory);



    var _uniform3 = _interopRequireDefault(uniform$1);



    var _uniformInt3 = _interopRequireDefault(uniformInt);



    var _uniformBoolean3 = _interopRequireDefault(uniformBoolean);



    var _normal3 = _interopRequireDefault(normal$1);



    var _logNormal3 = _interopRequireDefault(logNormal$1);



    var _bernoulli3 = _interopRequireDefault(bernoulli$1);



    var _binomial3 = _interopRequireDefault(binomial$1);



    var _geometric3 = _interopRequireDefault(geometric$1);



    var _poisson3 = _interopRequireDefault(poisson$1);



    var _exponential3 = _interopRequireDefault(exponential$2);



    var _irwinHall3 = _interopRequireDefault(irwinHall$1);



    var _bates3 = _interopRequireDefault(bates$1);



    var _pareto3 = _interopRequireDefault(pareto$1);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    exports.RNG = _rng2.default;
    exports.RNGFactory = _rngFactory2.default;

    /**
     * Seedable random number generator supporting many common distributions.
     *
     * Defaults to Math.random as its underlying pseudorandom number generator.
     *
     * @name Random
     * @class
     *
     * @param {RNG|function} [rng=Math.random] - Underlying pseudorandom number generator.
     */

    var Random = function () {
      function Random(rng) {
        _classCallCheck(this, Random);

        if (rng) (0, _owLite2.default)(rng, _owLite2.default.object.instanceOf(_rng2.default));

        this._cache = {};
        this.use(rng);
      }

      /**
       * @member {RNG} Underlying pseudo-random number generator
       */


      _createClass(Random, [{
        key: 'clone',


        /**
         * Creates a new `Random` instance, optionally specifying parameters to
         * set a new seed.
         *
         * @see RNG.clone
         *
         * @param {string} [seed] - Optional seed for new RNG.
         * @param {object} [opts] - Optional config for new RNG options.
         * @return {Random}
         */
        value: function clone() {
          if (arguments.length) {
            return new Random(_rngFactory2.default.apply(undefined, arguments));
          } else {
            return new Random(this.rng.clone());
          }
        }

        /**
         * Sets the underlying pseudorandom number generator used via
         * either an instance of `seedrandom`, a custom instance of RNG
         * (for PRNG plugins), or a string specifying the PRNG to use
         * along with an optional `seed` and `opts` to initialize the
         * RNG.
         *
         * @example
         * const random = require('random')
         *
         * random.use('example_seedrandom_string')
         * // or
         * random.use(seedrandom('kittens'))
         * // or
         * random.use(Math.random)
         *
         * @param {...*} args
         */

      }, {
        key: 'use',
        value: function use() {
          this._rng = _rngFactory2.default.apply(undefined, arguments);
        }

        /**
         * Patches `Math.random` with this Random instance's PRNG.
         */

      }, {
        key: 'patch',
        value: function patch() {
          if (this._patch) {
            throw new Error('Math.random already patched');
          }

          this._patch = Math.random;
          Math.random = this.uniform();
        }

        /**
         * Restores a previously patched `Math.random` to its original value.
         */

      }, {
        key: 'unpatch',
        value: function unpatch() {
          if (this._patch) {
            Math.random = this._patch;
            delete this._patch;
          }
        }

        // --------------------------------------------------------------------------
        // Uniform utility functions
        // --------------------------------------------------------------------------

        /**
         * Convenience wrapper around `this.rng.next()`
         *
         * Returns a floating point number in [0, 1).
         *
         * @return {number}
         */

      }, {
        key: 'next',
        value: function next() {
          return this._rng.next();
        }

        /**
         * Samples a uniform random floating point number, optionally specifying
         * lower and upper bounds.
         *
         * Convence wrapper around `random.uniform()`
         *
         * @param {number} [min=0] - Lower bound (float, inclusive)
         * @param {number} [max=1] - Upper bound (float, exclusive)
         * @return {number}
         */

      }, {
        key: 'float',
        value: function float(min, max) {
          return this.uniform(min, max)();
        }

        /**
         * Samples a uniform random integer, optionally specifying lower and upper
         * bounds.
         *
         * Convence wrapper around `random.uniformInt()`
         *
         * @param {number} [min=0] - Lower bound (integer, inclusive)
         * @param {number} [max=1] - Upper bound (integer, inclusive)
         * @return {number}
         */

      }, {
        key: 'int',
        value: function int(min, max) {
          return this.uniformInt(min, max)();
        }

        /**
         * Samples a uniform random integer, optionally specifying lower and upper
         * bounds.
         *
         * Convence wrapper around `random.uniformInt()`
         *
         * @alias `random.int`
         *
         * @param {number} [min=0] - Lower bound (integer, inclusive)
         * @param {number} [max=1] - Upper bound (integer, inclusive)
         * @return {number}
         */

      }, {
        key: 'integer',
        value: function integer(min, max) {
          return this.uniformInt(min, max)();
        }

        /**
         * Samples a uniform random boolean value.
         *
         * Convence wrapper around `random.uniformBoolean()`
         *
         * @alias `random.boolean`
         *
         * @return {boolean}
         */

      }, {
        key: 'bool',
        value: function bool() {
          return this.uniformBoolean()();
        }

        /**
         * Samples a uniform random boolean value.
         *
         * Convence wrapper around `random.uniformBoolean()`
         *
         * @return {boolean}
         */

      }, {
        key: 'boolean',
        value: function boolean() {
          return this.uniformBoolean()();
        }

        // --------------------------------------------------------------------------
        // Uniform distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Continuous uniform distribution](https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)).
         *
         * @param {number} [min=0] - Lower bound (float, inclusive)
         * @param {number} [max=1] - Upper bound (float, exclusive)
         * @return {function}
         */

      }, {
        key: 'uniform',
        value: function uniform(min, max) {
          return this._memoize('uniform', _uniform3.default, min, max);
        }

        /**
         * Generates a [Discrete uniform distribution](https://en.wikipedia.org/wiki/Discrete_uniform_distribution).
         *
         * @param {number} [min=0] - Lower bound (integer, inclusive)
         * @param {number} [max=1] - Upper bound (integer, inclusive)
         * @return {function}
         */

      }, {
        key: 'uniformInt',
        value: function uniformInt(min, max) {
          return this._memoize('uniformInt', _uniformInt3.default, min, max);
        }

        /**
         * Generates a [Discrete uniform distribution](https://en.wikipedia.org/wiki/Discrete_uniform_distribution),
         * with two possible outcomes, `true` or `false.
         *
         * This method is analogous to flipping a coin.
         *
         * @return {function}
         */

      }, {
        key: 'uniformBoolean',
        value: function uniformBoolean() {
          return this._memoize('uniformBoolean', _uniformBoolean3.default);
        }

        // --------------------------------------------------------------------------
        // Normal distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Normal distribution](https://en.wikipedia.org/wiki/Normal_distribution).
         *
         * @param {number} [mu=0] - Mean
         * @param {number} [sigma=1] - Standard deviation
         * @return {function}
         */

      }, {
        key: 'normal',
        value: function normal(mu, sigma) {
          return (0, _normal3.default)(this, mu, sigma);
        }

        /**
         * Generates a [Log-normal distribution](https://en.wikipedia.org/wiki/Log-normal_distribution).
         *
         * @param {number} [mu=0] - Mean of underlying normal distribution
         * @param {number} [sigma=1] - Standard deviation of underlying normal distribution
         * @return {function}
         */

      }, {
        key: 'logNormal',
        value: function logNormal(mu, sigma) {
          return (0, _logNormal3.default)(this, mu, sigma);
        }

        // --------------------------------------------------------------------------
        // Bernoulli distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution).
         *
         * @param {number} [p=0.5] - Success probability of each trial.
         * @return {function}
         */

      }, {
        key: 'bernoulli',
        value: function bernoulli(p) {
          return (0, _bernoulli3.default)(this, p);
        }

        /**
         * Generates a [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution).
         *
         * @param {number} [n=1] - Number of trials.
         * @param {number} [p=0.5] - Success probability of each trial.
         * @return {function}
         */

      }, {
        key: 'binomial',
        value: function binomial(n, p) {
          return (0, _binomial3.default)(this, n, p);
        }

        /**
         * Generates a [Geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution).
         *
         * @param {number} [p=0.5] - Success probability of each trial.
         * @return {function}
         */

      }, {
        key: 'geometric',
        value: function geometric(p) {
          return (0, _geometric3.default)(this, p);
        }

        // --------------------------------------------------------------------------
        // Poisson distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution).
         *
         * @param {number} [lambda=1] - Mean (lambda > 0)
         * @return {function}
         */

      }, {
        key: 'poisson',
        value: function poisson(lambda) {
          return (0, _poisson3.default)(this, lambda);
        }

        /**
         * Generates an [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution).
         *
         * @param {number} [lambda=1] - Inverse mean (lambda > 0)
         * @return {function}
         */

      }, {
        key: 'exponential',
        value: function exponential(lambda) {
          return (0, _exponential3.default)(this, lambda);
        }

        // --------------------------------------------------------------------------
        // Misc distributions
        // --------------------------------------------------------------------------

        /**
         * Generates an [Irwin Hall distribution](https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution).
         *
         * @param {number} [n=1] - Number of uniform samples to sum (n >= 0)
         * @return {function}
         */

      }, {
        key: 'irwinHall',
        value: function irwinHall(n) {
          return (0, _irwinHall3.default)(this, n);
        }

        /**
         * Generates a [Bates distribution](https://en.wikipedia.org/wiki/Bates_distribution).
         *
         * @param {number} [n=1] - Number of uniform samples to average (n >= 1)
         * @return {function}
         */

      }, {
        key: 'bates',
        value: function bates(n) {
          return (0, _bates3.default)(this, n);
        }

        /**
         * Generates a [Pareto distribution](https://en.wikipedia.org/wiki/Pareto_distribution).
         *
         * @param {number} [alpha=1] - Alpha
         * @return {function}
         */

      }, {
        key: 'pareto',
        value: function pareto(alpha) {
          return (0, _pareto3.default)(this, alpha);
        }

        // --------------------------------------------------------------------------
        // Internal
        // --------------------------------------------------------------------------

        /**
         * Memoizes distributions to ensure they're only created when necessary.
         *
         * Returns a thunk which that returns independent, identically distributed
         * samples from the specified distribution.
         *
         * @private
         *
         * @param {string} label - Name of distribution
         * @param {function} getter - Function which generates a new distribution
         * @param {...*} args - Distribution-specific arguments
         *
         * @return {function}
         */

      }, {
        key: '_memoize',
        value: function _memoize(label, getter) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          var key = '' + args.join(';');
          var value = this._cache[label];

          if (value === undefined || value.key !== key) {
            value = { key: key, distribution: getter.apply(undefined, [this].concat(args)) };
            this._cache[label] = value;
          }

          return value.distribution;
        }
      }, {
        key: 'rng',
        get: function get() {
          return this._rng;
        }
      }]);

      return Random;
    }();

    // defaults to Math.random as its RNG


    exports.default = new Random();

    });

    var random = random$1.default;

    class Gaussian {
      constructor(mean, cov) {
        // TODO: Consider saving the dimension
        if ((mean instanceof Matrix) && (cov instanceof Matrix)) {
          this.mean = mean;
          this.cov = cov;
        } else {
          this.mean = new Matrix([mean]).transpose();
          this.cov = new Matrix(cov);
        }
      }

      at(x) {
        const diff = (new Matrix([x])).transpose().sub(this.mean);
        const n = diff.transpose().mmul(inverse(this.cov)).mmul(diff).mul(-0.5).exp();
        const d = Math.sqrt(Math.pow(2*Math.PI, this.mean.rows)*this.cov.det());
        return (n * (1 / d));
      }

      // idx is the first row of b
      marginalize(idx) {
        // FIXME: Rewrite with Array.slice() for speed
        const aMean = sliceMat(this.mean,0,0,idx,1);
        const bMean = sliceMat(this.mean,idx,0,this.mean.rows,1);
        const aCov = sliceMat(this.cov,0,0,idx,idx);
        const bCov = sliceMat(this.cov,idx,idx,this.mean.rows,this.mean.rows);
        return [new Gaussian(aMean, aCov), new Gaussian(bMean, bCov)];
      }

      // Also refer to: https://stats.stackexchange.com/questions/232959/simulating-the-posterior-of-a-gaussian-process
      // FIXME: Currently only works with \mu_e = 0
      condition(X) {
        const idx = X.length;
        const x0 = new Matrix([X]).transpose();
        const Exx = sliceMat(this.cov,0,0,idx,idx);
        const Exy = sliceMat(this.cov,0,idx,idx,this.mean.rows);
        const Eyx = Exy.transpose();
        const Eyy = sliceMat(this.cov,idx,idx,this.mean.rows,this.mean.rows);

        // Compute new zero
        const Lxx = new CholeskyDecomposition(Exx).lowerTriangularMatrix;
        const mLy = solve(Lxx, x0);
        const Lk = solve(Lxx, Exy);
        const condMean = Lk.transpose().mmul(mLy); // Hack

        // FIXME: Make this more performant (use cholesky and slove instead of inverse)
        const condCov = Eyy.sub(Eyx.mmul(inverse(Exx)).mmul(Exy));
        return new Gaussian(condMean, condCov);
      }

      // Uses Eigenvalue decomposition to compute t from Cov = tt^T
      transformationMatrix() {
        const e = new EigenvalueDecomposition(this.cov);
        const r = e.eigenvectorMatrix;
        const d = Matrix.zeros(r.rows, r.columns);
        for(let i = 0; i < d.rows; ++i) {
          d.set(i,i, Math.sqrt(e.realEigenvalues[i]));
        }
        return r.mmul(d);
      }

      sample() {
        const z = Matrix.zeros(this.mean.rows, 1);
        const normal = random.normal();
        for(let i = 0; i < this.mean.rows; ++i)
          z.set(i,0,normal());

        const samples = Matrix.add(this.mean, this.transformationMatrix().mmul(z));
        return samples;
      }

      getMean() {
        return this.mean.transpose()[0];
      }

      getSd() {
        return this.cov.diag().map(s2 => Math.sqrt(s2));
      }
    }

    // ranges from [i1,i2) & [j1,j2)
    function sliceMat(mat,i1,j1,i2,j2) {
      const result = new Matrix(i2-i1,j2-j1);
      for(let i = i1; i < i2; ++i) 
        for(let j = j1; j < j2; ++j) {
          result.set(i-i1, j-j1, mat.get(i,j)); 
        }
      return result;
    }

    class RBFKernel {
      constructor() {
        this.g = new Gaussian([0], [[1]]);
        this.scale = 1.0 / this.g.at([0]);
      }

      call(x1, x2) {
        return this.g.at([x1 - x2]) * this.scale;
      }

      // find +x solving call(0, x) = y
      inv0(y) {
        var sigma2 = this.get_sigma2();
        var ys = y / this.scale;
        const sspi = Math.sqrt(sigma2 * 2.0 * Math.PI);
        const dssq = -2.0 * sigma2; 
        var x = Math.sqrt(dssq * Math.log(ys * sspi));
        return x;
      }

      set_sigma(sigma) {
        this.g = new Gaussian([0], [[sigma * sigma]]);
        this.scale = 1.0 / this.g.at([0]);
      }

      get_sigma2() {
        return this.g.cov[0][0];
      }

      cuts(x, beg, end) {
        return [];
      }
    }

    class RBFShuffleKernel {
      constructor(cut_size) {
        this.g = new Gaussian([0], [[1]]);
        this.scale = 1.0 / this.g.at([0]);
        this.cut_size = cut_size;
      }

      call(x1, x2) {
        var c = this.cut_size;
        var d = Math.floor(x2 / c);
        var r = x2 - d * c;
        if (Math.abs(d % 2) == 1) 
          x2 += c - 2 * r;

        return this.g.at([x2 - x1]) * this.scale;
      }

      set_sigma(sigma) {
        this.g = new Gaussian([0], [[sigma * sigma]]);
        this.scale = 1.0 / this.g.at([0]);
      }

      get_sigma2() {
        return this.g.cov[0][0];
      }

      // return a list of points of discontinuity in [beg, end] for the
      // representer function of x
      cuts(x, beg, end) {
        var s = beg; 
        var p = [];
        while (s < end) {
          p.push(s);
          s += this.cut_size;
        }
        return p;
      }
    }

    function ascending$3(a, b) {
      return a == null || b == null ? NaN
        : a < b ? -1
        : a > b ? 1
        : a >= b ? 0
        : NaN;
    }

    function bisector(f) {
      let delta = f;
      let compare = f;

      if (f.length === 1) {
        delta = (d, x) => f(d) - x;
        compare = ascendingComparator(f);
      }

      function left(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          const mid = (lo + hi) >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      }

      function right(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          const mid = (lo + hi) >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }

      function center(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {left, center, right};
    }

    function ascendingComparator(f) {
      return (d, x) => ascending$3(f(d), x);
    }

    function number$3(x) {
      return x === null ? NaN : +x;
    }

    function* numbers(values, valueof) {
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            yield value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            yield value;
          }
        }
      }
    }

    const ascendingBisect = bisector(ascending$3);
    const bisectRight = ascendingBisect.right;
    const bisectLeft = ascendingBisect.left;
    const bisectCenter = bisector(number$3).center;

    function count$1(values, valueof) {
      let count = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count;
          }
        }
      }
      return count;
    }

    function length$3(array) {
      return array.length | 0;
    }

    function empty$2(length) {
      return !(length > 0);
    }

    function arrayify(values) {
      return typeof values !== "object" || "length" in values ? values : Array.from(values);
    }

    function reducer(reduce) {
      return values => reduce(...values);
    }

    function cross$2(...values) {
      const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
      values = values.map(arrayify);
      const lengths = values.map(length$3);
      const j = values.length - 1;
      const index = new Array(j + 1).fill(0);
      const product = [];
      if (j < 0 || lengths.some(empty$2)) return product;
      while (true) {
        product.push(index.map((j, i) => values[i][j]));
        let i = j;
        while (++index[i] === lengths[i]) {
          if (i === 0) return reduce ? product.map(reduce) : product;
          index[i--] = 0;
        }
      }
    }

    function cumsum(values, valueof) {
      var sum = 0, index = 0;
      return Float64Array.from(values, valueof === undefined
        ? v => (sum += +v || 0)
        : v => (sum += +valueof(v, index++, values) || 0));
    }

    function descending$2(a, b) {
      return a == null || b == null ? NaN
        : b < a ? -1
        : b > a ? 1
        : b >= a ? 0
        : NaN;
    }

    function variance(values, valueof) {
      let count = 0;
      let delta;
      let mean = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      }
      if (count > 1) return sum / (count - 1);
    }

    function deviation(values, valueof) {
      const v = variance(values, valueof);
      return v ? Math.sqrt(v) : v;
    }

    function extent$1(values, valueof) {
      let min;
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
      return [min, max];
    }

    // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
    class Adder {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
          if (lo) p[i++] = lo;
          x = hi;
        }
        p[i] = x;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x, y, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x = hi;
            y = p[--n];
            hi = x + y;
            lo = y - (hi - x);
            if (lo) break;
          }
          if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
            y = lo * 2;
            x = hi + y;
            if (y == x - hi) hi = x;
          }
        }
        return hi;
      }
    }

    function fsum(values, valueof) {
      const adder = new Adder();
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            adder.add(value);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            adder.add(value);
          }
        }
      }
      return +adder;
    }

    function fcumsum(values, valueof) {
      const adder = new Adder();
      let index = -1;
      return Float64Array.from(values, valueof === undefined
          ? v => adder.add(+v || 0)
          : v => adder.add(+valueof(v, ++index, values) || 0)
      );
    }

    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (entries != null) for (const [key, value] of entries) this.set(key, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }

    class InternSet extends Set {
      constructor(values, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (values != null) for (const value of values) this.add(value);
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    }

    function intern_get({_intern, _key}, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }

    function intern_set({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }

    function intern_delete({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(value);
        _intern.delete(key);
      }
      return value;
    }

    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function identity$9(x) {
      return x;
    }

    function group(values, ...keys) {
      return nest(values, identity$9, identity$9, keys);
    }

    function groups(values, ...keys) {
      return nest(values, Array.from, identity$9, keys);
    }

    function flatten$1(groups, keys) {
      for (let i = 1, n = keys.length; i < n; ++i) {
        groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));
      }
      return groups;
    }

    function flatGroup(values, ...keys) {
      return flatten$1(groups(values, ...keys), keys);
    }

    function flatRollup(values, reduce, ...keys) {
      return flatten$1(rollups(values, reduce, ...keys), keys);
    }

    function rollup(values, reduce, ...keys) {
      return nest(values, identity$9, reduce, keys);
    }

    function rollups(values, reduce, ...keys) {
      return nest(values, Array.from, reduce, keys);
    }

    function index$4(values, ...keys) {
      return nest(values, identity$9, unique, keys);
    }

    function indexes(values, ...keys) {
      return nest(values, Array.from, unique, keys);
    }

    function unique(values) {
      if (values.length !== 1) throw new Error("duplicate key");
      return values[0];
    }

    function nest(values, map, reduce, keys) {
      return (function regroup(values, i) {
        if (i >= keys.length) return reduce(values);
        const groups = new InternMap();
        const keyof = keys[i++];
        let index = -1;
        for (const value of values) {
          const key = keyof(value, ++index, values);
          const group = groups.get(key);
          if (group) group.push(value);
          else groups.set(key, [value]);
        }
        for (const [key, values] of groups) {
          groups.set(key, regroup(values, i));
        }
        return map(groups);
      })(values, 0);
    }

    function permute(source, keys) {
      return Array.from(keys, key => source[key]);
    }

    function sort(values, ...F) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      values = Array.from(values);
      let [f = ascending$3] = F;
      if (f.length === 1 || F.length > 1) {
        const index = Uint32Array.from(values, (d, i) => i);
        if (F.length > 1) {
          F = F.map(f => values.map(f));
          index.sort((i, j) => {
            for (const f of F) {
              const c = ascending$3(f[i], f[j]);
              if (c) return c;
            }
          });
        } else {
          f = values.map(f);
          index.sort((i, j) => ascending$3(f[i], f[j]));
        }
        return permute(values, index);
      }
      return values.sort(f);
    }

    function groupSort(values, reduce, key) {
      return (reduce.length === 1
        ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending$3(av, bv) || ascending$3(ak, bk)))
        : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending$3(ak, bk))))
        .map(([key]) => key);
    }

    var array$5 = Array.prototype;

    var slice$3 = array$5.slice;

    function constant$b(x) {
      return function() {
        return x;
      };
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        let r0 = Math.round(start / step), r1 = Math.round(stop / step);
        if (r0 * step < start) ++r0;
        if (r1 * step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.round(start * step), r1 = Math.round(stop * step);
        if (r0 / step < start) ++r0;
        if (r1 / step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function nice$1(start, stop, count) {
      let prestep;
      while (true) {
        const step = tickIncrement(start, stop, count);
        if (step === prestep || step === 0 || !isFinite(step)) {
          return [start, stop];
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        }
        prestep = step;
      }
    }

    function thresholdSturges(values) {
      return Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1;
    }

    function bin() {
      var value = identity$9,
          domain = extent$1,
          threshold = thresholdSturges;

      function histogram(data) {
        if (!Array.isArray(data)) data = Array.from(data);

        var i,
            n = data.length,
            x,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds, and nice the
        // default domain accordingly.
        if (!Array.isArray(tz)) {
          const max = x1, tn = +tz;
          if (domain === extent$1) [x0, x1] = nice$1(x0, x1, tn);
          tz = ticks(x0, x1, tn);

          // If the last threshold is coincident with the domains upper bound, the
          // last bin will be zero-width. If the default domain is used, and this
          // last threshold is coincident with the maximum input value, we can
          // extend the niced upper bound by one tick to ensure uniform bin widths;
          // otherwise, we simply remove the last threshold. Note that we dont
          // coerce values or the domain to numbers, and thus must be careful to
          // compare order (>=) rather than strict equality (===)!
          if (tz[tz.length - 1] >= x1) {
            if (max >= x1 && domain === extent$1) {
              const step = tickIncrement(x0, x1, tn);
              if (isFinite(step)) {
                if (step > 0) {
                  x1 = (Math.floor(x1 / step) + 1) * step;
                } else if (step < 0) {
                  x1 = (Math.ceil(x1 * -step) + 1) / -step;
                }
              }
            } else {
              tz.pop();
            }
          }
        }

        // Remove any thresholds outside the domain.
        var m = tz.length;
        while (tz[0] <= x0) tz.shift(), --m;
        while (tz[m - 1] > x1) tz.pop(), --m;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        for (i = 0; i < n; ++i) {
          x = values[i];
          if (x != null && x0 <= x && x <= x1) {
            bins[bisectRight(tz, x, 0, m)].push(data[i]);
          }
        }

        return bins;
      }

      histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$b(_), histogram) : value;
      };

      histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant$b([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$b(slice$3.call(_)) : constant$b(_), histogram) : threshold;
      };

      return histogram;
    }

    function max$3(values, valueof) {
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      }
      return max;
    }

    function min$2(values, valueof) {
      let min;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      }
      return min;
    }

    // Based on https://github.com/mourner/quickselect
    // ISC license, Copyright 2018 Vladimir Agafonkin.
    function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending$3) {
      while (right > left) {
        if (right - left > 600) {
          const n = right - left + 1;
          const m = k - left + 1;
          const z = Math.log(n);
          const s = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
          const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
          quickselect(array, k, newLeft, newRight, compare);
        }

        const t = array[k];
        let i = left;
        let j = right;

        swap$1(array, left, k);
        if (compare(array[right], t) > 0) swap$1(array, left, right);

        while (i < j) {
          swap$1(array, i, j), ++i, --j;
          while (compare(array[i], t) < 0) ++i;
          while (compare(array[j], t) > 0) --j;
        }

        if (compare(array[left], t) === 0) swap$1(array, left, j);
        else ++j, swap$1(array, j, right);

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
      }
      return array;
    }

    function swap$1(array, i, j) {
      const t = array[i];
      array[i] = array[j];
      array[j] = t;
    }

    function quantile$1(values, p, valueof) {
      values = Float64Array.from(numbers(values, valueof));
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return min$2(values);
      if (p >= 1) return max$3(values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = max$3(quickselect(values, i0).subarray(0, i0 + 1)),
          value1 = min$2(values.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileSorted(values, p, valueof = number$3) {
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
      if (p >= 1) return +valueof(values[n - 1], n - 1, values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    }

    function freedmanDiaconis(values, min, max) {
      return Math.ceil((max - min) / (2 * (quantile$1(values, 0.75) - quantile$1(values, 0.25)) * Math.pow(count$1(values), -1 / 3)));
    }

    function scott(values, min, max) {
      return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(count$1(values), -1 / 3)));
    }

    function maxIndex(values, valueof) {
      let max;
      let maxIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      }
      return maxIndex;
    }

    function mean(values, valueof) {
      let count = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      }
      if (count) return sum / count;
    }

    function median(values, valueof) {
      return quantile$1(values, 0.5, valueof);
    }

    function* flatten(arrays) {
      for (const array of arrays) {
        yield* array;
      }
    }

    function merge(arrays) {
      return Array.from(flatten(arrays));
    }

    function minIndex(values, valueof) {
      let min;
      let minIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      }
      return minIndex;
    }

    function mode(values, valueof) {
      const counts = new InternMap();
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      }
      let modeValue;
      let modeCount = 0;
      for (const [value, count] of counts) {
        if (count > modeCount) {
          modeCount = count;
          modeValue = value;
        }
      }
      return modeValue;
    }

    function pairs(values, pairof = pair) {
      const pairs = [];
      let previous;
      let first = false;
      for (const value of values) {
        if (first) pairs.push(pairof(previous, value));
        previous = value;
        first = true;
      }
      return pairs;
    }

    function pair(a, b) {
      return [a, b];
    }

    function range$2(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    function least(values, compare = ascending$3) {
      let min;
      let defined = false;
      if (compare.length === 1) {
        let minValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, minValue) < 0
              : ascending$3(value, value) === 0) {
            min = element;
            minValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, min) < 0
              : compare(value, value) === 0) {
            min = value;
            defined = true;
          }
        }
      }
      return min;
    }

    function leastIndex(values, compare = ascending$3) {
      if (compare.length === 1) return minIndex(values, compare);
      let minValue;
      let min = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (min < 0
            ? compare(value, value) === 0
            : compare(value, minValue) < 0) {
          minValue = value;
          min = index;
        }
      }
      return min;
    }

    function greatest(values, compare = ascending$3) {
      let max;
      let defined = false;
      if (compare.length === 1) {
        let maxValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, maxValue) > 0
              : ascending$3(value, value) === 0) {
            max = element;
            maxValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, max) > 0
              : compare(value, value) === 0) {
            max = value;
            defined = true;
          }
        }
      }
      return max;
    }

    function greatestIndex(values, compare = ascending$3) {
      if (compare.length === 1) return maxIndex(values, compare);
      let maxValue;
      let max = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (max < 0
            ? compare(value, value) === 0
            : compare(value, maxValue) > 0) {
          maxValue = value;
          max = index;
        }
      }
      return max;
    }

    function scan(values, compare) {
      const index = leastIndex(values, compare);
      return index < 0 ? undefined : index;
    }

    var shuffle$1 = shuffler(Math.random);

    function shuffler(random) {
      return function shuffle(array, i0 = 0, i1 = array.length) {
        let m = i1 - (i0 = +i0);
        while (m) {
          const i = random() * m-- | 0, t = array[m + i0];
          array[m + i0] = array[i + i0];
          array[i + i0] = t;
        }
        return array;
      };
    }

    function sum$2(values, valueof) {
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            sum += value;
          }
        }
      }
      return sum;
    }

    function transpose(matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min$2(matrix, length$2), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    }

    function length$2(d) {
      return d.length;
    }

    function zip() {
      return transpose(arguments);
    }

    function every(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (!test(value, ++index, values)) {
          return false;
        }
      }
      return true;
    }

    function some(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          return true;
        }
      }
      return false;
    }

    function filter$1(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      const array = [];
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          array.push(value);
        }
      }
      return array;
    }

    function map$1(values, mapper) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
      return Array.from(values, (value, index) => mapper(value, index, values));
    }

    function reduce(values, reducer, value) {
      if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
      const iterator = values[Symbol.iterator]();
      let done, next, index = -1;
      if (arguments.length < 3) {
        ({done, value} = iterator.next());
        if (done) return;
        ++index;
      }
      while (({done, value: next} = iterator.next()), !done) {
        value = reducer(value, next, ++index, values);
      }
      return value;
    }

    function reverse$1(values) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      return Array.from(values).reverse();
    }

    function difference(values, ...others) {
      values = new Set(values);
      for (const other of others) {
        for (const value of other) {
          values.delete(value);
        }
      }
      return values;
    }

    function disjoint(values, other) {
      const iterator = other[Symbol.iterator](), set = new Set();
      for (const v of values) {
        if (set.has(v)) return false;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) break;
          if (Object.is(v, value)) return false;
          set.add(value);
        }
      }
      return true;
    }

    function set$2(values) {
      return values instanceof Set ? values : new Set(values);
    }

    function intersection(values, ...others) {
      values = new Set(values);
      others = others.map(set$2);
      out: for (const value of values) {
        for (const other of others) {
          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      }
      return values;
    }

    function superset(values, other) {
      const iterator = values[Symbol.iterator](), set = new Set();
      for (const o of other) {
        if (set.has(o)) continue;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) return false;
          set.add(value);
          if (Object.is(o, value)) break;
        }
      }
      return true;
    }

    function subset(values, other) {
      return superset(other, values);
    }

    function union(...others) {
      const set = new Set();
      for (const other of others) {
        for (const o of other) {
          set.add(o);
        }
      }
      return set;
    }

    function identity$8(x) {
      return x;
    }

    var top = 1,
        right = 2,
        bottom = 3,
        left = 4,
        epsilon$6 = 1e-6;

    function translateX(x) {
      return "translate(" + x + ",0)";
    }

    function translateY(y) {
      return "translate(0," + y + ")";
    }

    function number$2(scale) {
      return d => +scale(d);
    }

    function center$1(scale, offset) {
      offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
      if (scale.round()) offset = Math.round(offset);
      return d => +scale(d) + offset;
    }

    function entering() {
      return !this.__axis;
    }

    function axis(orient, scale) {
      var tickArguments = [],
          tickValues = null,
          tickFormat = null,
          tickSizeInner = 6,
          tickSizeOuter = 6,
          tickPadding = 3,
          offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
          k = orient === top || orient === left ? -1 : 1,
          x = orient === left || orient === right ? "x" : "y",
          transform = orient === top || orient === bottom ? translateX : translateY;

      function axis(context) {
        var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
            format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8) : tickFormat,
            spacing = Math.max(tickSizeInner, 0) + tickPadding,
            range = scale.range(),
            range0 = +range[0] + offset,
            range1 = +range[range.length - 1] + offset,
            position = (scale.bandwidth ? center$1 : number$2)(scale.copy(), offset),
            selection = context.selection ? context.selection() : context,
            path = selection.selectAll(".domain").data([null]),
            tick = selection.selectAll(".tick").data(values, scale).order(),
            tickExit = tick.exit(),
            tickEnter = tick.enter().append("g").attr("class", "tick"),
            line = tick.select("line"),
            text = tick.select("text");

        path = path.merge(path.enter().insert("path", ".tick")
            .attr("class", "domain")
            .attr("stroke", "currentColor"));

        tick = tick.merge(tickEnter);

        line = line.merge(tickEnter.append("line")
            .attr("stroke", "currentColor")
            .attr(x + "2", k * tickSizeInner));

        text = text.merge(tickEnter.append("text")
            .attr("fill", "currentColor")
            .attr(x, k * spacing)
            .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

        if (context !== selection) {
          path = path.transition(context);
          tick = tick.transition(context);
          line = line.transition(context);
          text = text.transition(context);

          tickExit = tickExit.transition(context)
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

          tickEnter
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
        }

        tickExit.remove();

        path
            .attr("d", orient === left || orient === right
                ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
                : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

        tick
            .attr("opacity", 1)
            .attr("transform", function(d) { return transform(position(d) + offset); });

        line
            .attr(x + "2", k * tickSizeInner);

        text
            .attr(x, k * spacing)
            .text(format);

        selection.filter(entering)
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

        selection
            .each(function() { this.__axis = position; });
      }

      axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
      };

      axis.ticks = function() {
        return tickArguments = Array.from(arguments), axis;
      };

      axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
      };

      axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
      };

      axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
      };

      axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
      };

      axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
      };

      axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
      };

      axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
      };

      axis.offset = function(_) {
        return arguments.length ? (offset = +_, axis) : offset;
      };

      return axis;
    }

    function axisTop(scale) {
      return axis(top, scale);
    }

    function axisRight(scale) {
      return axis(right, scale);
    }

    function axisBottom(scale) {
      return axis(bottom, scale);
    }

    function axisLeft(scale) {
      return axis(left, scale);
    }

    var noop$4 = {value: () => {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames$1(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$1(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$4, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none$2() {}

    function selector(selector) {
      return selector == null ? none$2 : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we dont ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array$4(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty$1() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty$1 : function() {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function() {
        return array$4(select.apply(this, arguments));
      };
    }

    function selection_selectAll(select) {
      if (typeof select === "function") select = arrayAll(select);
      else select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function childMatcher(selector) {
      return function(node) {
        return node.matches(selector);
      };
    }

    var find$1 = Array.prototype.find;

    function childFind(match) {
      return function() {
        return find$1.call(this.children, match);
      };
    }

    function childFirst() {
      return this.firstElementChild;
    }

    function selection_selectChild(match) {
      return this.select(match == null ? childFirst
          : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter = Array.prototype.filter;

    function children() {
      return Array.from(this.children);
    }

    function childrenFilter(match) {
      return function() {
        return filter.call(this.children, match);
      };
    }

    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children
          : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$a(x) {
      return function() {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that dont fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = new Map,
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
          exit[i] = node;
        }
      }
    }

    function datum(node) {
      return node.__data__;
    }

    function selection_data(value, key) {
      if (!arguments.length) return Array.from(this, datum);

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$a(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isnt worried about live collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // dont; wed rather avoid a gratuitous copy.)
    function arraylike(data) {
      return typeof data === "object" && "length" in data
        ? data // Array, TypedArray, NodeList, array-like
        : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(context) {
      var selection = context.selection ? context.selection() : context;

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending$2;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending$2(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      return Array.from(this);
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      let size = 0;
      for (const node of this) ++size; // eslint-disable-line no-unused-vars
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }

    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, options) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root$1 = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root$1);
    }

    function selection_selection() {
      return this;
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root$1);
    }

    function create$1(name) {
      return select(creator(name).call(document.documentElement));
    }

    var nextId = 0;

    function local$1() {
      return new Local;
    }

    function Local() {
      this._ = "@" + (++nextId).toString(36);
    }

    Local.prototype = local$1.prototype = {
      constructor: Local,
      get: function(node) {
        var id = this._;
        while (!(id in node)) if (!(node = node.parentNode)) return;
        return node[id];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };

    function sourceEvent(event) {
      let sourceEvent;
      while (sourceEvent = event.sourceEvent) event = sourceEvent;
      return event;
    }

    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }

    function pointers(events, node) {
      if (events.target) { // i.e., instanceof Event, not TouchList or iterable
        events = sourceEvent(events);
        if (node === undefined) node = events.currentTarget;
        events = events.touches || [events];
      }
      return Array.from(events, event => pointer(event, node));
    }

    function selectAll(selector) {
      return typeof selector === "string"
          ? new Selection$1([document.querySelectorAll(selector)], [document.documentElement])
          : new Selection$1([array$4(selector)], root$1);
    }

    // These are typically used in conjunction with noevent to ensure that we can
    // preventDefault on the event.
    const nonpassive = {passive: false};
    const nonpassivecapture = {capture: true, passive: false};

    function nopropagation$2(event) {
      event.stopImmediatePropagation();
    }

    function noevent$2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable(view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent$2, nonpassivecapture);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$2, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent$2, nonpassivecapture);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var constant$9 = x => () => x;

    function DragEvent(type, {
      sourceEvent,
      subject,
      target,
      identifier,
      active,
      x, y, dx, dy,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        subject: {value: subject, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        identifier: {value: identifier, enumerable: true, configurable: true},
        active: {value: active, enumerable: true, configurable: true},
        x: {value: x, enumerable: true, configurable: true},
        y: {value: y, enumerable: true, configurable: true},
        dx: {value: dx, enumerable: true, configurable: true},
        dy: {value: dy, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$2(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(event, d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable$2() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
      var filter = defaultFilter$2,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable$2,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved, nonpassive)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned(event, d) {
        if (touchending || !filter.call(this, event, d)) return;
        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
        if (!gesture) return;
        select(event.view)
          .on("mousemove.drag", mousemoved, nonpassivecapture)
          .on("mouseup.drag", mouseupped, nonpassivecapture);
        dragDisable(event.view);
        nopropagation$2(event);
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start", event);
      }

      function mousemoved(event) {
        noevent$2(event);
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag", event);
      }

      function mouseupped(event) {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent$2(event);
        gestures.mouse("end", event);
      }

      function touchstarted(event, d) {
        if (!filter.call(this, event, d)) return;
        var touches = event.changedTouches,
            c = container.call(this, event, d),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
            nopropagation$2(event);
            gesture("start", event, touches[i]);
          }
        }
      }

      function touchmoved(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent$2(event);
            gesture("drag", event, touches[i]);
          }
        }
      }

      function touchended(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation$2(event);
            gesture("end", event, touches[i]);
          }
        }
      }

      function beforestart(that, container, event, d, identifier, touch) {
        var dispatch = listeners.copy(),
            p = pointer(touch || event, container), dx, dy,
            s;

        if ((s = subject.call(that, new DragEvent("beforestart", {
            sourceEvent: event,
            target: drag,
            identifier,
            active,
            x: p[0],
            y: p[1],
            dx: 0,
            dy: 0,
            dispatch
          }), d)) == null) return;

        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;

        return function gesture(type, event, touch) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[identifier] = gesture, n = active++; break;
            case "end": delete gestures[identifier], --active; // falls through
            case "drag": p = pointer(touch || event, container), n = active; break;
          }
          dispatch.call(
            type,
            that,
            new DragEvent(type, {
              sourceEvent: event,
              subject: s,
              target: drag,
              identifier,
              active: n,
              x: p[0] + dx,
              y: p[1] + dy,
              dx: p[0] - p0[0],
              dy: p[1] - p0[1],
              dispatch
            }),
            d
          );
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$9(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$9(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$9(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$9(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend$1(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color$1, {
      copy: function(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color$1(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color$1(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend$1(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color$1(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl$2(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl$2, extend$1(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    const radians$1 = Math.PI / 180;
    const degrees$2 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    const K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0$1 = 4 / 29,
        t1$1 = 6 / 29,
        t2 = 3 * t1$1 * t1$1,
        t3 = t1$1 * t1$1 * t1$1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function gray(l, opacity) {
      return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
    }

    function lab$1(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab$1, extend$1(Color, {
      brighter: function(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker: function(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb: function() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
    }

    function lab2xyz(t) {
      return t > t1$1 ? t * t * t : t2 * (t - t0$1);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * degrees$2;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function lch(l, c, h, opacity) {
      return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function hcl$2(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * radians$1;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl$2, extend$1(Color, {
      brighter: function(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker: function(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb: function() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B$1 = +1.78277,
        C = -0.29227,
        D$1 = -0.90649,
        E = +1.97294,
        ED = E * D$1,
        EB = E * B$1,
        BC_DA = B$1 * C - D$1 * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D$1,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * degrees$2 - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix$3(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix$3, extend$1(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians$1,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B$1 * sinh)),
          255 * (l + a * (C * cosh + D$1 * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function basis$1(t1, v0, v1, v2, v3) {
      var t2 = t1 * t1, t3 = t2 * t1;
      return ((1 - 3 * t1 + 3 * t2 - t3) * v0
          + (4 - 6 * t2 + 3 * t3) * v1
          + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
          + t3 * v3) / 6;
    }

    function basis$2(values) {
      var n = values.length - 1;
      return function(t) {
        var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function basisClosed$1(values) {
      var n = values.length;
      return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
            v0 = values[(i + n - 1) % n],
            v1 = values[i % n],
            v2 = values[(i + 1) % n],
            v3 = values[(i + 2) % n];
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    var constant$8 = x => () => x;

    function linear$2(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential$1(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue$1(a, b) {
      var d = b - a;
      return d ? linear$2(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$8(isNaN(a) ? b : a);
    }

    function gamma$1(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential$1(a, b, y) : constant$8(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$2(a, d) : constant$8(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma$1(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function rgbSpline(spline) {
      return function(colors) {
        var n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n),
            i, color;
        for (i = 0; i < n; ++i) {
          color = rgb(colors[i]);
          r[i] = color.r || 0;
          g[i] = color.g || 0;
          b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
          color.r = r(t);
          color.g = g(t);
          color.b = b(t);
          return color + "";
        };
      };
    }

    var rgbBasis = rgbSpline(basis$2);
    var rgbBasisClosed = rgbSpline(basisClosed$1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function array$3(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate$2(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date$1(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object$1(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate$2(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate$2(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$8(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color$1(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color$1 ? interpolateRgb
          : b instanceof Date ? date$1
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1
          : interpolateNumber)(a, b);
    }

    function discrete(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    function hue(a, b) {
      var i = hue$1(+a, +b);
      return function(t) {
        var x = i(t);
        return x - 360 * Math.floor(x / 360);
      };
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees$1 = 180 / Math.PI;

    var identity$7 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees$1,
        skewX: Math.atan(skewX) * degrees$1,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;

    /* eslint-disable no-undef */
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$7 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }

    function parseSvg(value) {
      if (value == null) return identity$7;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$7;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var epsilon2$1 = 1e-12;

    function cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }

    function sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }

    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }

    var interpolateZoom = (function zoomRho(rho, rho2, rho4) {

      // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]
      function zoom(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
            ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;

        // Special case for u0  u1.
        if (d2 < epsilon2$1) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        }

        // General case.
        else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
              b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s = t * S,
                coshr0 = cosh(r0),
                u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh(rho * s + r0)
            ];
          };
        }

        i.duration = S * 1000 * rho / Math.SQRT2;

        return i;
      }

      zoom.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };

      return zoom;
    })(Math.SQRT2, 2, 4);

    function hsl(hue) {
      return function(start, end) {
        var h = hue((start = hsl$2(start)).h, (end = hsl$2(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hsl$1 = hsl(hue$1);
    var hslLong = hsl(nogamma);

    function lab(start, end) {
      var l = nogamma((start = lab$1(start)).l, (end = lab$1(end)).l),
          a = nogamma(start.a, end.a),
          b = nogamma(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.l = l(t);
        start.a = a(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    function hcl(hue) {
      return function(start, end) {
        var h = hue((start = hcl$2(start)).h, (end = hcl$2(end)).h),
            c = nogamma(start.c, end.c),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.c = c(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hcl$1 = hcl(hue$1);
    var hclLong = hcl(nogamma);

    function cubehelix$1(hue) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix(start, end) {
          var h = hue((start = cubehelix$3(start)).h, (end = cubehelix$3(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix.gamma = cubehelixGamma;

        return cubehelix;
      })(1);
    }

    var cubehelix$2 = cubehelix$1(hue$1);
    var cubehelixLong = cubehelix$1(nogamma);

    function piecewise(interpolate, values) {
      if (values === undefined) values = interpolate, interpolate = interpolate$2;
      var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
      while (i < n) I[i] = interpolate(v, v = values[++i]);
      return function(t) {
        var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i](t - i);
      };
    }

    function quantize$1(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
      return samples;
    }

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval$1 = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend weve set an alarm, if we havent already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval$1) interval$1 = clearInterval(interval$1);
      } else {
        if (!interval$1) clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    function interval(callback, delay, time) {
      var t = new Timer, total = delay;
      if (delay == null) return t.restart(callback, delay, time), t;
      t._restart = t.restart;
      t.restart = function(callback, delay, time) {
        delay = +delay, time = time == null ? now() : +time;
        t._restart(function tick(elapsed) {
          elapsed += total;
          t._restart(tick, total += delay, time);
          callback(elapsed);
        }, delay, time);
      };
      t.restart(callback, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get(node, id).value[name];
      };
    }

    function interpolate$1(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color$1 ? interpolateRgb
          : (c = color$1(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error;
        set(this, id).ease = v;
      };
    }

    function transition_easeVarying(value) {
      if (typeof value !== "function") throw new Error;
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and were done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });

        // The selection was empty, resolve end immediately
        if (size === 0) resolve();
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    const linear$1 = t => +t;

    function quadIn(t) {
      return t * t;
    }

    function quadOut(t) {
      return t * (2 - t);
    }

    function quadInOut(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
      return t * t * t;
    }

    function cubicOut(t) {
      return --t * t * t + 1;
    }

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent$1 = 3;

    var polyIn = (function custom(e) {
      e = +e;

      function polyIn(t) {
        return Math.pow(t, e);
      }

      polyIn.exponent = custom;

      return polyIn;
    })(exponent$1);

    var polyOut = (function custom(e) {
      e = +e;

      function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
      }

      polyOut.exponent = custom;

      return polyOut;
    })(exponent$1);

    var polyInOut = (function custom(e) {
      e = +e;

      function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      polyInOut.exponent = custom;

      return polyInOut;
    })(exponent$1);

    var pi$4 = Math.PI,
        halfPi$3 = pi$4 / 2;

    function sinIn(t) {
      return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi$3);
    }

    function sinOut(t) {
      return Math.sin(t * halfPi$3);
    }

    function sinInOut(t) {
      return (1 - Math.cos(pi$4 * t)) / 2;
    }

    // tpmt is two power minus ten times t scaled to [0,1]
    function tpmt(x) {
      return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
    }

    function expIn(t) {
      return tpmt(1 - +t);
    }

    function expOut(t) {
      return 1 - tpmt(t);
    }

    function expInOut(t) {
      return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
    }

    function circleIn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function circleOut(t) {
      return Math.sqrt(1 - --t * t);
    }

    function circleInOut(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1 = 4 / 11,
        b2 = 6 / 11,
        b3 = 8 / 11,
        b4 = 3 / 4,
        b5 = 9 / 11,
        b6 = 10 / 11,
        b7 = 15 / 16,
        b8 = 21 / 22,
        b9 = 63 / 64,
        b0 = 1 / b1 / b1;

    function bounceIn(t) {
      return 1 - bounceOut(1 - t);
    }

    function bounceOut(t) {
      return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }

    function bounceInOut(t) {
      return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;

    var backIn = (function custom(s) {
      s = +s;

      function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
      }

      backIn.overshoot = custom;

      return backIn;
    })(overshoot);

    var backOut = (function custom(s) {
      s = +s;

      function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
      }

      backOut.overshoot = custom;

      return backOut;
    })(overshoot);

    var backInOut = (function custom(s) {
      s = +s;

      function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
      }

      backInOut.overshoot = custom;

      return backInOut;
    })(overshoot);

    var tau$5 = 2 * Math.PI,
        amplitude = 1,
        period = 0.3;

    var elasticIn = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticIn(t) {
        return a * tpmt(-(--t)) * Math.sin((s - t) / p);
      }

      elasticIn.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticIn.period = function(p) { return custom(a, p); };

      return elasticIn;
    })(amplitude, period);

    var elasticOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticOut(t) {
        return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
      }

      elasticOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticOut.period = function(p) { return custom(a, p); };

      return elasticOut;
    })(amplitude, period);

    var elasticInOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0
            ? a * tpmt(-t) * Math.sin((s - t) / p)
            : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
      }

      elasticInOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticInOut.period = function(p) { return custom(a, p); };

      return elasticInOut;
    })(amplitude, period);

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var root = [null];

    function active(node, name) {
      var schedules = node.__transition,
          schedule,
          i;

      if (schedules) {
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
            return new Transition([[node]], root, name, +i);
          }
        }
      }

      return null;
    }

    var constant$7 = x => () => x;

    function BrushEvent(type, {
      sourceEvent,
      target,
      selection,
      mode,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        selection: {value: selection, enumerable: true, configurable: true},
        mode: {value: mode, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function nopropagation$1(event) {
      event.stopImmediatePropagation();
    }

    function noevent$1(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    var MODE_DRAG = {name: "drag"},
        MODE_SPACE = {name: "space"},
        MODE_HANDLE = {name: "handle"},
        MODE_CENTER = {name: "center"};

    const {abs: abs$3, max: max$2, min: min$1} = Math;

    function number1(e) {
      return [+e[0], +e[1]];
    }

    function number2(e) {
      return [number1(e[0]), number1(e[1])];
    }

    var X = {
      name: "x",
      handles: ["w", "e"].map(type),
      input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
      output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
    };

    var Y = {
      name: "y",
      handles: ["n", "s"].map(type),
      input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
      output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
    };

    var XY = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
      input: function(xy) { return xy == null ? null : number2(xy); },
      output: function(xy) { return xy; }
    };

    var cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };

    var flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };

    var flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };

    var signsX = {
      overlay: +1,
      selection: +1,
      n: null,
      e: +1,
      s: null,
      w: -1,
      nw: -1,
      ne: +1,
      se: +1,
      sw: -1
    };

    var signsY = {
      overlay: +1,
      selection: +1,
      n: -1,
      e: null,
      s: +1,
      w: null,
      nw: -1,
      ne: -1,
      se: +1,
      sw: +1
    };

    function type(t) {
      return {type: t};
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$1(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultExtent$1() {
      var svg = this.ownerSVGElement || this;
      if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
      }
      return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }

    function defaultTouchable$1() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    // Like d3.local, but with the name __brush rather than auto-generated.
    function local(node) {
      while (!node.__brush) if (!(node = node.parentNode)) return;
      return node.__brush;
    }

    function empty(extent) {
      return extent[0][0] === extent[1][0]
          || extent[0][1] === extent[1][1];
    }

    function brushSelection(node) {
      var state = node.__brush;
      return state ? state.dim.output(state.selection) : null;
    }

    function brushX() {
      return brush$1(X);
    }

    function brushY() {
      return brush$1(Y);
    }

    function brush() {
      return brush$1(XY);
    }

    function brush$1(dim) {
      var extent = defaultExtent$1,
          filter = defaultFilter$1,
          touchable = defaultTouchable$1,
          keys = true,
          listeners = dispatch("start", "brush", "end"),
          handleSize = 6,
          touchending;

      function brush(group) {
        var overlay = group
            .property("__brush", initialize)
          .selectAll(".overlay")
          .data([type("overlay")]);

        overlay.enter().append("rect")
            .attr("class", "overlay")
            .attr("pointer-events", "all")
            .attr("cursor", cursors.overlay)
          .merge(overlay)
            .each(function() {
              var extent = local(this).extent;
              select(this)
                  .attr("x", extent[0][0])
                  .attr("y", extent[0][1])
                  .attr("width", extent[1][0] - extent[0][0])
                  .attr("height", extent[1][1] - extent[0][1]);
            });

        group.selectAll(".selection")
          .data([type("selection")])
          .enter().append("rect")
            .attr("class", "selection")
            .attr("cursor", cursors.selection)
            .attr("fill", "#777")
            .attr("fill-opacity", 0.3)
            .attr("stroke", "#fff")
            .attr("shape-rendering", "crispEdges");

        var handle = group.selectAll(".handle")
          .data(dim.handles, function(d) { return d.type; });

        handle.exit().remove();

        handle.enter().append("rect")
            .attr("class", function(d) { return "handle handle--" + d.type; })
            .attr("cursor", function(d) { return cursors[d.type]; });

        group
            .each(redraw)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousedown.brush", started)
          .filter(touchable)
            .on("touchstart.brush", started)
            .on("touchmove.brush", touchmoved)
            .on("touchend.brush touchcancel.brush", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      brush.move = function(group, selection, event) {
        if (group.tween) {
          group
              .on("start.brush", function(event) { emitter(this, arguments).beforestart().start(event); })
              .on("interrupt.brush end.brush", function(event) { emitter(this, arguments).end(event); })
              .tween("brush", function() {
                var that = this,
                    state = that.__brush,
                    emit = emitter(that, arguments),
                    selection0 = state.selection,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                    i = interpolate$2(selection0, selection1);

                function tween(t) {
                  state.selection = t === 1 && selection1 === null ? null : i(t);
                  redraw.call(that);
                  emit.brush();
                }

                return selection0 !== null && selection1 !== null ? tween : tween(1);
              });
        } else {
          group
              .each(function() {
                var that = this,
                    args = arguments,
                    state = that.__brush,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                    emit = emitter(that, args).beforestart();

                interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start(event).brush(event).end(event);
              });
        }
      };

      brush.clear = function(group, event) {
        brush.move(group, null, event);
      };

      function redraw() {
        var group = select(this),
            selection = local(this).selection;

        if (selection) {
          group.selectAll(".selection")
              .style("display", null)
              .attr("x", selection[0][0])
              .attr("y", selection[0][1])
              .attr("width", selection[1][0] - selection[0][0])
              .attr("height", selection[1][1] - selection[0][1]);

          group.selectAll(".handle")
              .style("display", null)
              .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
              .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
              .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
              .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
        }

        else {
          group.selectAll(".selection,.handle")
              .style("display", "none")
              .attr("x", null)
              .attr("y", null)
              .attr("width", null)
              .attr("height", null);
        }
      }

      function emitter(that, args, clean) {
        var emit = that.__brush.emitter;
        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
      }

      function Emitter(that, args, clean) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
        this.clean = clean;
      }

      Emitter.prototype = {
        beforestart: function() {
          if (++this.active === 1) this.state.emitter = this, this.starting = true;
          return this;
        },
        start: function(event, mode) {
          if (this.starting) this.starting = false, this.emit("start", event, mode);
          else this.emit("brush", event);
          return this;
        },
        brush: function(event, mode) {
          this.emit("brush", event, mode);
          return this;
        },
        end: function(event, mode) {
          if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
          return this;
        },
        emit: function(type, event, mode) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new BrushEvent(type, {
              sourceEvent: event,
              target: brush,
              selection: dim.output(this.state.selection),
              mode,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function started(event) {
        if (touchending && !event.touches) return;
        if (!filter.apply(this, arguments)) return;

        var that = this,
            type = event.target.__data__.type,
            mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
            signX = dim === Y ? null : signsX[type],
            signY = dim === X ? null : signsY[type],
            state = local(that),
            extent = state.extent,
            selection = state.selection,
            W = extent[0][0], w0, w1,
            N = extent[0][1], n0, n1,
            E = extent[1][0], e0, e1,
            S = extent[1][1], s0, s1,
            dx = 0,
            dy = 0,
            moving,
            shifting = signX && signY && keys && event.shiftKey,
            lockX,
            lockY,
            points = Array.from(event.touches || [event], t => {
              const i = t.identifier;
              t = pointer(t, that);
              t.point0 = t.slice();
              t.identifier = i;
              return t;
            });

        interrupt(that);
        var emit = emitter(that, arguments, true).beforestart();

        if (type === "overlay") {
          if (selection) moving = true;
          const pts = [points[0], points[1] || points[0]];
          state.selection = selection = [[
              w0 = dim === Y ? W : min$1(pts[0][0], pts[1][0]),
              n0 = dim === X ? N : min$1(pts[0][1], pts[1][1])
            ], [
              e0 = dim === Y ? E : max$2(pts[0][0], pts[1][0]),
              s0 = dim === X ? S : max$2(pts[0][1], pts[1][1])
            ]];
          if (points.length > 1) move(event);
        } else {
          w0 = selection[0][0];
          n0 = selection[0][1];
          e0 = selection[1][0];
          s0 = selection[1][1];
        }

        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;

        var group = select(that)
            .attr("pointer-events", "none");

        var overlay = group.selectAll(".overlay")
            .attr("cursor", cursors[type]);

        if (event.touches) {
          emit.moved = moved;
          emit.ended = ended;
        } else {
          var view = select(event.view)
              .on("mousemove.brush", moved, true)
              .on("mouseup.brush", ended, true);
          if (keys) view
              .on("keydown.brush", keydowned, true)
              .on("keyup.brush", keyupped, true);

          dragDisable(event.view);
        }

        redraw.call(that);
        emit.start(event, mode.name);

        function moved(event) {
          for (const p of event.changedTouches || [event]) {
            for (const d of points)
              if (d.identifier === p.identifier) d.cur = pointer(p, that);
          }
          if (shifting && !lockX && !lockY && points.length === 1) {
            const point = points[0];
            if (abs$3(point.cur[0] - point[0]) > abs$3(point.cur[1] - point[1]))
              lockY = true;
            else
              lockX = true;
          }
          for (const point of points)
            if (point.cur) point[0] = point.cur[0], point[1] = point.cur[1];
          moving = true;
          noevent$1(event);
          move(event);
        }

        function move(event) {
          const point = points[0], point0 = point.point0;
          var t;

          dx = point[0] - point0[0];
          dy = point[1] - point0[1];

          switch (mode) {
            case MODE_SPACE:
            case MODE_DRAG: {
              if (signX) dx = max$2(W - w0, min$1(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
              if (signY) dy = max$2(N - n0, min$1(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
              break;
            }
            case MODE_HANDLE: {
              if (points[1]) {
                if (signX) w1 = max$2(W, min$1(E, points[0][0])), e1 = max$2(W, min$1(E, points[1][0])), signX = 1;
                if (signY) n1 = max$2(N, min$1(S, points[0][1])), s1 = max$2(N, min$1(S, points[1][1])), signY = 1;
              } else {
                if (signX < 0) dx = max$2(W - w0, min$1(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                else if (signX > 0) dx = max$2(W - e0, min$1(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                if (signY < 0) dy = max$2(N - n0, min$1(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                else if (signY > 0) dy = max$2(N - s0, min$1(S - s0, dy)), n1 = n0, s1 = s0 + dy;
              }
              break;
            }
            case MODE_CENTER: {
              if (signX) w1 = max$2(W, min$1(E, w0 - dx * signX)), e1 = max$2(W, min$1(E, e0 + dx * signX));
              if (signY) n1 = max$2(N, min$1(S, n0 - dy * signY)), s1 = max$2(N, min$1(S, s0 + dy * signY));
              break;
            }
          }

          if (e1 < w1) {
            signX *= -1;
            t = w0, w0 = e0, e0 = t;
            t = w1, w1 = e1, e1 = t;
            if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
          }

          if (s1 < n1) {
            signY *= -1;
            t = n0, n0 = s0, s0 = t;
            t = n1, n1 = s1, s1 = t;
            if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
          }

          if (state.selection) selection = state.selection; // May be set by brush.move!
          if (lockX) w1 = selection[0][0], e1 = selection[1][0];
          if (lockY) n1 = selection[0][1], s1 = selection[1][1];

          if (selection[0][0] !== w1
              || selection[0][1] !== n1
              || selection[1][0] !== e1
              || selection[1][1] !== s1) {
            state.selection = [[w1, n1], [e1, s1]];
            redraw.call(that);
            emit.brush(event, mode.name);
          }
        }

        function ended(event) {
          nopropagation$1(event);
          if (event.touches) {
            if (event.touches.length) return;
            if (touchending) clearTimeout(touchending);
            touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
          } else {
            yesdrag(event.view, moving);
            view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
          }
          group.attr("pointer-events", "all");
          overlay.attr("cursor", cursors.overlay);
          if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
          if (empty(selection)) state.selection = null, redraw.call(that);
          emit.end(event, mode.name);
        }

        function keydowned(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              shifting = signX && signY;
              break;
            }
            case 18: { // ALT
              if (mode === MODE_HANDLE) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
                move(event);
              }
              break;
            }
            case 32: { // SPACE; takes priority over ALT
              if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
                if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
                mode = MODE_SPACE;
                overlay.attr("cursor", cursors.selection);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }

        function keyupped(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              if (shifting) {
                lockX = lockY = shifting = false;
                move(event);
              }
              break;
            }
            case 18: { // ALT
              if (mode === MODE_CENTER) {
                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
                move(event);
              }
              break;
            }
            case 32: { // SPACE
              if (mode === MODE_SPACE) {
                if (event.altKey) {
                  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                  mode = MODE_CENTER;
                } else {
                  if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                  if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                  mode = MODE_HANDLE;
                }
                overlay.attr("cursor", cursors[type]);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }
      }

      function touchmoved(event) {
        emitter(this, arguments).moved(event);
      }

      function touchended(event) {
        emitter(this, arguments).ended(event);
      }

      function initialize() {
        var state = this.__brush || {selection: null};
        state.extent = number2(extent.apply(this, arguments));
        state.dim = dim;
        return state;
      }

      brush.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$7(number2(_)), brush) : extent;
      };

      brush.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$7(!!_), brush) : filter;
      };

      brush.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$7(!!_), brush) : touchable;
      };

      brush.handleSize = function(_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
      };

      brush.keyModifiers = function(_) {
        return arguments.length ? (keys = !!_, brush) : keys;
      };

      brush.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
      };

      return brush;
    }

    var abs$2 = Math.abs;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var pi$3 = Math.PI;
    var halfPi$2 = pi$3 / 2;
    var tau$4 = pi$3 * 2;
    var max$1 = Math.max;
    var epsilon$5 = 1e-12;

    function range$1(i, j) {
      return Array.from({length: j - i}, (_, k) => i + k);
    }

    function compareValue(compare) {
      return function(a, b) {
        return compare(
          a.source.value + a.target.value,
          b.source.value + b.target.value
        );
      };
    }

    function chord() {
      return chord$1(false, false);
    }

    function chordTranspose() {
      return chord$1(false, true);
    }

    function chordDirected() {
      return chord$1(true, false);
    }

    function chord$1(directed, transpose) {
      var padAngle = 0,
          sortGroups = null,
          sortSubgroups = null,
          sortChords = null;

      function chord(matrix) {
        var n = matrix.length,
            groupSums = new Array(n),
            groupIndex = range$1(0, n),
            chords = new Array(n * n),
            groups = new Array(n),
            k = 0, dx;

        matrix = Float64Array.from({length: n * n}, transpose
            ? (_, i) => matrix[i % n][i / n | 0]
            : (_, i) => matrix[i / n | 0][i % n]);

        // Compute the scaling factor from value to angle in [0, 2pi].
        for (let i = 0; i < n; ++i) {
          let x = 0;
          for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];
          k += groupSums[i] = x;
        }
        k = max$1(0, tau$4 - padAngle * n) / k;
        dx = k ? padAngle : tau$4 / n;

        // Compute the angles for each group and constituent chord.
        {
          let x = 0;
          if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));
          for (const i of groupIndex) {
            const x0 = x;
            if (directed) {
              const subgroupIndex = range$1(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
              for (const j of subgroupIndex) {
                if (j < 0) {
                  const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};
                } else {
                  const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            } else {
              const subgroupIndex = range$1(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));
              for (const j of subgroupIndex) {
                let chord;
                if (i < j) {
                  chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                } else {
                  chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                  if (i === j) chord.source = chord.target;
                }
                if (chord.source && chord.target && chord.source.value < chord.target.value) {
                  const source = chord.source;
                  chord.source = chord.target;
                  chord.target = source;
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            }
            x += dx;
          }
        }

        // Remove empty chords.
        chords = Object.values(chords);
        chords.groups = groups;
        return sortChords ? chords.sort(sortChords) : chords;
      }

      chord.padAngle = function(_) {
        return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
      };

      chord.sortGroups = function(_) {
        return arguments.length ? (sortGroups = _, chord) : sortGroups;
      };

      chord.sortSubgroups = function(_) {
        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
      };

      chord.sortChords = function(_) {
        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
      };

      return chord;
    }

    const pi$2 = Math.PI,
        tau$3 = 2 * pi$2,
        epsilon$4 = 1e-6,
        tauEpsilon = tau$3 - epsilon$4;

    function Path$1() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }

    function path() {
      return new Path$1;
    }

    Path$1.prototype = path.prototype = {
      constructor: Path$1,
      moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$4));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$4) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$4) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$4 || Math.abs(this._y1 - y0) > epsilon$4) {
          this._ += "L" + x0 + "," + y0;
        }

        // Is this arc empty? Were done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$3 + tau$3;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$4) {
          this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
      },
      toString: function() {
        return this._;
      }
    };

    var slice$2 = Array.prototype.slice;

    function constant$6(x) {
      return function() {
        return x;
      };
    }

    function defaultSource$1(d) {
      return d.source;
    }

    function defaultTarget(d) {
      return d.target;
    }

    function defaultRadius$1(d) {
      return d.radius;
    }

    function defaultStartAngle(d) {
      return d.startAngle;
    }

    function defaultEndAngle(d) {
      return d.endAngle;
    }

    function defaultPadAngle() {
      return 0;
    }

    function defaultArrowheadRadius() {
      return 10;
    }

    function ribbon(headRadius) {
      var source = defaultSource$1,
          target = defaultTarget,
          sourceRadius = defaultRadius$1,
          targetRadius = defaultRadius$1,
          startAngle = defaultStartAngle,
          endAngle = defaultEndAngle,
          padAngle = defaultPadAngle,
          context = null;

      function ribbon() {
        var buffer,
            s = source.apply(this, arguments),
            t = target.apply(this, arguments),
            ap = padAngle.apply(this, arguments) / 2,
            argv = slice$2.call(arguments),
            sr = +sourceRadius.apply(this, (argv[0] = s, argv)),
            sa0 = startAngle.apply(this, argv) - halfPi$2,
            sa1 = endAngle.apply(this, argv) - halfPi$2,
            tr = +targetRadius.apply(this, (argv[0] = t, argv)),
            ta0 = startAngle.apply(this, argv) - halfPi$2,
            ta1 = endAngle.apply(this, argv) - halfPi$2;

        if (!context) context = buffer = path();

        if (ap > epsilon$5) {
          if (abs$2(sa1 - sa0) > ap * 2 + epsilon$5) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
          else sa0 = sa1 = (sa0 + sa1) / 2;
          if (abs$2(ta1 - ta0) > ap * 2 + epsilon$5) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
          else ta0 = ta1 = (ta0 + ta1) / 2;
        }

        context.moveTo(sr * cos$2(sa0), sr * sin$2(sa0));
        context.arc(0, 0, sr, sa0, sa1);
        if (sa0 !== ta0 || sa1 !== ta1) {
          if (headRadius) {
            var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
            context.quadraticCurveTo(0, 0, tr2 * cos$2(ta0), tr2 * sin$2(ta0));
            context.lineTo(tr * cos$2(ta2), tr * sin$2(ta2));
            context.lineTo(tr2 * cos$2(ta1), tr2 * sin$2(ta1));
          } else {
            context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
            context.arc(0, 0, tr, ta0, ta1);
          }
        }
        context.quadraticCurveTo(0, 0, sr * cos$2(sa0), sr * sin$2(sa0));
        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      if (headRadius) ribbon.headRadius = function(_) {
        return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : headRadius;
      };

      ribbon.radius = function(_) {
        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.sourceRadius = function(_) {
        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.targetRadius = function(_) {
        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : targetRadius;
      };

      ribbon.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : startAngle;
      };

      ribbon.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : endAngle;
      };

      ribbon.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : padAngle;
      };

      ribbon.source = function(_) {
        return arguments.length ? (source = _, ribbon) : source;
      };

      ribbon.target = function(_) {
        return arguments.length ? (target = _, ribbon) : target;
      };

      ribbon.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
      };

      return ribbon;
    }

    function ribbon$1() {
      return ribbon();
    }

    function ribbonArrow() {
      return ribbon(defaultArrowheadRadius);
    }

    var array$2 = Array.prototype;

    var slice$1 = array$2.slice;

    function ascending$1(a, b) {
      return a - b;
    }

    function area$3(ring) {
      var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area;
    }

    var constant$5 = x => () => x;

    function contains$2(ring, hole) {
      var i = -1, n = hole.length, c;
      while (++i < n) if (c = ringContains(ring, hole[i])) return c;
      return 0;
    }

    function ringContains(ring, point) {
      var x = point[0], y = point[1], contains = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) return 0;
        if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
      }
      return contains;
    }

    function segmentContains(a, b, c) {
      var i; return collinear$1(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
    }

    function collinear$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
    }

    function within(p, q, r) {
      return p <= q && q <= r || r <= q && q <= p;
    }

    function noop$3() {}

    var cases = [
      [],
      [[[1.0, 1.5], [0.5, 1.0]]],
      [[[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [0.5, 1.0]]],
      [[[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 0.5], [1.0, 1.5]]],
      [[[1.0, 0.5], [0.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 0.5]]],
      [[[1.0, 1.5], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.5, 1.0]]],
      [[[1.0, 1.5], [1.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 1.5]]],
      []
    ];

    function contours() {
      var dx = 1,
          dy = 1,
          threshold = thresholdSturges,
          smooth = smoothLinear;

      function contours(values) {
        var tz = threshold(values);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          const e = extent$1(values), ts = tickStep(e[0], e[1], tz);
          tz = ticks(Math.floor(e[0] / ts) * ts, Math.floor(e[1] / ts - 1) * ts, tz);
        } else {
          tz = tz.slice().sort(ascending$1);
        }

        return tz.map(value => contour(values, value));
      }

      // Accumulate, smooth contour rings, assign holes to exterior rings.
      // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
      function contour(values, value) {
        var polygons = [],
            holes = [];

        isorings(values, value, function(ring) {
          smooth(ring, values, value);
          if (area$3(ring) > 0) polygons.push([ring]);
          else holes.push(ring);
        });

        holes.forEach(function(hole) {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            if (contains$2((polygon = polygons[i])[0], hole) !== -1) {
              polygon.push(hole);
              return;
            }
          }
        });

        return {
          type: "MultiPolygon",
          value: value,
          coordinates: polygons
        };
      }

      // Marching squares with isolines stitched into rings.
      // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
      function isorings(values, value, callback) {
        var fragmentByStart = new Array,
            fragmentByEnd = new Array,
            x, y, t0, t1, t2, t3;

        // Special case for the first row (y = -1, t2 = t3 = 0).
        x = y = -1;
        t1 = values[0] >= value;
        cases[t1 << 1].forEach(stitch);
        while (++x < dx - 1) {
          t0 = t1, t1 = values[x + 1] >= value;
          cases[t0 | t1 << 1].forEach(stitch);
        }
        cases[t1 << 0].forEach(stitch);

        // General case for the intermediate rows.
        while (++y < dy - 1) {
          x = -1;
          t1 = values[y * dx + dx] >= value;
          t2 = values[y * dx] >= value;
          cases[t1 << 1 | t2 << 2].forEach(stitch);
          while (++x < dx - 1) {
            t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
            t3 = t2, t2 = values[y * dx + x + 1] >= value;
            cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
          }
          cases[t1 | t2 << 3].forEach(stitch);
        }

        // Special case for the last row (y = dy - 1, t0 = t1 = 0).
        x = -1;
        t2 = values[y * dx] >= value;
        cases[t2 << 2].forEach(stitch);
        while (++x < dx - 1) {
          t3 = t2, t2 = values[y * dx + x + 1] >= value;
          cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);

        function stitch(line) {
          var start = [line[0][0] + x, line[0][1] + y],
              end = [line[1][0] + x, line[1][1] + y],
              startIndex = index(start),
              endIndex = index(end),
              f, g;
          if (f = fragmentByEnd[startIndex]) {
            if (g = fragmentByStart[endIndex]) {
              delete fragmentByEnd[f.end];
              delete fragmentByStart[g.start];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
              }
            } else {
              delete fragmentByEnd[f.end];
              f.ring.push(end);
              fragmentByEnd[f.end = endIndex] = f;
            }
          } else if (f = fragmentByStart[endIndex]) {
            if (g = fragmentByEnd[startIndex]) {
              delete fragmentByStart[f.start];
              delete fragmentByEnd[g.end];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
              }
            } else {
              delete fragmentByStart[f.start];
              f.ring.unshift(start);
              fragmentByStart[f.start = startIndex] = f;
            }
          } else {
            fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
          }
        }
      }

      function index(point) {
        return point[0] * 2 + point[1] * (dx + 1) * 4;
      }

      function smoothLinear(ring, values, value) {
        ring.forEach(function(point) {
          var x = point[0],
              y = point[1],
              xt = x | 0,
              yt = y | 0,
              v0,
              v1 = values[yt * dx + xt];
          if (x > 0 && x < dx && xt === x) {
            v0 = values[yt * dx + xt - 1];
            point[0] = x + (value - v0) / (v1 - v0) - 0.5;
          }
          if (y > 0 && y < dy && yt === y) {
            v0 = values[(yt - 1) * dx + xt];
            point[1] = y + (value - v0) / (v1 - v0) - 0.5;
          }
        });
      }

      contours.contour = contour;

      contours.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, contours;
      };

      contours.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), contours) : threshold;
      };

      contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop$3, contours) : smooth === smoothLinear;
      };

      return contours;
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurX(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var j = 0; j < m; ++j) {
        for (var i = 0, sr = 0; i < n + r; ++i) {
          if (i < n) {
            sr += source.data[i + j * n];
          }
          if (i >= r) {
            if (i >= w) {
              sr -= source.data[i - w + j * n];
            }
            target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
          }
        }
      }
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurY(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var i = 0; i < n; ++i) {
        for (var j = 0, sr = 0; j < m + r; ++j) {
          if (j < m) {
            sr += source.data[i + j * n];
          }
          if (j >= r) {
            if (j >= w) {
              sr -= source.data[i + (j - w) * n];
            }
            target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
          }
        }
      }
    }

    function defaultX$1(d) {
      return d[0];
    }

    function defaultY$1(d) {
      return d[1];
    }

    function defaultWeight() {
      return 1;
    }

    function density() {
      var x = defaultX$1,
          y = defaultY$1,
          weight = defaultWeight,
          dx = 960,
          dy = 500,
          r = 20, // blur radius
          k = 2, // log2(grid cell size)
          o = r * 3, // grid offset, to pad for blur
          n = (dx + o * 2) >> k, // grid width
          m = (dy + o * 2) >> k, // grid height
          threshold = constant$5(20);

      function density(data) {
        var values0 = new Float32Array(n * m),
            values1 = new Float32Array(n * m),
            pow2k = Math.pow(2, -k);

        data.forEach(function(d, i, data) {
          var xi = (x(d, i, data) + o) * pow2k,
              yi = (y(d, i, data) + o) * pow2k,
              wi = +weight(d, i, data);
          if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
            var x0 = Math.floor(xi),
                y0 = Math.floor(yi),
                xt = xi - x0 - 0.5,
                yt = yi - y0 - 0.5;
            values0[x0 + y0 * n] += (1 - xt) * (1 - yt) * wi;
            values0[x0 + 1 + y0 * n] += xt * (1 - yt) * wi;
            values0[x0 + 1 + (y0 + 1) * n] += xt * yt * wi;
            values0[x0 + (y0 + 1) * n] += (1 - xt) * yt * wi;
          }
        });

        // TODO Optimize.
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

        var tz = threshold(values0);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          var stop = max$3(values0);
          tz = tickStep(0, stop, tz);
          tz = range$2(0, Math.floor(stop / tz) * tz, tz);
          tz.shift();
        }

        return contours()
            .thresholds(tz)
            .size([n, m])
          (values0)
            .map(transform);
      }

      function transform(geometry) {
        geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      }

      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }

      function transformRing(coordinates) {
        coordinates.forEach(transformPoint);
      }

      // TODO Optimize.
      function transformPoint(coordinates) {
        coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
        coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
      }

      function resize() {
        o = r * 3;
        n = (dx + o * 2) >> k;
        m = (dy + o * 2) >> k;
        return density;
      }

      density.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$5(+_), density) : x;
      };

      density.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$5(+_), density) : y;
      };

      density.weight = function(_) {
        return arguments.length ? (weight = typeof _ === "function" ? _ : constant$5(+_), density) : weight;
      };

      density.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = +_[0], _1 = +_[1];
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, resize();
      };

      density.cellSize = function(_) {
        if (!arguments.length) return 1 << k;
        if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
        return k = Math.floor(Math.log(_) / Math.LN2), resize();
      };

      density.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), density) : threshold;
      };

      density.bandwidth = function(_) {
        if (!arguments.length) return Math.sqrt(r * (r + 1));
        if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
        return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
      };

      return density;
    }

    const epsilon$3 = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon$3) * epsilon$3;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum$1(elen, e, flen, f, h) {
        let Q, Qnew, hh, bvirt;
        let enow = e[0];
        let fnow = f[0];
        let eindex = 0;
        let findex = 0;
        if ((fnow > enow) === (fnow > -enow)) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        let hindex = 0;
        if (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
                if ((fnow > enow) === (fnow > -enow)) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) {
                    h[hindex++] = hh;
                }
            }
        }
        while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
        }
        return hindex;
    }

    function estimate(elen, e) {
        let Q = e[0];
        for (let i = 1; i < elen; i++) Q += e[i];
        return Q;
    }

    function vec(n) {
        return new Float64Array(n);
    }

    const ccwerrboundA = (3 + 16 * epsilon$3) * epsilon$3;
    const ccwerrboundB = (2 + 12 * epsilon$3) * epsilon$3;
    const ccwerrboundC = (9 + 64 * epsilon$3) * epsilon$3 * epsilon$3;

    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);

    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        let acxtail, acytail, bcxtail, bcytail;
        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

        const acx = ax - cx;
        const bcx = bx - cx;
        const acy = ay - cy;
        const bcy = by - cy;

        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B[3] = u3;

        let det = estimate(4, B);
        let errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) {
            return det;
        }

        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);

        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
        }

        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) return det;

        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C1len = sum$1(4, B, 4, u, C1);

        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C2len = sum$1(C1len, C1, 4, u, C2);

        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const Dlen = sum$1(C2len, C2, 4, u, D);

        return D[Dlen - 1];
    }

    function orient2d(ax, ay, bx, by, cx, cy) {
        const detleft = (ay - cy) * (bx - cx);
        const detright = (ax - cx) * (by - cy);
        const det = detleft - detright;

        if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;

        const detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) return det;

        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    const EPSILON = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);

    class Delaunator {

        static from(points, getX = defaultGetX, getY = defaultGetY) {
            const n = points.length;
            const coords = new Float64Array(n * 2);

            for (let i = 0; i < n; i++) {
                const p = points[i];
                coords[2 * i] = getX(p);
                coords[2 * i + 1] = getY(p);
            }

            return new Delaunator(coords);
        }

        constructor(coords) {
            const n = coords.length >> 1;
            if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

            this.coords = coords;

            // arrays that will store the triangulation graph
            const maxTriangles = Math.max(2 * n - 5, 0);
            this._triangles = new Uint32Array(maxTriangles * 3);
            this._halfedges = new Int32Array(maxTriangles * 3);

            // temporary arrays for tracking the edges of the advancing convex hull
            this._hashSize = Math.ceil(Math.sqrt(n));
            this._hullPrev = new Uint32Array(n); // edge to prev edge
            this._hullNext = new Uint32Array(n); // edge to next edge
            this._hullTri = new Uint32Array(n); // edge to adjacent triangle
            this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

            // temporary arrays for sorting points
            this._ids = new Uint32Array(n);
            this._dists = new Float64Array(n);

            this.update();
        }

        update() {
            const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
            const n = coords.length >> 1;

            // populate an array of point indices; calculate input data bbox
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            for (let i = 0; i < n; i++) {
                const x = coords[2 * i];
                const y = coords[2 * i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                this._ids[i] = i;
            }
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            let minDist = Infinity;
            let i0, i1, i2;

            // pick a seed point close to the center
            for (let i = 0; i < n; i++) {
                const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist) {
                    i0 = i;
                    minDist = d;
                }
            }
            const i0x = coords[2 * i0];
            const i0y = coords[2 * i0 + 1];

            minDist = Infinity;

            // find the point closest to the seed
            for (let i = 0; i < n; i++) {
                if (i === i0) continue;
                const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist && d > 0) {
                    i1 = i;
                    minDist = d;
                }
            }
            let i1x = coords[2 * i1];
            let i1y = coords[2 * i1 + 1];

            let minRadius = Infinity;

            // find the third point which forms the smallest circumcircle with the first two
            for (let i = 0; i < n; i++) {
                if (i === i0 || i === i1) continue;
                const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
                if (r < minRadius) {
                    i2 = i;
                    minRadius = r;
                }
            }
            let i2x = coords[2 * i2];
            let i2y = coords[2 * i2 + 1];

            if (minRadius === Infinity) {
                // order collinear points by dx (or dy if all x are identical)
                // and return the list as a hull
                for (let i = 0; i < n; i++) {
                    this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
                }
                quicksort(this._ids, this._dists, 0, n - 1);
                const hull = new Uint32Array(n);
                let j = 0;
                for (let i = 0, d0 = -Infinity; i < n; i++) {
                    const id = this._ids[i];
                    if (this._dists[id] > d0) {
                        hull[j++] = id;
                        d0 = this._dists[id];
                    }
                }
                this.hull = hull.subarray(0, j);
                this.triangles = new Uint32Array(0);
                this.halfedges = new Uint32Array(0);
                return;
            }

            // swap the order of the seed points for counter-clockwise orientation
            if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
                const i = i1;
                const x = i1x;
                const y = i1y;
                i1 = i2;
                i1x = i2x;
                i1y = i2y;
                i2 = i;
                i2x = x;
                i2y = y;
            }

            const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
            this._cx = center.x;
            this._cy = center.y;

            for (let i = 0; i < n; i++) {
                this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
            }

            // sort the points by distance from the seed triangle circumcenter
            quicksort(this._ids, this._dists, 0, n - 1);

            // set up the seed triangle as the starting hull
            this._hullStart = i0;
            let hullSize = 3;

            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;

            hullTri[i0] = 0;
            hullTri[i1] = 1;
            hullTri[i2] = 2;

            hullHash.fill(-1);
            hullHash[this._hashKey(i0x, i0y)] = i0;
            hullHash[this._hashKey(i1x, i1y)] = i1;
            hullHash[this._hashKey(i2x, i2y)] = i2;

            this.trianglesLen = 0;
            this._addTriangle(i0, i1, i2, -1, -1, -1);

            for (let k = 0, xp, yp; k < this._ids.length; k++) {
                const i = this._ids[k];
                const x = coords[2 * i];
                const y = coords[2 * i + 1];

                // skip near-duplicate points
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
                xp = x;
                yp = y;

                // skip seed triangle points
                if (i === i0 || i === i1 || i === i2) continue;

                // find a visible edge on the convex hull using edge hash
                let start = 0;
                for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                    start = hullHash[(key + j) % this._hashSize];
                    if (start !== -1 && start !== hullNext[start]) break;
                }

                start = hullPrev[start];
                let e = start, q;
                while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                    e = q;
                    if (e === start) {
                        e = -1;
                        break;
                    }
                }
                if (e === -1) continue; // likely a near-duplicate point; skip it

                // add the first triangle from the point
                let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

                // recursively flip triangles from the point until they satisfy the Delaunay condition
                hullTri[i] = this._legalize(t + 2);
                hullTri[e] = t; // keep track of boundary triangles on the hull
                hullSize++;

                // walk forward through the hull, adding more triangles and flipping recursively
                let n = hullNext[e];
                while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                    t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this._legalize(t + 2);
                    hullNext[n] = n; // mark as removed
                    hullSize--;
                    n = q;
                }

                // walk backward from the other side, adding more triangles and flipping
                if (e === start) {
                    while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                        t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this._legalize(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e; // mark as removed
                        hullSize--;
                        e = q;
                    }
                }

                // update the hull indices
                this._hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;

                // save the two new edges in the hash table
                hullHash[this._hashKey(x, y)] = i;
                hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
            }

            this.hull = new Uint32Array(hullSize);
            for (let i = 0, e = this._hullStart; i < hullSize; i++) {
                this.hull[i] = e;
                e = hullNext[e];
            }

            // trim typed triangle mesh arrays
            this.triangles = this._triangles.subarray(0, this.trianglesLen);
            this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }

        _hashKey(x, y) {
            return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
        }

        _legalize(a) {
            const {_triangles: triangles, _halfedges: halfedges, coords} = this;

            let i = 0;
            let ar = 0;

            // recursion eliminated with a fixed-size stack
            while (true) {
                const b = halfedges[a];

                /* if the pair of triangles doesn't satisfy the Delaunay condition
                 * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
                 * then do the same check/flip recursively for the new pair of triangles
                 *
                 *           pl                    pl
                 *          /||\                  /  \
                 *       al/ || \bl            al/    \a
                 *        /  ||  \              /      \
                 *       /  a||b  \    flip    /___ar___\
                 *     p0\   ||   /p1   =>   p0\---bl---/p1
                 *        \  ||  /              \      /
                 *       ar\ || /br             b\    /br
                 *          \||/                  \  /
                 *           pr                    pr
                 */
                const a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;

                if (b === -1) { // convex hull edge
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                    continue;
                }

                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;

                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];

                const illegal = inCircle(
                    coords[2 * p0], coords[2 * p0 + 1],
                    coords[2 * pr], coords[2 * pr + 1],
                    coords[2 * pl], coords[2 * pl + 1],
                    coords[2 * p1], coords[2 * p1 + 1]);

                if (illegal) {
                    triangles[a] = p1;
                    triangles[b] = p0;

                    const hbl = halfedges[bl];

                    // edge swapped on the other side of the hull (rare); fix the halfedge reference
                    if (hbl === -1) {
                        let e = this._hullStart;
                        do {
                            if (this._hullTri[e] === bl) {
                                this._hullTri[e] = a;
                                break;
                            }
                            e = this._hullPrev[e];
                        } while (e !== this._hullStart);
                    }
                    this._link(a, hbl);
                    this._link(b, halfedges[ar]);
                    this._link(ar, bl);

                    const br = b0 + (b + 1) % 3;

                    // don't worry about hitting the cap: it can only happen on extremely degenerate input
                    if (i < EDGE_STACK.length) {
                        EDGE_STACK[i++] = br;
                    }
                } else {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                }
            }

            return ar;
        }

        _link(a, b) {
            this._halfedges[a] = b;
            if (b !== -1) this._halfedges[b] = a;
        }

        // add a new triangle given vertex indices and adjacent half-edge ids
        _addTriangle(i0, i1, i2, a, b, c) {
            const t = this.trianglesLen;

            this._triangles[t] = i0;
            this._triangles[t + 1] = i1;
            this._triangles[t + 2] = i2;

            this._link(t, a);
            this._link(t + 1, b);
            this._link(t + 2, c);

            this.trianglesLen += 3;

            return t;
        }
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    function pseudoAngle(dx, dy) {
        const p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
    }

    function dist(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return dx * dx + dy * dy;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        const dx = ax - px;
        const dy = ay - py;
        const ex = bx - px;
        const ey = by - py;
        const fx = cx - px;
        const fy = cy - py;

        const ap = dx * dx + dy * dy;
        const bp = ex * ex + ey * ey;
        const cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) -
               dy * (ex * cp - bp * fx) +
               ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = (ey * bl - dy * cl) * d;
        const y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = ax + (ey * bl - dy * cl) * d;
        const y = ay + (dx * cl - ex * bl) * d;

        return {x, y};
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (let i = left + 1; i <= right; i++) {
                const temp = ids[i];
                const tempDist = dists[temp];
                let j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
                ids[j + 1] = temp;
            }
        } else {
            const median = (left + right) >> 1;
            let i = left + 1;
            let j = right;
            swap(ids, median, i);
            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

            const temp = ids[i];
            const tempDist = dists[temp];
            while (true) {
                do i++; while (dists[ids[i]] < tempDist);
                do j--; while (dists[ids[j]] > tempDist);
                if (j < i) break;
                swap(ids, i, j);
            }
            ids[left + 1] = ids[j];
            ids[j] = temp;

            if (right - i + 1 >= j - left) {
                quicksort(ids, dists, i, right);
                quicksort(ids, dists, left, j - 1);
            } else {
                quicksort(ids, dists, left, j - 1);
                quicksort(ids, dists, i, right);
            }
        }
    }

    function swap(arr, i, j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultGetX(p) {
        return p[0];
    }
    function defaultGetY(p) {
        return p[1];
    }

    const epsilon$2 = 1e-6;

    class Path {
      constructor() {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
      }
      moveTo(x, y) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x, y) {
        this._ += `L${this._x1 = +x},${this._y1 = +y}`;
      }
      arc(x, y, r) {
        x = +x, y = +y, r = +r;
        const x0 = x + r;
        const y0 = y;
        if (r < 0) throw new Error("negative radius");
        if (this._x1 === null) this._ += `M${x0},${y0}`;
        else if (Math.abs(this._x1 - x0) > epsilon$2 || Math.abs(this._y1 - y0) > epsilon$2) this._ += "L" + x0 + "," + y0;
        if (!r) return;
        this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
      }
      rect(x, y, w, h) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
      }
      value() {
        return this._ || null;
      }
    }

    class Polygon {
      constructor() {
        this._ = [];
      }
      moveTo(x, y) {
        this._.push([x, y]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x, y) {
        this._.push([x, y]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    }

    class Voronoi {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const {delaunay: {points, hull, triangles}, vectors} = this;

        // Compute circumcenters.
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
          const t1 = triangles[i] * 2;
          const t2 = triangles[i + 1] * 2;
          const t3 = triangles[i + 2] * 2;
          const x1 = points[t1];
          const y1 = points[t1 + 1];
          const x2 = points[t2];
          const y2 = points[t2 + 1];
          const x3 = points[t3];
          const y3 = points[t3 + 1];

          const dx = x2 - x1;
          const dy = y2 - y1;
          const ex = x3 - x1;
          const ey = y3 - y1;
          const ab = (dx * ey - dy * ex) * 2;

          if (Math.abs(ab) < 1e-9) {
            // degenerate case (collinear diagram)
            // almost equal points (degenerate triangle)
            // the circumcenter is at the infinity, in a
            // direction that is:
            // 1. orthogonal to the halfedge.
            let a = 1e9;
            // 2. points away from the center; since the list of triangles starts
            // in the center, the first point of the first triangle
            // will be our reference
            const r = triangles[0] * 2;
            a *= Math.sign((points[r] - x1) * ey - (points[r + 1] - y1) * ex);
            x = (x1 + x3) / 2 - a * ey;
            y = (y1 + y3) / 2 + a * ex;
          } else {
            const d = 1 / ab;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x = x1 + (ey * bl - dy * cl) * d;
            y = y1 + (dx * cl - ex * bl) * d;
          }
          circumcenters[j] = x;
          circumcenters[j + 1] = y;
        }

        // Compute exterior cell rays.
        let h = hull[hull.length - 1];
        let p0, p1 = h * 4;
        let x0, x1 = points[2 * h];
        let y0, y1 = points[2 * h + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h = hull[i];
          p0 = p1, x0 = x1, y0 = y1;
          p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
          vectors[p0 + 2] = vectors[p1] = y0 - y1;
          vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
        }
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
        if (hull.length <= 1) return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t = Math.floor(inedges[h1] / 3) * 2;
          const x = circumcenters[t];
          const y = circumcenters[t + 1];
          const v = h0 * 4;
          const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
          if (p) this._renderSegment(x, y, p[0], p[1], context);
        }
        return buffer && buffer.value();
      }
      renderBounds(context) {
        const buffer = context == null ? context = new Path : undefined;
        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const points = this._clip(i);
        if (points === null || !points.length) return;
        context.moveTo(points[0], points[1]);
        let n = points.length;
        while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
        for (let i = 2; i < n; i += 2) {
          if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
            context.lineTo(points[i], points[i + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const {delaunay: {points}} = this;
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const cell = this.cellPolygon(i);
          if (cell) cell.index = i, yield cell;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon;
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x0, y0, x1, y1, context) {
        let S;
        const c0 = this._regioncode(x0, y0);
        const c1 = this._regioncode(x1, y1);
        if (c0 === 0 && c1 === 0) {
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
        } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
          context.moveTo(S[0], S[1]);
          context.lineTo(S[2], S[3]);
        }
      }
      contains(i, x, y) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
        return this.delaunay._step(i, x, y) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci) for (const j of this.delaunay.neighbors(i)) {
          const cj = this._clip(j);
          // find the common edge
          if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
            for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
              if (ci[ai] == cj[aj]
              && ci[ai + 1] == cj[aj + 1]
              && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
              && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
              ) {
                yield j;
                break loop;
              }
            }
          }
        }
      }
      _cell(i) {
        const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
        const e0 = inedges[i];
        if (e0 === -1) return null; // coincident point
        const points = [];
        let e = e0;
        do {
          const t = Math.floor(e / 3);
          points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
        } while (e !== e0 && e !== -1);
        return points;
      }
      _clip(i) {
        // degenerate case (1 valid point: return the box)
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points = this._cell(i);
        if (points === null) return null;
        const {vectors: V} = this;
        const v = i * 4;
        return V[v] || V[v + 1]
            ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
            : this._clipFinite(i, points);
      }
      _clipFinite(i, points) {
        const n = points.length;
        let P = null;
        let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
        let c0, c1 = this._regioncode(x1, y1);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
          c0 = c1, c1 = this._regioncode(x1, y1);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P) P.push(x1, y1);
            else P = [x1, y1];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1) this._edge(i, e0, e1, P, P.length);
              if (P) P.push(sx0, sy0);
              else P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1) this._edge(i, e0, e1, P, P.length);
            if (P) P.push(sx1, sy1);
            else P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x0, y0, x1, y1, c0, c1) {
        while (true) {
          if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
          if (c0 & c1) return null;
          let x, y, c = c0 || c1;
          if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
          else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
          else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
          else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
          if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
          else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
        }
      }
      _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
        let P = Array.from(points), p;
        if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x, y;
          switch (e0) {
            case 0b0101: e0 = 0b0100; continue; // top-left
            case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
            case 0b0110: e0 = 0b0010; continue; // top-right
            case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
            case 0b1010: e0 = 0b1000; continue; // bottom-right
            case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
            case 0b1001: e0 = 0b0001; continue; // bottom-left
            case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
          }
          // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are
          // undefined, the conditional statement will be executed.
          if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
            P.splice(j, 0, x, y), j += 2;
          }
        }
        if (P.length > 4) {
          for (let i = 0; i < P.length; i+= 2) {
            const j = (i + 2) % P.length, k = (i + 4) % P.length;
            if (P[i] === P[j] && P[j] === P[k]
            || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
              P.splice(j, 2), i -= 2;
          }
        }
        return j;
      }
      _project(x0, y0, vx, vy) {
        let t = Infinity, c, x, y;
        if (vy < 0) { // top
          if (y0 <= this.ymin) return null;
          if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
        } else if (vy > 0) { // bottom
          if (y0 >= this.ymax) return null;
          if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
        }
        if (vx > 0) { // right
          if (x0 >= this.xmax) return null;
          if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
        } else if (vx < 0) { // left
          if (x0 <= this.xmin) return null;
          if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
        }
        return [x, y];
      }
      _edgecode(x, y) {
        return (x === this.xmin ? 0b0001
            : x === this.xmax ? 0b0010 : 0b0000)
            | (y === this.ymin ? 0b0100
            : y === this.ymax ? 0b1000 : 0b0000);
      }
      _regioncode(x, y) {
        return (x < this.xmin ? 0b0001
            : x > this.xmax ? 0b0010 : 0b0000)
            | (y < this.ymin ? 0b0100
            : y > this.ymax ? 0b1000 : 0b0000);
      }
    }

    const tau$2 = 2 * Math.PI, pow$2 = Math.pow;

    function pointX(p) {
      return p[0];
    }

    function pointY(p) {
      return p[1];
    }

    // A triangulation is collinear if all its triangles have a non-null area
    function collinear(d) {
      const {triangles, coords} = d;
      for (let i = 0; i < triangles.length; i += 3) {
        const a = 2 * triangles[i],
              b = 2 * triangles[i + 1],
              c = 2 * triangles[i + 2],
              cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                    - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
        if (cross > 1e-10) return false;
      }
      return true;
    }

    function jitter(x, y, r) {
      return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
    }

    class Delaunay {
      static from(points, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points
            ? flatArray(points, fx, fy, that)
            : Float64Array.from(flatIterable(points, fx, fy, that)));
      }
      constructor(points) {
        this._delaunator = new Delaunator(points);
        this.inedges = new Int32Array(points.length / 2);
        this._hullIndex = new Int32Array(points.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points = this.points;

        // check for collinear
        if (d.hull && d.hull.length > 2 && collinear(d)) {
          this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
            .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
          const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
            bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
          for (let i = 0, n = points.length / 2; i < n; ++i) {
            const p = jitter(points[2 * i], points[2 * i + 1], r);
            points[2 * i] = p[0];
            points[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points);
        } else {
          delete this.collinear;
        }

        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);

        // Compute an index from each point to an (arbitrary) incoming halfedge
        // Used to give the first neighbor of each point; for this reason,
        // on the hull we give priority to exterior halfedges
        for (let e = 0, n = halfedges.length; e < n; ++e) {
          const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
          if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }

        // degenerate case: 1 or 2 (distinct) points
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds) {
        return new Voronoi(this, bounds);
      }
      *neighbors(i) {
        const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

        // degenerate case with several collinear points
        if (collinear) {
          const l = collinear.indexOf(i);
          if (l > 0) yield collinear[l - 1];
          if (l < collinear.length - 1) yield collinear[l + 1];
          return;
        }

        const e0 = inedges[i];
        if (e0 === -1) return; // coincident point
        let e = e0, p0 = -1;
        do {
          yield p0 = triangles[e];
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) return; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p0) yield p;
            return;
          }
        } while (e !== e0);
      }
      find(x, y, i = 0) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
        const i0 = i;
        let c;
        while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
        return c;
      }
      _step(i, x, y) {
        const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
        if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
        let c = i;
        let dc = pow$2(x - points[i * 2], 2) + pow$2(y - points[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e = e0;
        do {
          let t = triangles[e];
          const dt = pow$2(x - points[t * 2], 2) + pow$2(y - points[t * 2 + 1], 2);
          if (dt < dc) dc = dt, c = t;
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            e = hull[(_hullIndex[i] + 1) % hull.length];
            if (e !== t) {
              if (pow$2(x - points[e * 2], 2) + pow$2(y - points[e * 2 + 1], 2) < dc) return e;
            }
            break;
          }
        } while (e !== e0);
        return c;
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, halfedges, triangles} = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context.moveTo(points[ti], points[ti + 1]);
          context.lineTo(points[tj], points[tj + 1]);
        }
        this.renderHull(context);
        return buffer && buffer.value();
      }
      renderPoints(context, r) {
        if (r === undefined && (!context || typeof context.moveTo !== "function")) r = context, context = null;
        r = r == undefined ? 2 : +r;
        const buffer = context == null ? context = new Path : undefined;
        const {points} = this;
        for (let i = 0, n = points.length; i < n; i += 2) {
          const x = points[i], y = points[i + 1];
          context.moveTo(x + r, y);
          context.arc(x, y, r, 0, tau$2);
        }
        return buffer && buffer.value();
      }
      renderHull(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {hull, points} = this;
        const h = hull[0] * 2, n = hull.length;
        context.moveTo(points[h], points[h + 1]);
        for (let i = 1; i < n; ++i) {
          const h = 2 * hull[i];
          context.lineTo(points[h], points[h + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon;
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, triangles} = this;
        const t0 = triangles[i *= 3] * 2;
        const t1 = triangles[i + 1] * 2;
        const t2 = triangles[i + 2] * 2;
        context.moveTo(points[t0], points[t0 + 1]);
        context.lineTo(points[t1], points[t1 + 1]);
        context.lineTo(points[t2], points[t2 + 1]);
        context.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const {triangles} = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon;
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    }

    function flatArray(points, fx, fy, that) {
      const n = points.length;
      const array = new Float64Array(n * 2);
      for (let i = 0; i < n; ++i) {
        const p = points[i];
        array[i * 2] = fx.call(that, p, i, points);
        array[i * 2 + 1] = fy.call(that, p, i, points);
      }
      return array;
    }

    function* flatIterable(points, fx, fy, that) {
      let i = 0;
      for (const p of points) {
        yield fx.call(that, p, i, points);
        yield fy.call(that, p, i, points);
        ++i;
      }
    }

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad$1(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear$1(year) {
      return year < 0 ? "-" + pad$1(-year, 6)
        : year > 9999 ? "+" + pad$1(year, 6)
        : pad$1(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
          : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv$1 = dsvFormat(",");

    var csvParse = csv$1.parse;
    var csvParseRows = csv$1.parseRows;
    var csvFormat = csv$1.format;
    var csvFormatBody = csv$1.formatBody;
    var csvFormatRows = csv$1.formatRows;
    var csvFormatRow = csv$1.formatRow;
    var csvFormatValue = csv$1.formatValue;

    var tsv$1 = dsvFormat("\t");

    var tsvParse = tsv$1.parse;
    var tsvParseRows = tsv$1.parseRows;
    var tsvFormat = tsv$1.format;
    var tsvFormatBody = tsv$1.formatBody;
    var tsvFormatRows = tsv$1.formatRows;
    var tsvFormatRow = tsv$1.formatRow;
    var tsvFormatValue = tsv$1.formatValue;

    function autoType(object) {
      for (var key in object) {
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
          if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
          value = new Date(value);
        }
        else continue;
        object[key] = value;
      }
      return object;
    }

    // https://github.com/d3/d3-dsv/issues/45
    const fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function responseBlob(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.blob();
    }

    function blob(input, init) {
      return fetch(input, init).then(responseBlob);
    }

    function responseArrayBuffer(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.arrayBuffer();
    }

    function buffer(input, init) {
      return fetch(input, init).then(responseArrayBuffer);
    }

    function responseText(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.text();
    }

    function text(input, init) {
      return fetch(input, init).then(responseText);
    }

    function dsvParse(parse) {
      return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return text(input, init).then(function(response) {
          return parse(response, row);
        });
      };
    }

    function dsv(delimiter, input, init, row) {
      if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
      var format = dsvFormat(delimiter);
      return text(input, init).then(function(response) {
        return format.parse(response, row);
      });
    }

    var csv = dsvParse(csvParse);
    var tsv = dsvParse(tsvParse);

    function image(input, init) {
      return new Promise(function(resolve, reject) {
        var image = new Image;
        for (var key in init) image[key] = init[key];
        image.onerror = reject;
        image.onload = function() { resolve(image); };
        image.src = input;
      });
    }

    function responseJson(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      if (response.status === 204 || response.status === 205) return;
      return response.json();
    }

    function json(input, init) {
      return fetch(input, init).then(responseJson);
    }

    function parser(type) {
      return (input, init) => text(input, init)
        .then(text => (new DOMParser).parseFromString(text, type));
    }

    var xml = parser("application/xml");

    var html = parser("text/html");

    var svg = parser("image/svg+xml");

    function center(x, y) {
      var nodes, strength = 1;

      if (x == null) x = 0;
      if (y == null) y = 0;

      function force() {
        var i,
            n = nodes.length,
            node,
            sx = 0,
            sy = 0;

        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }

        for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }

      force.initialize = function(_) {
        nodes = _;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      return force;
    }

    function tree_add(d) {
      const x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add(this.cover(x, y), x, y, d);
    }

    function add(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries dont change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0 || 1,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant cant contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isnt necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function constant$4(x) {
      return function() {
        return x;
      };
    }

    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }

    function x$3(d) {
      return d.x + d.vx;
    }

    function y$3(d) {
      return d.y + d.vy;
    }

    function collide(radius) {
      var nodes,
          radii,
          random,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant$4(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$3, y$3).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(random), l += x * x;
                if (y === 0) y = jiggle(random), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index$3(d) {
      return d.index;
    }

    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("node not found: " + nodeId);
      return node;
    }

    function link$2(links) {
      var id = index$3,
          strength = defaultStrength,
          strengths,
          distance = constant$4(30),
          distances,
          nodes,
          count,
          bias,
          random,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle(random);
            y = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$4(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$1 = 1664525;
    const c$3 = 1013904223;
    const m = 4294967296; // 2^32

    function lcg$1() {
      let s = 1;
      return () => (s = (a$1 * s + c$3) % m) / m;
    }

    function x$2(d) {
      return d.x;
    }

    function y$2(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function simulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = new Map(),
          stepper = timer(step),
          event = dispatch("tick", "end"),
          random = lcg$1();

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.forEach(function(force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes, random);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function manyBody() {
      var nodes,
          node,
          random,
          alpha,
          strength = constant$4(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x$2, y$2).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function radial$1(radius, x, y) {
      var nodes,
          strength = constant$4(0.1),
          strengths,
          radiuses;

      if (typeof radius !== "function") radius = constant$4(+radius);
      if (x == null) x = 0;
      if (y == null) y = 0;

      function force(alpha) {
        for (var i = 0, n = nodes.length; i < n; ++i) {
          var node = nodes[i],
              dx = node.x - x || 1e-6,
              dy = node.y - y || 1e-6,
              r = Math.sqrt(dx * dx + dy * dy),
              k = (radiuses[i] - r) * strengths[i] * alpha / r;
          node.vx += dx * k;
          node.vy += dy * k;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for (i = 0; i < n; ++i) {
          radiuses[i] = +radius(nodes[i], i, nodes);
          strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _, initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function x$1(x) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant$4(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : x;
      };

      return force;
    }

    function y$1(y) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant$4(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : y;
      };

      return force;
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };

    function identity$6(x) {
      return x;
    }

    var map = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale$1(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$6 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$6 : formatNumerals(map.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer value part that can be
            // grouped, and fractional or exponential suffix part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format;
    var formatPrefix;

    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    var epsilon$1 = 1e-6;
    var epsilon2 = 1e-12;
    var pi$1 = Math.PI;
    var halfPi$1 = pi$1 / 2;
    var quarterPi = pi$1 / 4;
    var tau$1 = pi$1 * 2;

    var degrees = 180 / pi$1;
    var radians = pi$1 / 180;

    var abs$1 = Math.abs;
    var atan = Math.atan;
    var atan2$1 = Math.atan2;
    var cos$1 = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;
    var hypot = Math.hypot;
    var log$1 = Math.log;
    var pow$1 = Math.pow;
    var sin$1 = Math.sin;
    var sign$1 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$2 = Math.sqrt;
    var tan = Math.tan;

    function acos$1(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin$1(x) {
      return x > 1 ? halfPi$1 : x < -1 ? -halfPi$1 : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin$1(x / 2)) * x;
    }

    function noop$2() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    var areaRingSum$1 = new Adder();

    // hello?

    var areaSum$1 = new Adder(),
        lambda00$2,
        phi00$2,
        lambda0$2,
        cosPhi0$1,
        sinPhi0$1;

    var areaStream$1 = {
      point: noop$2,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: function() {
        areaRingSum$1 = new Adder();
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum$1;
        areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$2;
      },
      sphere: function() {
        areaSum$1.add(tau$1);
      }
    };

    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }

    function areaRingEnd$1() {
      areaPoint$1(lambda00$2, phi00$2);
    }

    function areaPointFirst$1(lambda, phi) {
      areaStream$1.point = areaPoint$1;
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians, phi *= radians;
      lambda0$2 = lambda, cosPhi0$1 = cos$1(phi = phi / 2 + quarterPi), sinPhi0$1 = sin$1(phi);
    }

    function areaPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      phi = phi / 2 + quarterPi; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnolis
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0$2,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos$1(phi),
          sinPhi = sin$1(phi),
          k = sinPhi0$1 * sinPhi,
          u = cosPhi0$1 * cosPhi + k * cos$1(adLambda),
          v = k * sdLambda * sin$1(adLambda);
      areaRingSum$1.add(atan2$1(v, u));

      // Advance the previous points.
      lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
    }

    function area$2(object) {
      areaSum$1 = new Adder();
      geoStream(object, areaStream$1);
      return areaSum$1 * 2;
    }

    function spherical(cartesian) {
      return [atan2$1(cartesian[1], cartesian[0]), asin$1(cartesian[2])];
    }

    function cartesian(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
      return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0, // previous 3D point
        deltaSum,
        ranges,
        range;

    var boundsStream$1 = {
      point: boundsPoint$1,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$1.point = boundsRingPoint;
        boundsStream$1.lineStart = boundsRingStart;
        boundsStream$1.lineEnd = boundsRingEnd;
        deltaSum = new Adder();
        areaStream$1.polygonStart();
      },
      polygonEnd: function() {
        areaStream$1.polygonEnd();
        boundsStream$1.point = boundsPoint$1;
        boundsStream$1.lineStart = boundsLineStart;
        boundsStream$1.lineEnd = boundsLineEnd;
        if (areaRingSum$1 < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$1) phi1 = 90;
        else if (deltaSum < -epsilon$1) phi0 = -90;
        range[0] = lambda0$1, range[1] = lambda1;
      },
      sphere: function() {
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };

    function boundsPoint$1(lambda, phi) {
      ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian([lambda * radians, phi * radians]);
      if (p0) {
        var normal = cartesianCross(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical(inflection);
        var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees * sign,
            phii,
            antimeridian = abs$1(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = inflection[1] * degrees;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = -inflection[1] * degrees;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream$1.point = linePoint;
    }

    function boundsLineEnd() {
      range[0] = lambda0$1, range[1] = lambda1;
      boundsStream$1.point = boundsPoint$1;
      p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream$1.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream$1.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream$1.lineEnd();
      if (abs$1(deltaSum) > epsilon$1) lambda0$1 = -(lambda1 = 180);
      range[0] = lambda0$1, range[1] = lambda1;
      p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
    // the distance between 180 to be 360.
    function angle(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range, x) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function bounds(feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream(feature, boundsStream$1);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range = null;

      return lambda0$1 === Infinity || phi0 === Infinity
          ? [[NaN, NaN], [NaN, NaN]]
          : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1,
        X0$1, Y0$1, Z0$1,
        X1$1, Y1$1, Z1$1,
        X2$1, Y2$1, Z2$1,
        lambda00, phi00, // first point
        x0$4, y0$4, z0; // previous point

    var centroidStream$1 = {
      sphere: noop$2,
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function() {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function() {
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0$1 += (x - X0$1) / W0;
      Y0$1 += (y - Y0$1) / W0;
      Z0$1 += (z - Z0$1) / W0;
    }

    function centroidLineStart$1() {
      centroidStream$1.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidStream$1.point = centroidLinePoint;
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          w = atan2$1(sqrt$2((w = y0$4 * z - z0 * y) * w + (w = z0 * x - x0$4 * z) * w + (w = x0$4 * y - y0$4 * x) * w), x0$4 * x + y0$4 * y + z0 * z);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart$1() {
      centroidStream$1.point = centroidRingPointFirst;
    }

    function centroidRingEnd$1() {
      centroidRingPoint(lambda00, phi00);
      centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00 = lambda, phi00 = phi;
      lambda *= radians, phi *= radians;
      centroidStream$1.point = centroidRingPoint;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          cx = y0$4 * z - z0 * y,
          cy = z0 * x - x0$4 * z,
          cz = x0$4 * y - y0$4 * x,
          m = hypot(cx, cy, cz),
          w = asin$1(m), // line weight = angle
          v = m && -w / m; // area weight multiplier
      X2$1.add(v * cx);
      Y2$1.add(v * cy);
      Z2$1.add(v * cz);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroid$1(object) {
      W0 = W1 =
      X0$1 = Y0$1 = Z0$1 =
      X1$1 = Y1$1 = Z1$1 = 0;
      X2$1 = new Adder();
      Y2$1 = new Adder();
      Z2$1 = new Adder();
      geoStream(object, centroidStream$1);

      var x = +X2$1,
          y = +Y2$1,
          z = +Z2$1,
          m = hypot(x, y, z);

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2) {
        x = X1$1, y = Y1$1, z = Z1$1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon$1) x = X0$1, y = Y0$1, z = Z0$1;
        m = hypot(x, y, z);
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2) return [NaN, NaN];
      }

      return [atan2$1(y, x) * degrees, asin$1(z / m) * degrees];
    }

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    function compose(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity(lambda, phi) {
      return [abs$1(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$1) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
        : rotationLambda(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
        : rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$1(deltaPhi),
          sinDeltaPhi = sin$1(deltaPhi),
          cosDeltaGamma = cos$1(deltaGamma),
          sinDeltaGamma = sin$1(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2$1(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin$1(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2$1(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin$1(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    function rotation(rotate) {
      rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }

      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };

      return forward;
    }

    // Generates a circle centered at [0, 0], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos$1(radius),
          sinRadius = sin$1(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau$1;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$1;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos$1(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau$1 - epsilon$1) % tau$1;
    }

    function circle$2() {
      var center = constant$3([0, 0]),
          radius = constant$3(90),
          precision = constant$3(6),
          ring,
          rotate,
          stream = {point: point};

      function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= degrees, x[1] *= degrees;
      }

      function circle() {
        var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * radians,
            p = precision.apply(this, arguments) * radians;
        ring = [];
        rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
        circleStream(stream, r, p, 1);
        c = {type: "Polygon", coordinates: [ring]};
        ring = rotate = null;
        return c;
      }

      circle.center = function(_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : constant$3([+_[0], +_[1]]), circle) : center;
      };

      circle.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$3(+_), circle) : radius;
      };

      circle.precision = function(_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : constant$3(+_), circle) : precision;
      };

      return circle;
    }

    function clipBuffer() {
      var lines = [],
          line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$2,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function pointEqual(a, b) {
      return abs$1(a[0] - b[0]) < epsilon$1 && abs$1(a[1] - b[1]) < epsilon$1;
    }

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        if (pointEqual(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          // handle degenerate cases by moving the point
          p1[0] += 2 * epsilon$1;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link$1(subject);
      link$1(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link$1(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    function longitude(point) {
      return abs$1(point[0]) <= pi$1 ? point[0] : sign$1(point[0]) * ((abs$1(point[0]) + pi$1) % tau$1 - pi$1);
    }

    function polygonContains(polygon, point) {
      var lambda = longitude(point),
          phi = point[1],
          sinPhi = sin$1(phi),
          normal = [sin$1(lambda), -cos$1(lambda), 0],
          angle = 0,
          winding = 0;

      var sum = new Adder();

      if (sinPhi === 1) phi = halfPi$1 + epsilon$1;
      else if (sinPhi === -1) phi = -halfPi$1 - epsilon$1;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = longitude(point0),
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin$1(phi0),
            cosPhi0 = cos$1(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = longitude(point1),
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin$1(phi1),
              cosPhi1 = cos$1(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi$1,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2$1(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
          angle += antimeridian ? delta + sign * tau$1 : delta;

          // Are the longitudes either side of the points meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon$1 || angle < epsilon$1 && sum < -epsilon2) ^ (winding & 1);
    }

    function clip(pointVisible, clipLine, interpolate, start) {
      return function(sink) {
        var line = clipLine(sink),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge(segments);
            var startInside = polygonContains(polygon, start);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    }

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi$1 - epsilon$1 : halfPi$1 - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$1 : halfPi$1 - b[1]);
    }

    var clipAntimeridian = clip(
      function() { return true; },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$1, -halfPi$1]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$1 : -pi$1,
              delta = abs$1(lambda1 - lambda0);
          if (abs$1(delta - pi$1) < epsilon$1) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$1 : -halfPi$1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$1) { // line crosses antimeridian
            if (abs$1(lambda0 - sign0) < epsilon$1) lambda0 -= sign0 * epsilon$1; // handle degeneracies
            if (abs$1(lambda1 - sign1) < epsilon$1) lambda1 -= sign1 * epsilon$1;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
      return abs$1(sinLambda0Lambda1) > epsilon$1
          ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
              - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi$1;
        stream.point(-pi$1, phi);
        stream.point(0, phi);
        stream.point(pi$1, phi);
        stream.point(pi$1, 0);
        stream.point(pi$1, -phi);
        stream.point(0, -phi);
        stream.point(-pi$1, -phi);
        stream.point(-pi$1, 0);
        stream.point(-pi$1, phi);
      } else if (abs$1(from[0] - to[0]) > epsilon$1) {
        var lambda = from[0] < to[0] ? pi$1 : -pi$1;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle(radius) {
      var cr = cos$1(radius),
          delta = 6 * radians,
          smallRadius = cr > 0,
          notHemisphere = abs$1(cr) > epsilon$1; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos$1(lambda) * cos$1(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian(a),
            pb = cartesian(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross(pa, pb),
            n2n2 = cartesianDot(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot(A, u),
            uu = cartesianDot(u, u),
            t2 = w * w - uu * (cartesianDot(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt$2(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs$1(delta - pi$1) < epsilon$1,
            meridian = polar || delta < epsilon$1;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon$1 ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi$1 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi$1 - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
    }

    function clipLine(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    var clipMax = 1e9, clipMin = -clipMax;

    // TODO Use d3-polygons polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs$1(p[0] - x0) < epsilon$1 ? direction > 0 ? 0 : 3
            : abs$1(p[0] - x1) < epsilon$1 ? direction > 0 ? 2 : 1
            : abs$1(p[1] - y0) < epsilon$1 ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    function extent() {
      var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip;

      return clip = {
        stream: function(stream) {
          return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function(_) {
          return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
        }
      };
    }

    var lengthSum$1,
        lambda0,
        sinPhi0,
        cosPhi0;

    var lengthStream$1 = {
      sphere: noop$2,
      point: noop$2,
      lineStart: lengthLineStart,
      lineEnd: noop$2,
      polygonStart: noop$2,
      polygonEnd: noop$2
    };

    function lengthLineStart() {
      lengthStream$1.point = lengthPointFirst$1;
      lengthStream$1.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream$1.point = lengthStream$1.lineEnd = noop$2;
    }

    function lengthPointFirst$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      lambda0 = lambda, sinPhi0 = sin$1(phi), cosPhi0 = cos$1(phi);
      lengthStream$1.point = lengthPoint$1;
    }

    function lengthPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var sinPhi = sin$1(phi),
          cosPhi = cos$1(phi),
          delta = abs$1(lambda - lambda0),
          cosDelta = cos$1(delta),
          sinDelta = sin$1(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
      lengthSum$1.add(atan2$1(sqrt$2(x * x + y * y), z));
      lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
    }

    function length$1(object) {
      lengthSum$1 = new Adder();
      geoStream(object, lengthStream$1);
      return +lengthSum$1;
    }

    var coordinates = [null, null],
        object = {type: "LineString", coordinates: coordinates};

    function distance(a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length$1(object);
    }

    var containsObjectType = {
      Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function(object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type)
          ? containsGeometryType[geometry.type](geometry, point)
          : false;
    }

    function containsPoint(coordinates, point) {
      return distance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ao, bo, ab;
      for (var i = 0, n = coordinates.length; i < n; i++) {
        bo = distance(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
          ab = distance(coordinates[i], coordinates[i - 1]);
          if (
            ab > 0 &&
            ao <= ab &&
            bo <= ab &&
            (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
          )
            return true;
        }
        ao = bo;
      }
      return false;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }

    function contains$1(object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type)
          ? containsObjectType[object.type]
          : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
      var y = range$2(y0, y1 - epsilon$1, dy).concat(y1);
      return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
      var x = range$2(x0, x1 - epsilon$1, dx).concat(x1);
      return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
      var x1, x0, X1, X0,
          y1, y0, Y1, Y0,
          dx = 10, dy = dx, DX = 90, DY = 360,
          x, y, X, Y,
          precision = 2.5;

      function graticule() {
        return {type: "MultiLineString", coordinates: lines()};
      }

      function lines() {
        return range$2(ceil(X0 / DX) * DX, X1, DX).map(X)
            .concat(range$2(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
            .concat(range$2(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$1(x % DX) > epsilon$1; }).map(x))
            .concat(range$2(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$1(y % DY) > epsilon$1; }).map(y));
      }

      graticule.lines = function() {
        return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
      };

      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X(X0).concat(
            Y(Y1).slice(1),
            X(X1).reverse().slice(1),
            Y(Y0).reverse().slice(1))
          ]
        };
      };

      graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function(_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function(_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function(_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function(_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule
          .extentMajor([[-180, -90 + epsilon$1], [180, 90 - epsilon$1]])
          .extentMinor([[-180, -80 - epsilon$1], [180, 80 + epsilon$1]]);
    }

    function graticule10() {
      return graticule()();
    }

    function interpolate(a, b) {
      var x0 = a[0] * radians,
          y0 = a[1] * radians,
          x1 = b[0] * radians,
          y1 = b[1] * radians,
          cy0 = cos$1(y0),
          sy0 = sin$1(y0),
          cy1 = cos$1(y1),
          sy1 = sin$1(y1),
          kx0 = cy0 * cos$1(x0),
          ky0 = cy0 * sin$1(x0),
          kx1 = cy1 * cos$1(x1),
          ky1 = cy1 * sin$1(x1),
          d = 2 * asin$1(sqrt$2(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin$1(d);

      var interpolate = d ? function(t) {
        var B = sin$1(t *= d) / k,
            A = sin$1(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [
          atan2$1(y, x) * degrees,
          atan2$1(z, sqrt$2(x * x + y * y)) * degrees
        ];
      } : function() {
        return [x0 * degrees, y0 * degrees];
      };

      interpolate.distance = d;

      return interpolate;
    }

    var identity$5 = x => x;

    var areaSum = new Adder(),
        areaRingSum = new Adder(),
        x00$2,
        y00$2,
        x0$3,
        y0$3;

    var areaStream = {
      point: noop$2,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$2;
        areaSum.add(abs$1(areaRingSum));
        areaRingSum = new Adder();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum = new Adder();
        return area;
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00$2 = x0$3 = x, y00$2 = y0$3 = y;
    }

    function areaPoint(x, y) {
      areaRingSum.add(y0$3 * x - x0$3 * y);
      x0$3 = x, y0$3 = y;
    }

    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }

    var x0$2 = Infinity,
        y0$2 = x0$2,
        x1 = -x0$2,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: noop$2,
      polygonEnd: noop$2,
      result: function() {
        var bounds = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0$2) x0$2 = x;
      if (x > x1) x1 = x;
      if (y < y0$2) y0$2 = y;
      if (y > y1) y1 = y;
    }

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00$1,
        y00$1,
        x0$1,
        y0$1;

    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
            : Z1 ? [X1 / Z1, Y1 / Z1]
            : Z0 ? [X0 / Z0, Y0 / Z0]
            : [NaN, NaN];
        X0 = Y0 = Z0 =
        X1 = Y1 = Z1 =
        X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };

    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$1, dy = y - y0$1, z = sqrt$2(dx * dx + dy * dy);
      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }

    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$1 = x, y00$1 = y0$1 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$1,
          dy = y - y0$1,
          z = sqrt$2(dx * dx + dy * dy);

      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;

      z = y0$1 * x - x0$1 * y;
      X2 += z * (x0$1 + x);
      Y2 += z * (y0$1 + y);
      Z2 += z * 3;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$1);
            break;
          }
        }
      },
      result: noop$2
    };

    var lengthSum = new Adder(),
        lengthRing,
        x00,
        y00,
        x0,
        y0;

    var lengthStream = {
      point: noop$2,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing) lengthPoint(x00, y00);
        lengthStream.point = noop$2;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length = +lengthSum;
        lengthSum = new Adder();
        return length;
      }
    };

    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00 = x0 = x, y00 = y0 = y;
    }

    function lengthPoint(x, y) {
      x0 -= x, y0 -= y;
      lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
      x0 = x, y0 = y;
    }

    function PathString() {
      this._string = [];
    }

    PathString.prototype = {
      _radius: 4.5,
      _circle: circle$1(4.5),
      pointRadius: function(_) {
        if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._string.push("Z");
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x, ",", y);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x, ",", y);
            break;
          }
          default: {
            if (this._circle == null) this._circle = circle$1(this._radius);
            this._string.push("M", x, ",", y, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };

    function circle$1(radius) {
      return "m0," + radius
          + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
          + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
          + "z";
    }

    function index$2(projection, context) {
      var pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function(object) {
        geoStream(object, projectionStream(areaStream));
        return areaStream.result();
      };

      path.measure = function(object) {
        geoStream(object, projectionStream(lengthStream));
        return lengthStream.result();
      };

      path.bounds = function(object) {
        geoStream(object, projectionStream(boundsStream));
        return boundsStream.result();
      };

      path.centroid = function(object) {
        geoStream(object, projectionStream(centroidStream));
        return centroidStream.result();
      };

      path.projection = function(_) {
        return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$5) : (projection = _).stream, path) : projection;
      };

      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      return path.projection(projection).context(context);
    }

    function transform$1(methods) {
      return {
        stream: transformer$3(methods)
      };
    }

    function transformer$3(methods) {
      return function(stream) {
        var s = new TransformStream;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
      var clip = projection.clipExtent && projection.clipExtent();
      projection.scale(150).translate([0, 0]);
      if (clip != null) projection.clipExtent(null);
      geoStream(object, projection.stream(boundsStream));
      fitBounds(boundsStream.result());
      if (clip != null) projection.clipExtent(clip);
      return projection;
    }

    function fitExtent(projection, extent, object) {
      return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    function fitWidth(projection, width, object) {
      return fit(projection, function(b) {
        var w = +width,
            k = w / (b[1][0] - b[0][0]),
            x = (w - k * (b[1][0] + b[0][0])) / 2,
            y = -k * b[0][1];
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitHeight(projection, height, object) {
      return fit(projection, function(b) {
        var h = +height,
            k = h / (b[1][1] - b[0][1]),
            x = -k * b[0][0],
            y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
      return transformer$3({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt$2(a * a + b * b + c * c),
              phi2 = asin$1(c /= m),
              lambda2 = abs$1(abs$1(c) - 1) < epsilon$1 || abs$1(lambda0 - lambda1) < epsilon$1 ? (lambda0 + lambda1) / 2 : atan2$1(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer$3({
      point: function(x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });

    function transformRotate(rotate) {
      return transformer$3({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx; y *= sy;
        return [dx + k * x, dy - k * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k * sx, (dy - y) / k * sy];
      };
      return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
      var cosAlpha = cos$1(alpha),
          sinAlpha = sin$1(alpha),
          a = cosAlpha * k,
          b = sinAlpha * k,
          ai = cosAlpha / k,
          bi = sinAlpha / k,
          ci = (sinAlpha * dy - cosAlpha * dx) / k,
          fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform(x, y) {
        x *= sx; y *= sy;
        return [a * x - b * y + dx, dy - b * x - a * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }

    function projection(project) {
      return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
          alpha = 0, // post-rotate angle
          sx = 1, // reflectX
          sy = 1, // reflectX
          theta = null, preclip = clipAntimeridian, // pre-clip angle
          x0 = null, y0, x1, y1, postclip = identity$5, // post-clip extent
          delta2 = 0.5, // precision
          projectResample,
          projectTransform,
          projectRotateTransform,
          cache,
          cacheStream;

      function projection(point) {
        return projectRotateTransform(point[0] * radians, point[1] * radians);
      }

      function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [point[0] * degrees, point[1] * degrees];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };

      projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
      };

      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };

      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
      };

      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };

      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$2(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };

      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };

      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
            transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project, transform);
        projectRotateTransform = compose(rotate, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function conicProjection(projectAt) {
      var phi0 = 0,
          phi1 = pi$1 / 3,
          m = projectionMutator(projectAt),
          p = m(phi0, phi1);

      p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
      };

      return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos$1(phi0);

      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
      }

      forward.invert = function(x, y) {
        return [x / cosPhi0, asin$1(y * cosPhi0)];
      };

      return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
      var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

      // Are the parallels symmetrical around the Equator?
      if (abs$1(n) < epsilon$1) return cylindricalEqualAreaRaw(y0);

      var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c) / n;

      function project(x, y) {
        var r = sqrt$2(c - 2 * n * sin$1(y)) / n;
        return [r * sin$1(x *= n), r0 - r * cos$1(x)];
      }

      project.invert = function(x, y) {
        var r0y = r0 - y,
            l = atan2$1(x, abs$1(r0y)) * sign$1(r0y);
        if (r0y * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(r0y);
        return [l / n, asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };

      return project;
    }

    function conicEqualArea() {
      return conicProjection(conicEqualAreaRaw)
          .scale(155.424)
          .center([0, 33.6442]);
    }

    function albers() {
      return conicEqualArea()
          .parallels([29.5, 45.5])
          .scale(1070)
          .translate([480, 250])
          .rotate([96, 0])
          .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
        sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
        lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
        lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
        polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
        polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
      };
    }

    // A composite projection for the United States, configured by default for
    // 960500. The projection also works quite well at 960600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa() {
      var cache,
          cacheStream,
          lower48 = albers(), lower48Point,
          alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
          hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
          point, pointStream = {point: function(x, y) { point = [x, y]; }};

      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point = null,
            (lower48Point.point(x, y), point)
            || (alaskaPoint.point(x, y), point)
            || (hawaiiPoint.point(x, y), point);
      }

      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k;
        return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
            : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
            : lower48).invert(coordinates);
      };

      albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };

      albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };

      albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };

      albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];

        lower48Point = lower48
            .translate(_)
            .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
            .stream(pointStream);

        alaskaPoint = alaska
            .translate([x - 0.307 * k, y + 0.201 * k])
            .clipExtent([[x - 0.425 * k + epsilon$1, y + 0.120 * k + epsilon$1], [x - 0.214 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        hawaiiPoint = hawaii
            .translate([x - 0.205 * k, y + 0.212 * k])
            .clipExtent([[x - 0.214 * k + epsilon$1, y + 0.166 * k + epsilon$1], [x - 0.115 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        return reset();
      };

      albersUsa.fitExtent = function(extent, object) {
        return fitExtent(albersUsa, extent, object);
      };

      albersUsa.fitSize = function(size, object) {
        return fitSize(albersUsa, size, object);
      };

      albersUsa.fitWidth = function(width, object) {
        return fitWidth(albersUsa, width, object);
      };

      albersUsa.fitHeight = function(height, object) {
        return fitHeight(albersUsa, height, object);
      };

      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }

      return albersUsa.scale(1070);
    }

    function azimuthalRaw(scale) {
      return function(x, y) {
        var cx = cos$1(x),
            cy = cos$1(y),
            k = scale(cx * cy);
            if (k === Infinity) return [2, 0];
        return [
          k * cy * sin$1(x),
          k * sin$1(y)
        ];
      }
    }

    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt$2(x * x + y * y),
            c = angle(z),
            sc = sin$1(c),
            cc = cos$1(c);
        return [
          atan2$1(x * sc, z * cc),
          asin$1(z && y * sc / z)
        ];
      }
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt$2(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin$1(z / 2);
    });

    function azimuthalEqualArea() {
      return projection(azimuthalEqualAreaRaw)
          .scale(124.75)
          .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
      return (c = acos$1(c)) && c / sin$1(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });

    function azimuthalEquidistant() {
      return projection(azimuthalEquidistantRaw)
          .scale(79.4188)
          .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
      return [lambda, log$1(tan((halfPi$1 + phi) / 2))];
    }

    mercatorRaw.invert = function(x, y) {
      return [x, 2 * atan(exp(y)) - halfPi$1];
    };

    function mercator() {
      return mercatorProjection(mercatorRaw)
          .scale(961 / tau$1);
    }

    function mercatorProjection(project) {
      var m = projection(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null, y0, x1, y1; // clip extent

      m.scale = function(_) {
        return arguments.length ? (scale(_), reclip()) : scale();
      };

      m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };

      m.center = function(_) {
        return arguments.length ? (center(_), reclip()) : center();
      };

      m.clipExtent = function(_) {
        return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      function reclip() {
        var k = pi$1 * scale(),
            t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x0 == null
            ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
            ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
            : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
      }

      return reclip();
    }

    function tany(y) {
      return tan((halfPi$1 + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : log$1(cy0 / cos$1(y1)) / log$1(tany(y1) / tany(y0)),
          f = cy0 * pow$1(tany(y0), n) / n;

      if (!n) return mercatorRaw;

      function project(x, y) {
        if (f > 0) { if (y < -halfPi$1 + epsilon$1) y = -halfPi$1 + epsilon$1; }
        else { if (y > halfPi$1 - epsilon$1) y = halfPi$1 - epsilon$1; }
        var r = f / pow$1(tany(y), n);
        return [r * sin$1(n * x), f - r * cos$1(n * x)];
      }

      project.invert = function(x, y) {
        var fy = f - y, r = sign$1(n) * sqrt$2(x * x + fy * fy),
          l = atan2$1(x, abs$1(fy)) * sign$1(fy);
        if (fy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(fy);
        return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi$1];
      };

      return project;
    }

    function conicConformal() {
      return conicProjection(conicConformalRaw)
          .scale(109.5)
          .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    function equirectangular() {
      return projection(equirectangularRaw)
          .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
          g = cy0 / n + y0;

      if (abs$1(n) < epsilon$1) return equirectangularRaw;

      function project(x, y) {
        var gy = g - y, nx = n * x;
        return [gy * sin$1(nx), g - gy * cos$1(nx)];
      }

      project.invert = function(x, y) {
        var gy = g - y,
            l = atan2$1(x, abs$1(gy)) * sign$1(gy);
        if (gy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(gy);
        return [l / n, g - sign$1(n) * sqrt$2(x * x + gy * gy)];
      };

      return project;
    }

    function conicEquidistant() {
      return conicProjection(conicEquidistantRaw)
          .scale(131.154)
          .center([0, 13.9389]);
    }

    var A1 = 1.340264,
        A2 = -0.081106,
        A3 = 0.000893,
        A4 = 0.003796,
        M = sqrt$2(3) / 2,
        iterations = 12;

    function equalEarthRaw(lambda, phi) {
      var l = asin$1(M * sin$1(phi)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
      ];
    }

    equalEarthRaw.invert = function(x, y) {
      var l = y, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs$1(delta) < epsilon2) break;
      }
      return [
        M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
        asin$1(sin$1(l) / M)
      ];
    };

    function equalEarth() {
      return projection(equalEarthRaw)
          .scale(177.158);
    }

    function gnomonicRaw(x, y) {
      var cy = cos$1(y), k = cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert(atan);

    function gnomonic() {
      return projection(gnomonicRaw)
          .scale(144.049)
          .clipAngle(60);
    }

    function identity$4() {
      var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
          alpha = 0, ca, sa, // angle
          x0 = null, y0, x1, y1, // clip extent
          kx = 1, ky = 1,
          transform = transformer$3({
            point: function(x, y) {
              var p = projection([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }),
          postclip = identity$5,
          cache,
          cacheStream;

      function reset() {
        kx = k * sx;
        ky = k * sy;
        cache = cacheStream = null;
        return projection;
      }

      function projection (p) {
        var x = p[0] * kx, y = p[1] * ky;
        if (alpha) {
          var t = y * ca - x * sa;
          x = x * ca + y * sa;
          y = t;
        }    
        return [x + tx, y + ty];
      }
      projection.invert = function(p) {
        var x = p[0] - tx, y = p[1] - ty;
        if (alpha) {
          var t = y * ca + x * sa;
          x = x * ca - y * sa;
          y = t;
        }
        return [x / kx, y / ky];
      };
      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
      };
      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };
      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };
      projection.scale = function(_) {
        return arguments.length ? (k = +_, reset()) : k;
      };
      projection.translate = function(_) {
        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
      };
      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, sa = sin$1(alpha), ca = cos$1(alpha), reset()) : alpha * degrees;
      };
      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
      };
      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
      };
      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };
      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };
      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };
      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      return projection;
    }

    function naturalEarth1Raw(lambda, phi) {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      return [
        lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
        phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
      ];
    }

    naturalEarth1Raw.invert = function(x, y) {
      var phi = y, i = 25, delta;
      do {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
            (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
      } while (abs$1(delta) > epsilon$1 && --i > 0);
      return [
        x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
        phi
      ];
    };

    function naturalEarth1() {
      return projection(naturalEarth1Raw)
          .scale(175.295);
    }

    function orthographicRaw(x, y) {
      return [cos$1(y) * sin$1(x), sin$1(y)];
    }

    orthographicRaw.invert = azimuthalInvert(asin$1);

    function orthographic() {
      return projection(orthographicRaw)
          .scale(249.5)
          .clipAngle(90 + epsilon$1);
    }

    function stereographicRaw(x, y) {
      var cy = cos$1(y), k = 1 + cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });

    function stereographic() {
      return projection(stereographicRaw)
          .scale(250)
          .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
      return [log$1(tan((halfPi$1 + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function(x, y) {
      return [-y, 2 * atan(exp(x)) - halfPi$1];
    };

    function transverseMercator() {
      var m = mercatorProjection(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate;

      m.center = function(_) {
        return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
      };

      m.rotate = function(_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };

      return rotate([0, 0, 90])
          .scale(159.155);
    }

    function defaultSeparation$1(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    function meanX(children) {
      return children.reduce(meanXReduce, 0) / children.length;
    }

    function meanXReduce(x, c) {
      return x + c.x;
    }

    function maxY(children) {
      return 1 + children.reduce(maxYReduce, 0);
    }

    function maxYReduce(y, c) {
      return Math.max(y, c.y);
    }

    function leafLeft(node) {
      var children;
      while (children = node.children) node = children[0];
      return node;
    }

    function leafRight(node) {
      var children;
      while (children = node.children) node = children[children.length - 1];
      return node;
    }

    function cluster() {
      var separation = defaultSeparation$1,
          dx = 1,
          dy = 1,
          nodeSize = false;

      function cluster(root) {
        var previousNode,
            x = 0;

        // First walk, computing the initial x & y values.
        root.eachAfter(function(node) {
          var children = node.children;
          if (children) {
            node.x = meanX(children);
            node.y = maxY(children);
          } else {
            node.x = previousNode ? x += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });

        var left = leafLeft(root),
            right = leafRight(root),
            x0 = left.x - separation(left, right) / 2,
            x1 = right.x + separation(right, left) / 2;

        // Second walk, normalizing x & y to the desired size.
        return root.eachAfter(nodeSize ? function(node) {
          node.x = (node.x - root.x) * dx;
          node.y = (root.y - node.y) * dy;
        } : function(node) {
          node.x = (node.x - x0) / (x1 - x0) * dx;
          node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
        });
      }

      cluster.separation = function(x) {
        return arguments.length ? (separation = x, cluster) : separation;
      };

      cluster.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
      };

      cluster.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
      };

      return cluster;
    }

    function count(node) {
      var sum = 0,
          children = node.children,
          i = children && children.length;
      if (!i) sum = 1;
      else while (--i >= 0) sum += children[i].value;
      node.value = sum;
    }

    function node_count() {
      return this.eachAfter(count);
    }

    function node_each(callback, that) {
      let index = -1;
      for (const node of this) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_eachBefore(callback, that) {
      var node = this, nodes = [node], children, i, index = -1;
      while (node = nodes.pop()) {
        callback.call(that, node, ++index, this);
        if (children = node.children) {
          for (i = children.length - 1; i >= 0; --i) {
            nodes.push(children[i]);
          }
        }
      }
      return this;
    }

    function node_eachAfter(callback, that) {
      var node = this, nodes = [node], next = [], children, i, n, index = -1;
      while (node = nodes.pop()) {
        next.push(node);
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            nodes.push(children[i]);
          }
        }
      }
      while (node = next.pop()) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_find(callback, that) {
      let index = -1;
      for (const node of this) {
        if (callback.call(that, node, ++index, this)) {
          return node;
        }
      }
    }

    function node_sum(value) {
      return this.eachAfter(function(node) {
        var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length;
        while (--i >= 0) sum += children[i].value;
        node.value = sum;
      });
    }

    function node_sort(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }

    function node_path(end) {
      var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start];
      while (start !== ancestor) {
        start = start.parent;
        nodes.push(start);
      }
      var k = nodes.length;
      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }
      return nodes;
    }

    function leastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }

    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }

    function node_descendants() {
      return Array.from(this);
    }

    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }

    function node_links() {
      var root = this, links = [];
      root.each(function(node) {
        if (node !== root) { // Dont include the roots parent, if any.
          links.push({source: node.parent, target: node});
        }
      });
      return links;
    }

    function* node_iterator() {
      var node = this, current, next = [node], children, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          yield node;
          if (children = node.children) {
            for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }
        }
      } while (next.length);
    }

    function hierarchy(data, children) {
      if (data instanceof Map) {
        data = [undefined, data];
        if (children === undefined) children = mapChildren;
      } else if (children === undefined) {
        children = objectChildren;
      }

      var root = new Node$1(data),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n;

      while (node = nodes.pop()) {
        if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
          node.children = childs;
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = childs[i] = new Node$1(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }

      return root.eachBefore(computeHeight);
    }

    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }

    function objectChildren(d) {
      return d.children;
    }

    function mapChildren(d) {
      return Array.isArray(d) ? d[1] : null;
    }

    function copyData(node) {
      if (node.data.value !== undefined) node.value = node.data.value;
      node.data = node.data.data;
    }

    function computeHeight(node) {
      var height = 0;
      do node.height = height;
      while ((node = node.parent) && (node.height < ++height));
    }

    function Node$1(data) {
      this.data = data;
      this.depth =
      this.height = 0;
      this.parent = null;
    }

    Node$1.prototype = hierarchy.prototype = {
      constructor: Node$1,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      find: node_find,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy,
      [Symbol.iterator]: node_iterator
    };

    function array$1(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function shuffle(array) {
      var m = array.length,
          t,
          i;

      while (m) {
        i = Math.random() * m-- | 0;
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }

      return array;
    }

    function enclose(circles) {
      var i = 0, n = (circles = shuffle(Array.from(circles))).length, B = [], p, e;

      while (i < n) {
        p = circles[i];
        if (e && enclosesWeak(e, p)) ++i;
        else e = encloseBasis(B = extendBasis(B, p)), i = 0;
      }

      return e;
    }

    function extendBasis(B, p) {
      var i, j;

      if (enclosesWeakAll(p, B)) return [p];

      // If we get here then B must have at least one element.
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i])
            && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }

      // If we get here then B must have at least two elements.
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p)
              && enclosesNot(encloseBasis2(B[i], p), B[j])
              && enclosesNot(encloseBasis2(B[j], p), B[i])
              && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }

      // If we get here then something is very wrong.
      throw new Error;
    }

    function enclosesNot(a, b) {
      var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }

    function enclosesWeak(a, b) {
      var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }

    function encloseBasis(B) {
      switch (B.length) {
        case 1: return encloseBasis1(B[0]);
        case 2: return encloseBasis2(B[0], B[1]);
        case 3: return encloseBasis3(B[0], B[1], B[2]);
      }
    }

    function encloseBasis1(a) {
      return {
        x: a.x,
        y: a.y,
        r: a.r
      };
    }

    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
          l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
        x: (x1 + x2 + x21 / l * r21) / 2,
        y: (y1 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
      };
    }

    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x3 = c.x, y3 = c.y, r3 = c.r,
          a2 = x1 - x2,
          a3 = x1 - x3,
          b2 = y1 - y2,
          b3 = y1 - y3,
          c2 = r2 - r1,
          c3 = r3 - r1,
          d1 = x1 * x1 + y1 * y1 - r1 * r1,
          d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
          d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
          ab = a3 * b2 - a2 * b3,
          xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
          xb = (b3 * c2 - b2 * c3) / ab,
          ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
          yb = (a2 * c3 - a3 * c2) / ab,
          A = xb * xb + yb * yb - 1,
          B = 2 * (r1 + xa * xb + ya * yb),
          C = xa * xa + ya * ya - r1 * r1,
          r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return {
        x: x1 + xa + xb * r,
        y: y1 + ya + yb * r,
        r: r
      };
    }

    function place(b, a, c) {
      var dx = b.x - a.x, x, a2,
          dy = b.y - a.y, y, b2,
          d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r, a2 *= a2;
        b2 = b.r + c.r, b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }

    function intersects(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function score(node) {
      var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab,
          dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }

    function Node(circle) {
      this._ = circle;
      this.next = null;
      this.previous = null;
    }

    function packEnclose(circles) {
      if (!(n = (circles = array$1(circles)).length)) return 0;

      var a, b, c, n, aa, ca, i, j, k, sj, sk;

      // Place the first circle.
      a = circles[0], a.x = 0, a.y = 0;
      if (!(n > 1)) return a.r;

      // Place the second circle.
      b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
      if (!(n > 2)) return a.r + b.r;

      // Place the third circle.
      place(b, a, c = circles[2]);

      // Initialize the front-chain using the first three circles a, b and c.
      a = new Node(a), b = new Node(b), c = new Node(c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;

      // Attempt to place each remaining circle
      pack: for (i = 3; i < n; ++i) {
        place(a._, b._, c = circles[i]), c = new Node(c);

        // Find the closest intersecting circle on the front-chain, if any.
        // Closeness is determined by linear distance along the front-chain.
        // Ahead or behind is likewise determined by linear distance.
        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
        do {
          if (sj <= sk) {
            if (intersects(j._, c._)) {
              b = j, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sj += j._.r, j = j.next;
          } else {
            if (intersects(k._, c._)) {
              a = k, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sk += k._.r, k = k.previous;
          }
        } while (j !== k.next);

        // Success! Insert the new circle c between a and b.
        c.previous = a, c.next = b, a.next = b.previous = b = c;

        // Compute the new closest circle pair to the centroid.
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c, aa = ca;
          }
        }
        b = a.next;
      }

      // Compute the enclosing circle of the front chain.
      a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

      // Translate the circles to put the enclosing circle around the origin.
      for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

      return c.r;
    }

    function siblings(circles) {
      packEnclose(circles);
      return circles;
    }

    function optional(f) {
      return f == null ? null : required(f);
    }

    function required(f) {
      if (typeof f !== "function") throw new Error;
      return f;
    }

    function constantZero() {
      return 0;
    }

    function constant$2(x) {
      return function() {
        return x;
      };
    }

    function defaultRadius(d) {
      return Math.sqrt(d.value);
    }

    function index$1() {
      var radius = null,
          dx = 1,
          dy = 1,
          padding = constantZero;

      function pack(root) {
        root.x = dx / 2, root.y = dy / 2;
        if (radius) {
          root.eachBefore(radiusLeaf(radius))
              .eachAfter(packChildren(padding, 0.5))
              .eachBefore(translateChild(1));
        } else {
          root.eachBefore(radiusLeaf(defaultRadius))
              .eachAfter(packChildren(constantZero, 1))
              .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
              .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
        }
        return root;
      }

      pack.radius = function(x) {
        return arguments.length ? (radius = optional(x), pack) : radius;
      };

      pack.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
      };

      pack.padding = function(x) {
        return arguments.length ? (padding = typeof x === "function" ? x : constant$2(+x), pack) : padding;
      };

      return pack;
    }

    function radiusLeaf(radius) {
      return function(node) {
        if (!node.children) {
          node.r = Math.max(0, +radius(node) || 0);
        }
      };
    }

    function packChildren(padding, k) {
      return function(node) {
        if (children = node.children) {
          var children,
              i,
              n = children.length,
              r = padding(node) * k || 0,
              e;

          if (r) for (i = 0; i < n; ++i) children[i].r += r;
          e = packEnclose(children);
          if (r) for (i = 0; i < n; ++i) children[i].r -= r;
          node.r = e + r;
        }
      };
    }

    function translateChild(k) {
      return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
          node.x = parent.x + k * node.x;
          node.y = parent.y + k * node.y;
        }
      };
    }

    function roundNode(node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }

    function treemapDice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
      }
    }

    function partition() {
      var dx = 1,
          dy = 1,
          padding = 0,
          round = false;

      function partition(root) {
        var n = root.height + 1;
        root.x0 =
        root.y0 = padding;
        root.x1 = dx;
        root.y1 = dy / n;
        root.eachBefore(positionNode(dy, n));
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(dy, n) {
        return function(node) {
          if (node.children) {
            treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
          }
          var x0 = node.x0,
              y0 = node.y0,
              x1 = node.x1 - padding,
              y1 = node.y1 - padding;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
        };
      }

      partition.round = function(x) {
        return arguments.length ? (round = !!x, partition) : round;
      };

      partition.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
      };

      partition.padding = function(x) {
        return arguments.length ? (padding = +x, partition) : padding;
      };

      return partition;
    }

    var preroot = {depth: -1},
        ambiguous = {};

    function defaultId(d) {
      return d.id;
    }

    function defaultParentId(d) {
      return d.parentId;
    }

    function stratify() {
      var id = defaultId,
          parentId = defaultParentId;

      function stratify(data) {
        var nodes = Array.from(data),
            n = nodes.length,
            d,
            i,
            root,
            parent,
            node,
            nodeId,
            nodeKey,
            nodeByKey = new Map;

        for (i = 0; i < n; ++i) {
          d = nodes[i], node = nodes[i] = new Node$1(d);
          if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
            nodeKey = node.id = nodeId;
            nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
          }
          if ((nodeId = parentId(d, i, data)) != null && (nodeId += "")) {
            node.parent = nodeId;
          }
        }

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (nodeId = node.parent) {
            parent = nodeByKey.get(nodeId);
            if (!parent) throw new Error("missing: " + nodeId);
            if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
            if (parent.children) parent.children.push(node);
            else parent.children = [node];
            node.parent = parent;
          } else {
            if (root) throw new Error("multiple roots");
            root = node;
          }
        }

        if (!root) throw new Error("no root");
        root.parent = preroot;
        root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
        root.parent = null;
        if (n > 0) throw new Error("cycle");

        return root;
      }

      stratify.id = function(x) {
        return arguments.length ? (id = required(x), stratify) : id;
      };

      stratify.parentId = function(x) {
        return arguments.length ? (parentId = required(x), stratify) : parentId;
      };

      return stratify;
    }

    function defaultSeparation(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    // function radialSeparation(a, b) {
    //   return (a.parent === b.parent ? 1 : 2) / a.depth;
    // }

    // This function is used to traverse the left contour of a subtree (or
    // subforest). It returns the successor of v on this contour. This successor is
    // either given by the leftmost child of v or by the thread of v. The function
    // returns null if and only if v is on the highest level of its subtree.
    function nextLeft(v) {
      var children = v.children;
      return children ? children[0] : v.t;
    }

    // This function works analogously to nextLeft.
    function nextRight(v) {
      var children = v.children;
      return children ? children[children.length - 1] : v.t;
    }

    // Shifts the current subtree rooted at w+. This is done by increasing
    // prelim(w+) and mod(w+) by shift.
    function moveSubtree(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }

    // All other shifts, applied to the smaller subtrees between w- and w+, are
    // performed by this function. To prepare the shifts, we have to adjust
    // change(w+), shift(w+), and change(w-).
    function executeShifts(v) {
      var shift = 0,
          change = 0,
          children = v.children,
          i = children.length,
          w;
      while (--i >= 0) {
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }

    // If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
    // returns the specified (default) ancestor.
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null; // default ancestor
      this.a = this; // ancestor
      this.z = 0; // prelim
      this.m = 0; // mod
      this.c = 0; // change
      this.s = 0; // shift
      this.t = null; // thread
      this.i = i; // number
    }

    TreeNode.prototype = Object.create(Node$1.prototype);

    function treeRoot(root) {
      var tree = new TreeNode(root, 0),
          node,
          nodes = [tree],
          child,
          children,
          i,
          n;

      while (node = nodes.pop()) {
        if (children = node._.children) {
          node.children = new Array(n = children.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children[i], i));
            child.parent = node;
          }
        }
      }

      (tree.parent = new TreeNode(null, 0)).children = [tree];
      return tree;
    }

    // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
    function tree() {
      var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = null;

      function tree(root) {
        var t = treeRoot(root);

        // Compute the layout using Buchheim et al.s algorithm.
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);

        // If a fixed node size is specified, scale x and y.
        if (nodeSize) root.eachBefore(sizeNode);

        // If a fixed tree size is specified, scale x and y based on the extent.
        // Compute the left-most, right-most, and depth-most nodes for extents.
        else {
          var left = root,
              right = root,
              bottom = root;
          root.eachBefore(function(node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1);
          root.eachBefore(function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }

        return root;
      }

      // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
      // applied recursively to the children of v, as well as the function
      // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
      // node v is placed to the midpoint of its outermost children.
      function firstWalk(v) {
        var children = v.children,
            siblings = v.parent.children,
            w = v.i ? siblings[v.i - 1] : null;
        if (children) {
          executeShifts(v);
          var midpoint = (children[0].z + children[children.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }

      // Computes all real x-coordinates by summing up the modifiers recursively.
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }

      // The core of the algorithm. Here, a new subtree is combined with the
      // previous subtrees. Threads are used to traverse the inside and outside
      // contours of the left and right subtree up to the highest common level. The
      // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
      // superscript o means outside and i means inside, the subscript - means left
      // subtree and + means right subtree. For summing up the modifiers along the
      // contour, we use respective variables si+, si-, so-, and so+. Whenever two
      // nodes of the inside contours conflict, we compute the left one of the
      // greatest uncommon ancestors using the function ANCESTOR and call MOVE
      // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
      // Finally, we add a new thread (if necessary).
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v,
              vop = v,
              vim = w,
              vom = vip.parent.children[0],
              sip = vip.m,
              sop = vop.m,
              sim = vim.m,
              som = vom.m,
              shift;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }

      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }

      tree.separation = function(x) {
        return arguments.length ? (separation = x, tree) : separation;
      };

      tree.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
      };

      tree.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
      };

      return tree;
    }

    function treemapSlice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
      }
    }

    var phi$1 = (1 + Math.sqrt(5)) / 2;

    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx, dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta;

      while (i0 < n) {
        dx = x1 - x0, dy = y1 - y0;

        // Find the next non-empty node.
        do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);

        // Keep adding nodes while the aspect ratio maintains or improves.
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue) minValue = nodeValue;
          if (nodeValue > maxValue) maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) { sumValue -= nodeValue; break; }
          minRatio = newRatio;
        }

        // Position and record the row orientation.
        rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
        else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
      }

      return rows;
    }

    var squarify = (function custom(ratio) {

      function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }

      squarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return squarify;
    })(phi$1);

    function index() {
      var tile = squarify,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = constantZero,
          paddingTop = constantZero,
          paddingRight = constantZero,
          paddingBottom = constantZero,
          paddingLeft = constantZero;

      function treemap(root) {
        root.x0 =
        root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [0];
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(node) {
        var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
          x0 += paddingLeft(node) - p;
          y0 += paddingTop(node) - p;
          x1 -= paddingRight(node) - p;
          y1 -= paddingBottom(node) - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          tile(node, x0, y0, x1, y1);
        }
      }

      treemap.round = function(x) {
        return arguments.length ? (round = !!x, treemap) : round;
      };

      treemap.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
      };

      treemap.tile = function(x) {
        return arguments.length ? (tile = required(x), treemap) : tile;
      };

      treemap.padding = function(x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
      };

      treemap.paddingInner = function(x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$2(+x), treemap) : paddingInner;
      };

      treemap.paddingOuter = function(x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
      };

      treemap.paddingTop = function(x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$2(+x), treemap) : paddingTop;
      };

      treemap.paddingRight = function(x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$2(+x), treemap) : paddingRight;
      };

      treemap.paddingBottom = function(x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$2(+x), treemap) : paddingBottom;
      };

      treemap.paddingLeft = function(x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$2(+x), treemap) : paddingLeft;
      };

      return treemap;
    }

    function binary(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          i, n = nodes.length,
          sum, sums = new Array(n + 1);

      for (sums[0] = sum = i = 0; i < n; ++i) {
        sums[i + 1] = sum += nodes[i].value;
      }

      partition(0, n, parent.value, x0, y0, x1, y1);

      function partition(i, j, value, x0, y0, x1, y1) {
        if (i >= j - 1) {
          var node = nodes[i];
          node.x0 = x0, node.y0 = y0;
          node.x1 = x1, node.y1 = y1;
          return;
        }

        var valueOffset = sums[i],
            valueTarget = (value / 2) + valueOffset,
            k = i + 1,
            hi = j - 1;

        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget) k = mid + 1;
          else hi = mid;
        }

        if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

        var valueLeft = sums[k] - valueOffset,
            valueRight = value - valueLeft;

        if ((x1 - x0) > (y1 - y0)) {
          var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
          partition(i, k, valueLeft, x0, y0, xk, y1);
          partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
          var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
          partition(i, k, valueLeft, x0, y0, x1, yk);
          partition(k, j, valueRight, x0, yk, x1, y1);
        }
      }
    }

    function sliceDice(parent, x0, y0, x1, y1) {
      (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
    }

    var resquarify = (function custom(ratio) {

      function resquarify(parent, x0, y0, x1, y1) {
        if ((rows = parent._squarify) && (rows.ratio === ratio)) {
          var rows,
              row,
              nodes,
              i,
              j = -1,
              n,
              m = rows.length,
              value = parent.value;

          while (++j < m) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
            if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
            else treemapSlice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
            value -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
          rows.ratio = ratio;
        }
      }

      resquarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return resquarify;
    })(phi$1);

    function area$1(polygon) {
      var i = -1,
          n = polygon.length,
          a,
          b = polygon[n - 1],
          area = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        area += a[1] * b[0] - a[0] * b[1];
      }

      return area / 2;
    }

    function centroid(polygon) {
      var i = -1,
          n = polygon.length,
          x = 0,
          y = 0,
          a,
          b = polygon[n - 1],
          c,
          k = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        k += c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }

      return k *= 3, [x / k, y / k];
    }

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
    // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
    // right, +y is up). Returns a positive value if ABC is counter-clockwise,
    // negative if clockwise, and zero if the points are collinear.
    function cross$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }

    function lexicographicOrder(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }

    // Computes the upper convex hull per the monotone chain algorithm.
    // Assumes points.length >= 3, is sorted by x, unique in y.
    // Returns an array of indices into points in left-to-right order.
    function computeUpperHullIndexes(points) {
      const n = points.length,
          indexes = [0, 1];
      let size = 2, i;

      for (i = 2; i < n; ++i) {
        while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
        indexes[size++] = i;
      }

      return indexes.slice(0, size); // remove popped points
    }

    function hull(points) {
      if ((n = points.length) < 3) return null;

      var i,
          n,
          sortedPoints = new Array(n),
          flippedPoints = new Array(n);

      for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
      sortedPoints.sort(lexicographicOrder);
      for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

      var upperIndexes = computeUpperHullIndexes(sortedPoints),
          lowerIndexes = computeUpperHullIndexes(flippedPoints);

      // Construct the hull polygon, removing possible duplicate endpoints.
      var skipLeft = lowerIndexes[0] === upperIndexes[0],
          skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
          hull = [];

      // Add upper hull in right-to-l order.
      // Then add lower hull in left-to-right order.
      for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
      for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

      return hull;
    }

    function contains(polygon, point) {
      var n = polygon.length,
          p = polygon[n - 1],
          x = point[0], y = point[1],
          x0 = p[0], y0 = p[1],
          x1, y1,
          inside = false;

      for (var i = 0; i < n; ++i) {
        p = polygon[i], x1 = p[0], y1 = p[1];
        if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
        x0 = x1, y0 = y1;
      }

      return inside;
    }

    function length(polygon) {
      var i = -1,
          n = polygon.length,
          b = polygon[n - 1],
          xa,
          ya,
          xb = b[0],
          yb = b[1],
          perimeter = 0;

      while (++i < n) {
        xa = xb;
        ya = yb;
        b = polygon[i];
        xb = b[0];
        yb = b[1];
        xa -= xb;
        ya -= yb;
        perimeter += Math.hypot(xa, ya);
      }

      return perimeter;
    }

    var defaultSource = Math.random;

    var uniform = (function sourceRandomUniform(source) {
      function randomUniform(min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;
        else max -= min;
        return function() {
          return source() * max + min;
        };
      }

      randomUniform.source = sourceRandomUniform;

      return randomUniform;
    })(defaultSource);

    var int = (function sourceRandomInt(source) {
      function randomInt(min, max) {
        if (arguments.length < 2) max = min, min = 0;
        min = Math.floor(min);
        max = Math.floor(max) - min;
        return function() {
          return Math.floor(source() * max + min);
        };
      }

      randomInt.source = sourceRandomInt;

      return randomInt;
    })(defaultSource);

    var normal = (function sourceRandomNormal(source) {
      function randomNormal(mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
          var y;

          // If available, use the second previously-generated uniform random.
          if (x != null) y = x, x = null;

          // Otherwise, generate a new x and y.
          else do {
            x = source() * 2 - 1;
            y = source() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);

          return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
      }

      randomNormal.source = sourceRandomNormal;

      return randomNormal;
    })(defaultSource);

    var logNormal = (function sourceRandomLogNormal(source) {
      var N = normal.source(source);

      function randomLogNormal() {
        var randomNormal = N.apply(this, arguments);
        return function() {
          return Math.exp(randomNormal());
        };
      }

      randomLogNormal.source = sourceRandomLogNormal;

      return randomLogNormal;
    })(defaultSource);

    var irwinHall = (function sourceRandomIrwinHall(source) {
      function randomIrwinHall(n) {
        if ((n = +n) <= 0) return () => 0;
        return function() {
          for (var sum = 0, i = n; i > 1; --i) sum += source();
          return sum + i * source();
        };
      }

      randomIrwinHall.source = sourceRandomIrwinHall;

      return randomIrwinHall;
    })(defaultSource);

    var bates = (function sourceRandomBates(source) {
      var I = irwinHall.source(source);

      function randomBates(n) {
        // use limiting distribution at n === 0
        if ((n = +n) === 0) return source;
        var randomIrwinHall = I(n);
        return function() {
          return randomIrwinHall() / n;
        };
      }

      randomBates.source = sourceRandomBates;

      return randomBates;
    })(defaultSource);

    var exponential = (function sourceRandomExponential(source) {
      function randomExponential(lambda) {
        return function() {
          return -Math.log1p(-source()) / lambda;
        };
      }

      randomExponential.source = sourceRandomExponential;

      return randomExponential;
    })(defaultSource);

    var pareto = (function sourceRandomPareto(source) {
      function randomPareto(alpha) {
        if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
        alpha = 1 / -alpha;
        return function() {
          return Math.pow(1 - source(), alpha);
        };
      }

      randomPareto.source = sourceRandomPareto;

      return randomPareto;
    })(defaultSource);

    var bernoulli = (function sourceRandomBernoulli(source) {
      function randomBernoulli(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        return function() {
          return Math.floor(source() + p);
        };
      }

      randomBernoulli.source = sourceRandomBernoulli;

      return randomBernoulli;
    })(defaultSource);

    var geometric = (function sourceRandomGeometric(source) {
      function randomGeometric(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        if (p === 0) return () => Infinity;
        if (p === 1) return () => 1;
        p = Math.log1p(-p);
        return function() {
          return 1 + Math.floor(Math.log1p(-source()) / p);
        };
      }

      randomGeometric.source = sourceRandomGeometric;

      return randomGeometric;
    })(defaultSource);

    var gamma = (function sourceRandomGamma(source) {
      var randomNormal = normal.source(source)();

      function randomGamma(k, theta) {
        if ((k = +k) < 0) throw new RangeError("invalid k");
        // degenerate distribution if k === 0
        if (k === 0) return () => 0;
        theta = theta == null ? 1 : +theta;
        // exponential distribution if k === 1
        if (k === 1) return () => -Math.log1p(-source()) * theta;

        var d = (k < 1 ? k + 1 : k) - 1 / 3,
            c = 1 / (3 * Math.sqrt(d)),
            multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;
        return function() {
          do {
            do {
              var x = randomNormal(),
                  v = 1 + c * x;
            } while (v <= 0);
            v *= v * v;
            var u = 1 - source();
          } while (u >= 1 - 0.0331 * x * x * x * x && Math.log(u) >= 0.5 * x * x + d * (1 - v + Math.log(v)));
          return d * v * multiplier() * theta;
        };
      }

      randomGamma.source = sourceRandomGamma;

      return randomGamma;
    })(defaultSource);

    var beta = (function sourceRandomBeta(source) {
      var G = gamma.source(source);

      function randomBeta(alpha, beta) {
        var X = G(alpha),
            Y = G(beta);
        return function() {
          var x = X();
          return x === 0 ? 0 : x / (x + Y());
        };
      }

      randomBeta.source = sourceRandomBeta;

      return randomBeta;
    })(defaultSource);

    var binomial = (function sourceRandomBinomial(source) {
      var G = geometric.source(source),
          B = beta.source(source);

      function randomBinomial(n, p) {
        n = +n;
        if ((p = +p) >= 1) return () => n;
        if (p <= 0) return () => 0;
        return function() {
          var acc = 0, nn = n, pp = p;
          while (nn * pp > 16 && nn * (1 - pp) > 16) {
            var i = Math.floor((nn + 1) * pp),
                y = B(i, nn - i + 1)();
            if (y <= pp) {
              acc += i;
              nn -= i;
              pp = (pp - y) / (1 - y);
            } else {
              nn = i - 1;
              pp /= y;
            }
          }
          var sign = pp < 0.5,
              pFinal = sign ? pp : 1 - pp,
              g = G(pFinal);
          for (var s = g(), k = 0; s <= nn; ++k) s += g();
          return acc + (sign ? k : nn - k);
        };
      }

      randomBinomial.source = sourceRandomBinomial;

      return randomBinomial;
    })(defaultSource);

    var weibull = (function sourceRandomWeibull(source) {
      function randomWeibull(k, a, b) {
        var outerFunc;
        if ((k = +k) === 0) {
          outerFunc = x => -Math.log(x);
        } else {
          k = 1 / k;
          outerFunc = x => Math.pow(x, k);
        }
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * outerFunc(-Math.log1p(-source()));
        };
      }

      randomWeibull.source = sourceRandomWeibull;

      return randomWeibull;
    })(defaultSource);

    var cauchy = (function sourceRandomCauchy(source) {
      function randomCauchy(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * Math.tan(Math.PI * source());
        };
      }

      randomCauchy.source = sourceRandomCauchy;

      return randomCauchy;
    })(defaultSource);

    var logistic = (function sourceRandomLogistic(source) {
      function randomLogistic(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          var u = source();
          return a + b * Math.log(u / (1 - u));
        };
      }

      randomLogistic.source = sourceRandomLogistic;

      return randomLogistic;
    })(defaultSource);

    var poisson = (function sourceRandomPoisson(source) {
      var G = gamma.source(source),
          B = binomial.source(source);

      function randomPoisson(lambda) {
        return function() {
          var acc = 0, l = lambda;
          while (l > 16) {
            var n = Math.floor(0.875 * l),
                t = G(n)();
            if (t > l) return acc + B(n - 1, l / t)();
            acc += n;
            l -= t;
          }
          for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k) s -= Math.log1p(-source());
          return acc + k;
        };
      }

      randomPoisson.source = sourceRandomPoisson;

      return randomPoisson;
    })(defaultSource);

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const mul = 0x19660D;
    const inc = 0x3C6EF35F;
    const eps = 1 / 0x100000000;

    function lcg(seed = Math.random()) {
      let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
      return () => (state = mul * state + inc | 0, eps * (state >>> 0));
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0: break;
        case 1: {
          if (typeof domain === "function") this.interpolator(domain);
          else this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function") this.interpolator(interpolator);
          else this.range(interpolator);
          break;
        }
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function band() {
      var scale = ordinal().unknown(undefined),
          domain = scale.domain,
          ordinalRange = scale.range,
          r0 = 0,
          r1 = 1,
          step,
          bandwidth,
          round = false,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;

      delete scale.unknown;

      function rescale() {
        var n = domain().length,
            reverse = r1 < r0,
            start = reverse ? r1 : r0,
            stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = range$2(n).map(function(i) { return start + step * i; });
        return ordinalRange(reverse ? values.reverse() : values);
      }

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };

      scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
      };

      scale.bandwidth = function() {
        return bandwidth;
      };

      scale.step = function() {
        return step;
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
      };

      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };

      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };

      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };

      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };

      scale.copy = function() {
        return band(domain(), [r0, r1])
            .round(round)
            .paddingInner(paddingInner)
            .paddingOuter(paddingOuter)
            .align(align);
      };

      return initRange.apply(rescale(), arguments);
    }

    function pointish(scale) {
      var copy = scale.copy;

      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;

      scale.copy = function() {
        return pointish(copy());
      };

      return scale;
    }

    function point$4() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }

    function constants(x) {
      return function() {
        return x;
      };
    }

    function number$1(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$3(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisectRight(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy$1(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer$2() {
      var domain = unit,
          range = unit,
          interpolate = interpolate$2,
          transform,
          untransform,
          unknown,
          clamp = identity$3,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$3) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer$2()(identity$3, identity$3);
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }

        return scale;
      };

      return scale;
    }

    function linear() {
      var scale = continuous();

      scale.copy = function() {
        return copy$1(scale, linear());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function identity$2(domain) {
      var unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : x;
      }

      scale.invert = scale;

      scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return identity$2(domain).unknown(unknown);
      };

      domain = arguments.length ? Array.from(domain, number$1) : [0, 1];

      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();

      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    function transformLog(x) {
      return Math.log(x);
    }

    function transformExp(x) {
      return Math.exp(x);
    }

    function transformLogn(x) {
      return -Math.log(-x);
    }

    function transformExpn(x) {
      return -Math.exp(-x);
    }

    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }

    function powp(base) {
      return base === 10 ? pow10
          : base === Math.E ? Math.exp
          : function(x) { return Math.pow(base, x); };
    }

    function logp(base) {
      return base === Math.E ? Math.log
          : base === 10 && Math.log10
          || base === 2 && Math.log2
          || (base = Math.log(base), function(x) { return Math.log(x) / base; });
    }

    function reflect(f) {
      return function(x) {
        return -f(-x);
      };
    }

    function loggish(transform) {
      var scale = transform(transformLog, transformExp),
          domain = scale.domain,
          base = 10,
          logs,
          pows;

      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog, transformExp);
        }
        return scale;
      }

      scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.ticks = function(count) {
        var d = domain(),
            u = d[0],
            v = d[d.length - 1],
            r;

        if (r = v < u) i = u, u = v, v = i;

        var i = logs(u),
            j = logs(v),
            p,
            k,
            t,
            n = count == null ? 10 : +count,
            z = [];

        if (!(base % 1) && j - i < n) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u > 0) for (; i <= j; ++i) {
            for (k = 1, p = pows(i); k < base; ++k) {
              t = p * k;
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          } else for (; i <= j; ++i) {
            for (k = base - 1, p = pows(i); k >= 1; --k) {
              t = p * k;
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          }
          if (z.length * 2 < n) z = ticks(u, v, n);
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }

        return r ? z.reverse() : z;
      };

      scale.tickFormat = function(count, specifier) {
        if (specifier == null) specifier = base === 10 ? ".0e" : ",";
        if (typeof specifier !== "function") specifier = format(specifier);
        if (count === Infinity) return specifier;
        if (count == null) count = 10;
        var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return function(d) {
          var i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k ? specifier(d) : "";
        };
      };

      scale.nice = function() {
        return domain(nice(domain(), {
          floor: function(x) { return pows(Math.floor(logs(x))); },
          ceil: function(x) { return pows(Math.ceil(logs(x))); }
        }));
      };

      return scale;
    }

    function log() {
      var scale = loggish(transformer$2()).domain([1, 10]);

      scale.copy = function() {
        return copy$1(scale, log()).base(scale.base());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function transformSymlog(c) {
      return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
      };
    }

    function transformSymexp(c) {
      return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
      };
    }

    function symlogish(transform) {
      var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

      scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
      };

      return linearish(scale);
    }

    function symlog() {
      var scale = symlogish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, symlog()).constant(scale.constant());
      };

      return initRange.apply(scale, arguments);
    }

    function transformPow(exponent) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };
    }

    function transformSqrt(x) {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }

    function transformSquare(x) {
      return x < 0 ? -x * x : x * x;
    }

    function powish(transform) {
      var scale = transform(identity$3, identity$3),
          exponent = 1;

      function rescale() {
        return exponent === 1 ? transform(identity$3, identity$3)
            : exponent === 0.5 ? transform(transformSqrt, transformSquare)
            : transform(transformPow(exponent), transformPow(1 / exponent));
      }

      scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
      };

      return linearish(scale);
    }

    function pow() {
      var scale = powish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, pow()).exponent(scale.exponent());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function sqrt$1() {
      return pow.apply(null, arguments).exponent(0.5);
    }

    function square$1(x) {
      return Math.sign(x) * x * x;
    }

    function unsquare(x) {
      return Math.sign(x) * Math.sqrt(Math.abs(x));
    }

    function radial() {
      var squared = continuous(),
          range = [0, 1],
          round = false,
          unknown;

      function scale(x) {
        var y = unsquare(squared(x));
        return isNaN(y) ? unknown : round ? Math.round(y) : y;
      }

      scale.invert = function(y) {
        return squared.invert(square$1(y));
      };

      scale.domain = function(_) {
        return arguments.length ? (squared.domain(_), scale) : squared.domain();
      };

      scale.range = function(_) {
        return arguments.length ? (squared.range((range = Array.from(_, number$1)).map(square$1)), scale) : range.slice();
      };

      scale.rangeRound = function(_) {
        return scale.range(_).round(true);
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, scale) : round;
      };

      scale.clamp = function(_) {
        return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return radial(squared.domain(), range)
            .round(round)
            .clamp(squared.clamp())
            .unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function quantile() {
      var domain = [],
          range = [],
          thresholds = [],
          unknown;

      function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : range[bisectRight(thresholds, x)];
      }

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return rescale();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.quantiles = function() {
        return thresholds.slice();
      };

      scale.copy = function() {
        return quantile()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    function quantize() {
      var x0 = 0,
          x1 = 1,
          n = 1,
          domain = [0.5],
          range = [0, 1],
          unknown;

      function scale(x) {
        return x != null && x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
      }

      function rescale() {
        var i = -1;
        domain = new Array(n);
        while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
      };

      scale.range = function(_) {
        return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN]
            : i < 1 ? [x0, domain[0]]
            : i >= n ? [domain[n - 1], x1]
            : [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
      };

      scale.thresholds = function() {
        return domain.slice();
      };

      scale.copy = function() {
        return quantize()
            .domain([x0, x1])
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(linearish(scale), arguments);
    }

    function threshold() {
      var domain = [0.5],
          range = [0, 1],
          unknown,
          n = 1;

      function scale(x) {
        return x != null && x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
      }

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return threshold()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    var t0 = new Date,
        t1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
      }

      interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };
    var milliseconds = millisecond.range;

    const durationSecond = 1000;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;

    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });
    var seconds = second.range;

    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });
    var minutes = minute.range;

    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });
    var hours = hour.range;

    var day = newInterval(
      date => date.setHours(0, 0, 0, 0),
      (date, step) => date.setDate(date.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
      date => date.getDate() - 1
    );
    var days = day.range;

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var sundays = sunday.range;
    var mondays = monday.range;
    var tuesdays = tuesday.range;
    var wednesdays = wednesday.range;
    var thursdays = thursday.range;
    var fridays = friday.range;
    var saturdays = saturday.range;

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });
    var months = month.range;

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };
    var years = year.range;

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });
    var utcMinutes = utcMinute.range;

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });
    var utcHours = utcHour.range;

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });
    var utcDays = utcDay.range;

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcSundays = utcSunday.range;
    var utcMondays = utcMonday.range;
    var utcTuesdays = utcTuesday.range;
    var utcWednesdays = utcWednesday.range;
    var utcThursdays = utcThursday.range;
    var utcFridays = utcFriday.range;
    var utcSaturdays = utcSaturday.range;

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });
    var utcMonths = utcMonth.range;

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };
    var utcYears = utcYear.range;

    function ticker(year, month, week, day, hour, minute) {

      const tickIntervals = [
        [second,  1,      durationSecond],
        [second,  5,  5 * durationSecond],
        [second, 15, 15 * durationSecond],
        [second, 30, 30 * durationSecond],
        [minute,  1,      durationMinute],
        [minute,  5,  5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [  hour,  1,      durationHour  ],
        [  hour,  3,  3 * durationHour  ],
        [  hour,  6,  6 * durationHour  ],
        [  hour, 12, 12 * durationHour  ],
        [   day,  1,      durationDay   ],
        [   day,  2,  2 * durationDay   ],
        [  week,  1,      durationWeek  ],
        [ month,  1,      durationMonth ],
        [ month,  3,  3 * durationMonth ],
        [  year,  1,      durationYear  ]
      ];

      function ticks(start, stop, count) {
        const reverse = stop < start;
        if (reverse) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
      }

      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector(([,, step]) => step).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }

      return [ticks, tickInterval];
    }

    const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute);
    const [timeTicks, timeTickInterval] = ticker(year, month, sunday, day, hour, minute);

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day$1;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
              week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
              week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
              week = day.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + day.count(year(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(year(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day = d.getDay();
      return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(year(d) - 1, d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day = d.getUTCDay();
      return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    function date(t) {
      return new Date(t);
    }

    function number(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain;

      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
            : hour(date) < date ? formatMinute
            : day(date) < date ? formatHour
            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
            : year(date) < date ? formatMonth
            : formatYear)(date);
      }

      scale.invert = function(y) {
        return new Date(invert(y));
      };

      scale.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };

      scale.ticks = function(interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };

      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function(interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };

      scale.copy = function() {
        return copy$1(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };

      return scale;
    }

    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, year, month, sunday, day, hour, minute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
    }

    function transformer$1() {
      var x0 = 0,
          x1 = 1,
          t0,
          t1,
          k10,
          transform,
          interpolator = identity$3,
          clamp = false,
          unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function sequential() {
      var scale = linearish(transformer$1()(identity$3));

      scale.copy = function() {
        return copy(scale, sequential());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialLog() {
      var scale = loggish(transformer$1()).domain([1, 10]);

      scale.copy = function() {
        return copy(scale, sequentialLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSymlog() {
      var scale = symlogish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialPow() {
      var scale = powish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }

    function sequentialQuantile() {
      var domain = [],
          interpolator = identity$3;

      function scale(x) {
        if (x != null && !isNaN(x = +x)) return interpolator((bisectRight(domain, x, 1) - 1) / (domain.length - 1));
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return scale;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.range = function() {
        return domain.map((d, i) => interpolator(i / (domain.length - 1)));
      };

      scale.quantiles = function(n) {
        return Array.from({length: n + 1}, (_, i) => quantile$1(domain, i / n));
      };

      scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
      };

      return initInterpolator.apply(scale, arguments);
    }

    function transformer() {
      var x0 = 0,
          x1 = 0.5,
          x2 = 1,
          s = 1,
          t0,
          t1,
          t2,
          k10,
          k21,
          interpolator = identity$3,
          transform,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
        return scale;
      };
    }

    function diverging$1() {
      var scale = linearish(transformer()(identity$3));

      scale.copy = function() {
        return copy(scale, diverging$1());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingLog() {
      var scale = loggish(transformer()).domain([0.1, 1, 10]);

      scale.copy = function() {
        return copy(scale, divergingLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSymlog() {
      var scale = symlogish(transformer());

      scale.copy = function() {
        return copy(scale, divergingSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingPow() {
      var scale = powish(transformer());

      scale.copy = function() {
        return copy(scale, divergingPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    var ramp$1 = scheme => rgbBasis(scheme[scheme.length - 1]);

    var scheme$q = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);

    var BrBG = ramp$1(scheme$q);

    var scheme$p = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);

    var PRGn = ramp$1(scheme$p);

    var scheme$o = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);

    var PiYG = ramp$1(scheme$o);

    var scheme$n = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);

    var PuOr = ramp$1(scheme$n);

    var scheme$m = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);

    var RdBu = ramp$1(scheme$m);

    var scheme$l = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);

    var RdGy = ramp$1(scheme$l);

    var scheme$k = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);

    var RdYlBu = ramp$1(scheme$k);

    var scheme$j = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);

    var RdYlGn = ramp$1(scheme$j);

    var scheme$i = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);

    var Spectral = ramp$1(scheme$i);

    var scheme$h = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);

    var BuGn = ramp$1(scheme$h);

    var scheme$g = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);

    var BuPu = ramp$1(scheme$g);

    var scheme$f = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);

    var GnBu = ramp$1(scheme$f);

    var scheme$e = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);

    var OrRd = ramp$1(scheme$e);

    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);

    var PuBuGn = ramp$1(scheme$d);

    var scheme$c = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);

    var PuBu = ramp$1(scheme$c);

    var scheme$b = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);

    var PuRd = ramp$1(scheme$b);

    var scheme$a = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);

    var RdPu = ramp$1(scheme$a);

    var scheme$9 = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);

    var YlGnBu = ramp$1(scheme$9);

    var scheme$8 = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);

    var YlGn = ramp$1(scheme$8);

    var scheme$7 = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);

    var YlOrBr = ramp$1(scheme$7);

    var scheme$6 = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);

    var YlOrRd = ramp$1(scheme$6);

    var scheme$5 = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);

    var Blues = ramp$1(scheme$5);

    var scheme$4 = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);

    var Greens = ramp$1(scheme$4);

    var scheme$3 = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);

    var Greys = ramp$1(scheme$3);

    var scheme$2 = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);

    var Purples = ramp$1(scheme$2);

    var scheme$1 = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);

    var Reds = ramp$1(scheme$1);

    var scheme = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);

    var Oranges = ramp$1(scheme);

    function cividis(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
          + ")";
    }

    var cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0.0), cubehelix$3(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var c$2 = cubehelix$3();

    function rainbow(t) {
      if (t < 0 || t > 1) t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c$2.h = 360 * t - 100;
      c$2.s = 1.5 - 1.5 * ts;
      c$2.l = 0.8 - 0.9 * ts;
      return c$2 + "";
    }

    var c$1 = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function sinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c$1.r = 255 * (x = Math.sin(t)) * x;
      c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c$1 + "";
    }

    function turbo(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
          + ")";
    }

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function constant$1(x) {
      return function constant() {
        return x;
      };
    }

    var abs = Math.abs;
    var atan2 = Math.atan2;
    var cos = Math.cos;
    var max = Math.max;
    var min = Math.min;
    var sin = Math.sin;
    var sqrt = Math.sqrt;

    var epsilon = 1e-12;
    var pi = Math.PI;
    var halfPi = pi / 2;
    var tau = 2 * pi;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
      return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant$1(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null;

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi,
            a1 = endAngle.apply(this, arguments) - halfPi,
            da = abs(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau - epsilon) {
          context.moveTo(r1 * cos(a0), r1 * sin(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon) {
            context.moveTo(r0 * cos(a1), r0 * sin(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
              rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1  r0, da1  da0.
          if (rp > epsilon) {
            var p0 = asin(rp / r0 * sin(ap)),
                p1 = asin(rp / r1 * sin(ap));
            if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos(a01),
              y01 = r1 * sin(a01),
              x10 = r0 * cos(a10),
              y10 = r0 * sin(a10);

          // Apply rounded corners?
          if (rc > epsilon) {
            var x11 = r1 * cos(a11),
                y11 = r1 * sin(a11),
                x00 = r0 * cos(a00),
                y00 = r0 * sin(a00),
                oc;

            // Restrict the corner radius according to the sector angle.
            if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
                  lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min(rc, (r0 - lc) / (kc - 1));
              rc1 = min(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon)) context.moveTo(x01, y01);

          // Does the sectors outer ring have rounded corners?
          else if (rc1 > epsilon) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and its a circular sector?
          // Or perhaps its an annular sector collapsed due to padding?
          if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

          // Does the sectors inner ring (or point) have rounded corners?
          else if (rc0 > epsilon) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
        return [cos(a) * r, sin(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    var slice = Array.prototype.slice;

    function array(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: this._context.lineTo(x, y); break;
        }
      }
    };

    function curveLinear(context) {
      return new Linear(context);
    }

    function x(p) {
      return p[0];
    }

    function y(p) {
      return p[1];
    }

    function line(x$1, y$1) {
      var defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x$1 = typeof x$1 === "function" ? x$1 : (x$1 === undefined) ? x : constant$1(x$1);
      y$1 = typeof y$1 === "function" ? y$1 : (y$1 === undefined) ? y : constant$1(y$1);

      function line(data) {
        var i,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer;

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), line) : x$1;
      };

      line.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), line) : y$1;
      };

      line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), line) : defined;
      };

      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area(x0, y0, y1) {
      var x1 = null,
          defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x : constant$1(+x0);
      y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant$1(0) : constant$1(+y0);
      y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y : constant$1(+y1);

      function area(data) {
        var i,
            j,
            k,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }

      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
      };

      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
      };

      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
      };

      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
      };

      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
      };

      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
      };

      area.lineX0 =
      area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };

      area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), area) : defined;
      };

      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    function descending$1(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$1(d) {
      return d;
    }

    function pie() {
      var value = identity$1,
          sortValues = descending$1,
          sort = null,
          startAngle = constant$1(0),
          endAngle = constant$1(tau),
          padAngle = constant$1(0);

      function pie(data) {
        var i,
            n = (data = array(data)).length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v;

        for (i = 0; i < n; ++i) {
          if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
            sum += v;
          }
        }

        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
        else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

        // Compute the arcs! They are stored in the original data's order.
        for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
          j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
          };
        }

        return arcs;
      }

      pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), pie) : value;
      };

      pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
      };

      pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
      };

      pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : startAngle;
      };

      pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : endAngle;
      };

      pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : padAngle;
      };

      return pie;
    }

    var curveRadialLinear = curveRadial$1(curveLinear);

    function Radial(curve) {
      this._curve = curve;
    }

    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
      }
    };

    function curveRadial$1(curve) {

      function radial(context) {
        return new Radial(curve(context));
      }

      radial._curve = curve;

      return radial;
    }

    function lineRadial(l) {
      var c = l.curve;

      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;

      l.curve = function(_) {
        return arguments.length ? c(curveRadial$1(_)) : c()._curve;
      };

      return l;
    }

    function lineRadial$1() {
      return lineRadial(line().curve(curveRadialLinear));
    }

    function areaRadial() {
      var a = area().curve(curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1;

      a.angle = a.x, delete a.x;
      a.startAngle = a.x0, delete a.x0;
      a.endAngle = a.x1, delete a.x1;
      a.radius = a.y, delete a.y;
      a.innerRadius = a.y0, delete a.y0;
      a.outerRadius = a.y1, delete a.y1;
      a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
      a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
      a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
      a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

      a.curve = function(_) {
        return arguments.length ? c(curveRadial$1(_)) : c()._curve;
      };

      return a;
    }

    function pointRadial(x, y) {
      return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    function linkSource(d) {
      return d.source;
    }

    function linkTarget(d) {
      return d.target;
    }

    function link(curve) {
      var source = linkSource,
          target = linkTarget,
          x$1 = x,
          y$1 = y,
          context = null;

      function link() {
        var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
        if (!context) context = buffer = path();
        curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
        if (buffer) return context = null, buffer + "" || null;
      }

      link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
      };

      link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
      };

      link.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), link) : x$1;
      };

      link.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), link) : y$1;
      };

      link.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), link) : context;
      };

      return link;
    }

    function curveHorizontal(context, x0, y0, x1, y1) {
      context.moveTo(x0, y0);
      context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
    }

    function curveVertical(context, x0, y0, x1, y1) {
      context.moveTo(x0, y0);
      context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
    }

    function curveRadial(context, x0, y0, x1, y1) {
      var p0 = pointRadial(x0, y0),
          p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
          p2 = pointRadial(x1, y0),
          p3 = pointRadial(x1, y1);
      context.moveTo(p0[0], p0[1]);
      context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
    }

    function linkHorizontal() {
      return link(curveHorizontal);
    }

    function linkVertical() {
      return link(curveVertical);
    }

    function linkRadial() {
      var l = link(curveRadial);
      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;
      return l;
    }

    var circle = {
      draw: function(context, size) {
        var r = Math.sqrt(size / pi);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau);
      }
    };

    var cross = {
      draw: function(context, size) {
        var r = Math.sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };

    var tan30 = Math.sqrt(1 / 3),
        tan30_2 = tan30 * 2;

    var diamond = {
      draw: function(context, size) {
        var y = Math.sqrt(size / tan30_2),
            x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };

    var ka = 0.89081309152928522810,
        kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
        kx = Math.sin(tau / 10) * kr,
        ky = -Math.cos(tau / 10) * kr;

    var star = {
      draw: function(context, size) {
        var r = Math.sqrt(size * ka),
            x = kx * r,
            y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (var i = 1; i < 5; ++i) {
          var a = tau * i / 5,
              c = Math.cos(a),
              s = Math.sin(a);
          context.lineTo(s * r, -c * r);
          context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
      }
    };

    var square = {
      draw: function(context, size) {
        var w = Math.sqrt(size),
            x = -w / 2;
        context.rect(x, x, w, w);
      }
    };

    var sqrt3 = Math.sqrt(3);

    var triangle = {
      draw: function(context, size) {
        var y = -Math.sqrt(size / (sqrt3 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3 * y, -y);
        context.lineTo(sqrt3 * y, -y);
        context.closePath();
      }
    };

    var c = -0.5,
        s = Math.sqrt(3) / 2,
        k = 1 / Math.sqrt(12),
        a = (k / 2 + 1) * 3;

    var wye = {
      draw: function(context, size) {
        var r = Math.sqrt(size / a),
            x0 = r / 2,
            y0 = r * k,
            x1 = x0,
            y1 = r * k + r,
            x2 = -x1,
            y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };

    var symbols = [
      circle,
      cross,
      diamond,
      square,
      star,
      triangle,
      wye
    ];

    function symbol(type, size) {
      var context = null;
      type = typeof type === "function" ? type : constant$1(type || circle);
      size = typeof size === "function" ? size : constant$1(size === undefined ? 64 : +size);

      function symbol() {
        var buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$1(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$1(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function noop$1() {}

    function point$3(that, x, y) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x) / 6,
        (that._y0 + 4 * that._y1 + y) / 6
      );
    }

    function Basis(context) {
      this._context = context;
    }

    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3: point$3(this, this._x1, this._y1); // falls through
          case 2: this._context.lineTo(this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basis(context) {
      return new Basis(context);
    }

    function BasisClosed(context) {
      this._context = context;
    }

    BasisClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
          case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
          case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisClosed(context) {
      return new BasisClosed(context);
    }

    function BasisOpen(context) {
      this._context = context;
    }

    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
          case 3: this._point = 4; // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisOpen(context) {
      return new BasisOpen(context);
    }

    class Bump {
      constructor(context, x) {
        this._context = context;
        this._x = x;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line) this._context.lineTo(x, y);
            else this._context.moveTo(x, y);
            break;
          }
          case 1: this._point = 2; // falls through
          default: {
            if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
            else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
            break;
          }
        }
        this._x0 = x, this._y0 = y;
      }
    }

    function bumpX(context) {
      return new Bump(context, true);
    }

    function bumpY(context) {
      return new Bump(context, false);
    }

    function Bundle(context, beta) {
      this._basis = new Basis(context);
      this._beta = beta;
    }

    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            j = x.length - 1;

        if (j > 0) {
          var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t;

          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }

        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    var bundle = (function custom(beta) {

      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }

      bundle.beta = function(beta) {
        return custom(+beta);
      };

      return bundle;
    })(0.85);

    function point$2(that, x, y) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x),
        that._y2 + that._k * (that._y1 - y),
        that._x2,
        that._y2
      );
    }

    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: point$2(this, this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
          case 2: this._point = 3; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinal = (function custom(tension) {

      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalClosed = (function custom(tension) {

      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalOpen = (function custom(tension) {

      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function point$1(that, x, y) {
      var x1 = that._x1,
          y1 = that._y1,
          x2 = that._x2,
          y2 = that._y2;

      if (that._l01_a > epsilon) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
            n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
      }

      if (that._l23_a > epsilon) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
            m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
      }

      that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }

    function CatmullRom(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: this.point(this._x2, this._y2); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRom = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomClosed(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomClosed = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomOpen(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomOpen = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function LinearClosed(context) {
      this._context = context;
    }

    LinearClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
      }
    };

    function linearClosed(context) {
      return new LinearClosed(context);
    }

    function sign(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bzier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    function monotoneX(context) {
      return new MonotoneX(context);
    }

    function monotoneY(context) {
      return new MonotoneY(context);
    }

    function Natural(context) {
      this._context = context;
    }

    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            n = x.length;

        if (n) {
          this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
          if (n === 2) {
            this._context.lineTo(x[1], y[1]);
          } else {
            var px = controlPoints(x),
                py = controlPoints(y);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
          }
        }

        if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
    function controlPoints(x) {
      var i,
          n = x.length - 1,
          m,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n);
      a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
      for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
      a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
      for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
      a[n - 1] = r[n - 1] / b[n - 1];
      for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
      b[n - 1] = (x[n] + a[n - 1]) / 2;
      for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
      return [a, b];
    }

    function natural(context) {
      return new Natural(context);
    }

    function Step(context, t) {
      this._context = context;
      this._t = t;
    }

    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
        }
        this._x = x, this._y = y;
      }
    };

    function step(context) {
      return new Step(context, 0.5);
    }

    function stepBefore(context) {
      return new Step(context, 0);
    }

    function stepAfter(context) {
      return new Step(context, 1);
    }

    function none$1(series, order) {
      if (!((n = series.length) > 1)) return;
      for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
        s0 = s1, s1 = series[order[i]];
        for (j = 0; j < m; ++j) {
          s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
        }
      }
    }

    function none(series) {
      var n = series.length, o = new Array(n);
      while (--n >= 0) o[n] = n;
      return o;
    }

    function stackValue(d, key) {
      return d[key];
    }

    function stackSeries(key) {
      const series = [];
      series.key = key;
      return series;
    }

    function stack() {
      var keys = constant$1([]),
          order = none,
          offset = none$1,
          value = stackValue;

      function stack(data) {
        var sz = Array.from(keys.apply(this, arguments), stackSeries),
            i, n = sz.length, j = -1,
            oz;

        for (const d of data) {
          for (i = 0, ++j; i < n; ++i) {
            (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
          }
        }

        for (i = 0, oz = array(order(sz)); i < n; ++i) {
          sz[oz[i]].index = i;
        }

        offset(sz, oz);
        return sz;
      }

      stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : keys;
      };

      stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), stack) : value;
      };

      stack.order = function(_) {
        return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : order;
      };

      stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
      };

      return stack;
    }

    function expand(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
        for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
        if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
      }
      none$1(series, order);
    }

    function diverging(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
        for (yp = yn = 0, i = 0; i < n; ++i) {
          if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
            d[0] = yp, d[1] = yp += dy;
          } else if (dy < 0) {
            d[1] = yn, d[0] = yn += dy;
          } else {
            d[0] = 0, d[1] = dy;
          }
        }
      }
    }

    function silhouette(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
        for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
      }
      none$1(series, order);
    }

    function wiggle(series, order) {
      if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
      for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
        for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
          var si = series[order[i]],
              sij0 = si[j][1] || 0,
              sij1 = si[j - 1][1] || 0,
              s3 = (sij0 - sij1) / 2;
          for (var k = 0; k < i; ++k) {
            var sk = series[order[k]],
                skj0 = sk[j][1] || 0,
                skj1 = sk[j - 1][1] || 0;
            s3 += skj0 - skj1;
          }
          s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      none$1(series, order);
    }

    function appearance(series) {
      var peaks = series.map(peak);
      return none(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
    }

    function peak(series) {
      var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
      while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
      return j;
    }

    function ascending(series) {
      var sums = series.map(sum);
      return none(series).sort(function(a, b) { return sums[a] - sums[b]; });
    }

    function sum(series) {
      var s = 0, i = -1, n = series.length, v;
      while (++i < n) if (v = +series[i][1]) s += v;
      return s;
    }

    function descending(series) {
      return ascending(series).reverse();
    }

    function insideOut(series) {
      var n = series.length,
          i,
          j,
          sums = series.map(sum),
          order = appearance(series),
          top = 0,
          bottom = 0,
          tops = [],
          bottoms = [];

      for (i = 0; i < n; ++i) {
        j = order[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }

      return bottoms.reverse().concat(tops);
    }

    function reverse(series) {
      return none(series).reverse();
    }

    var constant = x => () => x;

    function ZoomEvent(type, {
      sourceEvent,
      target,
      transform,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        transform: {value: transform, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }

    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };

    var identity = new Transform(1, 0, 0);

    transform.prototype = Transform.prototype;

    function transform(node) {
      while (!node.__zoom) if (!(node = node.parentNode)) return identity;
      return node.__zoom;
    }

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }

    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === 'wheel') && !event.button;
    }

    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }

    function defaultTransform() {
      return this.__zoom || identity;
    }

    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
          dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
          dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
          dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }

    function zoom() {
      var filter = defaultFilter,
          extent = defaultExtent,
          constrain = defaultConstrain,
          wheelDelta = defaultWheelDelta,
          touchable = defaultTouchable,
          scaleExtent = [0, Infinity],
          translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
          duration = 250,
          interpolate = interpolateZoom,
          listeners = dispatch("start", "zoom", "end"),
          touchstarting,
          touchfirst,
          touchending,
          touchDelay = 500,
          wheelDelay = 150,
          clickDistance2 = 0,
          tapDistance = 10;

      function zoom(selection) {
        selection
            .property("__zoom", defaultTransform)
            .on("wheel.zoom", wheeled, {passive: false})
            .on("mousedown.zoom", mousedowned)
            .on("dblclick.zoom", dblclicked)
          .filter(touchable)
            .on("touchstart.zoom", touchstarted)
            .on("touchmove.zoom", touchmoved)
            .on("touchend.zoom touchcancel.zoom", touchended)
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      zoom.transform = function(collection, transform, point, event) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
          schedule(collection, transform, point, event);
        } else {
          selection.interrupt().each(function() {
            gesture(this, arguments)
              .event(event)
              .start()
              .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
              .end();
          });
        }
      };

      zoom.scaleBy = function(selection, k, p, event) {
        zoom.scaleTo(selection, function() {
          var k0 = this.__zoom.k,
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p, event);
      };

      zoom.scaleTo = function(selection, k, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t0 = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
              p1 = t0.invert(p0),
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p, event);
      };

      zoom.translateBy = function(selection, x, y, event) {
        zoom.transform(selection, function() {
          return constrain(this.__zoom.translate(
            typeof x === "function" ? x.apply(this, arguments) : x,
            typeof y === "function" ? y.apply(this, arguments) : y
          ), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };

      zoom.translateTo = function(selection, x, y, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x === "function" ? -x.apply(this, arguments) : -x,
            typeof y === "function" ? -y.apply(this, arguments) : -y
          ), e, translateExtent);
        }, p, event);
      };

      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }

      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }

      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }

      function schedule(transition, transform, point, event) {
        transition
            .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
            .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
            .tween("zoom", function() {
              var that = this,
                  args = arguments,
                  g = gesture(that, args).event(event),
                  e = extent.apply(that, args),
                  p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
                  w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                  a = that.__zoom,
                  b = typeof transform === "function" ? transform.apply(that, args) : transform,
                  i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
              return function(t) {
                if (t === 1) t = b; // Avoid rounding error on end.
                else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
                g.zoom(null, t);
              };
            });
      }

      function gesture(that, args, clean) {
        return (!clean && that.__zooming) || new Gesture(that, args);
      }

      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }

      Gesture.prototype = {
        event: function(event) {
          if (event) this.sourceEvent = event;
          return this;
        },
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new ZoomEvent(type, {
              sourceEvent: this.sourceEvent,
              target: zoom,
              type,
              transform: this.that.__zoom,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function wheeled(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, args).event(event),
            t = this.__zoom,
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
            p = pointer(event);

        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }
          clearTimeout(g.wheel);
        }

        // If this wheel event wont trigger a transform change, ignore it.
        else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }

      function mousedowned(event, ...args) {
        if (touchending || !filter.apply(this, arguments)) return;
        var currentTarget = event.currentTarget,
            g = gesture(this, args, true).event(event),
            v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
            p = pointer(event, currentTarget),
            x0 = event.clientX,
            y0 = event.clientY;

        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();

        function mousemoved(event) {
          noevent(event);
          if (!g.moved) {
            var dx = event.clientX - x0, dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event)
           .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }

        function mouseupped(event) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent(event);
          g.event(event).end();
        }
      }

      function dblclicked(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
            p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
            p1 = t0.invert(p0),
            k1 = t0.k * (event.shiftKey ? 0.5 : 2),
            t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

        noevent(event);
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);
        else select(this).call(zoom.transform, t1, p0, event);
      }

      function touchstarted(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
            n = touches.length,
            g = gesture(this, args, event.changedTouches.length === n).event(event),
            started, i, t, p;

        nopropagation(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }

        if (touchstarting) touchstarting = clearTimeout(touchstarting);

        if (started) {
          if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
          interrupt(this);
          g.start();
        }
      }

      function touchmoved(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t, p, l;

        noevent(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
          else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1],
              p1 = g.touch1[0], l1 = g.touch1[1],
              dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
              dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        }
        else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
        else return;

        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }

      function touchended(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t;

        nopropagation(event);
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
            }
          }
        }
      }

      zoom.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
      };

      zoom.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
      };

      zoom.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
      };

      zoom.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };

      zoom.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };

      zoom.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };

      zoom.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };

      zoom.duration = function(_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };

      zoom.interpolate = function(_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };

      zoom.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };

      zoom.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };

      zoom.tapDistance = function(_) {
        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
      };

      return zoom;
    }

    var d3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bisect: bisectRight,
        bisectRight: bisectRight,
        bisectLeft: bisectLeft,
        bisectCenter: bisectCenter,
        ascending: ascending$3,
        bisector: bisector,
        count: count$1,
        cross: cross$2,
        cumsum: cumsum,
        descending: descending$2,
        deviation: deviation,
        extent: extent$1,
        Adder: Adder,
        fsum: fsum,
        fcumsum: fcumsum,
        group: group,
        flatGroup: flatGroup,
        flatRollup: flatRollup,
        groups: groups,
        index: index$4,
        indexes: indexes,
        rollup: rollup,
        rollups: rollups,
        groupSort: groupSort,
        bin: bin,
        histogram: bin,
        thresholdFreedmanDiaconis: freedmanDiaconis,
        thresholdScott: scott,
        thresholdSturges: thresholdSturges,
        max: max$3,
        maxIndex: maxIndex,
        mean: mean,
        median: median,
        merge: merge,
        min: min$2,
        minIndex: minIndex,
        mode: mode,
        nice: nice$1,
        pairs: pairs,
        permute: permute,
        quantile: quantile$1,
        quantileSorted: quantileSorted,
        quickselect: quickselect,
        range: range$2,
        least: least,
        leastIndex: leastIndex,
        greatest: greatest,
        greatestIndex: greatestIndex,
        scan: scan,
        shuffle: shuffle$1,
        shuffler: shuffler,
        sum: sum$2,
        ticks: ticks,
        tickIncrement: tickIncrement,
        tickStep: tickStep,
        transpose: transpose,
        variance: variance,
        zip: zip,
        every: every,
        some: some,
        filter: filter$1,
        map: map$1,
        reduce: reduce,
        reverse: reverse$1,
        sort: sort,
        difference: difference,
        disjoint: disjoint,
        intersection: intersection,
        subset: subset,
        superset: superset,
        union: union,
        InternMap: InternMap,
        InternSet: InternSet,
        axisTop: axisTop,
        axisRight: axisRight,
        axisBottom: axisBottom,
        axisLeft: axisLeft,
        brush: brush,
        brushX: brushX,
        brushY: brushY,
        brushSelection: brushSelection,
        chord: chord,
        chordTranspose: chordTranspose,
        chordDirected: chordDirected,
        ribbon: ribbon$1,
        ribbonArrow: ribbonArrow,
        color: color$1,
        rgb: rgb,
        hsl: hsl$2,
        lab: lab$1,
        hcl: hcl$2,
        lch: lch,
        gray: gray,
        cubehelix: cubehelix$3,
        contours: contours,
        contourDensity: density,
        Delaunay: Delaunay,
        Voronoi: Voronoi,
        dispatch: dispatch,
        drag: drag,
        dragDisable: dragDisable,
        dragEnable: yesdrag,
        dsvFormat: dsvFormat,
        csvParse: csvParse,
        csvParseRows: csvParseRows,
        csvFormat: csvFormat,
        csvFormatBody: csvFormatBody,
        csvFormatRows: csvFormatRows,
        csvFormatRow: csvFormatRow,
        csvFormatValue: csvFormatValue,
        tsvParse: tsvParse,
        tsvParseRows: tsvParseRows,
        tsvFormat: tsvFormat,
        tsvFormatBody: tsvFormatBody,
        tsvFormatRows: tsvFormatRows,
        tsvFormatRow: tsvFormatRow,
        tsvFormatValue: tsvFormatValue,
        autoType: autoType,
        easeLinear: linear$1,
        easeQuad: quadInOut,
        easeQuadIn: quadIn,
        easeQuadOut: quadOut,
        easeQuadInOut: quadInOut,
        easeCubic: cubicInOut,
        easeCubicIn: cubicIn,
        easeCubicOut: cubicOut,
        easeCubicInOut: cubicInOut,
        easePoly: polyInOut,
        easePolyIn: polyIn,
        easePolyOut: polyOut,
        easePolyInOut: polyInOut,
        easeSin: sinInOut,
        easeSinIn: sinIn,
        easeSinOut: sinOut,
        easeSinInOut: sinInOut,
        easeExp: expInOut,
        easeExpIn: expIn,
        easeExpOut: expOut,
        easeExpInOut: expInOut,
        easeCircle: circleInOut,
        easeCircleIn: circleIn,
        easeCircleOut: circleOut,
        easeCircleInOut: circleInOut,
        easeBounce: bounceOut,
        easeBounceIn: bounceIn,
        easeBounceOut: bounceOut,
        easeBounceInOut: bounceInOut,
        easeBack: backInOut,
        easeBackIn: backIn,
        easeBackOut: backOut,
        easeBackInOut: backInOut,
        easeElastic: elasticOut,
        easeElasticIn: elasticIn,
        easeElasticOut: elasticOut,
        easeElasticInOut: elasticInOut,
        blob: blob,
        buffer: buffer,
        dsv: dsv,
        csv: csv,
        tsv: tsv,
        image: image,
        json: json,
        text: text,
        xml: xml,
        html: html,
        svg: svg,
        forceCenter: center,
        forceCollide: collide,
        forceLink: link$2,
        forceManyBody: manyBody,
        forceRadial: radial$1,
        forceSimulation: simulation,
        forceX: x$1,
        forceY: y$1,
        formatDefaultLocale: defaultLocale$1,
        get format () { return format; },
        get formatPrefix () { return formatPrefix; },
        formatLocale: formatLocale$1,
        formatSpecifier: formatSpecifier,
        FormatSpecifier: FormatSpecifier,
        precisionFixed: precisionFixed,
        precisionPrefix: precisionPrefix,
        precisionRound: precisionRound,
        geoArea: area$2,
        geoBounds: bounds,
        geoCentroid: centroid$1,
        geoCircle: circle$2,
        geoClipAntimeridian: clipAntimeridian,
        geoClipCircle: clipCircle,
        geoClipExtent: extent,
        geoClipRectangle: clipRectangle,
        geoContains: contains$1,
        geoDistance: distance,
        geoGraticule: graticule,
        geoGraticule10: graticule10,
        geoInterpolate: interpolate,
        geoLength: length$1,
        geoPath: index$2,
        geoAlbers: albers,
        geoAlbersUsa: albersUsa,
        geoAzimuthalEqualArea: azimuthalEqualArea,
        geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
        geoAzimuthalEquidistant: azimuthalEquidistant,
        geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
        geoConicConformal: conicConformal,
        geoConicConformalRaw: conicConformalRaw,
        geoConicEqualArea: conicEqualArea,
        geoConicEqualAreaRaw: conicEqualAreaRaw,
        geoConicEquidistant: conicEquidistant,
        geoConicEquidistantRaw: conicEquidistantRaw,
        geoEqualEarth: equalEarth,
        geoEqualEarthRaw: equalEarthRaw,
        geoEquirectangular: equirectangular,
        geoEquirectangularRaw: equirectangularRaw,
        geoGnomonic: gnomonic,
        geoGnomonicRaw: gnomonicRaw,
        geoIdentity: identity$4,
        geoProjection: projection,
        geoProjectionMutator: projectionMutator,
        geoMercator: mercator,
        geoMercatorRaw: mercatorRaw,
        geoNaturalEarth1: naturalEarth1,
        geoNaturalEarth1Raw: naturalEarth1Raw,
        geoOrthographic: orthographic,
        geoOrthographicRaw: orthographicRaw,
        geoStereographic: stereographic,
        geoStereographicRaw: stereographicRaw,
        geoTransverseMercator: transverseMercator,
        geoTransverseMercatorRaw: transverseMercatorRaw,
        geoRotation: rotation,
        geoStream: geoStream,
        geoTransform: transform$1,
        cluster: cluster,
        hierarchy: hierarchy,
        Node: Node$1,
        pack: index$1,
        packSiblings: siblings,
        packEnclose: enclose,
        partition: partition,
        stratify: stratify,
        tree: tree,
        treemap: index,
        treemapBinary: binary,
        treemapDice: treemapDice,
        treemapSlice: treemapSlice,
        treemapSliceDice: sliceDice,
        treemapSquarify: squarify,
        treemapResquarify: resquarify,
        interpolate: interpolate$2,
        interpolateArray: array$3,
        interpolateBasis: basis$2,
        interpolateBasisClosed: basisClosed$1,
        interpolateDate: date$1,
        interpolateDiscrete: discrete,
        interpolateHue: hue,
        interpolateNumber: interpolateNumber,
        interpolateNumberArray: numberArray,
        interpolateObject: object$1,
        interpolateRound: interpolateRound,
        interpolateString: interpolateString,
        interpolateTransformCss: interpolateTransformCss,
        interpolateTransformSvg: interpolateTransformSvg,
        interpolateZoom: interpolateZoom,
        interpolateRgb: interpolateRgb,
        interpolateRgbBasis: rgbBasis,
        interpolateRgbBasisClosed: rgbBasisClosed,
        interpolateHsl: hsl$1,
        interpolateHslLong: hslLong,
        interpolateLab: lab,
        interpolateHcl: hcl$1,
        interpolateHclLong: hclLong,
        interpolateCubehelix: cubehelix$2,
        interpolateCubehelixLong: cubehelixLong,
        piecewise: piecewise,
        quantize: quantize$1,
        path: path,
        polygonArea: area$1,
        polygonCentroid: centroid,
        polygonHull: hull,
        polygonContains: contains,
        polygonLength: length,
        quadtree: quadtree,
        randomUniform: uniform,
        randomInt: int,
        randomNormal: normal,
        randomLogNormal: logNormal,
        randomBates: bates,
        randomIrwinHall: irwinHall,
        randomExponential: exponential,
        randomPareto: pareto,
        randomBernoulli: bernoulli,
        randomGeometric: geometric,
        randomBinomial: binomial,
        randomGamma: gamma,
        randomBeta: beta,
        randomWeibull: weibull,
        randomCauchy: cauchy,
        randomLogistic: logistic,
        randomPoisson: poisson,
        randomLcg: lcg,
        scaleBand: band,
        scalePoint: point$4,
        scaleIdentity: identity$2,
        scaleLinear: linear,
        scaleLog: log,
        scaleSymlog: symlog,
        scaleOrdinal: ordinal,
        scaleImplicit: implicit,
        scalePow: pow,
        scaleSqrt: sqrt$1,
        scaleRadial: radial,
        scaleQuantile: quantile,
        scaleQuantize: quantize,
        scaleThreshold: threshold,
        scaleTime: time,
        scaleUtc: utcTime,
        scaleSequential: sequential,
        scaleSequentialLog: sequentialLog,
        scaleSequentialPow: sequentialPow,
        scaleSequentialSqrt: sequentialSqrt,
        scaleSequentialSymlog: sequentialSymlog,
        scaleSequentialQuantile: sequentialQuantile,
        scaleDiverging: diverging$1,
        scaleDivergingLog: divergingLog,
        scaleDivergingPow: divergingPow,
        scaleDivergingSqrt: divergingSqrt,
        scaleDivergingSymlog: divergingSymlog,
        tickFormat: tickFormat,
        schemeCategory10: category10,
        schemeAccent: Accent,
        schemeDark2: Dark2,
        schemePaired: Paired,
        schemePastel1: Pastel1,
        schemePastel2: Pastel2,
        schemeSet1: Set1,
        schemeSet2: Set2,
        schemeSet3: Set3,
        schemeTableau10: Tableau10,
        interpolateBrBG: BrBG,
        schemeBrBG: scheme$q,
        interpolatePRGn: PRGn,
        schemePRGn: scheme$p,
        interpolatePiYG: PiYG,
        schemePiYG: scheme$o,
        interpolatePuOr: PuOr,
        schemePuOr: scheme$n,
        interpolateRdBu: RdBu,
        schemeRdBu: scheme$m,
        interpolateRdGy: RdGy,
        schemeRdGy: scheme$l,
        interpolateRdYlBu: RdYlBu,
        schemeRdYlBu: scheme$k,
        interpolateRdYlGn: RdYlGn,
        schemeRdYlGn: scheme$j,
        interpolateSpectral: Spectral,
        schemeSpectral: scheme$i,
        interpolateBuGn: BuGn,
        schemeBuGn: scheme$h,
        interpolateBuPu: BuPu,
        schemeBuPu: scheme$g,
        interpolateGnBu: GnBu,
        schemeGnBu: scheme$f,
        interpolateOrRd: OrRd,
        schemeOrRd: scheme$e,
        interpolatePuBuGn: PuBuGn,
        schemePuBuGn: scheme$d,
        interpolatePuBu: PuBu,
        schemePuBu: scheme$c,
        interpolatePuRd: PuRd,
        schemePuRd: scheme$b,
        interpolateRdPu: RdPu,
        schemeRdPu: scheme$a,
        interpolateYlGnBu: YlGnBu,
        schemeYlGnBu: scheme$9,
        interpolateYlGn: YlGn,
        schemeYlGn: scheme$8,
        interpolateYlOrBr: YlOrBr,
        schemeYlOrBr: scheme$7,
        interpolateYlOrRd: YlOrRd,
        schemeYlOrRd: scheme$6,
        interpolateBlues: Blues,
        schemeBlues: scheme$5,
        interpolateGreens: Greens,
        schemeGreens: scheme$4,
        interpolateGreys: Greys,
        schemeGreys: scheme$3,
        interpolatePurples: Purples,
        schemePurples: scheme$2,
        interpolateReds: Reds,
        schemeReds: scheme$1,
        interpolateOranges: Oranges,
        schemeOranges: scheme,
        interpolateCividis: cividis,
        interpolateCubehelixDefault: cubehelix,
        interpolateRainbow: rainbow,
        interpolateWarm: warm,
        interpolateCool: cool,
        interpolateSinebow: sinebow,
        interpolateTurbo: turbo,
        interpolateViridis: viridis,
        interpolateMagma: magma,
        interpolateInferno: inferno,
        interpolatePlasma: plasma,
        create: create$1,
        creator: creator,
        local: local$1,
        matcher: matcher,
        namespace: namespace,
        namespaces: namespaces,
        pointer: pointer,
        pointers: pointers,
        select: select,
        selectAll: selectAll,
        selection: selection,
        selector: selector,
        selectorAll: selectorAll,
        style: styleValue,
        window: defaultView,
        arc: arc,
        area: area,
        line: line,
        pie: pie,
        areaRadial: areaRadial,
        radialArea: areaRadial,
        lineRadial: lineRadial$1,
        radialLine: lineRadial$1,
        pointRadial: pointRadial,
        linkHorizontal: linkHorizontal,
        linkVertical: linkVertical,
        linkRadial: linkRadial,
        symbol: symbol,
        symbols: symbols,
        symbolCircle: circle,
        symbolCross: cross,
        symbolDiamond: diamond,
        symbolSquare: square,
        symbolStar: star,
        symbolTriangle: triangle,
        symbolWye: wye,
        curveBasisClosed: basisClosed,
        curveBasisOpen: basisOpen,
        curveBasis: basis,
        curveBumpX: bumpX,
        curveBumpY: bumpY,
        curveBundle: bundle,
        curveCardinalClosed: cardinalClosed,
        curveCardinalOpen: cardinalOpen,
        curveCardinal: cardinal,
        curveCatmullRomClosed: catmullRomClosed,
        curveCatmullRomOpen: catmullRomOpen,
        curveCatmullRom: catmullRom,
        curveLinearClosed: linearClosed,
        curveLinear: curveLinear,
        curveMonotoneX: monotoneX,
        curveMonotoneY: monotoneY,
        curveNatural: natural,
        curveStep: step,
        curveStepAfter: stepAfter,
        curveStepBefore: stepBefore,
        stack: stack,
        stackOffsetExpand: expand,
        stackOffsetDiverging: diverging,
        stackOffsetNone: none$1,
        stackOffsetSilhouette: silhouette,
        stackOffsetWiggle: wiggle,
        stackOrderAppearance: appearance,
        stackOrderAscending: ascending,
        stackOrderDescending: descending,
        stackOrderInsideOut: insideOut,
        stackOrderNone: none,
        stackOrderReverse: reverse,
        timeInterval: newInterval,
        timeMillisecond: millisecond,
        timeMilliseconds: milliseconds,
        utcMillisecond: millisecond,
        utcMilliseconds: milliseconds,
        timeSecond: second,
        timeSeconds: seconds,
        utcSecond: second,
        utcSeconds: seconds,
        timeMinute: minute,
        timeMinutes: minutes,
        timeHour: hour,
        timeHours: hours,
        timeDay: day,
        timeDays: days,
        timeWeek: sunday,
        timeWeeks: sundays,
        timeSunday: sunday,
        timeSundays: sundays,
        timeMonday: monday,
        timeMondays: mondays,
        timeTuesday: tuesday,
        timeTuesdays: tuesdays,
        timeWednesday: wednesday,
        timeWednesdays: wednesdays,
        timeThursday: thursday,
        timeThursdays: thursdays,
        timeFriday: friday,
        timeFridays: fridays,
        timeSaturday: saturday,
        timeSaturdays: saturdays,
        timeMonth: month,
        timeMonths: months,
        timeYear: year,
        timeYears: years,
        utcMinute: utcMinute,
        utcMinutes: utcMinutes,
        utcHour: utcHour,
        utcHours: utcHours,
        utcDay: utcDay,
        utcDays: utcDays,
        utcWeek: utcSunday,
        utcWeeks: utcSundays,
        utcSunday: utcSunday,
        utcSundays: utcSundays,
        utcMonday: utcMonday,
        utcMondays: utcMondays,
        utcTuesday: utcTuesday,
        utcTuesdays: utcTuesdays,
        utcWednesday: utcWednesday,
        utcWednesdays: utcWednesdays,
        utcThursday: utcThursday,
        utcThursdays: utcThursdays,
        utcFriday: utcFriday,
        utcFridays: utcFridays,
        utcSaturday: utcSaturday,
        utcSaturdays: utcSaturdays,
        utcMonth: utcMonth,
        utcMonths: utcMonths,
        utcYear: utcYear,
        utcYears: utcYears,
        utcTicks: utcTicks,
        utcTickInterval: utcTickInterval,
        timeTicks: timeTicks,
        timeTickInterval: timeTickInterval,
        timeFormatDefaultLocale: defaultLocale,
        get timeFormat () { return timeFormat; },
        get timeParse () { return timeParse; },
        get utcFormat () { return utcFormat; },
        get utcParse () { return utcParse; },
        timeFormatLocale: formatLocale,
        isoFormat: formatIso,
        isoParse: parseIso,
        now: now,
        timer: timer,
        timerFlush: timerFlush,
        timeout: timeout,
        interval: interval,
        transition: transition,
        active: active,
        interrupt: interrupt,
        zoom: zoom,
        zoomTransform: transform,
        zoomIdentity: identity,
        ZoomTransform: Transform
    });

    const STEP = 0.0125;
    // const STEP = 0.5;
    const CUT_SIZE = 2;
    const ALPHA_RANGE = 5;

    class Plot {
      constructor(context, n) {
        this.touch = 0;
        this.ctx = context; 
        this.height = this.ctx.height;
        this.width = this.ctx.width;
        this.unitToAlpha = linear().domain([0, 1]).range([-ALPHA_RANGE, ALPHA_RANGE]);
        this.n = n;
        this.kernels = [null, null];
        this.kernels[0] = new RBFKernel();
        this.kernels[1] = new RBFShuffleKernel(CUT_SIZE);
        this.active_ker = 0;

        // matrix p = row i is phi(mu_i)
        // matrix f = row i is phi(x_i)
        // pft means P F^T, ppt means P P^T
        // when mu_i = x_i, then P = F, and PF^T = FF^T = K
        this.pft = Matrix.zeros(this.n, this.n);
        this.ppt = Matrix.zeros(this.n, this.n);
        this.fft = Matrix.zeros(this.n, this.n);
        this.invpft = Matrix.zeros(this.n, this.n);
        this.curveCache = null; // cc[ci][xi] = y.  (curve_idx, x_idx)
        this.xCache = null;
        this.invertible = true;

        this.populate();

      }

      get_xrange() {
        return [this.ctx.xmin, this.ctx.xmax];
      }

      // if i is undefined, initialize the whole matrix
      // otherwise, initialize i'th row and column only
      init_metrics() {
        this.init_mat('ppt');
        this.init_mat('pft');
        this.init_mat('fft');
      }

      _init_mat(row, col, type) {
        var m = Matrix.zeros(this.n, this.n);
        for (let i = 0; i != this.n; i++) 
          for (let j = 0; j != this.n; j++)
            m[i][j] = this.kernel(row[i], col[j]); 
        this[type] = m;
      }

      _update_mat(row, col, i, type) {
        for (let j = 0; j != this.n; j++){
          this[type][i][j] = this.kernel(row[i], col[j]);
          this[type][j][i] = this.kernel(row[j], col[i]);
        }
      }

      init_mat(type, i) {
        var row, col;
        if (type == 'ppt') [row, col] = [this.mu, this.mu];
        else if (type == 'pft') [row, col] = [this.mu, this.x];
        else if (type == 'fft') [row, col] = [this.x, this.x];
        else throw `init_mat: invalid type ${type}`;

        if (i === undefined) this._init_mat(row, col, type);
        else this._update_mat(row, col, i, type);
      }

      initXCache() {
        var cuts = [this.ctx.xmin, this.ctx.xmax];
        var xs;
        for (let i = 0; i != this.n; i++)
          cuts.push(...this.jumps(this.x[i]));
        cuts.sort((a, b) => a - b);

        this.xCache = new Array(0);
        for (let s = 0; s != cuts.length - 1; s++) {
          xs = range$2(cuts[s], cuts[s+1], STEP);
          this.xCache.push(xs);
        }
      }

      initCurveCache() {
        var n = this.n;
        this.initXCache();
        this.curveCache = new Array(n);
        for (let ci = 0; ci != n; ci++) 
            this.updateCurveCache(ci);
      }

      // updates i'th curve Cache
      updateCurveCache(ci) {
        var seg;
        this.curveCache[ci] = new Array();
        for (let si = 0; si != this.xCache.length; si++) {
          seg = this.xCache[si].map(x => this.kernel(this.mu[ci], x));
          this.curveCache[ci].push(...seg);
        }
      }

      set_scramble(flag) {
        this.active_ker = flag ? 1 : 0;
        this.init_metrics();
        this.initCurveCache();
      }

      scrambled() {
        return this.active_ker == 1;
      }

      cut_size() {
        return CUT_SIZE;
      }

      resetAlpha() {
        this.alpha.fill(1);
      }

      set_sigma(log_sigma) {
        for (let k = 0; k != this.kernels.length; k++) {
          this.kernels[k].set_sigma(Math.pow(10, log_sigma));
        }
        for (let ci = 0; ci != this.n; ci++)
          this.updateCurveCache(ci);

        this.init_metrics();
      }

      recenter_mu() {
        for (let i = 0; i != this.n; i++) {
          this.mu[i] = this.x[i];
        }
        this.init_metrics();
        this.initCurveCache();
      }

      get_sigma2() {
        return this.kernels[this.active_ker].get_sigma2();
      }

      populate() {
        var n = this.n;
        this.x = new Array(n);
        this.y = new Array(n);
        this.mu = new Array(n);
        this.alpha = new Array(n); 

        for (let i = 0; i != n; i++) {
          this.x[i] = this.ctx.unitToX(Math.random());
          this.mu[i] = this.x[i];
          this.y[i] = this.ctx.unitToY(Math.random());
        }
        this.init_metrics();
        this.initCurveCache();

        /*
        for (let i = 0; i != n; i++) 
          this.y[i] = this.solutionPoint(i);
          */

        this.alpha.fill(1.0);
      }

      setDataPoint(i, u, v) {
        // update the value of the i'th data point
        this.x[i] = this.ctx.x(u);
        this.y[i] = this.ctx.y(v);
        this.init_mat('pft', i);
        this.init_mat('fft', i);
        this.updateCurveCache(i);
      }

      setMu(i, u) {
        this.mu[i] = this.ctx.x(u);
        this.init_mat('ppt', i);
        this.init_mat('pft', i);
        this.updateCurveCache(i);
      }

      kernel(x1, x2) {
        return this.kernels[this.active_ker].call(x1, x2);
      }

      jumps(x) {
        var k = this.kernels[this.active_ker];
        return k.cuts(x, this.ctx.xmin, this.ctx.xmax);
      }


      // return the solution, or if failed,
      // plot.alpha
      solutionAlpha() {
        var y = new Matrix([this.y]);
        try {
          var inv = inverse(this.pft); 
          var alpha = y.mmul(inv).flat();
          self.invertible = true;
          return alpha;

        } catch(err) {
          // console.log('could not invert.  leaving as-is');
          self.invertible = false;
          return this.alpha;
        }

      }

      _fNorm2() {
        var a = new Matrix([this.alpha]);
        return a.mmul(this.ppt).mmul(a.transpose()).flat()[0];
      }

      fNorm() {
        return Math.sqrt(this._fNorm2());
      }

      _fNormParallel2() {
        var a = new Matrix([this.alpha]);
        var b;
        try {
          var fft_inv = inverse(this.fft);
          b = a
            .mmul(this.pft)
            .mmul(fft_inv);
        } catch (err) {
          console.log(`Could not invert matrix`);
          return NaN;
        }

        var norm2 = b.mmul(this.fft).mmul(b.transpose());
        return norm2;
      }

      fNormParallel() {
        return Math.sqrt(this._fNormParallel2());
      }

      fNormPerp() {
        var fnorm2 = this._fNorm2();
        var fparnorm2 = this._fNormParallel2(); 
        var norm2 = fnorm2 - fparnorm2;
        if (norm2 > -1e-8) norm2 = Math.max(0, norm2);

        return Math.sqrt(norm2);
      }


      resize(w, h) {
        this.ctx.setWidth(w);
        this.ctx.setHeight(h);
        this.width = this.ctx.width;
        this.height = this.ctx.height;
      }

      updateContext(context) {
        this.ctx = context;
        this.height = this.ctx.height;
        this.width = this.ctx.width;
      }

      addPoint() {
        this.n++;
        this.populate();
      }

      delPoint() {
        if (this.n == 1) return;
        this.n--;
        this.populate();
      }

      updateAlpha(delta, index) {
        if (isNaN(delta + this.alpha[index])) {
          console.log(`updateAlpha got ${delta} and ${this.alpha[index]}`);
          return;
        }
        this.alpha[index] += delta;
      }

      makeLine(xs, ys) {
        var x2u = this.ctx.xToViewport;
        var [ymin, ymax] = [this.ctx.ymin, this.ctx.ymax];

        var y2v = (y) => this.ctx.yToViewport(Math.max(ymin - 1, Math.min(ymax + 1, y)));
        const path = line()(zip(xs.map(x2u), ys.map(y2v)));
        return path || '';
      }

      makeLines(ys) {
        var line = '';
        var off = 0, rng, len;
        for (let si = 0; si != this.xCache.length; si++) {
          rng = this.xCache[si];
          len = rng.length;
          line += this.makeLine(rng, ys.slice(off, off + len));
          off += len;
        }
        return line;
      }

      curve(ci) {
        var ys;
        var a = this.alpha[ci];
        var ys = this.curveCache[ci].map(y => a * y);
        return this.makeLines(ys);
      }

      solutionCurve() {
        if (this.n == 0) return '';
        var ys = new Array(this.curveCache[0].length).fill(0.0);

        for (let ci = 0; ci != this.n; ci++) {
          var a = this.alpha[ci];
          var cc = this.curveCache[ci];
          for (let xi = 0; xi != cc.length; xi++)
            ys[xi] += cc[xi] * a;
        }
        return this.makeLines(ys);
      }
      
      // return the u,v points for the i'th scaled curve
      points(i) {
        var a = this.alpha[i];
        var pts = range$2(this.n).map(j => [
          this.ctx.u(this.x[j]), 
          this.ctx.v(a * this.pft.get(i,j))
        ]);
        return pts;
      }

      data() {
        return zip(this.x, this.y).map(([x,y]) => 
          [this.ctx.u(x), this.ctx.v(y)]
        );
      }

      getMuX() {
        return zip(this.mu, this.x).map(([mu,x]) => 
          [this.ctx.u(mu), this.ctx.u(x)]
        );
      }

      // return the y value for the solution at the i'th x location
      // unused currently
      solutionPoint(i) {
        var y = range$2(this.n).map(j => this.alpha[j] * this.pft.get(i,j))
          .reduce((y1, y2) => y1 + y2, 0);
        return y;
      }


      u(x) {
        return this.ctx.u(x);
      }

      v(y) {
        return this.ctx.v(y);
      }


    }

    class Context {
      constructor(width, height, [xmin, xmax], [ymin, ymax]) {
        this.width = width;
        this.height = height;
        this.xmin = xmin;
        this.xmax = xmax;
        this.ymin = ymin;
        this.ymax = ymax;
        this.xToViewport = linear().domain([xmin, xmax]).range([0,width]);
        this.yToViewport = linear().domain([ymin, ymax]).range([height,0]);
        this.unitToX = linear().domain([0, 1]).range([xmin, xmax]);
        this.unitToY = linear().domain([0, 1]).range([ymin, ymax]);
        this.xToUnit = linear().domain([xmin, xmax]).range([0, 1]);
        // console.log(d3.scaleLinear);
      }

      setWidth(w) {
        this.width = w;
        this.xToViewport.range([0,w]);
      }

      setHeight(h) {
        this.height = h;
        this.yToViewport.range([h,0]);
      }

      x(u) {
        return this.xToViewport.invert(u);
      }

      y(v) {
        return this.yToViewport.invert(v);
      }

      u(x) {
        return this.xToViewport(x);
      }

      v(y) {
        return this.yToViewport(y);
      }

      xDomain() {
        return this.xToViewport.domain();
      }

      yDomain() {
        return this.yToViewport.domain();
      }
    }

    /* To synchronize two or more components that share data,
     * see https://svelte.dev/repl/a2e5e34a08b4491a975d523ded3b82c2?version=3.41.0
     * 
     */
    class Sync {
      constructor(sig, component_num, update_fn) {
    		component_num = parseInt(component_num);
    		if (isNaN(component_num) || component_num <= 0)
          throw `sync.js: component_num must be integer > 0, got ${component_num}`;
    		
    		this.sig = sig;
    		this.cnum = component_num;
    		this.sig.subscribe((val) => {
      		if (Math.abs(val) != this.cnum) {
    	  		// console.log(`updating component ${this.cnum}`)
      	  	update_fn();
    		  }    
    		});
    	}
    	
    	notify() {
    		// console.log(`notify from component ${this.cnum}`);
    		this.sig.update(n => {
      		var sign = Math.sign(n) || 1;
          return -sign * this.cnum;
    		});
    	}
    }

    /* src/Curves.svelte generated by Svelte v3.40.2 */

    const { console: console_1 } = globals;
    const file$9 = "src/Curves.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i][0];
    	child_ctx[18] = list[i][1];
    	child_ctx[20] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i][0];
    	child_ctx[18] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i][0];
    	child_ctx[26] = list[i][1];
    	child_ctx[20] = i;
    	return child_ctx;
    }

    // (126:2) {#each plot.getMuX() as [mu,x], i}
    function create_each_block_3$1(ctx) {
    	let use;
    	let use_x_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			use = svg_element("use");
    			attr_dev(use, "class", "marker draggable svelte-cs9siv");
    			attr_dev(use, "id", "mu" + /*i*/ ctx[20]);
    			attr_dev(use, "x", use_x_value = /*mu*/ ctx[25]);
    			attr_dev(use, "y", "0");
    			xlink_attr(use, "xlink:href", "#mu-select");
    			add_location(use, file$9, 126, 4, 3271);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, use, anchor);

    			if (!mounted) {
    				dispose = listen_dev(use, "mousedown", /*onMouseDown*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && use_x_value !== (use_x_value = /*mu*/ ctx[25])) {
    				attr_dev(use, "x", use_x_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(use);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(126:2) {#each plot.getMuX() as [mu,x], i}",
    		ctx
    	});

    	return block;
    }

    // (134:4) {#if cfg.curves}
    function create_if_block_3(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "curve svelte-cs9siv");
    			attr_dev(path, "d", path_d_value = /*plot*/ ctx[1].curve(/*i*/ ctx[20]));
    			add_location(path, file$9, 134, 6, 3486);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && path_d_value !== (path_d_value = /*plot*/ ctx[1].curve(/*i*/ ctx[20]))) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(134:4) {#if cfg.curves}",
    		ctx
    	});

    	return block;
    }

    // (138:4) {#if cfg.points}
    function create_if_block_2(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*plot*/ ctx[1].points(/*i*/ ctx[20]);
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot, range*/ 2) {
    				each_value_2 = /*plot*/ ctx[1].points(/*i*/ ctx[20]);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(138:4) {#if cfg.points}",
    		ctx
    	});

    	return block;
    }

    // (139:6) {#each plot.points(i) as [u,v]}
    function create_each_block_2$1(ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "point svelte-cs9siv");
    			attr_dev(circle, "cx", circle_cx_value = /*u*/ ctx[17]);
    			attr_dev(circle, "cy", circle_cy_value = /*v*/ ctx[18]);
    			attr_dev(circle, "r", "4");
    			add_location(circle, file$9, 139, 8, 3606);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && circle_cx_value !== (circle_cx_value = /*u*/ ctx[17])) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty & /*plot*/ 2 && circle_cy_value !== (circle_cy_value = /*v*/ ctx[18])) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(139:6) {#each plot.points(i) as [u,v]}",
    		ctx
    	});

    	return block;
    }

    // (133:2) {#each range(plot.n) as i}
    function create_each_block_1$2(ctx) {
    	let if_block0_anchor;
    	let if_block1_anchor;
    	let if_block0 = /*cfg*/ ctx[0].curves && create_if_block_3(ctx);
    	let if_block1 = /*cfg*/ ctx[0].points && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, if_block0_anchor, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*cfg*/ ctx[0].curves) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*cfg*/ ctx[0].points) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(if_block0_anchor);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(133:2) {#each range(plot.n) as i}",
    		ctx
    	});

    	return block;
    }

    // (145:2) {#if cfg.solution}
    function create_if_block_1(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "solution-curve svelte-cs9siv");
    			attr_dev(path, "d", path_d_value = /*plot*/ ctx[1].solutionCurve());
    			add_location(path, file$9, 145, 4, 3714);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && path_d_value !== (path_d_value = /*plot*/ ctx[1].solutionCurve())) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(145:2) {#if cfg.solution}",
    		ctx
    	});

    	return block;
    }

    // (149:2) {#if cfg.show_data}
    function create_if_block$3(ctx) {
    	let each_1_anchor;
    	let each_value = /*plot*/ ctx[1].data();
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot, onMouseDown*/ 34) {
    				each_value = /*plot*/ ctx[1].data();
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(149:2) {#if cfg.show_data}",
    		ctx
    	});

    	return block;
    }

    // (150:4) {#each plot.data() as [u,v], i}
    function create_each_block$5(ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "id", "xy" + /*i*/ ctx[20]);
    			attr_dev(circle, "class", "marker draggable svelte-cs9siv");
    			attr_dev(circle, "cx", circle_cx_value = /*u*/ ctx[17]);
    			attr_dev(circle, "cy", circle_cy_value = /*v*/ ctx[18]);
    			attr_dev(circle, "r", "5");
    			add_location(circle, file$9, 150, 6, 3845);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);

    			if (!mounted) {
    				dispose = listen_dev(circle, "mousedown", /*onMouseDown*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && circle_cx_value !== (circle_cx_value = /*u*/ ctx[17])) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty & /*plot*/ 2 && circle_cy_value !== (circle_cy_value = /*v*/ ctx[18])) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(150:4) {#each plot.data() as [u,v], i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let div;
    	let div_class_value;
    	let div_resize_listener;
    	let t;
    	let svg;
    	let defs;
    	let polygon;
    	let each0_anchor;
    	let each1_anchor;
    	let if_block0_anchor;
    	let svg_class_value;
    	let mounted;
    	let dispose;
    	let each_value_3 = /*plot*/ ctx[1].getMuX();
    	validate_each_argument(each_value_3);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_1[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	let each_value_1 = range$2(/*plot*/ ctx[1].n);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	let if_block0 = /*cfg*/ ctx[0].solution && create_if_block_1(ctx);
    	let if_block1 = /*cfg*/ ctx[0].show_data && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			polygon = svg_element("polygon");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			each0_anchor = empty$3();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each1_anchor = empty$3();
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", div_class_value = "framed " + /*gridarea*/ ctx[2] + " z3" + " svelte-cs9siv");
    			add_render_callback(() => /*div_elementresize_handler*/ ctx[10].call(div));
    			add_location(div, file$9, 117, 0, 2969);
    			attr_dev(polygon, "id", "mu-select");
    			attr_dev(polygon, "points", "-6,0 6,0 0,12");
    			add_location(polygon, file$9, 123, 5, 3168);
    			add_location(defs, file$9, 122, 5, 3156);
    			attr_dev(svg, "class", svg_class_value = "framed " + /*gridarea*/ ctx[2] + " svelte-cs9siv");
    			add_location(svg, file$9, 118, 0, 3053);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[10].bind(div));
    			insert_dev(target, t, anchor);
    			insert_dev(target, svg, anchor);
    			append_dev(svg, defs);
    			append_dev(defs, polygon);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(svg, null);
    			}

    			append_dev(svg, each0_anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svg, null);
    			}

    			append_dev(svg, each1_anchor);
    			if (if_block0) if_block0.m(svg, null);
    			append_dev(svg, if_block0_anchor);
    			if (if_block1) if_block1.m(svg, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "mousemove", /*onMouseMove*/ ctx[6], false, false, false),
    					listen_dev(svg, "mouseup", /*onMouseUp*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*gridarea*/ 4 && div_class_value !== (div_class_value = "framed " + /*gridarea*/ ctx[2] + " z3" + " svelte-cs9siv")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*plot, onMouseDown*/ 34) {
    				each_value_3 = /*plot*/ ctx[1].getMuX();
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_3$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(svg, each0_anchor);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_3.length;
    			}

    			if (dirty & /*plot, range, cfg*/ 3) {
    				each_value_1 = range$2(/*plot*/ ctx[1].n);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(svg, each1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*cfg*/ ctx[0].solution) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					if_block0.m(svg, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*cfg*/ ctx[0].show_data) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$3(ctx);
    					if_block1.c();
    					if_block1.m(svg, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*gridarea*/ 4 && svg_class_value !== (svg_class_value = "framed " + /*gridarea*/ ctx[2] + " svelte-cs9siv")) {
    				attr_dev(svg, "class", svg_class_value);
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			div_resize_listener();
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(svg);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Curves', slots, []);

    	let { sig } = $$props,
    		{ cfg } = $$props,
    		{ plot } = $$props,
    		{ cn } = $$props,
    		{ gridarea } = $$props;

    	let w = 0, h = 0;
    	let drag_point = null;
    	let s, mounted = false;

    	function solve(do_solve, msg) {
    		console.log(`in solve: ${msg}, do_solve=${do_solve}`);
    		if (!do_solve) return;
    		const NSTEPS = 50;
    		var start_alpha = plot.alpha;
    		var end_alpha = plot.solutionAlpha();
    		console.log(`in solve: ${end_alpha}`);

    		function transition(step, nsteps) {
    			if (step == nsteps) {
    				$$invalidate(1, plot.alpha = end_alpha, plot);
    			} else {
    				var delta = step / nsteps;

    				for (let i = 0; i != plot.n; i++) {
    					$$invalidate(1, plot.alpha[i] = delta * end_alpha[i] + (1 - delta) * start_alpha[i], plot);
    				}
    			}

    			s.notify();

    			if (step != nsteps) {
    				setTimeout(() => transition(step + 1, nsteps), 10);
    			}
    		}

    		transition(0, NSTEPS);
    	}

    	function update() {
    		if (!mounted) return;
    		var cmd = cfg.cmd;

    		// console.log(cfg);
    		if (cmd == null) throw 'got null cfg.cmd in Curves update';

    		if (cmd == 'reset_alpha') plot.resetAlpha();
    		if (cmd == 'del_point') plot.delPoint();
    		if (cmd == 'add_point') plot.addPoint();
    		if (cmd == 'new_data') plot.populate();
    		if (cmd == 'auto_solve') solve(cfg.auto_solve);
    		if (cmd == 'mu_tracks_x' && cfg.mu_tracks_x) plot.recenter_mu();
    		if (cmd == 'scramble') plot.set_scramble(cfg.scramble);
    		if (cmd == 'set_sigma') plot.set_sigma(cfg.log_sigma);

    		if (cmd.match(/update_alpha/)) ; else if (cmd == 'set_sigma' || cmd == 'mu_xy_changed') {
    			if (cfg.auto_solve) $$invalidate(1, plot.alpha = plot.solutionAlpha(), plot); // do nothing
    		} else if (cmd != 'reset_alpha') {
    			solve(cfg.auto_solve);
    		}

    		$$invalidate(1, plot.touch++, plot);
    		$$invalidate(0, cfg.cmd = null, cfg);
    		s.notify();
    	}

    	function resize(width, height) {
    		if (!mounted) return;

    		// console.log(`in resize with ${width} x ${height}`);
    		plot.resize(width, height);

    		$$invalidate(1, plot.touch++, plot);
    	}

    	onMount(() => {
    		s = new Sync(sig, cn, update);
    		mounted = true;
    		resize(w, h);
    	});

    	function onMouseDown(evt) {
    		drag_point = evt.target;
    	}

    	function onMouseMove(evt) {
    		if (drag_point == null) return;
    		var g = drag_point.id.match(/(?<code>\D+)(?<num>\d+)/).groups;

    		if (g.code == 'mu') plot.setMu(g.num, evt.offsetX); else if (g.code == 'xy') {
    			plot.setDataPoint(g.num, evt.offsetX, evt.offsetY);
    			if (cfg.mu_tracks_x) plot.setMu(g.num, evt.offsetX);
    		}

    		$$invalidate(0, cfg.cmd = 'mu_xy_changed', cfg);
    		update();
    	} // s.notify();

    	function onMouseUp(evt) {
    		drag_point = null;
    	}

    	const writable_props = ['sig', 'cfg', 'plot', 'cn', 'gridarea'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Curves> was created with unknown prop '${key}'`);
    	});

    	function div_elementresize_handler() {
    		w = this.clientWidth;
    		h = this.clientHeight;
    		$$invalidate(3, w);
    		$$invalidate(4, h);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('gridarea' in $$props) $$invalidate(2, gridarea = $$props.gridarea);
    	};

    	$$self.$capture_state = () => ({
    		Sync,
    		range: range$2,
    		onMount,
    		sig,
    		cfg,
    		plot,
    		cn,
    		gridarea,
    		w,
    		h,
    		drag_point,
    		s,
    		mounted,
    		solve,
    		update,
    		resize,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('gridarea' in $$props) $$invalidate(2, gridarea = $$props.gridarea);
    		if ('w' in $$props) $$invalidate(3, w = $$props.w);
    		if ('h' in $$props) $$invalidate(4, h = $$props.h);
    		if ('drag_point' in $$props) drag_point = $$props.drag_point;
    		if ('s' in $$props) s = $$props.s;
    		if ('mounted' in $$props) mounted = $$props.mounted;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*w, h*/ 24) {
    			resize(w, h);
    		}
    	};

    	return [
    		cfg,
    		plot,
    		gridarea,
    		w,
    		h,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp,
    		sig,
    		cn,
    		div_elementresize_handler
    	];
    }

    class Curves extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			sig: 8,
    			cfg: 0,
    			plot: 1,
    			cn: 9,
    			gridarea: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Curves",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[8] === undefined && !('sig' in props)) {
    			console_1.warn("<Curves> was created without expected prop 'sig'");
    		}

    		if (/*cfg*/ ctx[0] === undefined && !('cfg' in props)) {
    			console_1.warn("<Curves> was created without expected prop 'cfg'");
    		}

    		if (/*plot*/ ctx[1] === undefined && !('plot' in props)) {
    			console_1.warn("<Curves> was created without expected prop 'plot'");
    		}

    		if (/*cn*/ ctx[9] === undefined && !('cn' in props)) {
    			console_1.warn("<Curves> was created without expected prop 'cn'");
    		}

    		if (/*gridarea*/ ctx[2] === undefined && !('gridarea' in props)) {
    			console_1.warn("<Curves> was created without expected prop 'gridarea'");
    		}
    	}

    	get sig() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cfg() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cfg(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gridarea() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gridarea(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // accept single number or array
    // return single number or array
    function numberDisplay(nums) {
      var fn = (n) => 
        Math.abs(n) > 1000 || Math.abs(n) < 1e-2 ? n.toExponential(2) : n.toFixed(2);
      if (nums instanceof Array) return nums.map(fn);
      else return fn(nums);
    }

    /* src/LowPanelControls.svelte generated by Svelte v3.40.2 */
    const file$8 = "src/LowPanelControls.svelte";

    function create_fragment$8(ctx) {
    	let div7;
    	let div0;
    	let d_math0;
    	let raw0_value = `\\|f\\| = ` + "";
    	let t0;

    	let t1_value = (/*plot*/ ctx[1].invertible
    	? numberDisplay(/*plot*/ ctx[1].fNorm())
    	: 'Could not solve') + "";

    	let t1;
    	let t2;
    	let div1;
    	let d_math1;
    	let raw1_value = `\\|f_\\parallel\\| = ` + "";
    	let t3;

    	let t4_value = (/*plot*/ ctx[1].invertible
    	? numberDisplay(/*plot*/ ctx[1].fNormParallel())
    	: 'Could not solve') + "";

    	let t4;
    	let t5;
    	let div2;
    	let d_math2;
    	let raw2_value = `\\|f_\\perp\\| = ` + "";
    	let t6;

    	let t7_value = (/*plot*/ ctx[1].invertible
    	? numberDisplay(/*plot*/ ctx[1].fNormPerp())
    	: 'Could not solve') + "";

    	let t7;
    	let t8;
    	let div3;
    	let label0;
    	let input0;
    	let t9;
    	let t10;
    	let div4;
    	let label1;
    	let input1;
    	let t11;
    	let d_math3;
    	let raw3_value = `\\mu` + "";
    	let t12;
    	let d_math4;
    	let raw4_value = `x` + "";
    	let t13;
    	let div5;
    	let label2;
    	let input2;
    	let t14;
    	let t15;
    	let div6;
    	let label3;
    	let d_math5;
    	let raw5_value = `\\sigma` + "";
    	let t16;
    	let input3;
    	let t17;
    	let t18_value = numberDisplay(Math.pow(10, /*cfg*/ ctx[0].log_sigma)) + "";
    	let t18;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div0 = element("div");
    			d_math0 = element("d-math");
    			t0 = space();
    			t1 = text$1(t1_value);
    			t2 = space();
    			div1 = element("div");
    			d_math1 = element("d-math");
    			t3 = space();
    			t4 = text$1(t4_value);
    			t5 = space();
    			div2 = element("div");
    			d_math2 = element("d-math");
    			t6 = space();
    			t7 = text$1(t7_value);
    			t8 = space();
    			div3 = element("div");
    			label0 = element("label");
    			input0 = element("input");
    			t9 = text$1("\n      auto solve");
    			t10 = space();
    			div4 = element("div");
    			label1 = element("label");
    			input1 = element("input");
    			t11 = space();
    			d_math3 = element("d-math");
    			t12 = text$1(" tracks ");
    			d_math4 = element("d-math");
    			t13 = space();
    			div5 = element("div");
    			label2 = element("label");
    			input2 = element("input");
    			t14 = text$1("\n      scramble");
    			t15 = space();
    			div6 = element("div");
    			label3 = element("label");
    			d_math5 = element("d-math");
    			t16 = text$1(": \n      ");
    			input3 = element("input");
    			t17 = space();
    			t18 = text$1(t18_value);
    			add_location(d_math0, file$8, 24, 4, 355);
    			attr_dev(div0, "class", "col1 line svelte-h0ylfy");
    			add_location(div0, file$8, 23, 2, 327);
    			add_location(d_math1, file$8, 28, 4, 505);
    			attr_dev(div1, "class", "col2 line svelte-h0ylfy");
    			add_location(div1, file$8, 27, 2, 477);
    			add_location(d_math2, file$8, 32, 4, 679);
    			attr_dev(div2, "class", "col2 row2 line svelte-h0ylfy");
    			add_location(div2, file$8, 31, 2, 646);
    			attr_dev(input0, "id", "auto_solve");
    			attr_dev(input0, "type", "checkbox");
    			add_location(input0, file$8, 37, 6, 870);
    			attr_dev(label0, "class", "ib");
    			add_location(label0, file$8, 36, 4, 845);
    			attr_dev(div3, "class", "col4 row1 line svelte-h0ylfy");
    			add_location(div3, file$8, 35, 2, 812);
    			attr_dev(input1, "id", "mu_tracks_x");
    			attr_dev(input1, "type", "checkbox");
    			add_location(input1, file$8, 46, 6, 1094);
    			add_location(d_math3, file$8, 50, 6, 1226);
    			add_location(d_math4, file$8, 50, 45, 1265);
    			attr_dev(label1, "class", "ib");
    			add_location(label1, file$8, 45, 4, 1069);
    			attr_dev(div4, "class", "col4 row2 line svelte-h0ylfy");
    			add_location(div4, file$8, 44, 2, 1036);
    			attr_dev(input2, "id", "scramble");
    			attr_dev(input2, "type", "checkbox");
    			add_location(input2, file$8, 55, 6, 1376);
    			attr_dev(label2, "class", "ib");
    			add_location(label2, file$8, 54, 4, 1351);
    			attr_dev(div5, "class", "col5 row1 line svelte-h0ylfy");
    			add_location(div5, file$8, 53, 2, 1318);
    			add_location(d_math5, file$8, 63, 22, 1586);
    			attr_dev(input3, "id", "set_sigma");
    			attr_dev(input3, "class", "short svelte-h0ylfy");
    			attr_dev(input3, "type", "range");
    			attr_dev(input3, "min", "-5");
    			attr_dev(input3, "max", "2");
    			attr_dev(input3, "step", "0.01");
    			add_location(input3, file$8, 64, 6, 1629);
    			attr_dev(label3, "class", "ib");
    			add_location(label3, file$8, 63, 4, 1568);
    			attr_dev(div6, "class", "col5 row2 line svelte-h0ylfy");
    			add_location(div6, file$8, 62, 2, 1535);
    			attr_dev(div7, "class", "gb gi svelte-h0ylfy");
    			add_location(div7, file$8, 22, 0, 305);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div0);
    			append_dev(div0, d_math0);
    			d_math0.innerHTML = raw0_value;
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div7, t2);
    			append_dev(div7, div1);
    			append_dev(div1, d_math1);
    			d_math1.innerHTML = raw1_value;
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			append_dev(div7, t5);
    			append_dev(div7, div2);
    			append_dev(div2, d_math2);
    			d_math2.innerHTML = raw2_value;
    			append_dev(div2, t6);
    			append_dev(div2, t7);
    			append_dev(div7, t8);
    			append_dev(div7, div3);
    			append_dev(div3, label0);
    			append_dev(label0, input0);
    			input0.checked = /*cfg*/ ctx[0].auto_solve;
    			append_dev(label0, t9);
    			append_dev(div7, t10);
    			append_dev(div7, div4);
    			append_dev(div4, label1);
    			append_dev(label1, input1);
    			input1.checked = /*cfg*/ ctx[0].mu_tracks_x;
    			append_dev(label1, t11);
    			append_dev(label1, d_math3);
    			d_math3.innerHTML = raw3_value;
    			append_dev(label1, t12);
    			append_dev(label1, d_math4);
    			d_math4.innerHTML = raw4_value;
    			append_dev(div7, t13);
    			append_dev(div7, div5);
    			append_dev(div5, label2);
    			append_dev(label2, input2);
    			input2.checked = /*cfg*/ ctx[0].scramble;
    			append_dev(label2, t14);
    			append_dev(div7, t15);
    			append_dev(div7, div6);
    			append_dev(div6, label3);
    			append_dev(label3, d_math5);
    			d_math5.innerHTML = raw5_value;
    			append_dev(label3, t16);
    			append_dev(label3, input3);
    			set_input_value(input3, /*cfg*/ ctx[0].log_sigma);
    			append_dev(label3, t17);
    			append_dev(label3, t18);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[5]),
    					listen_dev(input0, "change", /*h*/ ctx[2], false, false, false),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[6]),
    					listen_dev(input1, "change", /*h*/ ctx[2], false, false, false),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[7]),
    					listen_dev(input2, "change", /*h*/ ctx[2], false, false, false),
    					listen_dev(input3, "change", /*input3_change_input_handler*/ ctx[8]),
    					listen_dev(input3, "input", /*input3_change_input_handler*/ ctx[8]),
    					listen_dev(input3, "input", /*h*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*plot*/ 2 && t1_value !== (t1_value = (/*plot*/ ctx[1].invertible
    			? numberDisplay(/*plot*/ ctx[1].fNorm())
    			: 'Could not solve') + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*plot*/ 2 && t4_value !== (t4_value = (/*plot*/ ctx[1].invertible
    			? numberDisplay(/*plot*/ ctx[1].fNormParallel())
    			: 'Could not solve') + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*plot*/ 2 && t7_value !== (t7_value = (/*plot*/ ctx[1].invertible
    			? numberDisplay(/*plot*/ ctx[1].fNormPerp())
    			: 'Could not solve') + "")) set_data_dev(t7, t7_value);

    			if (dirty & /*cfg*/ 1) {
    				input0.checked = /*cfg*/ ctx[0].auto_solve;
    			}

    			if (dirty & /*cfg*/ 1) {
    				input1.checked = /*cfg*/ ctx[0].mu_tracks_x;
    			}

    			if (dirty & /*cfg*/ 1) {
    				input2.checked = /*cfg*/ ctx[0].scramble;
    			}

    			if (dirty & /*cfg*/ 1) {
    				set_input_value(input3, /*cfg*/ ctx[0].log_sigma);
    			}

    			if (dirty & /*cfg*/ 1 && t18_value !== (t18_value = numberDisplay(Math.pow(10, /*cfg*/ ctx[0].log_sigma)) + "")) set_data_dev(t18, t18_value);
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LowPanelControls', slots, []);
    	let { sig } = $$props, { cn } = $$props, { cfg } = $$props, { plot } = $$props;

    	function update() {
    		$$invalidate(1, plot.touch++, plot);
    	}

    	var s = new Sync(sig, cn, update);

    	// catch-all event handler
    	function h(e) {
    		$$invalidate(0, cfg.cmd = e.target.id, cfg);
    		update();
    		s.notify();
    	}

    	const writable_props = ['sig', 'cn', 'cfg', 'plot'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LowPanelControls> was created with unknown prop '${key}'`);
    	});

    	function input0_change_handler() {
    		cfg.auto_solve = this.checked;
    		$$invalidate(0, cfg);
    	}

    	function input1_change_handler() {
    		cfg.mu_tracks_x = this.checked;
    		$$invalidate(0, cfg);
    	}

    	function input2_change_handler() {
    		cfg.scramble = this.checked;
    		$$invalidate(0, cfg);
    	}

    	function input3_change_input_handler() {
    		cfg.log_sigma = to_number(this.value);
    		$$invalidate(0, cfg);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(4, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    	};

    	$$self.$capture_state = () => ({
    		Sync,
    		numberDisplay,
    		sig,
    		cn,
    		cfg,
    		plot,
    		update,
    		s,
    		h
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(4, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    		if ('s' in $$props) s = $$props.s;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		cfg,
    		plot,
    		h,
    		sig,
    		cn,
    		input0_change_handler,
    		input1_change_handler,
    		input2_change_handler,
    		input3_change_input_handler
    	];
    }

    class LowPanelControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, { sig: 3, cn: 4, cfg: 0, plot: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LowPanelControls",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[3] === undefined && !('sig' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'sig'");
    		}

    		if (/*cn*/ ctx[4] === undefined && !('cn' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'cn'");
    		}

    		if (/*cfg*/ ctx[0] === undefined && !('cfg' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'cfg'");
    		}

    		if (/*plot*/ ctx[1] === undefined && !('plot' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'plot'");
    		}
    	}

    	get sig() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cfg() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cfg(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/SliderControls.svelte generated by Svelte v3.40.2 */
    const file$7 = "src/SliderControls.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[9] = list;
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (23:2) {#each plot.alpha as a, i}
    function create_each_block$4(ctx) {
    	let div1;
    	let label;
    	let d_math;
    	let html_tag;
    	let raw_value = '\\alpha_' + "";
    	let t0;
    	let t1;
    	let input;
    	let t2;
    	let div0;
    	let t3_value = numberDisplay(/*a*/ ctx[8]) + "";
    	let t3;
    	let mounted;
    	let dispose;

    	function input_change_input_handler() {
    		/*input_change_input_handler*/ ctx[5].call(input, /*each_value*/ ctx[9], /*i*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			label = element("label");
    			d_math = element("d-math");
    			html_tag = new HtmlTag();
    			t0 = text$1(/*i*/ ctx[10]);
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			div0 = element("div");
    			t3 = text$1(t3_value);
    			html_tag.a = t0;
    			set_custom_element_data(d_math, "plain", "");
    			add_location(d_math, file$7, 24, 24, 394);
    			attr_dev(input, "id", "update_alpha" + /*i*/ ctx[10]);
    			attr_dev(input, "class", "ib slider svelte-n9jner");
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "-10");
    			attr_dev(input, "max", "10");
    			attr_dev(input, "step", "0.01");
    			add_location(input, file$7, 25, 8, 447);
    			attr_dev(div0, "class", "ib svelte-n9jner");
    			add_location(div0, file$7, 31, 6, 639);
    			attr_dev(label, "class", "ib svelte-n9jner");
    			add_location(label, file$7, 24, 6, 376);
    			attr_dev(div1, "class", "alpha svelte-n9jner");
    			add_location(div1, file$7, 23, 4, 350);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label);
    			append_dev(label, d_math);
    			html_tag.m(raw_value, d_math);
    			append_dev(d_math, t0);
    			append_dev(label, t1);
    			append_dev(label, input);
    			set_input_value(input, /*a*/ ctx[8]);
    			append_dev(label, t2);
    			append_dev(label, div0);
    			append_dev(div0, t3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", input_change_input_handler),
    					listen_dev(input, "input", input_change_input_handler),
    					listen_dev(input, "input", /*h*/ ctx[1], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*plot*/ 1) {
    				set_input_value(input, /*a*/ ctx[8]);
    			}

    			if (dirty & /*plot*/ 1 && t3_value !== (t3_value = numberDisplay(/*a*/ ctx[8]) + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(23:2) {#each plot.alpha as a, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div;
    	let t0;
    	let button0;
    	let t2;
    	let button1;
    	let t3;
    	let d_math;
    	let raw_value = `\\alpha` + "";
    	let t4;
    	let button2;
    	let t6;
    	let button3;
    	let mounted;
    	let dispose;
    	let each_value = /*plot*/ ctx[0].alpha;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			button0 = element("button");
    			button0.textContent = "New Data";
    			t2 = space();
    			button1 = element("button");
    			t3 = text$1("Reset ");
    			d_math = element("d-math");
    			t4 = space();
    			button2 = element("button");
    			button2.textContent = "Del Point";
    			t6 = space();
    			button3 = element("button");
    			button3.textContent = "Add Point";
    			attr_dev(button0, "id", "new_data");
    			add_location(button0, file$7, 35, 2, 718);
    			add_location(d_math, file$7, 36, 46, 817);
    			attr_dev(button1, "id", "reset_alpha");
    			add_location(button1, file$7, 36, 2, 773);
    			attr_dev(button2, "id", "del_point");
    			add_location(button2, file$7, 37, 2, 863);
    			attr_dev(button3, "id", "add_point");
    			add_location(button3, file$7, 38, 2, 920);
    			attr_dev(div, "class", "gb svelte-n9jner");
    			add_location(div, file$7, 21, 0, 300);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t0);
    			append_dev(div, button0);
    			append_dev(div, t2);
    			append_dev(div, button1);
    			append_dev(button1, t3);
    			append_dev(button1, d_math);
    			d_math.innerHTML = raw_value;
    			append_dev(div, t4);
    			append_dev(div, button2);
    			append_dev(div, t6);
    			append_dev(div, button3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*h*/ ctx[1], false, false, false),
    					listen_dev(button1, "click", /*h*/ ctx[1], false, false, false),
    					listen_dev(button2, "click", /*h*/ ctx[1], false, false, false),
    					listen_dev(button3, "click", /*h*/ ctx[1], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*numberDisplay, plot, h*/ 3) {
    				each_value = /*plot*/ ctx[0].alpha;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, t0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SliderControls', slots, []);
    	let { sig } = $$props, { cn } = $$props, { cfg } = $$props, { plot } = $$props;

    	function update() {
    		$$invalidate(0, plot.touch++, plot);
    	}

    	var s = new Sync(sig, cn, update);

    	// generic handler
    	function h(evt) {
    		$$invalidate(2, cfg.cmd = evt.target.id, cfg);
    		s.notify();
    		update();
    	}

    	const writable_props = ['sig', 'cn', 'cfg', 'plot'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SliderControls> was created with unknown prop '${key}'`);
    	});

    	function input_change_input_handler(each_value, i) {
    		each_value[i] = to_number(this.value);
    		$$invalidate(0, plot);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(4, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(2, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    	};

    	$$self.$capture_state = () => ({
    		Sync,
    		numberDisplay,
    		sig,
    		cn,
    		cfg,
    		plot,
    		update,
    		s,
    		h
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(4, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(2, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('s' in $$props) s = $$props.s;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [plot, h, cfg, sig, cn, input_change_input_handler];
    }

    class SliderControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$7, create_fragment$7, safe_not_equal, { sig: 3, cn: 4, cfg: 2, plot: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliderControls",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[3] === undefined && !('sig' in props)) {
    			console.warn("<SliderControls> was created without expected prop 'sig'");
    		}

    		if (/*cn*/ ctx[4] === undefined && !('cn' in props)) {
    			console.warn("<SliderControls> was created without expected prop 'cn'");
    		}

    		if (/*cfg*/ ctx[2] === undefined && !('cfg' in props)) {
    			console.warn("<SliderControls> was created without expected prop 'cfg'");
    		}

    		if (/*plot*/ ctx[0] === undefined && !('plot' in props)) {
    			console.warn("<SliderControls> was created without expected prop 'plot'");
    		}
    	}

    	get sig() {
    		throw new Error("<SliderControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<SliderControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<SliderControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<SliderControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cfg() {
    		throw new Error("<SliderControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cfg(value) {
    		throw new Error("<SliderControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<SliderControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<SliderControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var win;

    if (typeof window !== "undefined") {
        win = window;
    } else if (typeof commonjsGlobal !== "undefined") {
        win = commonjsGlobal;
    } else if (typeof self !== "undefined"){
        win = self;
    } else {
        win = {};
    }

    var window_1 = win;

    var isFunction_1 = isFunction;

    var toString = Object.prototype.toString;

    function isFunction (fn) {
      if (!fn) {
        return false
      }
      var string = toString.call(fn);
      return string === '[object Function]' ||
        (typeof fn === 'function' && string !== '[object RegExp]') ||
        (typeof window !== 'undefined' &&
         // IE8 and below
         (fn === window.setTimeout ||
          fn === window.alert ||
          fn === window.confirm ||
          fn === window.prompt))
    }

    var trim = function(string) {
      return string.replace(/^\s+|\s+$/g, '');
    }
      , isArray = function(arg) {
          return Object.prototype.toString.call(arg) === '[object Array]';
        };

    var parseHeaders = function (headers) {
      if (!headers)
        return {}

      var result = {};

      var headersArr = trim(headers).split('\n');

      for (var i = 0; i < headersArr.length; i++) {
        var row = headersArr[i];
        var index = row.indexOf(':')
        , key = trim(row.slice(0, index)).toLowerCase()
        , value = trim(row.slice(index + 1));

        if (typeof(result[key]) === 'undefined') {
          result[key] = value;
        } else if (isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [ result[key], value ];
        }
      }

      return result
    };

    var immutable = extend;

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function extend() {
        var target = {};

        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target
    }

    var xhr = createXHR;
    // Allow use of default import syntax in TypeScript
    var _default = createXHR;
    createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop;
    createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window_1.XDomainRequest;

    forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
        createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
            options = initParams(uri, options, callback);
            options.method = method.toUpperCase();
            return _createXHR(options)
        };
    });

    function forEachArray(array, iterator) {
        for (var i = 0; i < array.length; i++) {
            iterator(array[i]);
        }
    }

    function isEmpty(obj){
        for(var i in obj){
            if(obj.hasOwnProperty(i)) return false
        }
        return true
    }

    function initParams(uri, options, callback) {
        var params = uri;

        if (isFunction_1(options)) {
            callback = options;
            if (typeof uri === "string") {
                params = {uri:uri};
            }
        } else {
            params = immutable(options, {uri: uri});
        }

        params.callback = callback;
        return params
    }

    function createXHR(uri, options, callback) {
        options = initParams(uri, options, callback);
        return _createXHR(options)
    }

    function _createXHR(options) {
        if(typeof options.callback === "undefined"){
            throw new Error("callback argument missing")
        }

        var called = false;
        var callback = function cbOnce(err, response, body){
            if(!called){
                called = true;
                options.callback(err, response, body);
            }
        };

        function readystatechange() {
            if (xhr.readyState === 4) {
                setTimeout(loadFunc, 0);
            }
        }

        function getBody() {
            // Chrome with requestType=blob throws errors arround when even testing access to responseText
            var body = undefined;

            if (xhr.response) {
                body = xhr.response;
            } else {
                body = xhr.responseText || getXml(xhr);
            }

            if (isJson) {
                try {
                    body = JSON.parse(body);
                } catch (e) {}
            }

            return body
        }

        function errorFunc(evt) {
            clearTimeout(timeoutTimer);
            if(!(evt instanceof Error)){
                evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") );
            }
            evt.statusCode = 0;
            return callback(evt, failureResponse)
        }

        // will load the data & process the response in a special response object
        function loadFunc() {
            if (aborted) return
            var status;
            clearTimeout(timeoutTimer);
            if(options.useXDR && xhr.status===undefined) {
                //IE8 CORS GET successful response doesn't have a status field, but body is fine
                status = 200;
            } else {
                status = (xhr.status === 1223 ? 204 : xhr.status);
            }
            var response = failureResponse;
            var err = null;

            if (status !== 0){
                response = {
                    body: getBody(),
                    statusCode: status,
                    method: method,
                    headers: {},
                    url: uri,
                    rawRequest: xhr
                };
                if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                    response.headers = parseHeaders(xhr.getAllResponseHeaders());
                }
            } else {
                err = new Error("Internal XMLHttpRequest Error");
            }
            return callback(err, response, response.body)
        }

        var xhr = options.xhr || null;

        if (!xhr) {
            if (options.cors || options.useXDR) {
                xhr = new createXHR.XDomainRequest();
            }else {
                xhr = new createXHR.XMLHttpRequest();
            }
        }

        var key;
        var aborted;
        var uri = xhr.url = options.uri || options.url;
        var method = xhr.method = options.method || "GET";
        var body = options.body || options.data;
        var headers = xhr.headers = options.headers || {};
        var sync = !!options.sync;
        var isJson = false;
        var timeoutTimer;
        var failureResponse = {
            body: undefined,
            headers: {},
            statusCode: 0,
            method: method,
            url: uri,
            rawRequest: xhr
        };

        if ("json" in options && options.json !== false) {
            isJson = true;
            headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json"); //Don't override existing accept header declared by user
            if (method !== "GET" && method !== "HEAD") {
                headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"); //Don't override existing accept header declared by user
                body = JSON.stringify(options.json === true ? body : options.json);
            }
        }

        xhr.onreadystatechange = readystatechange;
        xhr.onload = loadFunc;
        xhr.onerror = errorFunc;
        // IE9 must have onprogress be set to a unique function.
        xhr.onprogress = function () {
            // IE must die
        };
        xhr.onabort = function(){
            aborted = true;
        };
        xhr.ontimeout = errorFunc;
        xhr.open(method, uri, !sync, options.username, options.password);
        //has to be after open
        if(!sync) {
            xhr.withCredentials = !!options.withCredentials;
        }
        // Cannot set timeout with sync request
        // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
        // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
        if (!sync && options.timeout > 0 ) {
            timeoutTimer = setTimeout(function(){
                if (aborted) return
                aborted = true;//IE9 may still call readystatechange
                xhr.abort("timeout");
                var e = new Error("XMLHttpRequest timeout");
                e.code = "ETIMEDOUT";
                errorFunc(e);
            }, options.timeout );
        }

        if (xhr.setRequestHeader) {
            for(key in headers){
                if(headers.hasOwnProperty(key)){
                    xhr.setRequestHeader(key, headers[key]);
                }
            }
        } else if (options.headers && !isEmpty(options.headers)) {
            throw new Error("Headers cannot be set on an XDomainRequest object")
        }

        if ("responseType" in options) {
            xhr.responseType = options.responseType;
        }

        if ("beforeSend" in options &&
            typeof options.beforeSend === "function"
        ) {
            options.beforeSend(xhr);
        }

        // Microsoft Edge browser sends "undefined" when send is called with undefined value.
        // XMLHttpRequest spec says to pass null as body to indicate no body
        // See https://github.com/naugtur/xhr/issues/100.
        xhr.send(body || null);

        return xhr


    }

    function getXml(xhr) {
        // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
        // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
        try {
            if (xhr.responseType === "document") {
                return xhr.responseXML
            }
            var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
            if (xhr.responseType === "" && !firefoxBugTakenEffect) {
                return xhr.responseXML
            }
        } catch (e) {}

        return null
    }

    function noop() {}
    xhr.default = _default;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };





    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();









































    var toConsumableArray = function (arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      } else {
        return Array.from(arr);
      }
    };

    var lastError = '';

    /**
     * Creates the HTLM for a failure message
     * @param {string} canvasContainerId id of container of th
     *        canvas.
     * @return {string} The html.
     */
    function makeFailHTML(msg) {
        return '\n<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>\n<td align="center">\n<div style="display: table-cell; vertical-align: middle;">\n<div style="">' + msg + '</div>\n</div>\n</td></tr></table>\n';
    }

    /**
     * Message for getting a webgl browser
     * @type {string}
     */
    var GET_A_WEBGL_BROWSER = '\n\tThis page requires a browser that supports WebGL.<br/>\n\t<a href="http://get.webgl.org">Click here to upgrade your browser.</a>\n';

    /**
     * Message for need better hardware
     * @type {string}
     */
    var OTHER_PROBLEM = '\n\tIt does not appear your computer can support WebGL.<br/>\n\t<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>\n';

    /**
     * Code to return in `onError` callback when the browser doesn't support webgl
     * @type {number}
     */
    var ERROR_BROWSER_SUPPORT = 1;

    /**
     * Code to return in `onError` callback there's any other problem related to webgl
     * @type {number}
     */
    var ERROR_OTHER = 2;

    /**
     * Creates a webgl context. If creation fails it will
     * change the contents of the container of the <canvas>
     * tag to an error message with the correct links for WebGL,
     * unless `onError` option is defined to a callback,
     * which allows for custom error handling..
     * @param {Element} canvas. The canvas element to create a
     *     context from.
     * @param {WebGLContextCreationAttributes} optAttribs Any
     *     creation attributes you want to pass in.
     * @return {WebGLRenderingContext} The created context.
     */
    function setupWebGL(canvas, optAttribs, onError) {
        function showLink(str) {
            var container = canvas.parentNode;
            if (container) {
                container.innerHTML = makeFailHTML(str);
            }
        }

        function handleError(errorCode, msg) {
            if (typeof onError === 'function') {
                onError(errorCode);
            } else {
                showLink(msg);
            }
        }

        if (!window.WebGLRenderingContext) {
            handleError(ERROR_BROWSER_SUPPORT, GET_A_WEBGL_BROWSER);
            return null;
        }

        var context = create3DContext(canvas, optAttribs);
        if (!context) {
            handleError(ERROR_OTHER, OTHER_PROBLEM);
        } else {
            context.getExtension('OES_standard_derivatives');
        }
        return context;
    }

    /**
     * Creates a webgl context.
     * @param {!Canvas} canvas The canvas tag to get context
     *     from. If one is not passed in one will be created.
     * @return {!WebGLContext} The created context.
     */
    function create3DContext(canvas, optAttribs) {
        var names = ['webgl', 'experimental-webgl'];
        var context = null;
        for (var ii = 0; ii < names.length; ++ii) {
            try {
                context = canvas.getContext(names[ii], optAttribs);
            } catch (e) {
                if (context) {
                    break;
                }
            }
        }
        return context;
    }

    /*
     *	Create a Vertex of a specific type (gl.VERTEX_SHADER/)
     */
    function createShader(main, source, type, offset) {
        var gl = main.gl;

        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

        if (!compiled) {
            // Something went wrong during compilation; get the error
            lastError = gl.getShaderInfoLog(shader);
            console.error('*** Error compiling shader ' + shader + ':' + lastError);
            main.trigger('error', {
                shader: shader,
                source: source,
                type: type,
                error: lastError,
                offset: offset || 0
            });
            gl.deleteShader(shader);
            return null;
        }

        return shader;
    }

    /**
     * Loads a shader.
     * @param {!WebGLContext} gl The WebGLContext to use.
     * @param {string} shaderSource The shader source.
     * @param {number} shaderType The type of shader.
     * @param {function(string): void) opt_errorCallback callback for errors.
     * @return {!WebGLShader} The created shader.
     */
    function createProgram(main, shaders, optAttribs, optLocations) {
        var gl = main.gl;

        var program = gl.createProgram();
        for (var ii = 0; ii < shaders.length; ++ii) {
            gl.attachShader(program, shaders[ii]);
        }
        if (optAttribs) {
            for (var _ii = 0; _ii < optAttribs.length; ++_ii) {
                gl.bindAttribLocation(program, optLocations ? optLocations[_ii] : _ii, optAttribs[_ii]);
            }
        }
        gl.linkProgram(program);

        // Check the link status
        var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!linked) {
            // something went wrong with the link
            lastError = gl.getProgramInfoLog(program);
            console.log('Error in program linking:' + lastError);
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    // By Brett Camber on
    // https://github.com/tangrams/tangram/blob/master/src/gl/glsl.js
    function parseUniforms(uniforms) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var parsed = [];

        for (var name in uniforms) {
            var uniform = uniforms[name];
            var u = void 0;

            if (prefix) {
                name = prefix + '.' + name;
            }

            // Single float
            if (typeof uniform === 'number') {
                parsed.push({
                    type: 'float',
                    method: '1f',
                    name: name,
                    value: uniform
                });
            }
            // Array: vector, array of floats, array of textures, or array of structs
            else if (Array.isArray(uniform)) {
                    // Numeric values
                    if (typeof uniform[0] === 'number') {
                        // float vectors (vec2, vec3, vec4)
                        if (uniform.length === 1) {
                            parsed.push({
                                type: 'float',
                                method: '1f',
                                name: name,
                                value: uniform
                            });
                        }
                        // float vectors (vec2, vec3, vec4)
                        else if (uniform.length >= 2 && uniform.length <= 4) {
                                parsed.push({
                                    type: 'vec' + uniform.length,
                                    method: uniform.length + 'fv',
                                    name: name,
                                    value: uniform
                                });
                            }
                            // float array
                            else if (uniform.length > 4) {
                                    parsed.push({
                                        type: 'float[]',
                                        method: '1fv',
                                        name: name + '[0]',
                                        value: uniform
                                    });
                                }
                        // TODO: assume matrix for (typeof == Float32Array && length == 16)?
                    }
                    // Array of textures
                    else if (typeof uniform[0] === 'string') {
                            parsed.push({
                                type: 'sampler2D',
                                method: '1i',
                                name: name,
                                value: uniform
                            });
                        }
                        // Array of arrays - but only arrays of vectors are allowed in this case
                        else if (Array.isArray(uniform[0]) && typeof uniform[0][0] === 'number') {
                                // float vectors (vec2, vec3, vec4)
                                if (uniform[0].length >= 2 && uniform[0].length <= 4) {
                                    // Set each vector in the array
                                    for (u = 0; u < uniform.length; u++) {
                                        parsed.push({
                                            type: 'vec' + uniform[0].length,
                                            method: uniform[u].length + 'fv',
                                            name: name + '[' + u + ']',
                                            value: uniform[u]
                                        });
                                    }
                                }
                                // else error?
                            }
                            // Array of structures
                            else if (_typeof(uniform[0]) === 'object') {
                                    for (u = 0; u < uniform.length; u++) {
                                        // Set each struct in the array
                                        parsed.push.apply(parsed, toConsumableArray(parseUniforms(uniform[u], name + '[' + u + ']')));
                                    }
                                }
                }
                // Boolean
                else if (typeof uniform === 'boolean') {
                        parsed.push({
                            type: 'bool',
                            method: '1i',
                            name: name,
                            value: uniform
                        });
                    }
                    // Texture
                    else if (typeof uniform === 'string') {
                            parsed.push({
                                type: 'sampler2D',
                                method: '1i',
                                name: name,
                                value: uniform
                            });
                        }
                        // Structure
                        else if ((typeof uniform === 'undefined' ? 'undefined' : _typeof(uniform)) === 'object') {
                                // Set each field in the struct
                                parsed.push.apply(parsed, toConsumableArray(parseUniforms(uniform, name)));
                            }
            // TODO: support other non-float types? (int, etc.)
        }
        return parsed;
    }

    function isCanvasVisible(canvas) {
        return canvas.getBoundingClientRect().top + canvas.height > 0 && canvas.getBoundingClientRect().top < (window.innerHeight || document.documentElement.clientHeight);
    }

    function isPowerOf2(value) {
        return (value & value - 1) === 0;
    }

    function isSafari() {
        return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        );
    }







    function isDiff(a, b) {
        if (a && b) {
            return a.toString() !== b.toString();
        }
        return false;
    }

    function subscribeMixin$1(target) {
        var listeners = new Set();

        return Object.assign(target, {
            on: function on(type, f) {
                var listener = {};
                listener[type] = f;
                listeners.add(listener);
            },
            off: function off(type, f) {
                if (f) {
                    var listener = {};
                    listener[type] = f;
                    listeners.delete(listener);
                } else {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var item = _step.value;
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = Object.keys(item)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var key = _step2.value;

                                    if (key === type) {
                                        listeners.delete(item);
                                        return;
                                    }
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                        _iterator2.return();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
            },
            listSubscriptions: function listSubscriptions() {
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = listeners[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var item = _step3.value;

                        console.log(item);
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
            },
            subscribe: function subscribe(listener) {
                listeners.add(listener);
            },
            unsubscribe: function unsubscribe(listener) {
                listeners.delete(listener);
            },
            unsubscribeAll: function unsubscribeAll() {
                listeners.clear();
            },
            trigger: function trigger(event) {
                for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    data[_key - 1] = arguments[_key];
                }

                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = listeners[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var listener = _step4.value;

                        if (typeof listener[event] === 'function') {
                            listener[event].apply(listener, toConsumableArray(data));
                        }
                    }
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }
            }
        });
    }

    // Texture management
    var Texture = function () {
        function Texture(gl, name) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            classCallCheck(this, Texture);

            subscribeMixin$1(this);

            this.gl = gl;
            this.texture = gl.createTexture();
            if (this.texture) {
                this.valid = true;
            }
            this.bind();

            this.name = name;
            this.source = null;
            this.sourceType = null;
            this.loading = null; // a Promise object to track the loading state of this texture

            // Default to a 1-pixel black texture so we can safely render while we wait for an image to load
            // See: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
            this.setData(1, 1, new Uint8Array([0, 0, 0, 255]), { filtering: 'linear' });
            this.setFiltering(options.filtering);

            this.load(options);
        }

        // Destroy a single texture instance


        createClass(Texture, [{
            key: 'destroy',
            value: function destroy() {
                if (!this.valid) {
                    return;
                }
                this.gl.deleteTexture(this.texture);
                this.texture = null;
                delete this.data;
                this.data = null;
                this.valid = false;
            }
        }, {
            key: 'bind',
            value: function bind(unit) {
                if (!this.valid) {
                    return;
                }
                if (typeof unit === 'number') {
                    if (Texture.activeUnit !== unit) {
                        this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                        Texture.activeUnit = unit;
                    }
                }
                if (Texture.activeTexture !== this.texture) {
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                    Texture.activeTexture = this.texture;
                }
            }
        }, {
            key: 'load',
            value: function load() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                this.loading = null;

                if (typeof options.url === 'string') {
                    if (this.url === undefined || options.url !== this.url) {
                        this.setUrl(options.url, options);
                    }
                } else if (options.element) {
                    this.setElement(options.element, options);
                } else if (options.data && options.width && options.height) {
                    this.setData(options.width, options.height, options.data, options);
                }
            }

            // Sets texture from an url

        }, {
            key: 'setUrl',
            value: function setUrl(url) {
                var _this = this;

                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                if (!this.valid) {
                    return;
                }

                this.url = url; // save URL reference (will be overwritten when element is loaded below)
                this.source = this.url;
                this.sourceType = 'url';

                this.loading = new Promise(function (resolve, reject) {
                    var ext = url.split('.').pop().toLowerCase();
                    var isVideo = ext === 'ogv' || ext === 'webm' || ext === 'mp4';

                    var element = undefined;
                    if (isVideo) {
                        element = document.createElement('video');
                        element.autoplay = true;
                        options.filtering = 'nearest';
                        // element.preload = 'auto';
                        // element.style.display = 'none';
                        // document.body.appendChild(element);
                    } else {
                        element = new Image();
                    }

                    element.onload = function () {
                        try {
                            _this.setElement(element, options);
                        } catch (e) {
                            console.log('Texture \'' + _this.name + '\': failed to load url: \'' + _this.source + '\'', e, options);
                        }
                        resolve(_this);
                    };
                    element.onerror = function (e) {
                        // Warn and resolve on error
                        console.log('Texture \'' + _this.name + '\': failed to load url: \'' + _this.source + '\'', e, options);
                        resolve(_this);
                    };

                    // Safari has a bug loading data-URL elements with CORS enabled, so it must be disabled in that case
                    // https://bugs.webkit.org/show_bug.cgi?id=123978
                    if (!(isSafari() && _this.source.slice(0, 5) === 'data:')) {
                        element.crossOrigin = 'anonymous';
                    }

                    element.src = _this.source;
                    if (isVideo) {
                        _this.setElement(element, options);
                    }
                });
                return this.loading;
            }

            // Sets texture to a raw image buffer

        }, {
            key: 'setData',
            value: function setData(width, height, data) {
                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

                this.width = width;
                this.height = height;

                this.source = data;
                this.sourceType = 'data';

                this.update(options);
                this.setFiltering(options);

                this.loading = Promise.resolve(this);
                return this.loading;
            }

            // Sets the texture to track a element (canvas/image)

        }, {
            key: 'setElement',
            value: function setElement(element, options) {
                var _this2 = this;

                var el = element;

                // a string element is interpeted as a CSS selector
                if (typeof element === 'string') {
                    element = document.querySelector(element);
                }

                if (element instanceof HTMLCanvasElement || element instanceof HTMLImageElement || element instanceof HTMLVideoElement) {
                    this.source = element;
                    this.sourceType = 'element';

                    if (element instanceof HTMLVideoElement) {
                        element.addEventListener('canplaythrough', function () {
                            _this2.intervalID = setInterval(function () {
                                _this2.update(options);
                            }, 15);
                        }, true);
                        element.addEventListener('ended', function () {
                            element.currentTime = 0;
                            element.play();
                        }, true);
                    } else {
                        this.update(options);
                    }
                    this.setFiltering(options);
                } else {
                    var msg = 'the \'element\' parameter (`element: ' + JSON.stringify(el) + '`) must be a CSS ';
                    msg += 'selector string, or a <canvas>, <image> or <video> object';
                    console.log('Texture \'' + this.name + '\': ' + msg, options);
                }

                this.loading = Promise.resolve(this);
                return this.loading;
            }

            // Uploads current image or buffer to the GPU (can be used to update animated textures on the fly)

        }, {
            key: 'update',
            value: function update() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (!this.valid) {
                    return;
                }

                this.bind();
                this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, options.UNPACK_FLIP_Y_WEBGL === false ? false : true);
                this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.UNPACK_PREMULTIPLY_ALPHA_WEBGL || false);

                // Image or Canvas element
                if (this.sourceType === 'element' && (this.source instanceof HTMLCanvasElement || this.source instanceof HTMLVideoElement || this.source instanceof HTMLImageElement && this.source.complete)) {
                    if (this.source instanceof HTMLVideoElement) {
                        this.width = this.source.videoWidth;
                        this.height = this.source.videoHeight;
                    } else {
                        this.width = this.source.width;
                        this.height = this.source.height;
                    }
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.source);
                }
                // Raw image buffer
                else if (this.sourceType === 'data') {
                        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.source);
                    }
                this.trigger('loaded', this);
            }

            // Determines appropriate filtering mode

        }, {
            key: 'setFiltering',
            value: function setFiltering() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (!this.valid) {
                    return;
                }

                this.powerOf2 = isPowerOf2(this.width) && isPowerOf2(this.height);
                var defualtFilter = this.powerOf2 ? 'mipmap' : 'linear';
                this.filtering = options.filtering || defualtFilter;

                var gl = this.gl;
                this.bind();

                // For power-of-2 textures, the following presets are available:
                // mipmap: linear blend from nearest mip
                // linear: linear blend from original image (no mips)
                // nearest: nearest pixel from original image (no mips, 'blocky' look)
                if (this.powerOf2) {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);

                    if (this.filtering === 'mipmap') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR); // TODO: use trilinear filtering by defualt instead?
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else if (this.filtering === 'linear') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    } else if (this.filtering === 'nearest') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    }
                } else {
                    // WebGL has strict requirements on non-power-of-2 textures:
                    // No mipmaps and must clamp to edge
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    if (this.filtering === 'mipmap') {
                        this.filtering = 'linear';
                    }

                    if (this.filtering === 'nearest') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    } else {
                        // default to linear for non-power-of-2 textures
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    }
                }
            }
        }]);
        return Texture;
    }();

    // Report max texture size for a GL context


    Texture.getMaxTextureSize = function (gl) {
        return gl.getParameter(gl.MAX_TEXTURE_SIZE);
    };

    // Global set of textures, by name
    Texture.activeUnit = -1;

    /*
    The MIT License (MIT)

    Copyright (c) 2015 Patricio Gonzalez Vivo ( http://www.patriciogonzalezvivo.com )

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the 'Software'), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
    the Software, and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */

    var GlslCanvas = function () {
        function GlslCanvas(canvas, contextOptions, options) {
            var _this = this;

            classCallCheck(this, GlslCanvas);

            subscribeMixin$1(this);

            contextOptions = contextOptions || {};
            options = options || {};

            this.width = canvas.clientWidth;
            this.height = canvas.clientHeight;

            this.canvas = canvas;
            this.gl = undefined;
            this.program = undefined;
            this.textures = {};
            this.buffers = {};
            this.uniforms = {};
            this.vbo = {};
            this.isValid = false;

            this.BUFFER_COUNT = 0;
            // this.TEXTURE_COUNT = 0;

            this.vertexString = contextOptions.vertexString || '\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nattribute vec2 a_position;\nattribute vec2 a_texcoord;\n\nvarying vec2 v_texcoord;\n\nvoid main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    v_texcoord = a_texcoord;\n}\n';
            this.fragmentString = contextOptions.fragmentString || '\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvarying vec2 v_texcoord;\n\nvoid main(){\n    gl_FragColor = vec4(0.0);\n}\n';

            // GL Context
            var gl = setupWebGL(canvas, contextOptions, options.onError);
            if (!gl) {
                return;
            }
            this.gl = gl;
            this.timeLoad = this.timePrev = performance.now();
            this.timeDelta = 0.0;
            this.forceRender = true;
            this.paused = false;
            this.realToCSSPixels = window.devicePixelRatio || 1;

            // Allow alpha
            canvas.style.backgroundColor = contextOptions.backgroundColor || 'rgba(1,1,1,0)';

            // Load shader
            if (canvas.hasAttribute('data-fragment')) {
                this.fragmentString = canvas.getAttribute('data-fragment');
            } else if (canvas.hasAttribute('data-fragment-url')) {
                var source = canvas.getAttribute('data-fragment-url');
                xhr.get(source, function (error, response, body) {
                    _this.load(body, _this.vertexString);
                });
            }

            // Load shader
            if (canvas.hasAttribute('data-vertex')) {
                this.vertexString = canvas.getAttribute('data-vertex');
            } else if (canvas.hasAttribute('data-vertex-url')) {
                var _source = canvas.getAttribute('data-vertex-url');
                xhr.get(_source, function (error, response, body) {
                    _this.load(_this.fragmentString, body);
                });
            }

            this.load();

            if (!this.program) {
                return;
            }

            // Define Vertex buffer
            var texCoordsLoc = gl.getAttribLocation(this.program, 'a_texcoord');
            this.vbo.texCoords = gl.createBuffer();
            this.gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.texCoords);
            this.gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
            this.gl.enableVertexAttribArray(texCoordsLoc);
            this.gl.vertexAttribPointer(texCoordsLoc, 2, gl.FLOAT, false, 0, 0);

            var verticesLoc = gl.getAttribLocation(this.program, 'a_position');
            this.vbo.vertices = gl.createBuffer();
            this.gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.vertices);
            this.gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]), gl.STATIC_DRAW);
            this.gl.enableVertexAttribArray(verticesLoc);
            this.gl.vertexAttribPointer(verticesLoc, 2, gl.FLOAT, false, 0, 0);

            // load TEXTURES
            if (canvas.hasAttribute('data-textures')) {
                var imgList = canvas.getAttribute('data-textures').split(',');
                for (var nImg in imgList) {
                    this.setUniform('u_tex' + nImg, imgList[nImg]);
                }
            }

            // ========================== EVENTS
            var mouse = {
                x: 0,
                y: 0
            };
            document.addEventListener('mousemove', function (e) {
                mouse.x = e.clientX || e.pageX;
                mouse.y = e.clientY || e.pageY;
            }, false);

            var sandbox = this;
            function RenderLoop() {
                if (sandbox.nMouse > 1) {
                    sandbox.setMouse(mouse);
                }

                if (sandbox.resize()) {
                    sandbox.forceRender = true;
                }

                sandbox.render();
                window.requestAnimationFrame(RenderLoop);
            }

            // Start
            this.setMouse({ x: 0, y: 0 });
            RenderLoop();
            return this;
        }

        createClass(GlslCanvas, [{
            key: 'destroy',
            value: function destroy() {
                this.animated = false;
                this.isValid = false;
                for (var tex in this.textures) {
                    if (tex.destroy) {
                        tex.destroy();
                    }
                }
                this.textures = {};
                for (var att in this.attribs) {
                    this.gl.deleteBuffer(this.attribs[att]);
                }
                this.gl.useProgram(null);
                this.gl.deleteProgram(this.program);
                for (var key in this.buffers) {
                    var buffer = this.buffers[key];
                    this.gl.deleteProgram(buffer.program);
                }
                this.program = null;
                this.gl = null;
            }
        }, {
            key: 'load',
            value: function load(fragString, vertString) {

                // Load vertex shader if there is one
                if (vertString) {
                    this.vertexString = vertString;
                }

                // Load fragment shader if there is one
                if (fragString) {
                    this.fragmentString = fragString;
                }

                this.animated = false;
                this.nDelta = (this.fragmentString.match(/u_delta/g) || []).length;
                this.nTime = (this.fragmentString.match(/u_time/g) || []).length;
                this.nDate = (this.fragmentString.match(/u_date/g) || []).length;
                this.nMouse = (this.fragmentString.match(/u_mouse/g) || []).length;
                this.animated = this.nDate > 1 || this.nTime > 1 || this.nMouse > 1;

                var nTextures = this.fragmentString.search(/sampler2D/g);
                if (nTextures) {
                    var lines = this.fragmentString.split('\n');
                    for (var i = 0; i < lines.length; i++) {
                        var match = lines[i].match(/uniform\s*sampler2D\s*([\w]*);\s*\/\/\s*([\w|\:\/\/|\.|\-|\_]*)/i);
                        if (match) {
                            var ext = match[2].split('.').pop().toLowerCase();
                            if (match[1] && match[2] && (ext === 'jpg' || ext === 'jpeg' || ext === 'png' || ext === 'ogv' || ext === 'webm' || ext === 'mp4')) {
                                this.setUniform(match[1], match[2]);
                            }
                        }
                        var main = lines[i].match(/\s*void\s*main\s*/g);
                        if (main) {
                            break;
                        }
                    }
                }

                var vertexShader = createShader(this, this.vertexString, this.gl.VERTEX_SHADER);
                var fragmentShader = createShader(this, this.fragmentString, this.gl.FRAGMENT_SHADER);

                // If Fragment shader fails load a empty one to sign the error
                if (!fragmentShader) {
                    fragmentShader = createShader(this, 'void main(){\n\tgl_FragColor = vec4(1.0);\n}', this.gl.FRAGMENT_SHADER);
                    this.isValid = false;
                } else {
                    this.isValid = true;
                }

                // Create and use program
                var program = createProgram(this, [vertexShader, fragmentShader]); //, [0,1],['a_texcoord','a_position']);
                this.gl.useProgram(program);

                // Delete shaders
                // this.gl.detachShader(program, vertexShader);
                // this.gl.detachShader(program, fragmentShader);
                this.gl.deleteShader(vertexShader);
                this.gl.deleteShader(fragmentShader);

                this.program = program;
                this.change = true;

                this.BUFFER_COUNT = 0;
                var buffers = this.getBuffers(this.fragmentString);
                if (Object.keys(buffers).length) {
                    this.loadPrograms(buffers);
                }
                this.buffers = buffers;
                this.texureIndex = this.BUFFER_COUNT;

                // Trigger event
                this.trigger('load', {});

                this.forceRender = true;
                this.render();
            }
        }, {
            key: 'test',
            value: function test(callback, fragString, vertString) {
                // Thanks to @thespite for the help here
                // https://www.khronos.org/registry/webgl/extensions/EXT_disjoint_timer_query/
                var pre_test_vert = this.vertexString;
                var pre_test_frag = this.fragmentString;
                var pre_test_paused = this.paused;

                var ext = this.gl.getExtension('EXT_disjoint_timer_query');
                var query = ext.createQueryEXT();
                var wasValid = this.isValid;

                if (fragString || vertString) {
                    this.load(fragString, vertString);
                    wasValid = this.isValid;
                    this.forceRender = true;
                    this.render();
                }

                this.paused = true;
                ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
                this.forceRender = true;
                this.render();
                ext.endQueryEXT(ext.TIME_ELAPSED_EXT);

                var sandbox = this;
                function finishTest() {
                    // Revert changes... go back to normal
                    sandbox.paused = pre_test_paused;
                    if (fragString || vertString) {
                        sandbox.load(pre_test_frag, pre_test_vert);
                    }
                }
                function waitForTest() {
                    sandbox.forceRender = true;
                    sandbox.render();
                    var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
                    var disjoint = sandbox.gl.getParameter(ext.GPU_DISJOINT_EXT);
                    if (available && !disjoint) {
                        var ret = {
                            wasValid: wasValid,
                            frag: fragString || sandbox.fragmentString,
                            vert: vertString || sandbox.vertexString,
                            timeElapsedMs: ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT) / 1000000.0
                        };
                        finishTest();
                        callback(ret);
                    } else {
                        window.requestAnimationFrame(waitForTest);
                    }
                }
                waitForTest();
            }
        }, {
            key: 'loadTexture',
            value: function loadTexture(name, urlElementOrData, options) {
                var _this2 = this;

                if (!options) {
                    options = {};
                }

                if (typeof urlElementOrData === 'string') {
                    options.url = urlElementOrData;
                } else if ((typeof urlElementOrData === 'undefined' ? 'undefined' : _typeof(urlElementOrData)) === 'object' && urlElementOrData.data && urlElementOrData.width && urlElementOrData.height) {
                    options.data = urlElementOrData.data;
                    options.width = urlElementOrData.width;
                    options.height = urlElementOrData.height;
                } else if ((typeof urlElementOrData === 'undefined' ? 'undefined' : _typeof(urlElementOrData)) === 'object') {
                    options.element = urlElementOrData;
                }

                if (this.textures[name]) {
                    if (this.textures[name]) {
                        this.textures[name].load(options);
                        this.textures[name].on('loaded', function (args) {
                            _this2.forceRender = true;
                        });
                    }
                } else {
                    this.textures[name] = new Texture(this.gl, name, options);
                    this.textures[name].on('loaded', function (args) {
                        _this2.forceRender = true;
                    });
                }
            }
        }, {
            key: 'refreshUniforms',
            value: function refreshUniforms() {
                this.uniforms = {};
            }
        }, {
            key: 'setUniform',
            value: function setUniform(name) {
                var u = {};

                for (var _len = arguments.length, value = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    value[_key - 1] = arguments[_key];
                }

                u[name] = value;
                this.setUniforms(u);
            }
        }, {
            key: 'setUniforms',
            value: function setUniforms(uniforms) {
                var parsed = parseUniforms(uniforms);
                // Set each uniform
                for (var u in parsed) {
                    if (parsed[u].type === 'sampler2D') {
                        // For textures, we need to track texture units, so we have a special setter
                        // this.uniformTexture(parsed[u].name, parsed[u].value[0]);
                        this.loadTexture(parsed[u].name, parsed[u].value[0]);
                    } else {
                        this.uniform(parsed[u].method, parsed[u].type, parsed[u].name, parsed[u].value);
                    }
                }
                this.forceRender = true;
            }
        }, {
            key: 'setMouse',
            value: function setMouse(mouse) {
                // set the mouse uniform
                var rect = this.canvas.getBoundingClientRect();
                if (mouse && mouse.x && mouse.x >= rect.left && mouse.x <= rect.right && mouse.y && mouse.y >= rect.top && mouse.y <= rect.bottom) {

                    var mouse_x = (mouse.x - rect.left) * this.realToCSSPixels;
                    var mouse_y = this.canvas.height - (mouse.y - rect.top) * this.realToCSSPixels;

                    this.uniform('2f', 'vec2', 'u_mouse', mouse_x, mouse_y);
                }
            }

            // ex: program.uniform('3f', 'position', x, y, z);

        }, {
            key: 'uniform',
            value: function uniform(method, type, name) {
                // 'value' is a method-appropriate arguments list
                this.uniforms[name] = this.uniforms[name] || {};
                var uniform = this.uniforms[name];

                for (var _len2 = arguments.length, value = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
                    value[_key2 - 3] = arguments[_key2];
                }

                var change = isDiff(uniform.value, value);

                // remember and keep track of uniforms location to save calls
                if (change || this.change || !uniform.location || !uniform.value) {
                    uniform.name = name;
                    uniform.type = type;
                    uniform.value = value;
                    uniform.method = 'uniform' + method;
                    this.gl.useProgram(this.program);
                    uniform.location = this.gl.getUniformLocation(this.program, name);
                    this.gl[uniform.method].apply(this.gl, [uniform.location].concat(uniform.value));
                    // If there is change update and there is buffer update manually one by one
                    for (var key in this.buffers) {
                        var buffer = this.buffers[key];
                        this.gl.useProgram(buffer.program);
                        var location = this.gl.getUniformLocation(buffer.program, name);
                        this.gl[uniform.method].apply(this.gl, [location].concat(uniform.value));
                    }
                }
            }
        }, {
            key: 'uniformTexture',
            value: function uniformTexture(name, texture, options) {
                if (this.textures[name] === undefined) {
                    this.loadTexture(name, texture, options);
                } else {
                    this.uniform('1i', 'sampler2D', name, this.texureIndex);

                    for (var key in this.buffers) {
                        var buffer = this.buffers[key];
                        this.gl.useProgram(buffer.program);
                        this.gl.activeTexture(this.gl.TEXTURE0 + this.texureIndex);
                        this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[name].texture);
                    }
                    this.gl.useProgram(this.program);
                    this.gl.activeTexture(this.gl.TEXTURE0 + this.texureIndex);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[name].texture);
                    this.uniform('2f', 'vec2', name + 'Resolution', this.textures[name].width, this.textures[name].height);
                }
            }
        }, {
            key: 'resize',
            value: function resize() {
                if (this.width !== this.canvas.clientWidth || this.height !== this.canvas.clientHeight) {
                    this.realToCSSPixels = window.devicePixelRatio || 1;

                    // Lookup the size the browser is displaying the canvas in CSS pixels
                    // and compute a size needed to make our drawingbuffer match it in
                    // device pixels.
                    var displayWidth = Math.floor(this.gl.canvas.clientWidth * this.realToCSSPixels);
                    var displayHeight = Math.floor(this.gl.canvas.clientHeight * this.realToCSSPixels);

                    // Check if the canvas is not the same size.
                    if (this.gl.canvas.width !== displayWidth || this.gl.canvas.height !== displayHeight) {
                        // Make the canvas the same size
                        this.gl.canvas.width = displayWidth;
                        this.gl.canvas.height = displayHeight;
                        // Set the viewport to match
                        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
                    }
                    this.width = this.canvas.clientWidth;
                    this.height = this.canvas.clientHeight;
                    this.resizeSwappableBuffers();
                    return true;
                } else {
                    return false;
                }
            }
        }, {
            key: 'render',
            value: function render() {
                this.visible = isCanvasVisible(this.canvas);
                if (this.forceRender || this.change || this.animated && this.visible && !this.paused) {

                    // Update Uniforms when are need
                    var date = new Date();
                    var now = performance.now();
                    this.timeDelta = (now - this.timePrev) / 1000.0;
                    this.timePrev = now;
                    if (this.nDelta > 1) {
                        // set the delta time uniform
                        this.uniform('1f', 'float', 'u_delta', this.timeDelta);
                    }

                    if (this.nTime > 1) {
                        // set the elapsed time uniform
                        this.uniform('1f', 'float', 'u_time', (now - this.timeLoad) / 1000.0);
                    }

                    if (this.nDate) {
                        // Set date uniform: year/month/day/time_in_sec
                        this.uniform('4f', 'float', 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);
                    }

                    // set the resolution uniform
                    this.uniform('2f', 'vec2', 'u_resolution', this.canvas.width, this.canvas.height);

                    for (var key in this.buffers) {
                        var buffer = this.buffers[key];
                        this.uniform('1i', 'sampler2D', buffer.name, buffer.bundle.input.index);
                    }

                    this.texureIndex = this.BUFFER_COUNT;
                    for (var tex in this.textures) {
                        this.uniformTexture(tex);
                        this.texureIndex++;
                    }

                    this.renderPrograms();

                    // Trigger event
                    this.trigger('render', {});
                    this.change = false;
                    this.forceRender = false;
                }
            }
        }, {
            key: 'pause',
            value: function pause() {
                this.paused = true;
            }
        }, {
            key: 'play',
            value: function play() {
                this.paused = false;
            }

            // render main and buffers programs

        }, {
            key: 'renderPrograms',
            value: function renderPrograms() {
                var gl = this.gl;
                var W = gl.canvas.width;
                var H = gl.canvas.height;

                gl.viewport(0, 0, W, H);

                for (var key in this.buffers) {
                    var buffer = this.buffers[key];
                    buffer.bundle.render(W, H, buffer.program, buffer.name);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }

                gl.useProgram(this.program);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            // parse input strings

        }, {
            key: 'getBuffers',
            value: function getBuffers(fragString) {
                var buffers = {};
                if (fragString) {
                    fragString.replace(/(?:^\s*)((?:#if|#elif)(?:\s*)(defined\s*\(\s*BUFFER_)(\d+)(?:\s*\))|(?:#ifdef)(?:\s*BUFFER_)(\d+)(?:\s*))/gm, function () {
                        var i = arguments[3] || arguments[4];
                        buffers['u_buffer' + i] = {
                            fragment: '#define BUFFER_' + i + '\n' + fragString
                        };
                    });
                }
                return buffers;
            }

            // load buffers programs

        }, {
            key: 'loadPrograms',
            value: function loadPrograms(buffers) {
                var glsl = this;
                var gl = this.gl;
                var vertex = createShader(glsl, glsl.vertexString, gl.VERTEX_SHADER);
                for (var key in buffers) {
                    var buffer = buffers[key];
                    var fragment = createShader(glsl, buffer.fragment, gl.FRAGMENT_SHADER, 1);
                    if (!fragment) {
                        fragment = createShader(glsl, 'void main(){\n\tgl_FragColor = vec4(1.0);\n}', gl.FRAGMENT_SHADER);
                        glsl.isValid = false;
                    } else {
                        glsl.isValid = true;
                    }
                    var program = createProgram(glsl, [vertex, fragment]);
                    buffer.name = key;
                    buffer.program = program;
                    buffer.bundle = glsl.createSwappableBuffer(glsl.canvas.width, glsl.canvas.height, program);
                    gl.deleteShader(fragment);
                }
                gl.deleteShader(vertex);
            }

            // create an input / output swappable buffer

        }, {
            key: 'createSwappableBuffer',
            value: function createSwappableBuffer(W, H, program) {
                var input = this.createBuffer(W, H, program);
                var output = this.createBuffer(W, H, program);
                var gl = this.gl;
                return {
                    input: input,
                    output: output,
                    swap: function swap() {
                        var temp = input;
                        input = output;
                        output = temp;
                        this.input = input;
                        this.output = output;
                    },
                    render: function render(W, H, program, name) {
                        gl.useProgram(program);
                        gl.viewport(0, 0, W, H);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, this.input.buffer);
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.output.texture, 0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        this.swap();
                    },
                    resize: function resize(W, H, program, name) {
                        gl.useProgram(program);
                        gl.viewport(0, 0, W, H);
                        this.input.resize(W, H);
                        this.output.resize(W, H);
                    }
                };
            }

            // create a buffers

        }, {
            key: 'createBuffer',
            value: function createBuffer(W, H, program) {
                var gl = this.gl;
                var index = this.BUFFER_COUNT;
                this.BUFFER_COUNT += 2;
                gl.getExtension('OES_texture_float');
                var texture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0 + index);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.FLOAT, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                var buffer = gl.createFramebuffer();
                return {
                    index: index,
                    texture: texture,
                    buffer: buffer,
                    W: W,
                    H: H,
                    resize: function resize(W, H) {
                        gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
                        var minW = Math.min(W, this.W);
                        var minH = Math.min(H, this.H);
                        var pixels = new Float32Array(minW * minH * 4);
                        gl.readPixels(0, 0, minW, minH, gl.RGBA, gl.FLOAT, pixels);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                        var newIndex = index + 1;
                        var newTexture = gl.createTexture();
                        gl.activeTexture(gl.TEXTURE0 + newIndex);
                        gl.bindTexture(gl.TEXTURE_2D, newTexture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.FLOAT, null);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, minW, minH, gl.RGBA, gl.FLOAT, pixels);
                        var newBuffer = gl.createFramebuffer();
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                        gl.deleteTexture(texture);
                        gl.activeTexture(gl.TEXTURE0 + index);
                        gl.bindTexture(gl.TEXTURE_2D, newTexture);
                        index = this.index = index;
                        texture = this.texture = newTexture;
                        buffer = this.buffer = newBuffer;
                        this.W = W;
                        this.H = H;
                    }
                };
            }

            // resize buffers on canvas resize
            // consider applying a throttle of 50 ms on canvas resize
            // to avoid requestAnimationFrame and Gl violations

        }, {
            key: 'resizeSwappableBuffers',
            value: function resizeSwappableBuffers() {
                var gl = this.gl;
                var W = gl.canvas.width,
                    H = gl.canvas.height;
                gl.viewport(0, 0, W, H);
                for (var key in this.buffers) {
                    var buffer = this.buffers[key];
                    buffer.bundle.resize(W, H, buffer.program, buffer.name);
                }
                gl.useProgram(this.program);
            }
        }, {
            key: 'version',
            value: function version() {
                return '0.1.7';
            }
        }]);
        return GlslCanvas;
    }();

    function loadAllGlslCanvas() {
        var list = document.getElementsByClassName('glslCanvas');
        if (list.length > 0) {
            window.glslCanvases = [];
            for (var i = 0; i < list.length; i++) {
                var sandbox = new GlslCanvas(list[i]);
                if (sandbox.isValid) {
                    window.glslCanvases.push(sandbox);
                }
            }
        }
    }

    window.addEventListener('load', function () {
        loadAllGlslCanvas();
    });

    var kernel_frag = "precision mediump float;precision lowp int;\n#define GLSLIFY 1\nuniform vec2 u_resolution;uniform float u_sigma;uniform float cut_size;uniform bool u_do_scramble;uniform float u_xmin;uniform float u_xmax;const vec3 blue=vec3(0.0,0.0,1.0);const vec3 white=vec3(1.0,1.0,1.0);const float pi=3.1415926539;float slope=u_xmax-u_xmin;float intercept=u_xmin;float scramble(float x){float d=floor(x/cut_size);float r=x-d*cut_size;if(abs(mod(d,2.0))==1.0){x=x+cut_size-2.0*r;}return x;}float kernel(vec2 st){float fac=1.0/(u_sigma*sqrt(2.0*pi));return fac*exp(-0.5*pow((st.x-st.y)/u_sigma,2.0));}void main(){vec2 st=gl_FragCoord.xy/u_resolution;st=vec2(st.x,1.0-st.y)*slope+intercept;if(u_do_scramble){st=vec2(scramble(st.x),st.y);}float k=kernel(st)/kernel(vec2(0.0,0.0));vec3 color=k*blue+(1.0-k)*white;gl_FragColor=vec4(color,1.0);}"; // eslint-disable-line

    /* src/KernelHeatmap.svelte generated by Svelte v3.40.2 */
    const file$6 = "src/KernelHeatmap.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	return child_ctx;
    }

    // (73:2) {#if mounted}
    function create_if_block$2(ctx) {
    	let each_1_anchor;
    	let each_value = /*plot*/ ctx[0].x;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot, xTou, yTov*/ 193) {
    				each_value = /*plot*/ ctx[0].x;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(73:2) {#if mounted}",
    		ctx
    	});

    	return block;
    }

    // (75:6) {#each plot.mu as mu}
    function create_each_block_1$1(ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", circle_cx_value = /*xTou*/ ctx[6](/*x*/ ctx[19]));
    			attr_dev(circle, "cy", circle_cy_value = /*yTov*/ ctx[7](/*mu*/ ctx[22]));
    			attr_dev(circle, "r", "2");
    			attr_dev(circle, "fill", "rgba(255,0,0,1)");
    			add_location(circle, file$6, 75, 8, 2104);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 1 && circle_cx_value !== (circle_cx_value = /*xTou*/ ctx[6](/*x*/ ctx[19]))) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty & /*plot*/ 1 && circle_cy_value !== (circle_cy_value = /*yTov*/ ctx[7](/*mu*/ ctx[22]))) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(75:6) {#each plot.mu as mu}",
    		ctx
    	});

    	return block;
    }

    // (74:4) {#each plot.x as x}
    function create_each_block$3(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*plot*/ ctx[0].mu;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*xTou, plot, yTov*/ 193) {
    				each_value_1 = /*plot*/ ctx[0].mu;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(74:4) {#each plot.x as x}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div;
    	let div_class_value;
    	let div_resize_listener;
    	let t0;
    	let canvas;
    	let canvas_class_value;
    	let t1;
    	let svg_1;
    	let svg_1_class_value;
    	let if_block = /*mounted*/ ctx[3] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = space();
    			canvas = element("canvas");
    			t1 = space();
    			svg_1 = svg_element("svg");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", div_class_value = "" + (/*gridarea*/ ctx[1] + " invis-framed" + " svelte-1cp5z7m"));
    			add_render_callback(() => /*div_elementresize_handler*/ ctx[10].call(div));
    			add_location(div, file$6, 69, 0, 1844);
    			attr_dev(canvas, "class", canvas_class_value = "" + (/*gridarea*/ ctx[1] + " framed z1" + " svelte-1cp5z7m"));
    			add_location(canvas, file$6, 70, 0, 1913);
    			attr_dev(svg_1, "class", svg_1_class_value = "" + (/*gridarea*/ ctx[1] + " framed z2" + " svelte-1cp5z7m"));
    			add_location(svg_1, file$6, 71, 0, 1976);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[10].bind(div));
    			insert_dev(target, t0, anchor);
    			insert_dev(target, canvas, anchor);
    			/*canvas_binding*/ ctx[11](canvas);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, svg_1, anchor);
    			if (if_block) if_block.m(svg_1, null);
    			/*svg_1_binding*/ ctx[12](svg_1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*gridarea*/ 2 && div_class_value !== (div_class_value = "" + (/*gridarea*/ ctx[1] + " invis-framed" + " svelte-1cp5z7m"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*gridarea*/ 2 && canvas_class_value !== (canvas_class_value = "" + (/*gridarea*/ ctx[1] + " framed z1" + " svelte-1cp5z7m"))) {
    				attr_dev(canvas, "class", canvas_class_value);
    			}

    			if (/*mounted*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					if_block.m(svg_1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*gridarea*/ 2 && svg_1_class_value !== (svg_1_class_value = "" + (/*gridarea*/ ctx[1] + " framed z2" + " svelte-1cp5z7m"))) {
    				attr_dev(svg_1, "class", svg_1_class_value);
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			div_resize_listener();
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(canvas);
    			/*canvas_binding*/ ctx[11](null);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(svg_1);
    			if (if_block) if_block.d();
    			/*svg_1_binding*/ ctx[12](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('KernelHeatmap', slots, []);

    	let { sig } = $$props,
    		{ cn } = $$props,
    		{ plot } = $$props,
    		{ gridarea } = $$props;

    	let xmin, xmax, mounted = false;
    	let sandbox;
    	let svg, can, divh;
    	let s;

    	function xTou(x) {
    		var h = svg.clientHeight;
    		return h * (x - xmin) / (xmax - xmin);
    	}

    	function yTov(y) {
    		return xTou(y);
    	}

    	function resize(dummy) {
    		if (!mounted) return;
    		var h = svg.clientHeight; // excludes border

    		// console.log(`in KernelHeatmap resize with dummy=${dummy}, svg.clientHeight=${h}`);
    		svg.setAttribute('width', h);

    		can.setAttribute('width', h);
    		update();
    	}

    	function update() {
    		var sigma = Math.sqrt(plot.get_sigma2());
    		var do_scramble = plot.scrambled();
    		var cut_size = plot.cut_size();
    		[xmin, xmax] = plot.get_xrange();

    		if (sandbox instanceof GlslCanvas) {
    			sandbox.setUniform("u_sigma", sigma);
    			sandbox.setUniform("cut_size", cut_size);
    			sandbox.setUniform("u_do_scramble", do_scramble ? 1 : 0);
    			sandbox.setUniform("u_xmin", xmin);
    			sandbox.setUniform("u_xmax", xmax);
    		}

    		$$invalidate(0, plot.touch++, plot);
    	}

    	onMount(() => {
    		s = new Sync(sig, cn, update);
    		var gl = can.getContext('webgl') || can.getContext('experimental-webgl');

    		if (gl && gl instanceof WebGLRenderingContext) {
    			sandbox = new GlslCanvas(can);
    			sandbox.load(kernel_frag);
    		}

    		$$invalidate(3, mounted = true);
    		resize();
    	});

    	const writable_props = ['sig', 'cn', 'plot', 'gridarea'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<KernelHeatmap> was created with unknown prop '${key}'`);
    	});

    	function div_elementresize_handler() {
    		divh = this.clientHeight;
    		$$invalidate(2, divh);
    	}

    	function canvas_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			can = $$value;
    			$$invalidate(5, can);
    		});
    	}

    	function svg_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			svg = $$value;
    			$$invalidate(4, svg);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		GlslCanvas,
    		RBFKernel,
    		RBFShuffleKernel,
    		kernel_frag,
    		Sync,
    		d3,
    		sig,
    		cn,
    		plot,
    		gridarea,
    		xmin,
    		xmax,
    		mounted,
    		sandbox,
    		svg,
    		can,
    		divh,
    		s,
    		xTou,
    		yTov,
    		resize,
    		update
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    		if ('xmin' in $$props) xmin = $$props.xmin;
    		if ('xmax' in $$props) xmax = $$props.xmax;
    		if ('mounted' in $$props) $$invalidate(3, mounted = $$props.mounted);
    		if ('sandbox' in $$props) sandbox = $$props.sandbox;
    		if ('svg' in $$props) $$invalidate(4, svg = $$props.svg);
    		if ('can' in $$props) $$invalidate(5, can = $$props.can);
    		if ('divh' in $$props) $$invalidate(2, divh = $$props.divh);
    		if ('s' in $$props) s = $$props.s;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*divh*/ 4) {
    			resize();
    		}
    	};

    	return [
    		plot,
    		gridarea,
    		divh,
    		mounted,
    		svg,
    		can,
    		xTou,
    		yTov,
    		sig,
    		cn,
    		div_elementresize_handler,
    		canvas_binding,
    		svg_1_binding
    	];
    }

    class KernelHeatmap extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$6, create_fragment$6, safe_not_equal, { sig: 8, cn: 9, plot: 0, gridarea: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KernelHeatmap",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[8] === undefined && !('sig' in props)) {
    			console.warn("<KernelHeatmap> was created without expected prop 'sig'");
    		}

    		if (/*cn*/ ctx[9] === undefined && !('cn' in props)) {
    			console.warn("<KernelHeatmap> was created without expected prop 'cn'");
    		}

    		if (/*plot*/ ctx[0] === undefined && !('plot' in props)) {
    			console.warn("<KernelHeatmap> was created without expected prop 'plot'");
    		}

    		if (/*gridarea*/ ctx[1] === undefined && !('gridarea' in props)) {
    			console.warn("<KernelHeatmap> was created without expected prop 'gridarea'");
    		}
    	}

    	get sig() {
    		throw new Error("<KernelHeatmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<KernelHeatmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<KernelHeatmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<KernelHeatmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<KernelHeatmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<KernelHeatmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gridarea() {
    		throw new Error("<KernelHeatmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gridarea(value) {
    		throw new Error("<KernelHeatmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/KernelMatrix.svelte generated by Svelte v3.40.2 */
    const file$5 = "src/KernelMatrix.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i].x;
    	child_ctx[15] = list[i].y;
    	child_ctx[16] = list[i].v;
    	child_ctx[17] = list[i].side;
    	return child_ctx;
    }

    // (69:2) {#if mounted}
    function create_if_block$1(ctx) {
    	let each_1_anchor;
    	let each_value = /*get_mat*/ ctx[5](/*plot*/ ctx[0]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*get_mat, plot, color*/ 33) {
    				each_value = /*get_mat*/ ctx[5](/*plot*/ ctx[0]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(69:2) {#if mounted}",
    		ctx
    	});

    	return block;
    }

    // (70:4) {#each get_mat(plot) as {x, y, v, side}}
    function create_each_block$2(ctx) {
    	let rect;
    	let rect_width_value;
    	let rect_height_value;
    	let rect_x_value;
    	let rect_y_value;

    	const block = {
    		c: function create() {
    			rect = svg_element("rect");
    			attr_dev(rect, "width", rect_width_value = /*side*/ ctx[17]);
    			attr_dev(rect, "height", rect_height_value = /*side*/ ctx[17]);
    			attr_dev(rect, "x", rect_x_value = /*x*/ ctx[14]);
    			attr_dev(rect, "y", rect_y_value = /*y*/ ctx[15]);
    			set_style(rect, "fill", color(/*v*/ ctx[16]));
    			add_location(rect, file$5, 70, 6, 1450);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, rect, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 1 && rect_width_value !== (rect_width_value = /*side*/ ctx[17])) {
    				attr_dev(rect, "width", rect_width_value);
    			}

    			if (dirty & /*plot*/ 1 && rect_height_value !== (rect_height_value = /*side*/ ctx[17])) {
    				attr_dev(rect, "height", rect_height_value);
    			}

    			if (dirty & /*plot*/ 1 && rect_x_value !== (rect_x_value = /*x*/ ctx[14])) {
    				attr_dev(rect, "x", rect_x_value);
    			}

    			if (dirty & /*plot*/ 1 && rect_y_value !== (rect_y_value = /*y*/ ctx[15])) {
    				attr_dev(rect, "y", rect_y_value);
    			}

    			if (dirty & /*plot*/ 1) {
    				set_style(rect, "fill", color(/*v*/ ctx[16]));
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(rect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(70:4) {#each get_mat(plot) as {x, y, v, side}}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div;
    	let div_class_value;
    	let div_resize_listener;
    	let t;
    	let svg_1;
    	let svg_1_class_value;
    	let if_block = /*mounted*/ ctx[4] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			svg_1 = svg_element("svg");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", div_class_value = "invis-framed " + /*gridarea*/ ctx[1] + " svelte-29ayl0");
    			add_render_callback(() => /*div_elementresize_handler*/ ctx[8].call(div));
    			add_location(div, file$5, 66, 0, 1266);
    			attr_dev(svg_1, "class", svg_1_class_value = "framed " + /*gridarea*/ ctx[1] + " svelte-29ayl0");
    			add_location(svg_1, file$5, 67, 0, 1335);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[8].bind(div));
    			insert_dev(target, t, anchor);
    			insert_dev(target, svg_1, anchor);
    			if (if_block) if_block.m(svg_1, null);
    			/*svg_1_binding*/ ctx[9](svg_1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*gridarea*/ 2 && div_class_value !== (div_class_value = "invis-framed " + /*gridarea*/ ctx[1] + " svelte-29ayl0")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (/*mounted*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(svg_1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*gridarea*/ 2 && svg_1_class_value !== (svg_1_class_value = "framed " + /*gridarea*/ ctx[1] + " svelte-29ayl0")) {
    				attr_dev(svg_1, "class", svg_1_class_value);
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			div_resize_listener();
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(svg_1);
    			if (if_block) if_block.d();
    			/*svg_1_binding*/ ctx[9](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function color(s) {
    	var i = 255 * s;
    	return `rgba(${255 - i}, ${255 - i}, 255)`;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('KernelMatrix', slots, []);

    	let { sig } = $$props,
    		{ cn } = $$props,
    		{ plot } = $$props,
    		{ gridarea } = $$props;

    	let s, divh;
    	let sqr_frac = 0.9;
    	let svg;
    	let mounted = false;

    	function get_mat(plot) {
    		var dat = [];
    		if (plot.n == 0) return dat;
    		var h = svg.clientHeight;
    		var fill = plot.n == 1 ? h : sqr_frac * h;
    		var blank = h - fill;
    		var side = fill / plot.n;
    		var gap = plot.n > 1 ? blank / (plot.n - 1) : 0;
    		var stride = side + gap;

    		for (let i = 0; i != plot.n; i++) {
    			for (let j = 0; j != plot.n; j++) {
    				dat.push({
    					x: stride * i,
    					y: stride * j,
    					v: plot.pft[i][j],
    					side
    				});
    			}
    		}

    		return dat;
    	}

    	function resize(dummy) {
    		if (!mounted) return;
    		var h = svg.clientHeight;

    		// console.log(`in KernelMatrix resize with dummy=${dummy}, svg.clientHeight=${h}`);
    		svg.setAttribute('width', h);

    		update();
    	}

    	function update() {
    		// console.log(`in KernelMatrix update with ${plot.n}`);
    		$$invalidate(0, plot.touch++, plot);
    	}

    	onMount(() => {
    		s = new Sync(sig, cn, update);

    		// console.log(plot.n);
    		$$invalidate(4, mounted = true);

    		resize();
    	});

    	const writable_props = ['sig', 'cn', 'plot', 'gridarea'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<KernelMatrix> was created with unknown prop '${key}'`);
    	});

    	function div_elementresize_handler() {
    		divh = this.clientHeight;
    		$$invalidate(2, divh);
    	}

    	function svg_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			svg = $$value;
    			$$invalidate(3, svg);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(6, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(7, cn = $$props.cn);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    	};

    	$$self.$capture_state = () => ({
    		Sync,
    		numberDisplay,
    		onMount,
    		sig,
    		cn,
    		plot,
    		gridarea,
    		s,
    		divh,
    		sqr_frac,
    		svg,
    		mounted,
    		color,
    		get_mat,
    		resize,
    		update
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(6, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(7, cn = $$props.cn);
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    		if ('s' in $$props) s = $$props.s;
    		if ('divh' in $$props) $$invalidate(2, divh = $$props.divh);
    		if ('sqr_frac' in $$props) sqr_frac = $$props.sqr_frac;
    		if ('svg' in $$props) $$invalidate(3, svg = $$props.svg);
    		if ('mounted' in $$props) $$invalidate(4, mounted = $$props.mounted);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*divh*/ 4) {
    			resize();
    		}
    	};

    	return [
    		plot,
    		gridarea,
    		divh,
    		svg,
    		mounted,
    		get_mat,
    		sig,
    		cn,
    		div_elementresize_handler,
    		svg_1_binding
    	];
    }

    class KernelMatrix extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, { sig: 6, cn: 7, plot: 0, gridarea: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KernelMatrix",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[6] === undefined && !('sig' in props)) {
    			console.warn("<KernelMatrix> was created without expected prop 'sig'");
    		}

    		if (/*cn*/ ctx[7] === undefined && !('cn' in props)) {
    			console.warn("<KernelMatrix> was created without expected prop 'cn'");
    		}

    		if (/*plot*/ ctx[0] === undefined && !('plot' in props)) {
    			console.warn("<KernelMatrix> was created without expected prop 'plot'");
    		}

    		if (/*gridarea*/ ctx[1] === undefined && !('gridarea' in props)) {
    			console.warn("<KernelMatrix> was created without expected prop 'gridarea'");
    		}
    	}

    	get sig() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gridarea() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gridarea(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Figure1.svelte generated by Svelte v3.40.2 */
    const file$4 = "src/Figure1.svelte";

    function create_fragment$4(ctx) {
    	let div8;
    	let div0;
    	let curves;
    	let t0;
    	let slidercontrols;
    	let t1;
    	let lowpanelcontrols;
    	let t2;
    	let div7;
    	let div1;
    	let d_math0;
    	let raw0_value = `\\mu` + "";
    	let t3;
    	let kernelheatmap;
    	let t4;
    	let div2;
    	let d_math1;
    	let raw1_value = `\\mu_i` + "";
    	let t5;
    	let kernelmatrix;
    	let t6;
    	let div3;
    	let d_math2;
    	let raw2_value = `x` + "";
    	let t7;
    	let div4;
    	let d_math3;
    	let raw3_value = `x_i` + "";
    	let t8;
    	let div5;
    	let d_math4;
    	let raw4_value = `\\mathcal{N}(x; \\mu, \\sigma)` + "";
    	let t9;
    	let div6;
    	let d_math5;
    	let raw5_value = `\\mathcal{N}(x_i; \\mu_i, \\sigma)` + "";
    	let current;

    	curves = new Curves({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cn: "1",
    				cfg: /*cfg*/ ctx[1],
    				plot: /*plot*/ ctx[2],
    				gridarea: "curves"
    			},
    			$$inline: true
    		});

    	slidercontrols = new SliderControls({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cn: "3",
    				cfg: /*cfg*/ ctx[1],
    				plot: /*plot*/ ctx[2]
    			},
    			$$inline: true
    		});

    	lowpanelcontrols = new LowPanelControls({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cn: "2",
    				cfg: /*cfg*/ ctx[1],
    				plot: /*plot*/ ctx[2]
    			},
    			$$inline: true
    		});

    	kernelheatmap = new KernelHeatmap({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cn: "4",
    				plot: /*plot*/ ctx[2],
    				gridarea: "cell2"
    			},
    			$$inline: true
    		});

    	kernelmatrix = new KernelMatrix({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cn: "5",
    				plot: /*plot*/ ctx[2],
    				gridarea: "cell6"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div0 = element("div");
    			create_component(curves.$$.fragment);
    			t0 = space();
    			create_component(slidercontrols.$$.fragment);
    			t1 = space();
    			create_component(lowpanelcontrols.$$.fragment);
    			t2 = space();
    			div7 = element("div");
    			div1 = element("div");
    			d_math0 = element("d-math");
    			t3 = space();
    			create_component(kernelheatmap.$$.fragment);
    			t4 = space();
    			div2 = element("div");
    			d_math1 = element("d-math");
    			t5 = space();
    			create_component(kernelmatrix.$$.fragment);
    			t6 = space();
    			div3 = element("div");
    			d_math2 = element("d-math");
    			t7 = space();
    			div4 = element("div");
    			d_math3 = element("d-math");
    			t8 = space();
    			div5 = element("div");
    			d_math4 = element("d-math");
    			t9 = space();
    			div6 = element("div");
    			d_math5 = element("d-math");
    			attr_dev(div0, "class", "fi-upper gbox-upper svelte-frau4j");
    			add_location(div0, file$4, 33, 2, 836);
    			add_location(d_math0, file$4, 40, 20, 1125);
    			attr_dev(div1, "class", "y1 svelte-frau4j");
    			add_location(div1, file$4, 40, 4, 1109);
    			add_location(d_math1, file$4, 42, 18, 1246);
    			attr_dev(div2, "class", "y2 svelte-frau4j");
    			add_location(div2, file$4, 42, 2, 1230);
    			add_location(d_math2, file$4, 44, 20, 1370);
    			attr_dev(div3, "class", "x1 svelte-frau4j");
    			add_location(div3, file$4, 44, 4, 1354);
    			add_location(d_math3, file$4, 45, 20, 1425);
    			attr_dev(div4, "class", "x2 svelte-frau4j");
    			add_location(div4, file$4, 45, 4, 1409);
    			add_location(d_math4, file$4, 47, 6, 1491);
    			attr_dev(div5, "class", "cap1 svelte-frau4j");
    			add_location(div5, file$4, 46, 4, 1466);
    			add_location(d_math5, file$4, 50, 6, 1589);
    			attr_dev(div6, "class", "cap2 svelte-frau4j");
    			add_location(div6, file$4, 49, 4, 1564);
    			attr_dev(div7, "class", "fi-lower gbox-lower svelte-frau4j");
    			add_location(div7, file$4, 39, 1, 1071);
    			attr_dev(div8, "class", "" + (/*topclass*/ ctx[0] + " fb-vert" + " svelte-frau4j"));
    			add_location(div8, file$4, 32, 0, 801);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div0);
    			mount_component(curves, div0, null);
    			append_dev(div0, t0);
    			mount_component(slidercontrols, div0, null);
    			append_dev(div0, t1);
    			mount_component(lowpanelcontrols, div0, null);
    			append_dev(div8, t2);
    			append_dev(div8, div7);
    			append_dev(div7, div1);
    			append_dev(div1, d_math0);
    			d_math0.innerHTML = raw0_value;
    			append_dev(div7, t3);
    			mount_component(kernelheatmap, div7, null);
    			append_dev(div7, t4);
    			append_dev(div7, div2);
    			append_dev(div2, d_math1);
    			d_math1.innerHTML = raw1_value;
    			append_dev(div7, t5);
    			mount_component(kernelmatrix, div7, null);
    			append_dev(div7, t6);
    			append_dev(div7, div3);
    			append_dev(div3, d_math2);
    			d_math2.innerHTML = raw2_value;
    			append_dev(div7, t7);
    			append_dev(div7, div4);
    			append_dev(div4, d_math3);
    			d_math3.innerHTML = raw3_value;
    			append_dev(div7, t8);
    			append_dev(div7, div5);
    			append_dev(div5, d_math4);
    			d_math4.innerHTML = raw4_value;
    			append_dev(div7, t9);
    			append_dev(div7, div6);
    			append_dev(div6, d_math5);
    			d_math5.innerHTML = raw5_value;
    			current = true;
    		},
    		p: noop$5,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(curves.$$.fragment, local);
    			transition_in(slidercontrols.$$.fragment, local);
    			transition_in(lowpanelcontrols.$$.fragment, local);
    			transition_in(kernelheatmap.$$.fragment, local);
    			transition_in(kernelmatrix.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(curves.$$.fragment, local);
    			transition_out(slidercontrols.$$.fragment, local);
    			transition_out(lowpanelcontrols.$$.fragment, local);
    			transition_out(kernelheatmap.$$.fragment, local);
    			transition_out(kernelmatrix.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_component(curves);
    			destroy_component(slidercontrols);
    			destroy_component(lowpanelcontrols);
    			destroy_component(kernelheatmap);
    			destroy_component(kernelmatrix);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Figure1', slots, []);
    	let { fullscreen = false } = $$props;
    	let topclass = fullscreen ? 'screen100' : 'screen80';

    	let cfg = {
    		cmd: null,
    		points: false,
    		curves: true,
    		solution: true,
    		auto_solve: false,
    		mu_tracks_x: true,
    		scramble: false,
    		log_sigma: 0,
    		show_data: true
    	};

    	let ctx = new Context(0, 0, [-4, 4], [-4, 4]);
    	let plot = new Plot(ctx, 3);
    	let sig = writable(0);
    	let h;
    	const writable_props = ['fullscreen'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Figure1> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('fullscreen' in $$props) $$invalidate(4, fullscreen = $$props.fullscreen);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		Plot,
    		Context,
    		Curves,
    		LowPanelControls,
    		SliderControls,
    		KernelHeatmap,
    		KernelMatrix,
    		fullscreen,
    		topclass,
    		cfg,
    		ctx,
    		plot,
    		sig,
    		h
    	});

    	$$self.$inject_state = $$props => {
    		if ('fullscreen' in $$props) $$invalidate(4, fullscreen = $$props.fullscreen);
    		if ('topclass' in $$props) $$invalidate(0, topclass = $$props.topclass);
    		if ('cfg' in $$props) $$invalidate(1, cfg = $$props.cfg);
    		if ('ctx' in $$props) ctx = $$props.ctx;
    		if ('plot' in $$props) $$invalidate(2, plot = $$props.plot);
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    		if ('h' in $$props) h = $$props.h;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [topclass, cfg, plot, sig, fullscreen];
    }

    class Figure1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, { fullscreen: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Figure1",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get fullscreen() {
    		throw new Error("<Figure1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullscreen(value) {
    		throw new Error("<Figure1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const XMIN = -4;
    const XMAX = 4;

    function dotp(p, q) {
      return p[0] * q[0] + p[1] * q[1];
    }

    function norm2(p) {
      return dotp(p, p);
    }

    function scale(p, factor) {
      return [p[0] * factor, p[1] * factor];
    }

    // calculate the vector projection of arg to onto
    function proj(onto, arg) {
      return scale(onto, dotp(onto, arg) / norm2(onto));
    }


    class PhiSpace$1 {
      constructor(max_alpha) {
        this.basis = new Matrix([[1,0], [0,0]]);
        this.xTou = linear().domain([-max_alpha, max_alpha]);
        this.yTov = linear().domain([-max_alpha, max_alpha]);

        var ctx = new Context(10, 10, [XMIN, XMAX], [XMIN, XMAX]);
        this.plot = new Plot(ctx, 2);
        this.updateBasis();
        this.plot.init_metrics();
        this.plot.initCurveCache();
      }

      toUV(xy) {
        return [this.xTou(xy[0]), this.yTov(xy[1])];
      }

      toXY(val) {
        return [this.xTou.invert(val[0]), this.yTov.invert(val[1])];
      }

      resize(w, h) {
        this.xTou.range([0, w]);
        this.yTov.range([h, 0]);
        this.plot.resize(w, h);
      }

      // update the second basis vector, assuming the kernel with k(v, v) = 1 for
      // all v
      updateBasis() {
        var kv = this.plot.ppt[0][1];
        var ang = Math.acos(kv);
        this.basis[1][0] = Math.cos(ang);
        this.basis[1][1] = Math.sin(ang);
      }

      // update the current function f
      updateF(u, v) {
        var f = this.toXY([u, v]);
        var F = new Matrix([f]);
        this.plot.alpha = F.mmul(inverse(this.basis)).flat();
      }

      F() {
        var [x, y] = this.alpha().mmul(this.basis).flat();
        var [u, v] = [this.xTou(x), this.yTov(y)];
        var deg = Math.atan2(y, x) * (-180.0 / Math.PI);
        return {u, v, deg};
      }

      updateY(u, v) {
        var F = new Matrix([this.toXY([u, v])]);
        var alpha  = F.mmul(inverse(this.basis));
        var y = alpha.mmul(this.plot.pft);
        // console.log(y);
        this.plot.y = y.flat();
      }
      
      _fHat() {
        var alpha_hat = new Matrix([this.plot.solutionAlpha()]);
        var f_hat = alpha_hat.mmul(this.basis).flat();
        return f_hat;
      }

      // c'th component of the solution vector
      fHat() {
        var f_hat = this._fHat();
        return this.toUV(f_hat);
      }

      fHatProj(b) {
        var fhp = proj(this.basis[b], this._fHat());
        return this.toUV(fhp);
      }

      alpha() {
        return new Matrix([this.plot.alpha]);
      }

      scr(i) {
        return this.toUV(this.basis[i]);
      }

    }

    var phi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PhiSpace: PhiSpace$1
    });

    /* src/PhiSpace.svelte generated by Svelte v3.40.2 */
    const file$3 = "src/PhiSpace.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i].p1;
    	child_ctx[18] = list[i].p2;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i][0];
    	child_ctx[22] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i][0];
    	child_ctx[26] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i][0];
    	child_ctx[22] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i][0];
    	child_ctx[26] = list[i][1];
    	return child_ctx;
    }

    // (83:4) {#each [pp.scr(0),pp.scr(1)] as [x2,y2]}
    function create_each_block_4(ctx) {
    	let line;
    	let line_x__value;
    	let line_y__value;
    	let line_x__value_1;
    	let line_y__value_1;

    	const block = {
    		c: function create() {
    			line = svg_element("line");
    			attr_dev(line, "class", "basis svelte-li3dzh");
    			attr_dev(line, "x1", line_x__value = /*x1*/ ctx[21]);
    			attr_dev(line, "y1", line_y__value = /*y1*/ ctx[22]);
    			attr_dev(line, "x2", line_x__value_1 = /*x2*/ ctx[25]);
    			attr_dev(line, "y2", line_y__value_1 = /*y2*/ ctx[26]);
    			attr_dev(line, "marker-end", "url(#basis-arrow)");
    			add_location(line, file$3, 83, 6, 1732);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, line, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp*/ 1 && line_x__value !== (line_x__value = /*x1*/ ctx[21])) {
    				attr_dev(line, "x1", line_x__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value !== (line_y__value = /*y1*/ ctx[22])) {
    				attr_dev(line, "y1", line_y__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_x__value_1 !== (line_x__value_1 = /*x2*/ ctx[25])) {
    				attr_dev(line, "x2", line_x__value_1);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value_1 !== (line_y__value_1 = /*y2*/ ctx[26])) {
    				attr_dev(line, "y2", line_y__value_1);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(line);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(83:4) {#each [pp.scr(0),pp.scr(1)] as [x2,y2]}",
    		ctx
    	});

    	return block;
    }

    // (82:2) {#each [pp.toUV([0,0])] as [x1, y1]}
    function create_each_block_3(ctx) {
    	let each_1_anchor;
    	let each_value_4 = [/*pp*/ ctx[0].scr(0), /*pp*/ ctx[0].scr(1)];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < 2; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp*/ 1) {
    				each_value_4 = [/*pp*/ ctx[0].scr(0), /*pp*/ ctx[0].scr(1)];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < 2; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < 2; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(82:2) {#each [pp.toUV([0,0])] as [x1, y1]}",
    		ctx
    	});

    	return block;
    }

    // (89:2) {#if 1}
    function create_if_block(ctx) {
    	let each_1_anchor;
    	let each_value_1 = [/*pp*/ ctx[0].fHat()];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < 1; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp, onMouseDown*/ 17) {
    				each_value_1 = [/*pp*/ ctx[0].fHat()];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < 1; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < 1; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(89:2) {#if 1}",
    		ctx
    	});

    	return block;
    }

    // (91:6) {#each [pp.fHatProj(0), pp.fHatProj(1)] as [x2, y2]}
    function create_each_block_2(ctx) {
    	let line;
    	let line_x__value;
    	let line_y__value;
    	let line_x__value_1;
    	let line_y__value_1;
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			line = svg_element("line");
    			circle = svg_element("circle");
    			attr_dev(line, "class", "perp svelte-li3dzh");
    			attr_dev(line, "x1", line_x__value = /*x1*/ ctx[21]);
    			attr_dev(line, "y1", line_y__value = /*y1*/ ctx[22]);
    			attr_dev(line, "x2", line_x__value_1 = /*x2*/ ctx[25]);
    			attr_dev(line, "y2", line_y__value_1 = /*y2*/ ctx[26]);
    			attr_dev(line, "stroke-dasharray", "4 4");
    			add_location(line, file$3, 91, 8, 1968);
    			attr_dev(circle, "id", "fhat");
    			attr_dev(circle, "class", "perp-target draggable svelte-li3dzh");
    			attr_dev(circle, "r", "6");
    			attr_dev(circle, "cx", circle_cx_value = /*x1*/ ctx[21]);
    			attr_dev(circle, "cy", circle_cy_value = /*y1*/ ctx[22]);
    			add_location(circle, file$3, 94, 8, 2076);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, line, anchor);
    			insert_dev(target, circle, anchor);

    			if (!mounted) {
    				dispose = listen_dev(circle, "mousedown", /*onMouseDown*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp*/ 1 && line_x__value !== (line_x__value = /*x1*/ ctx[21])) {
    				attr_dev(line, "x1", line_x__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value !== (line_y__value = /*y1*/ ctx[22])) {
    				attr_dev(line, "y1", line_y__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_x__value_1 !== (line_x__value_1 = /*x2*/ ctx[25])) {
    				attr_dev(line, "x2", line_x__value_1);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value_1 !== (line_y__value_1 = /*y2*/ ctx[26])) {
    				attr_dev(line, "y2", line_y__value_1);
    			}

    			if (dirty[0] & /*pp*/ 1 && circle_cx_value !== (circle_cx_value = /*x1*/ ctx[21])) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty[0] & /*pp*/ 1 && circle_cy_value !== (circle_cy_value = /*y1*/ ctx[22])) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(line);
    			if (detaching) detach_dev(circle);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(91:6) {#each [pp.fHatProj(0), pp.fHatProj(1)] as [x2, y2]}",
    		ctx
    	});

    	return block;
    }

    // (90:4) {#each [pp.fHat()] as [x1, y1]}
    function create_each_block_1(ctx) {
    	let each_1_anchor;
    	let each_value_2 = [/*pp*/ ctx[0].fHatProj(0), /*pp*/ ctx[0].fHatProj(1)];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < 2; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp, onMouseDown*/ 17) {
    				each_value_2 = [/*pp*/ ctx[0].fHatProj(0), /*pp*/ ctx[0].fHatProj(1)];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < 2; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < 2; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(90:4) {#each [pp.fHat()] as [x1, y1]}",
    		ctx
    	});

    	return block;
    }

    // (102:2) {#each [{ p1: pp.toUV([0,0]), p2: pp.F()} ] as {p1, p2}}
    function create_each_block$1(ctx) {
    	let line;
    	let line_x__value;
    	let line_y__value;
    	let line_x__value_1;
    	let line_y__value_1;
    	let use;
    	let use_x_value;
    	let use_y_value;
    	let use_transform_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			line = svg_element("line");
    			use = svg_element("use");
    			attr_dev(line, "class", "solution-curve svelte-li3dzh");
    			attr_dev(line, "x1", line_x__value = /*p1*/ ctx[17][0]);
    			attr_dev(line, "y1", line_y__value = /*p1*/ ctx[17][1]);
    			attr_dev(line, "x2", line_x__value_1 = /*p2*/ ctx[18].u);
    			attr_dev(line, "y2", line_y__value_1 = /*p2*/ ctx[18].v);
    			add_location(line, file$3, 102, 4, 2295);
    			attr_dev(use, "class", "solution-arrow draggable svelte-li3dzh");
    			xlink_attr(use, "xlink:href", "#pointer");
    			attr_dev(use, "id", "f");
    			attr_dev(use, "x", use_x_value = /*p2*/ ctx[18].u);
    			attr_dev(use, "y", use_y_value = /*p2*/ ctx[18].v);
    			attr_dev(use, "transform", use_transform_value = "rotate(" + /*p2*/ ctx[18].deg + ", " + /*p2*/ ctx[18].u + ", " + /*p2*/ ctx[18].v + ")");
    			add_location(use, file$3, 105, 4, 2392);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, line, anchor);
    			insert_dev(target, use, anchor);

    			if (!mounted) {
    				dispose = listen_dev(use, "mousedown", /*onMouseDown*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pp*/ 1 && line_x__value !== (line_x__value = /*p1*/ ctx[17][0])) {
    				attr_dev(line, "x1", line_x__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value !== (line_y__value = /*p1*/ ctx[17][1])) {
    				attr_dev(line, "y1", line_y__value);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_x__value_1 !== (line_x__value_1 = /*p2*/ ctx[18].u)) {
    				attr_dev(line, "x2", line_x__value_1);
    			}

    			if (dirty[0] & /*pp*/ 1 && line_y__value_1 !== (line_y__value_1 = /*p2*/ ctx[18].v)) {
    				attr_dev(line, "y2", line_y__value_1);
    			}

    			if (dirty[0] & /*pp*/ 1 && use_x_value !== (use_x_value = /*p2*/ ctx[18].u)) {
    				attr_dev(use, "x", use_x_value);
    			}

    			if (dirty[0] & /*pp*/ 1 && use_y_value !== (use_y_value = /*p2*/ ctx[18].v)) {
    				attr_dev(use, "y", use_y_value);
    			}

    			if (dirty[0] & /*pp*/ 1 && use_transform_value !== (use_transform_value = "rotate(" + /*p2*/ ctx[18].deg + ", " + /*p2*/ ctx[18].u + ", " + /*p2*/ ctx[18].v + ")")) {
    				attr_dev(use, "transform", use_transform_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(line);
    			if (detaching) detach_dev(use);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(102:2) {#each [{ p1: pp.toUV([0,0]), p2: pp.F()} ] as {p1, p2}}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let div;
    	let div_class_value;
    	let div_resize_listener;
    	let t;
    	let svg_1;
    	let defs;
    	let marker;
    	let path;
    	let polygon;
    	let each0_anchor;
    	let if_block_anchor;
    	let svg_1_class_value;
    	let mounted;
    	let dispose;
    	let each_value_3 = [/*pp*/ ctx[0].toUV([0, 0])];
    	validate_each_argument(each_value_3);
    	let each_blocks_1 = [];

    	for (let i = 0; i < 1; i += 1) {
    		each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	let if_block = create_if_block(ctx);

    	let each_value = [
    		{
    			p1: /*pp*/ ctx[0].toUV([0, 0]),
    			p2: /*pp*/ ctx[0].F()
    		}
    	];

    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < 1; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			svg_1 = svg_element("svg");
    			defs = svg_element("defs");
    			marker = svg_element("marker");
    			path = svg_element("path");
    			polygon = svg_element("polygon");

    			for (let i = 0; i < 1; i += 1) {
    				each_blocks_1[i].c();
    			}

    			each0_anchor = empty$3();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();

    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", div_class_value = "" + (/*gridarea*/ ctx[1] + " framed z3" + " svelte-li3dzh"));
    			add_render_callback(() => /*div_elementresize_handler*/ ctx[10].call(div));
    			add_location(div, file$3, 63, 0, 1138);
    			attr_dev(path, "d", "M 0 0 L 10 5 L 0 10 z");
    			add_location(path, file$3, 75, 6, 1527);
    			attr_dev(marker, "id", "basis-arrow");
    			attr_dev(marker, "class", "basis-arrow svelte-li3dzh");
    			attr_dev(marker, "viewBox", "0 0 10 10");
    			attr_dev(marker, "refX", "10");
    			attr_dev(marker, "refY", "5");
    			attr_dev(marker, "markerWidth", "6");
    			attr_dev(marker, "markerHeight", "6");
    			attr_dev(marker, "orient", "auto-start-reverse");
    			add_location(marker, file$3, 69, 4, 1326);
    			attr_dev(polygon, "id", "pointer");
    			attr_dev(polygon, "points", "-10,-5 0,0 -10,5");
    			add_location(polygon, file$3, 78, 4, 1581);
    			add_location(defs, file$3, 67, 2, 1314);
    			attr_dev(svg_1, "class", svg_1_class_value = "" + (/*gridarea*/ ctx[1] + " framed" + " svelte-li3dzh"));
    			add_location(svg_1, file$3, 64, 0, 1204);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[10].bind(div));
    			insert_dev(target, t, anchor);
    			insert_dev(target, svg_1, anchor);
    			append_dev(svg_1, defs);
    			append_dev(defs, marker);
    			append_dev(marker, path);
    			append_dev(defs, polygon);

    			for (let i = 0; i < 1; i += 1) {
    				each_blocks_1[i].m(svg_1, null);
    			}

    			append_dev(svg_1, each0_anchor);
    			if (if_block) if_block.m(svg_1, null);
    			append_dev(svg_1, if_block_anchor);

    			for (let i = 0; i < 1; i += 1) {
    				each_blocks[i].m(svg_1, null);
    			}

    			/*svg_1_binding*/ ctx[11](svg_1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg_1, "mousemove", /*onMouseMove*/ ctx[5], false, false, false),
    					listen_dev(svg_1, "mouseup", /*onMouseUp*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*gridarea*/ 2 && div_class_value !== (div_class_value = "" + (/*gridarea*/ ctx[1] + " framed z3" + " svelte-li3dzh"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty[0] & /*pp*/ 1) {
    				each_value_3 = [/*pp*/ ctx[0].toUV([0, 0])];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < 1; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_3(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(svg_1, each0_anchor);
    					}
    				}

    				for (; i < 1; i += 1) {
    					each_blocks_1[i].d(1);
    				}
    			}

    			if_block.p(ctx, dirty);

    			if (dirty[0] & /*pp, onMouseDown*/ 17) {
    				each_value = [
    					{
    						p1: /*pp*/ ctx[0].toUV([0, 0]),
    						p2: /*pp*/ ctx[0].F()
    					}
    				];

    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < 1; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(svg_1, null);
    					}
    				}

    				for (; i < 1; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}

    			if (dirty[0] & /*gridarea*/ 2 && svg_1_class_value !== (svg_1_class_value = "" + (/*gridarea*/ ctx[1] + " framed" + " svelte-li3dzh"))) {
    				attr_dev(svg_1, "class", svg_1_class_value);
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			div_resize_listener();
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(svg_1);
    			destroy_each(each_blocks_1, detaching);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    			/*svg_1_binding*/ ctx[11](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PhiSpace', slots, []);

    	let { sig } = $$props,
    		{ cn } = $$props,
    		{ cfg } = $$props,
    		{ pp } = $$props,
    		{ gridarea } = $$props;

    	let s, divh, svg, mounted = false;
    	let drag_point = null;

    	// called in response to a notify() call from any component
    	// that shares sig with this component
    	function update() {
    		if (!mounted) return;
    		pp.updateBasis();
    		$$invalidate(0, pp.plot.touch++, pp);
    		$$invalidate(0, pp.touch++, pp);
    	}

    	onMount(() => {
    		s = new Sync(sig, cn, update);
    		mounted = true;
    		resize();
    		update();
    	});

    	function onMouseDown(evt) {
    		drag_point = evt.target;
    	}

    	function onMouseMove(evt) {
    		if (drag_point == null) return;

    		if (drag_point.id == 'fhat') {
    			pp.updateY(evt.offsetX, evt.offsetY);
    			$$invalidate(7, cfg.cmd = 'mu_xy_changed', cfg);
    		} else {
    			pp.updateF(evt.offsetX, evt.offsetY);
    			$$invalidate(7, cfg.cmd = 'update_alpha', cfg);
    		}

    		update();
    		s.notify();
    	}

    	function onMouseUp(evt) {
    		drag_point = null;
    	}

    	function resize(dummy) {
    		if (!mounted) return;
    		var h = svg.clientHeight;
    		svg.setAttribute('width', h);
    		pp.resize(h, h);
    		$$invalidate(0, pp.plot.touch++, pp);
    		$$invalidate(0, pp.touch++, pp);
    	}

    	const writable_props = ['sig', 'cn', 'cfg', 'pp', 'gridarea'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PhiSpace> was created with unknown prop '${key}'`);
    	});

    	function div_elementresize_handler() {
    		divh = this.clientHeight;
    		$$invalidate(2, divh);
    	}

    	function svg_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			svg = $$value;
    			$$invalidate(3, svg);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(7, cfg = $$props.cfg);
    		if ('pp' in $$props) $$invalidate(0, pp = $$props.pp);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    	};

    	$$self.$capture_state = () => ({
    		Sync,
    		numberDisplay,
    		d3,
    		onMount,
    		sig,
    		cn,
    		cfg,
    		pp,
    		gridarea,
    		s,
    		divh,
    		svg,
    		mounted,
    		drag_point,
    		update,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp,
    		resize
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$invalidate(8, sig = $$props.sig);
    		if ('cn' in $$props) $$invalidate(9, cn = $$props.cn);
    		if ('cfg' in $$props) $$invalidate(7, cfg = $$props.cfg);
    		if ('pp' in $$props) $$invalidate(0, pp = $$props.pp);
    		if ('gridarea' in $$props) $$invalidate(1, gridarea = $$props.gridarea);
    		if ('s' in $$props) s = $$props.s;
    		if ('divh' in $$props) $$invalidate(2, divh = $$props.divh);
    		if ('svg' in $$props) $$invalidate(3, svg = $$props.svg);
    		if ('mounted' in $$props) mounted = $$props.mounted;
    		if ('drag_point' in $$props) drag_point = $$props.drag_point;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*divh*/ 4) {
    			resize();
    		}
    	};

    	return [
    		pp,
    		gridarea,
    		divh,
    		svg,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp,
    		cfg,
    		sig,
    		cn,
    		div_elementresize_handler,
    		svg_1_binding
    	];
    }

    class PhiSpace extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$1(
    			this,
    			options,
    			instance$3,
    			create_fragment$3,
    			safe_not_equal,
    			{
    				sig: 8,
    				cn: 9,
    				cfg: 7,
    				pp: 0,
    				gridarea: 1
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PhiSpace",
    			options,
    			id: create_fragment$3.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[8] === undefined && !('sig' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'sig'");
    		}

    		if (/*cn*/ ctx[9] === undefined && !('cn' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'cn'");
    		}

    		if (/*cfg*/ ctx[7] === undefined && !('cfg' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'cfg'");
    		}

    		if (/*pp*/ ctx[0] === undefined && !('pp' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'pp'");
    		}

    		if (/*gridarea*/ ctx[1] === undefined && !('gridarea' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'gridarea'");
    		}
    	}

    	get sig() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cn() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cn(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cfg() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cfg(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pp() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pp(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gridarea() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gridarea(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Figure2.svelte generated by Svelte v3.40.2 */
    const file$2 = "src/Figure2.svelte";

    function create_fragment$2(ctx) {
    	let div1;
    	let curves;
    	let t0;
    	let phispace;
    	let t1;
    	let lowpanelcontrols;
    	let t2;
    	let div0;
    	let t3;
    	let d_math0;
    	let raw0_value = `\\vec\\phi_\\sigma(\\mu_1)` + "";
    	let t4;
    	let d_math1;
    	let raw1_value = `\\vec\\phi_\\sigma(\\mu_2)` + "";
    	let t5;
    	let current;

    	curves = new Curves({
    			props: {
    				sig: /*sig*/ ctx[2],
    				cfg: /*cfg*/ ctx[0],
    				cn: "1",
    				plot: /*pp*/ ctx[1].plot,
    				gridarea: "curves"
    			},
    			$$inline: true
    		});

    	phispace = new PhiSpace({
    			props: {
    				sig: /*sig*/ ctx[2],
    				cn: "2",
    				cfg: /*cfg*/ ctx[0],
    				pp: /*pp*/ ctx[1],
    				gridarea: "phi"
    			},
    			$$inline: true
    		});

    	lowpanelcontrols = new LowPanelControls({
    			props: {
    				sig: /*sig*/ ctx[2],
    				cfg: /*cfg*/ ctx[0],
    				cn: "3",
    				plot: /*pp*/ ctx[1].plot
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(curves.$$.fragment);
    			t0 = space();
    			create_component(phispace.$$.fragment);
    			t1 = space();
    			create_component(lowpanelcontrols.$$.fragment);
    			t2 = space();
    			div0 = element("div");
    			t3 = text$1("Plane spanned by ");
    			d_math0 = element("d-math");
    			t4 = text$1(" and\n      ");
    			d_math1 = element("d-math");
    			t5 = text$1(".");
    			add_location(d_math0, file$2, 34, 26, 891);
    			add_location(d_math1, file$2, 35, 6, 955);
    			add_location(div0, file$2, 34, 4, 869);
    			attr_dev(div1, "class", "gb screen svelte-h34vza");
    			add_location(div1, file$2, 30, 0, 640);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(curves, div1, null);
    			append_dev(div1, t0);
    			mount_component(phispace, div1, null);
    			append_dev(div1, t1);
    			mount_component(lowpanelcontrols, div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			append_dev(div0, t3);
    			append_dev(div0, d_math0);
    			d_math0.innerHTML = raw0_value;
    			append_dev(div0, t4);
    			append_dev(div0, d_math1);
    			d_math1.innerHTML = raw1_value;
    			append_dev(div0, t5);
    			current = true;
    		},
    		p: noop$5,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(curves.$$.fragment, local);
    			transition_in(phispace.$$.fragment, local);
    			transition_in(lowpanelcontrols.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(curves.$$.fragment, local);
    			transition_out(phispace.$$.fragment, local);
    			transition_out(lowpanelcontrols.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(curves);
    			destroy_component(phispace);
    			destroy_component(lowpanelcontrols);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Figure2', slots, []);
    	let box = { w: 10, h: 10 };

    	let cfg = {
    		cmd: null,
    		points: false,
    		curves: true,
    		solution: true,
    		auto_solve: false,
    		mu_tracks_x: true,
    		scramble: false,
    		log_sigma: 0,
    		show_data: true
    	};

    	var max_alpha = 4;
    	let pp = new PhiSpace$1(max_alpha);
    	let sig = writable(0);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Figure2> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		writable,
    		Plot,
    		Context,
    		phi,
    		Curves,
    		PhiSpace,
    		LowPanelControls,
    		numberDisplay,
    		box,
    		cfg,
    		max_alpha,
    		pp,
    		sig
    	});

    	$$self.$inject_state = $$props => {
    		if ('box' in $$props) box = $$props.box;
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('max_alpha' in $$props) max_alpha = $$props.max_alpha;
    		if ('pp' in $$props) $$invalidate(1, pp = $$props.pp);
    		if ('sig' in $$props) $$invalidate(2, sig = $$props.sig);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [cfg, pp, sig];
    }

    class Figure2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Figure2",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/SourceChecksums.svelte generated by Svelte v3.40.2 */

    const { Error: Error_1 } = globals;
    const file$1 = "src/SourceChecksums.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (33:2) {:catch error}
    function create_catch_block(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2_value = /*error*/ ctx[5].message + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(/*path*/ ctx[1]);
    			t1 = text$1(" Error: ");
    			t2 = text$1(t2_value);
    			t3 = space();
    			add_location(div, file$1, 33, 4, 949);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			insert_dev(target, t3, anchor);
    		},
    		p: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(33:2) {:catch error}",
    		ctx
    	});

    	return block;
    }

    // (31:2) {:then digest}
    function create_then_block(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2_value = /*digest*/ ctx[4] + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$1(/*path*/ ctx[1]);
    			t1 = text$1(" digest: ");
    			t2 = text$1(t2_value);
    			t3 = space();
    			add_location(div, file$1, 31, 4, 893);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			insert_dev(target, t3, anchor);
    		},
    		p: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(31:2) {:then digest}",
    		ctx
    	});

    	return block;
    }

    // (29:31)      <p>...waiting</p>   {:then digest}
    function create_pending_block(ctx) {
    	let p;
    	let t1;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "...waiting";
    			t1 = space();
    			add_location(p, file$1, 29, 4, 854);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(29:31)      <p>...waiting</p>   {:then digest}",
    		ctx
    	});

    	return block;
    }

    // (28:0) {#each ['build/bundle.css', 'build/bundle.js'] as path}
    function create_each_block(ctx) {
    	let await_block_anchor;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: true,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 4,
    		error: 5
    	};

    	handle_promise(content_digest(/*path*/ ctx[1]), info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty$3();
    			info.block.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			update_await_block_branch(info, ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(28:0) {#each ['build/bundle.css', 'build/bundle.js'] as path}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let each_1_anchor;
    	let each_value = ['build/bundle.css', 'build/bundle.js'];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < 2; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*content_digest*/ 0) {
    				each_value = ['build/bundle.css', 'build/bundle.js'];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < 2; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < 2; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function content_digest(path) {
    	const res = await fetch(path);
    	const text = await res.text();

    	if (res.ok) {
    		const hex = await digestMessage(text);
    		return hex;
    	} else {
    		throw new Error(text);
    	}
    }

    async function digestMessage(message) {
    	const msgUint8 = new TextEncoder().encode(message); // encode as (utf-8) Uint8Array
    	const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8); // hash the message
    	const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array
    	const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string
    	return hashHex;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SourceChecksums', slots, []);
    	let script_digest;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SourceChecksums> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		script_digest,
    		content_digest,
    		digestMessage
    	});

    	$$self.$inject_state = $$props => {
    		if ('script_digest' in $$props) script_digest = $$props.script_digest;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class SourceChecksums extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SourceChecksums",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.40.2 */
    const file = "src/App.svelte";

    function create_fragment(ctx) {
    	let main;
    	let d_front_matter;
    	let script;
    	let t1;
    	let d_title;
    	let h1;
    	let t3;
    	let d_byline;
    	let t4;
    	let d_article;
    	let figure0;
    	let figure1;
    	let t5;
    	let figcaption0;
    	let t6;
    	let d_math0;
    	let raw0_value = `(x_i, y_i)` + "";
    	let t7;
    	let d_math1;
    	let raw1_value = `\\mu_i` + "";
    	let t8;
    	let b0;
    	let t10;
    	let d_math2;
    	let raw2_value = `\\mu_i` + "";
    	let t11;
    	let d_math3;
    	let raw3_value = `\\vec\\alpha` + "";
    	let t12;
    	let b1;
    	let t14;
    	let d_math4;
    	let raw4_value = `\\sigma` + "";
    	let t15;
    	let d_math5;
    	let raw5_value = `\\mu` + "";
    	let t16;
    	let b2;
    	let t18;
    	let d_math6;
    	let raw6_value = `\\mu_i` + "";
    	let t19;
    	let d_math7;
    	let raw7_value = `x_i` + "";
    	let t20;
    	let a;
    	let t22;
    	let t23;
    	let figure1_1;
    	let figure2;
    	let t24;
    	let figcaption1;
    	let b3;
    	let t26;
    	let b4;
    	let t28;
    	let d_math8;
    	let raw8_value = `\\vec\\phi(\\mu_1)` + "";
    	let t29;
    	let d_math9;
    	let raw9_value = `\\vec\\phi(\\mu_2)` + "";
    	let t30;
    	let d_math10;

    	let raw10_value = `\\alpha_1 \\vec\\phi(\\mu_1) + \\alpha_2
                    \\vec\\phi(\\mu_2)` + "";

    	let t31;
    	let t32;
    	let kernelmethods;
    	let t33;
    	let d_appendix;
    	let current;
    	figure1 = new Figure1({ $$inline: true });
    	figure2 = new Figure2({ $$inline: true });
    	kernelmethods = new Kernel_methods({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			d_front_matter = element("d-front-matter");
    			script = element("script");
    			script.textContent = "{\n        \"title\": \"Introduction to Kernel Regression\",\n      \"description\": \"A gentle introduction to Kernel Regression\",\n      \"authors\": [ { \"author\": \"Henry Bigelow\" } ] }";
    			t1 = space();
    			d_title = element("d-title");
    			h1 = element("h1");
    			h1.textContent = "Introduction to Kernel Regression";
    			t3 = space();
    			d_byline = element("d-byline");
    			t4 = space();
    			d_article = element("d-article");
    			figure0 = element("figure");
    			create_component(figure1.$$.fragment);
    			t5 = space();
    			figcaption0 = element("figcaption");
    			t6 = text$1("Interctive plot.  You can drag the black \n                ");
    			d_math0 = element("d-math");
    			t7 = text$1(" data points and triangles\n                (");
    			d_math1 = element("d-math");
    			t8 = text$1(" values).  ");
    			b0 = element("b");
    			b0.textContent = "Top";
    			t10 = text$1(": gray curves are\n                Gaussians centered at the ");
    			d_math2 = element("d-math");
    			t11 = text$1(".  Blue curve is the\n                ");
    			d_math3 = element("d-math");
    			t12 = text$1(" linear combination of the gray curves.\n                ");
    			b1 = element("b");
    			b1.textContent = "Bottom left";
    			t14 = text$1(": A heatmap showing the family of Gaussians\n                with the same ");
    			d_math4 = element("d-math");
    			t15 = text$1(" at every\n                ");
    			d_math5 = element("d-math");
    			t16 = text$1(" value.  Red dots show the locations of evaluation points.\n                ");
    			b2 = element("b");
    			b2.textContent = "Bottom right";
    			t18 = text$1(":  The matrix of values of evaluation\n                points organized by ");
    			d_math6 = element("d-math");
    			t19 = text$1(" and ");
    			d_math7 = element("d-math");
    			t20 = text$1(".\n                Other details provided in text.  ");
    			a = element("a");
    			a.textContent = "Full Page Figure";
    			t22 = text$1(".");
    			t23 = space();
    			figure1_1 = element("figure");
    			create_component(figure2.$$.fragment);
    			t24 = space();
    			figcaption1 = element("figcaption");
    			b3 = element("b");
    			b3.textContent = "Left";
    			t26 = text$1(": The curves plot as before with only two curves.\n                ");
    			b4 = element("b");
    			b4.textContent = "Right";
    			t28 = text$1(": The plane in feature space spanned by vectors\n                ");
    			d_math8 = element("d-math");
    			t29 = text$1(" and\n                ");
    			d_math9 = element("d-math");
    			t30 = text$1(" The blue arrow is\n                ");
    			d_math10 = element("d-math");
    			t31 = text$1(".");
    			t32 = space();
    			create_component(kernelmethods.$$.fragment);
    			t33 = space();
    			d_appendix = element("d-appendix");
    			attr_dev(script, "type", "text/json");
    			add_location(script, file, 15, 4, 275);
    			add_location(d_front_matter, file, 14, 4, 254);
    			add_location(h1, file, 24, 8, 562);
    			set_style(d_title, "padding-bottom", "0");
    			add_location(d_title, file, 23, 4, 518);
    			add_location(d_byline, file, 27, 4, 625);
    			add_location(d_math0, file, 37, 16, 849);
    			add_location(d_math1, file, 38, 17, 930);
    			add_location(b0, file, 38, 61, 974);
    			add_location(d_math2, file, 39, 42, 1044);
    			add_location(d_math3, file, 40, 16, 1114);
    			add_location(b1, file, 41, 16, 1209);
    			add_location(d_math4, file, 42, 30, 1301);
    			add_location(d_math5, file, 43, 16, 1361);
    			add_location(b2, file, 44, 16, 1467);
    			add_location(d_math6, file, 45, 36, 1560);
    			add_location(d_math7, file, 45, 74, 1598);
    			attr_dev(a, "href", "full.html");
    			add_location(a, file, 46, 49, 1679);
    			add_location(figcaption0, file, 36, 12, 779);
    			attr_dev(figure0, "class", "l-page-outset");
    			add_location(figure0, file, 34, 8, 711);
    			add_location(b3, file, 53, 16, 1869);
    			add_location(b4, file, 54, 16, 1946);
    			add_location(d_math8, file, 55, 16, 2022);
    			add_location(d_math9, file, 56, 16, 2088);
    			add_location(d_math10, file, 57, 16, 2168);
    			add_location(figcaption1, file, 52, 12, 1840);
    			attr_dev(figure1_1, "class", "l-page-outset");
    			add_location(figure1_1, file, 50, 8, 1774);
    			add_location(d_article, file, 30, 4, 653);
    			add_location(d_appendix, file, 66, 4, 2371);
    			add_location(main, file, 12, 0, 242);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, d_front_matter);
    			append_dev(d_front_matter, script);
    			append_dev(main, t1);
    			append_dev(main, d_title);
    			append_dev(d_title, h1);
    			append_dev(main, t3);
    			append_dev(main, d_byline);
    			append_dev(main, t4);
    			append_dev(main, d_article);
    			append_dev(d_article, figure0);
    			mount_component(figure1, figure0, null);
    			append_dev(figure0, t5);
    			append_dev(figure0, figcaption0);
    			append_dev(figcaption0, t6);
    			append_dev(figcaption0, d_math0);
    			d_math0.innerHTML = raw0_value;
    			append_dev(figcaption0, t7);
    			append_dev(figcaption0, d_math1);
    			d_math1.innerHTML = raw1_value;
    			append_dev(figcaption0, t8);
    			append_dev(figcaption0, b0);
    			append_dev(figcaption0, t10);
    			append_dev(figcaption0, d_math2);
    			d_math2.innerHTML = raw2_value;
    			append_dev(figcaption0, t11);
    			append_dev(figcaption0, d_math3);
    			d_math3.innerHTML = raw3_value;
    			append_dev(figcaption0, t12);
    			append_dev(figcaption0, b1);
    			append_dev(figcaption0, t14);
    			append_dev(figcaption0, d_math4);
    			d_math4.innerHTML = raw4_value;
    			append_dev(figcaption0, t15);
    			append_dev(figcaption0, d_math5);
    			d_math5.innerHTML = raw5_value;
    			append_dev(figcaption0, t16);
    			append_dev(figcaption0, b2);
    			append_dev(figcaption0, t18);
    			append_dev(figcaption0, d_math6);
    			d_math6.innerHTML = raw6_value;
    			append_dev(figcaption0, t19);
    			append_dev(figcaption0, d_math7);
    			d_math7.innerHTML = raw7_value;
    			append_dev(figcaption0, t20);
    			append_dev(figcaption0, a);
    			append_dev(figcaption0, t22);
    			append_dev(d_article, t23);
    			append_dev(d_article, figure1_1);
    			mount_component(figure2, figure1_1, null);
    			append_dev(figure1_1, t24);
    			append_dev(figure1_1, figcaption1);
    			append_dev(figcaption1, b3);
    			append_dev(figcaption1, t26);
    			append_dev(figcaption1, b4);
    			append_dev(figcaption1, t28);
    			append_dev(figcaption1, d_math8);
    			d_math8.innerHTML = raw8_value;
    			append_dev(figcaption1, t29);
    			append_dev(figcaption1, d_math9);
    			d_math9.innerHTML = raw9_value;
    			append_dev(figcaption1, t30);
    			append_dev(figcaption1, d_math10);
    			d_math10.innerHTML = raw10_value;
    			append_dev(figcaption1, t31);
    			append_dev(d_article, t32);
    			mount_component(kernelmethods, d_article, null);
    			append_dev(main, t33);
    			append_dev(main, d_appendix);
    			current = true;
    		},
    		p: noop$5,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(figure1.$$.fragment, local);
    			transition_in(figure2.$$.fragment, local);
    			transition_in(kernelmethods.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(figure1.$$.fragment, local);
    			transition_out(figure2.$$.fragment, local);
    			transition_out(kernelmethods.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(figure1);
    			destroy_component(figure2);
    			destroy_component(kernelmethods);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		KernelMethods: Kernel_methods,
    		Figure1,
    		Figure2,
    		SourceChecksums
    	});

    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
