
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$5() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$5;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function empty$3() {
        return text$1('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$1(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$5,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$5;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.40.2' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /* src/kernel_methods.md generated by Svelte v3.40.2 */

    const file$9 = "src/kernel_methods.md";

    function create_fragment$9(ctx) {
    	let h10;
    	let t1;
    	let p0;
    	let d_math0;

    	let raw0_value = `\\small {1 \\over 2}
` + "";

    	let t2;
    	let p1;
    	let t3;
    	let d_math1;

    	let raw1_value = `(x_i, y_i)
` + "";

    	let t4;
    	let d_math2;

    	let raw2_value = `x_i
` + "";

    	let t5;
    	let d_math3;

    	let raw3_value = `(\\alpha_1, \\cdots, \\alpha_n)
` + "";

    	let t6;
    	let d_math4;

    	let raw4_value = `\\alpha_i
` + "";

    	let t7;
    	let t8;
    	let p2;
    	let t9;
    	let d_math5;

    	let raw5_value = `y_i
` + "";

    	let t10;
    	let d_math6;

    	let raw6_value = `\\alpha
` + "";

    	let t11;
    	let d_math7;

    	let raw7_value = `(x_i, y_i)
` + "";

    	let t12;
    	let t13;
    	let p3;
    	let t14;
    	let d_math8;

    	let raw8_value = `x_i
` + "";

    	let t15;
    	let d_math9;

    	let raw9_value = `k_j(x)
` + "";

    	let t16;
    	let d_math10;

    	let raw10_value = `(k_j(x_1), k_j(x_2), \\cdots, k_j(x_n))
` + "";

    	let t17;
    	let d_math11;

    	let raw11_value = `\\sigma
` + "";

    	let t18;
    	let d_math12;

    	let raw12_value = `n
` + "";

    	let t19;
    	let d_math13;

    	let raw13_value = `\\mathbb{R}^n
` + "";

    	let t20;
    	let d_math14;

    	let raw14_value = `(y_i)
` + "";

    	let t21;
    	let t22;
    	let p4;
    	let t24;
    	let d_math15;

    	let raw15_value = `
\\begin{aligned}
k_j(x) & & \\text{Gaussians centered at $x_j$, $j = 1 .. n$} \\\\
f(x) & \\equiv \\sum_j { \\alpha_j k_j(x) } & \\text{the blue curve}\\\\
f(x_i) & = \\sum_j { \\alpha_j k_j(x_i) } = y_i & \\text{fitting the blue curve to the black points} \\\\
\\bold{\\alpha K} & = \\bold{y} , & \\text{defining $K_{ji} \\equiv k_j(x_i)$, same equations, in matrix form} \\\\
\\end{aligned}
` + "";

    	let t25;
    	let p5;
    	let t26;
    	let d_math16;

    	let raw16_value = `\\bold{\\alpha}
` + "";

    	let t27;
    	let d_math17;

    	let raw17_value = `\\bold{K}
` + "";

    	let t28;
    	let d_math18;

    	let raw18_value = `\\bold{K}
` + "";

    	let t29;
    	let d_math19;

    	let raw19_value = `\\sigma
` + "";

    	let t30;
    	let d_math20;

    	let raw20_value = `(f_j(x_1), \\cdots, f_j(x_n))
` + "";

    	let t31;
    	let d_math21;

    	let raw21_value = `\\bold{\\alpha}
` + "";

    	let t32;
    	let t33;
    	let h20;
    	let t35;
    	let p6;
    	let strong0;
    	let t36;
    	let d_math22;

    	let raw22_value = `\\mathbb{R} \\times \\mathbb{R}
` + "";

    	let t37;
    	let t38;
    	let em0;
    	let t40;
    	let d_math23;

    	let raw23_value = `x_i
` + "";

    	let t41;
    	let d_math24;

    	let raw24_value = `k_j(\\cdot)
` + "";

    	let t42;
    	let d_math25;

    	let raw25_value = `(k_j(x_i))
` + "";

    	let t43;
    	let d_math26;

    	let raw26_value = `(x_i, y_i)
` + "";

    	let t44;
    	let t45;
    	let p7;
    	let strong1;
    	let t46;
    	let d_math27;

    	let raw27_value = `x_i
` + "";

    	let t47;
    	let em1;
    	let t49;
    	let d_math28;

    	let raw28_value = `n
` + "";

    	let t50;
    	let d_math29;

    	let raw29_value = `\\mathbb{R}^n
` + "";

    	let t51;
    	let d_math30;

    	let raw30_value = `n
` + "";

    	let t52;
    	let em2;
    	let t54;
    	let d_math31;

    	let raw31_value = `x_i
` + "";

    	let t55;
    	let t56;
    	let p8;
    	let strong2;
    	let t58;
    	let d_math32;

    	let raw32_value = `\\mathbb{R}
` + "";

    	let t59;
    	let t60;
    	let p9;
    	let strong3;
    	let t62;
    	let t63;
    	let p10;
    	let t64;
    	let d_math33;

    	let raw33_value = `\\bold{\\alpha}
` + "";

    	let t65;
    	let t66;
    	let h21;
    	let t68;
    	let p11;
    	let t70;
    	let p12;
    	let t71;
    	let strong4;
    	let t73;
    	let d_math34;

    	let raw34_value = `f_i: \\mathcal{X} \\mapsto \\mathcal{Y}
` + "";

    	let t74;
    	let d_math35;

    	let raw35_value = `f_i
` + "";

    	let t75;
    	let d_math36;

    	let raw36_value = `x_i \\in \\mathcal{X}
` + "";

    	let t76;
    	let d_math37;

    	let raw37_value = `x_i
` + "";

    	let t77;
    	let t78;
    	let p13;
    	let t79;
    	let strong5;
    	let t81;
    	let d_math38;

    	let raw38_value = `n
` + "";

    	let t82;
    	let d_math39;

    	let raw39_value = `n
` + "";

    	let t83;
    	let d_math40;

    	let raw40_value = `n
` + "";

    	let t84;
    	let d_math41;

    	let raw41_value = `\\mathcal{X}
` + "";

    	let t85;
    	let d_math42;

    	let raw42_value = `n
` + "";

    	let t86;
    	let em3;
    	let t88;
    	let d_math43;

    	let raw43_value = `(f_i(x_1), f_i(x_2), \\cdots, f_i(x_n))
` + "";

    	let t89;
    	let d_math44;

    	let raw44_value = `f_i(x)
` + "";

    	let t90;
    	let t91;
    	let p14;
    	let t92;
    	let strong6;
    	let t94;
    	let br0;
    	let d_math45;

    	let raw45_value = `f_i(x) \\equiv \\bold{p}_i \\cdot \\bold{\\phi}(x)
` + "";

    	let t95;
    	let d_math46;

    	let raw46_value = `\\bold{p}_i
` + "";

    	let t96;
    	let t97;
    	let p15;
    	let t98;
    	let d_math47;

    	let raw47_value = `\\sigma
` + "";

    	let t99;
    	let d_math48;

    	let raw48_value = `\\mu
` + "";

    	let t100;
    	let t101;
    	let h22;
    	let t102;
    	let d_math49;
    	let raw49_value = `\\sigma` + "";
    	let t103;
    	let p16;
    	let t104;
    	let d_math50;

    	let raw50_value = `\\mu
` + "";

    	let t105;
    	let d_math51;

    	let raw51_value = `x
` + "";

    	let t106;
    	let d_math52;

    	let raw52_value = `e^{axy}
` + "";

    	let t107;
    	let d_math53;

    	let raw53_value = `e^{-{\\small {1 \\over 2}} a(x-y)^2}
` + "";

    	let t108;
    	let d_math54;

    	let raw54_value = `a
` + "";

    	let t109;
    	let t110;
    	let d_math55;

    	let raw55_value = `
\\begin{aligned}
e^{axy} & = \\sum_{i=0} { \\dfrac{a^i(xy)^i}{i!} } & \\text{Taylor expansion} \\\\
& = \\sum_{i=0} { \\dfrac{(a^{\\small {1 \\over 2}} x)^i}{(i!)^{\\small {1 \\over 2}}} \\dfrac{(a^{\\small {1 \\over 2}} y)^i}{(i!)^{\\small {1 \\over 2}}} } & \\text{Separate $x$ and $y$ terms to symmetric roles} \\\\
& = \\sum_{i=0} { \\psi_{a,i}(x) \\psi_{a,i}(y) } & \\text{Let $\\psi_{a,i}(p) \\equiv \\dfrac{(a^{\\small {1 \\over 2}} p)^i}{(i!)^{\\small {1 \\over 2}}}$ }\\\\
& = \\vec{\\psi_a}(x) \\cdot \\vec{\\psi_a}(y) & \\text{Let $\\vec{\\psi_a}(p) \\equiv (\\psi_{a,1}(p), \\psi_{a,2}(p), \\cdots)$ } \\\\
\\end{aligned}
` + "";

    	let t111;
    	let p17;
    	let t112;
    	let d_math56;

    	let raw56_value = `e^{axy}
` + "";

    	let t113;
    	let d_math57;

    	let raw57_value = `x
` + "";

    	let t114;
    	let d_math58;

    	let raw58_value = `y
` + "";

    	let t115;
    	let t116;
    	let d_math59;

    	let raw59_value = `
\\begin{aligned}
e^{-{\\small {1 \\over 2}} a(x-y)^2} & = e^{-{\\small {1 \\over 2}} a(x^2-2xy+y^2)} \\\\[1em]
& = e^{-{\\small {1 \\over 2}} a x^2} e^{axy} e^{-{\\small {1 \\over 2}} a y^2} \\\\[1em]
& = e^{-{\\small {1 \\over 2}} a x^2} ( \\vec{\\psi_a}(x) \\cdot \\vec{\\psi_a}(y) ) e^{-{\\small {1 \\over 2}} a y^2} & \\text{substitute formula above} \\\\[1em]
& = (e^{-{\\small {1 \\over 2}} a x^2} \\vec{\\psi_a}(x) \\cdot e^{-{\\small {1 \\over 2}} a y^2} \\vec{\\psi_a}(y)) & \\text{By bilinearity of dot product} \\\\[1em]
& = \\vec{\\phi_a}(x) \\cdot \\vec{\\phi_a}(y) & \\text{Let $\\vec{\\phi_a}(p) \\equiv e^{-{\\small {1 \\over 2}} ap^2} \\vec{\\psi_a}(p)$} \\\\
\\end{aligned}
` + "";

    	let t117;
    	let p18;
    	let t118;
    	let d_math60;

    	let raw60_value = `a = \\tfrac{1}{\\sigma^2}
` + "";

    	let t119;
    	let d_math61;

    	let raw61_value = `e^{-\\tfrac{1}{2} {(\\tfrac{x - \\mu}{\\sigma})}^2 }
` + "";

    	let t120;
    	let d_math62;

    	let raw62_value = `\\dfrac{1}{\\sigma^{\\small {1 \\over 2}} (2 \\pi)^{\\small 1 \\over 4}}
` + "";

    	let t121;
    	let p19;
    	let t122;
    	let d_math63;

    	let raw63_value = `x
` + "";

    	let t123;
    	let d_math64;

    	let raw64_value = `\\mu
` + "";

    	let t124;
    	let d_math65;

    	let raw65_value = `\\mu
` + "";

    	let t125;
    	let d_math66;

    	let raw66_value = `x
` + "";

    	let t126;
    	let d_math67;

    	let raw67_value = `x
` + "";

    	let t127;
    	let d_math68;

    	let raw68_value = `\\mu
` + "";

    	let t128;
    	let d_math69;

    	let raw69_value = `\\mu \\in \\mathcal{X}
` + "";

    	let t129;
    	let t130;
    	let p20;
    	let t131;
    	let d_math70;

    	let raw70_value = `x = \\mu
` + "";

    	let t132;
    	let d_math71;

    	let raw71_value = `\\vec{\\phi_a}(\\mu) \\cdot \\vec{\\phi_a}(\\mu)
` + "";

    	let t133;
    	let d_math72;

    	let raw72_value = `\\vec{\\phi_a}(x)
` + "";

    	let t134;
    	let d_math73;

    	let raw73_value = `\\vec{\\phi_a}(\\mu)
` + "";

    	let t135;
    	let d_math74;

    	let raw74_value = `90^\\circ
` + "";

    	let t136;
    	let d_math75;

    	let raw75_value = `[0^\\circ, 90^\\circ)
` + "";

    	let t137;
    	let t138;
    	let p21;
    	let t139;
    	let d_math76;

    	let raw76_value = `\\sigma
` + "";

    	let t140;
    	let d_math77;

    	let raw77_value = `\\sigma
` + "";

    	let t141;
    	let d_math78;

    	let raw78_value = `\\vec{\\phi_a}(\\cdot)
` + "";

    	let t142;
    	let d_math79;

    	let raw79_value = `\\mu
` + "";

    	let t143;
    	let em4;
    	let t145;
    	let d_math80;

    	let raw80_value = `x
` + "";

    	let t146;
    	let t147;
    	let h23;
    	let t149;
    	let ol;
    	let li0;
    	let p22;
    	let t151;
    	let li8;
    	let p23;
    	let t153;
    	let ul0;
    	let li1;
    	let t155;
    	let li2;
    	let t157;
    	let li3;
    	let t159;
    	let li4;
    	let t161;
    	let li5;
    	let t163;
    	let li6;
    	let t165;
    	let li7;
    	let t167;
    	let h24;
    	let t169;
    	let p24;
    	let t170;
    	let em5;
    	let t172;
    	let t173;
    	let p25;
    	let t175;
    	let p26;
    	let t177;
    	let p27;
    	let t179;
    	let h25;
    	let t181;
    	let p28;
    	let t182;
    	let d_math81;

    	let raw81_value = `f_i(x)
` + "";

    	let t183;
    	let t184;
    	let d_math82;

    	let raw82_value = `
\\begin{aligned}
\\bold{E} & \\equiv
\\begin{bmatrix}
f_1(x_1) & f_1(x_2) & \\cdots & f_1(x_n) \\\\
f_2(x_1) & f_2(x_2) & \\cdots & f_2(x_n) \\\\
& & \\cdots & \\\\
f_n(x_1) & f_n(x_2) & \\cdots & f_n(x_n) \\\\
\\end{bmatrix}
& \\text{The matrix of row vectors of evaluation on the $x_i$} \\\\[1em]
\\bold{E} & =
\\begin{bmatrix}
\\bold{p}_1 \\cdot \\bold{\\phi}(x_1) &
\\bold{p}_1 \\cdot \\bold{\\phi}(x_2) &
\\cdots & 
\\bold{p}_1 \\cdot \\bold{\\phi}(x_n) \\\\
\\bold{p}_2 \\cdot \\bold{\\phi}(x_1) &
\\bold{p}_2 \\cdot \\bold{\\phi}(x_2) &
\\cdots &
\\bold{p}_2 \\cdot \\bold{\\phi}(x_n) \\\\
& & \\cdots \\\\
\\bold{p}_n \\cdot \\bold{\\phi}(x_1) &
\\bold{p}_n \\cdot \\bold{\\phi}(x_2) &
\\cdots &
\\bold{p}_n \\cdot \\bold{\\phi}(x_n) \\\\
\\end{bmatrix} & \\text{By definition of the $f_i(x)$} \\\\[1em]
& =
\\begin{bmatrix}
- \\bold{p}_1 - \\\\
- \\bold{p}_2 - \\\\
\\cdots \\\\
- \\bold{p}_n - \\\\
\\end{bmatrix} 
\\begin{bmatrix}
- \\bold{\\phi}(x_1) - \\\\
- \\bold{\\phi}(x_2) - \\\\
\\cdots \\\\
- \\bold{\\phi}(x_n) - \\\\
\\end{bmatrix}^T \\\\[1.5em]
& = \\bold{P F}^T & \\text{Defining matrices $\\bold{P}$ and $\\bold{F}$ appropriately} \\\\
\\end{aligned}
` + "";

    	let t185;
    	let p29;
    	let t186;
    	let d_math83;

    	let raw83_value = `\\bold{\\phi}(x_i)
` + "";

    	let t187;
    	let d_math84;

    	let raw84_value = `\\bold{\\phi}(\\cdot)
` + "";

    	let t188;
    	let d_math85;

    	let raw85_value = `x_i
` + "";

    	let t189;
    	let d_math86;

    	let raw86_value = `\\bold{\\phi}(\\cdot)
` + "";

    	let t190;
    	let d_math87;

    	let raw87_value = `\\bold{\\phi}(\\cdot)
` + "";

    	let t191;
    	let t192;
    	let p30;
    	let t193;
    	let d_math88;

    	let raw88_value = `\\bold{\\phi}(\\cdot)
` + "";

    	let t194;
    	let d_math89;

    	let raw89_value = `\\bold{p}_i
` + "";

    	let t195;
    	let d_math90;

    	let raw90_value = `\\texttt{span}(\\bold{\\phi}(x_i))
` + "";

    	let t196;
    	let t197;
    	let d_math91;

    	let raw91_value = `
\\begin{aligned}
\\bold{PF}^T & = (\\bold{P}_\\parallel + \\bold{P}_\\perp) \\bold{F}^T & \\text{by bilinearity of dot product} \\\\
& = \\bold{P}_\\parallel \\bold{F}^T & \\text{since $\\bold{P}_\\perp$ has zero contribution} \\\\[2em]
\\text{where: }
\\bold{P}_\\parallel & \\equiv
\\begin{bmatrix}
- \\bold{p}_{\\parallel,1} - \\\\
- \\bold{p}_{\\parallel,2} - \\\\
\\cdots \\\\
- \\bold{p}_{\\parallel,n} - \\\\
\\end{bmatrix} & \\text{matrix of parallel parts, relative to $\\texttt{span}(\\bold{\\phi}(x_i))$} \\\\
\\end{aligned}
` + "";

    	let t198;
    	let p31;
    	let t199;
    	let d_math92;

    	let raw92_value = `\\bold{p}_i = \\bold{p}_{\\parallel i} + \\bold{p}_{\\perp i}
` + "";

    	let t200;
    	let d_math93;

    	let raw93_value = `\\texttt{span}(\\bold{F})
` + "";

    	let t201;
    	let d_math94;

    	let raw94_value = `\\bold{p}_i
` + "";

    	let t202;
    	let d_math95;

    	let raw95_value = `\\texttt{span}(\\bold{P}_\\parallel) = \\texttt{span}(\\bold{F})
` + "";

    	let t203;
    	let d_math96;

    	let raw96_value = `\\bold{P}_\\perp
` + "";

    	let t204;
    	let t205;
    	let p32;
    	let t206;
    	let d_math97;

    	let raw97_value = `\\bold{\\alpha}
` + "";

    	let t207;
    	let d_math98;

    	let raw98_value = `\\bold{E}
` + "";

    	let t208;
    	let d_math99;

    	let raw99_value = `\\bold{y}
` + "";

    	let t209;
    	let d_math100;

    	let raw100_value = `\\bold{E}
` + "";

    	let t210;
    	let d_math101;

    	let raw101_value = `\\bold{y}
` + "";

    	let t211;
    	let d_math102;

    	let raw102_value = `y_i(x)
` + "";

    	let t212;
    	let em6;
    	let t214;
    	let t215;
    	let d_math103;

    	let raw103_value = `
\\begin{aligned}
f(x) & \\equiv \\sum_i { \\alpha_i f_i(x) } \\\\
& = \\sum_i {\\alpha_i (\\bold{p}_i \\cdot \\bold{\\phi}(x)) } & \\text{by definition of the $f_i(x)$} \\\\
& = (\\sum_i {\\alpha_i \\bold{p}_i}) \\cdot \\bold{\\phi}(x) & \\text{by linearity of dot product} \\\\
& = \\bold{\\alpha P} \\cdot \\bold{\\phi}(x) & \\text{in matrix form} \\\\
\\end{aligned}
` + "";

    	let t216;
    	let p33;
    	let t217;
    	let d_math104;

    	let raw104_value = `f(x)
` + "";

    	let t218;
    	let d_math105;

    	let raw105_value = `\\bold{\\alpha P}
` + "";

    	let t219;
    	let d_math106;

    	let raw106_value = `f(x)
` + "";

    	let t220;
    	let d_math107;

    	let raw107_value = `x_i
` + "";

    	let t221;
    	let d_math108;

    	let raw108_value = `\\bold{\\alpha P F}^T
` + "";

    	let t222;
    	let t223;
    	let p34;
    	let t224;
    	let d_math109;

    	let raw109_value = `\\bold{P}
` + "";

    	let t225;
    	let d_math110;

    	let raw110_value = `\\texttt{span}(\\bold{P}_\\parallel) = \\texttt{span}(\\bold{F})
` + "";

    	let t226;
    	let d_math111;

    	let raw111_value = `\\bold{P_\\parallel}
` + "";

    	let t227;
    	let d_math112;

    	let raw112_value = `\\bold{P_\\parallel} = \\bold{T} \\bold{F}
` + "";

    	let t228;
    	let d_math113;

    	let raw113_value = `n \\times n
` + "";

    	let t229;
    	let d_math114;

    	let raw114_value = `\\bold{T}
` + "";

    	let t230;
    	let t231;
    	let d_math115;

    	let raw115_value = `
\\begin{aligned}
\\bold{\\alpha P F}^T & = \\bold{\\alpha (P_\\parallel + P_\\perp) F}^T & \\text{orthogonal decomposition}\\\\
& = \\bold{\\alpha P_\\parallel F}^T & \\text{perpendicular component has zero contribution} \\\\
& = \\bold{\\alpha TFF}^T & \\text{substituting from above} \\\\
& = (\\bold{\\alpha T}) \\bold{FF}^T & \\text{reexpressing using a transformed $\\bold{\\alpha}$} \\\\
\\end{aligned}
` + "";

    	let t232;
    	let p35;
    	let t233;
    	let d_math116;

    	let raw116_value = `\\bold{\\alpha}
` + "";

    	let t234;
    	let d_math117;

    	let raw117_value = `\\bold{P}
` + "";

    	let t235;
    	let d_math118;

    	let raw118_value = `\\bold{\\alpha T}
` + "";

    	let t236;
    	let d_math119;

    	let raw119_value = `\\bold{F}
` + "";

    	let t237;
    	let d_math120;

    	let raw120_value = `\\bold{F}
` + "";

    	let t238;
    	let t239;
    	let p36;
    	let t240;
    	let d_math121;

    	let raw121_value = `\\bold{P} \\equiv \\bold{F}
` + "";

    	let t241;
    	let em7;
    	let t243;
    	let d_math122;

    	let raw122_value = `\\bold{P}
` + "";

    	let t244;
    	let d_math123;

    	let raw123_value = `\\bold{P} \\equiv \\bold{F}
` + "";

    	let t245;
    	let t246;
    	let h26;
    	let t248;
    	let p37;
    	let t249;
    	let d_math124;

    	let raw124_value = `f(x) = \\sum_i { \\alpha_i f_i(x) }
` + "";

    	let t250;
    	let d_math125;

    	let raw125_value = `\\bold{p} = \\sum_i { \\alpha_i \\bold{p}_i }
` + "";

    	let t251;
    	let d_math126;

    	let raw126_value = `a, b \\in \\mathcal{X}
` + "";

    	let t252;
    	let d_math127;

    	let raw127_value = `f(a)
` + "";

    	let t253;
    	let d_math128;

    	let raw128_value = `|f(a) - f(b)|
` + "";

    	let t254;
    	let t255;
    	let d_math129;

    	let raw129_value = `
\\begin{aligned}
\\bold{\\phi}_{a} & \\equiv \\bold{\\phi}(a) & \\text{notation} \\\\
f(a) & = \\bold{p} \\cdot \\bold{\\phi}_{a} & \\text{definition of $f(x)$} \\\\
& = \\|\\bold{p}\\| \\|\\bold{\\phi}_{a}\\| \\cos \\theta_{\\bold{p},\\bold{\\phi}_{a}} & \\text{definition of dot product} \\\\
\\implies |f(a)| & \\le \\|\\bold{p}\\|\\|\\bold{\\phi}_{a}\\| & \\text{Cauchy Schwarz inequality} \\\\[2em]
f(a) - f(b) & = \\bold{p} \\cdot \\bold{\\phi}_{a} - \\bold{p} \\cdot \\bold{\\phi}_{b} &\\text{definition of $f(x)$} \\\\
& = \\bold{p} \\cdot (\\bold{\\phi}_{a} - \\bold{\\phi}_{b}) & \\text{bilinearity of dot product} \\\\
& = \\|\\bold{p}\\| \\|\\bold{\\phi}_{a} - \\bold{\\phi}_{b}\\| \\cos \\theta_{\\bold{p}, \\bold{\\phi}_{a} - \\bold{\\phi}_{b}} & \\text{definition of dot product} \\\\
\\implies |f(a) - f(b)| & \\le \\|\\bold{p}\\| \\|\\bold{\\phi}_{a} - \\bold{\\phi}_{b}\\| & \\text{Cauchy Schwarz inequality} \\\\
\\end{aligned}
` + "";

    	let t256;
    	let p38;
    	let t257;
    	let d_math130;

    	let raw130_value = `f
` + "";

    	let t258;
    	let d_math131;

    	let raw131_value = `\\|\\bold{p\\|}
` + "";

    	let t259;
    	let d_math132;

    	let raw132_value = `\\|\\bold{\\phi\\|_{a}}
` + "";

    	let t260;
    	let d_math133;

    	let raw133_value = `\\bold{\\phi}(\\cdot)
` + "";

    	let t261;
    	let d_math134;

    	let raw134_value = `\\|\\bold{p\\|}
` + "";

    	let t262;
    	let d_math135;

    	let raw135_value = `f
` + "";

    	let t263;
    	let t264;
    	let p39;
    	let t265;
    	let d_math136;

    	let raw136_value = `\\|\\bold{\\phi\\|_{a} - \\bold{\\phi}_{b}}
` + "";

    	let t266;
    	let d_math137;

    	let raw137_value = `\\|\\bold{p\\|}
` + "";

    	let t267;
    	let t268;
    	let p40;
    	let t269;
    	let d_math138;

    	let raw138_value = `\\bold{\\phi}(\\cdot)
` + "";

    	let t270;
    	let d_math139;

    	let raw139_value = `\\bold{\\phi}(\\cdot)
` + "";

    	let t271;
    	let d_math140;

    	let raw140_value = `\\|\\bold{\\phi\\|_{a} - \\bold{\\phi}_{b}}
` + "";

    	let t272;
    	let d_math141;

    	let raw141_value = `|y_a - y_b|
` + "";

    	let t273;
    	let d_math142;

    	let raw142_value = `(a, b) \\in \\mathcal{X}
` + "";

    	let t274;
    	let t275;
    	let p41;
    	let t276;
    	let d_math143;

    	let raw143_value = `\\|\\bold{\\phi\\|_{a} - \\bold{\\phi}_{b}}
` + "";

    	let t277;
    	let d_math144;

    	let raw144_value = `f_i(x)
` + "";

    	let t278;
    	let t279;
    	let d_math145;

    	let raw145_value = `
\\begin{aligned}
f_i(x) & = \\bold{p}_i \\cdot \\bold{\\phi}(x) \\\\
& = \\bold{\\phi}(x_i) \\cdot \\bold{\\phi}(x)
\\end{aligned}
` + "";

    	let t280;
    	let p42;
    	let t281;
    	let d_math146;

    	let raw146_value = `\\mu
` + "";

    	let t282;
    	let d_math147;

    	let raw147_value = `\\bold{\\phi}(\\mu)
` + "";

    	let t283;
    	let d_math148;

    	let raw148_value = `\\bold{\\phi}(\\cdot)
` + "";

    	let t284;
    	let d_math149;

    	let raw149_value = `x \\in \\mathcal{X}
` + "";

    	let t285;
    	let d_math150;

    	let raw150_value = `x = \\mu
` + "";

    	let t286;
    	let t287;
    	let p43;
    	let t289;
    	let d_math151;

    	let raw151_value = `
\\begin{aligned}
\\|\\bold{\\phi\\|_{\\mu} - \\bold{\\phi}_{x}}^2 & = (\\bold{\\phi}_{\\mu} - \\bold{\\phi}_{x}) \\cdot (\\bold{\\phi}_{\\mu} - \\bold{\\phi}_{x}) \\\\
& = \\bold{\\phi}_{\\mu} \\cdot \\bold{\\phi}_{\\mu} - 2 \\bold{\\phi}_{\\mu} \\cdot \\bold{\\phi}_{x} + \\bold{\\phi}_{x} \\cdot \\bold{\\phi}_{x} \\\\
\\bold{\\phi}_{\\mu} \\cdot \\bold{\\phi}_{x} & & \\text{height of gaussian with location $\\mu$ at $x$} \\\\
\\bold{\\phi}_{\\mu} \\cdot \\bold{\\phi}_{\\mu}, \\,\\, \\bold{\\phi}_{x} \\cdot \\bold{\\phi}_{x} & & \\text{height of any gaussian at peak}
\\end{aligned}
` + "";

    	let t290;
    	let p44;
    	let t291;
    	let d_math152;

    	let raw152_value = `(x_b, y_b)
` + "";

    	let t292;
    	let d_math153;

    	let raw153_value = `(x_a, y_a)
` + "";

    	let t293;
    	let d_math154;

    	let raw154_value = `|y_b - y_a|
` + "";

    	let t294;
    	let d_math155;

    	let raw155_value = `\\bold{p}
` + "";

    	let t295;
    	let d_math156;

    	let raw156_value = `f(x_a) = y_a, f(x_b) = y_b
` + "";

    	let t296;
    	let d_math157;

    	let raw157_value = `x_a
` + "";

    	let t297;
    	let d_math158;

    	let raw158_value = `x_b
` + "";

    	let t298;
    	let d_math159;

    	let raw159_value = `\\|\\bold{\\phi\\|_{x_a} - \\bold{\\phi}_{x_b}}
` + "";

    	let t299;
    	let d_math160;

    	let raw160_value = `\\|\\bold{b\\|}
` + "";

    	let t300;
    	let d_math161;

    	let raw161_value = `\\bold{\\phi}(\\cdot)
` + "";

    	let t301;
    	let t302;
    	let h27;
    	let t304;
    	let p45;
    	let t305;
    	let d_math162;

    	let raw162_value = `\\bold{P} \\equiv \\bold{F}
` + "";

    	let t306;
    	let t307;
    	let d_math163;

    	let raw163_value = `
\\begin{aligned}
\\bold{F} & \\equiv 
\\begin{bmatrix}
- \\bold{\\phi}(x_1) - \\\\
- \\bold{\\phi}(x_2) - \\\\
\\cdots \\\\
- \\bold{\\phi}(x_n) - \\\\
\\end{bmatrix} & \\text{definition from before} \\\\
\\bold{\\alpha F} & & \\text{The parameter vector for the solution function $f(\\cdot)$}\\\\
\\bold{\\alpha F F}^T & & \\text{vector of evaluation of the solution function $f(\\cdot)$} \\\\
\\end{aligned}
` + "";

    	let t308;
    	let p46;
    	let t309;
    	let d_math164;

    	let raw164_value = `\\bold{\\alpha}
` + "";

    	let t310;
    	let t311;
    	let d_math165;

    	let raw165_value = `
\\begin{aligned}
\\bold{\\hat{\\alpha}} & = \\min_{\\alpha} { \\|\\bold{\\alpha F F\\|^T - \\bold{y}}^2 }
\\end{aligned}
` + "";

    	let t312;
    	let p47;
    	let t314;
    	let d_math166;

    	let raw166_value = `
\\begin{aligned}
\\bold{\\hat{\\alpha}} & = \\min_{\\alpha} ( \\|\\bold{\\alpha F F\\|^T - \\bold{y}}^2 + \\lambda \\|\\bold{\\alpha F\\|}^2 ) & \\text{sum of squared error, regularized by norm of $\\bold{p}$}\\\\
& = \\min_{\\alpha} ( \\|\\bold{\\alpha F F\\|^T - \\bold{y}}^2 + \\lambda \\bold{\\alpha F F}^T \\bold{\\alpha}^T )
\\end{aligned}
` + "";

    	let t315;
    	let p48;
    	let t317;
    	let d_math167;

    	let raw167_value = `
\\begin{aligned}
f(x) & = \\bold{p} \\cdot \\bold{\\phi}(x) \\\\
& = \\bold{\\hat{\\alpha} F} \\cdot \\bold{\\phi}(x)
\\end{aligned}
` + "";

    	let t318;
    	let p49;
    	let t319;
    	let d_math168;

    	let raw168_value = `\\mathcal{X}
` + "";

    	let t320;
    	let d_math169;

    	let raw169_value = `\\bold{\\phi}(x_i) \\cdot \\bold{\\phi}(x_j)
` + "";

    	let t321;
    	let d_math170;

    	let raw170_value = `\\bold{F F}^T
` + "";

    	let t322;
    	let t323;
    	let d_math171;

    	let raw171_value = `
\\begin{aligned}
k(x,x') & \\equiv \\bold{\\phi}(x) \\cdot \\bold{\\phi}(x') & \\text{The kernel function} \\\\
\\bold{K} & \\equiv [ \\bold{K}_{ij} = k(x_i, x_j) ] & \\text{The Kernel matrix, metric matrix or Gramm matrix} \\\\
& = \\bold{F F}^T & \\text{from above}
\\end{aligned}
` + "";

    	let t324;
    	let p50;
    	let t326;
    	let d_math172;

    	let raw172_value = `
\\begin{aligned}
\\bold{\\hat{\\alpha}} & = \\min_{\\alpha} ( \\|\\bold{\\alpha K\\|- \\bold{y}}^2 + \\lambda \\bold{\\alpha K} \\bold{\\alpha}^T )
\\end{aligned}
` + "";

    	let t327;
    	let p51;
    	let t329;
    	let d_math173;

    	let raw173_value = `
\\begin{aligned}
f(x) & = \\sum_i { \\hat{\\alpha}_i k(x_i, x) } \\\\
\\end{aligned}
` + "";

    	let t330;
    	let h28;
    	let t332;
    	let p52;
    	let t333;
    	let d_math174;

    	let raw174_value = `\\mathcal{X} \\times \\mathcal{Y}
` + "";

    	let t334;
    	let d_math175;

    	let raw175_value = `\\mathcal{X}
` + "";

    	let t335;
    	let em8;
    	let t337;
    	let d_math176;

    	let raw176_value = `\\mathcal{X}
` + "";

    	let t338;
    	let d_math177;

    	let raw177_value = `\\mathbb{R}^n
` + "";

    	let t339;
    	let d_math178;

    	let raw178_value = `\\mathcal{X}
` + "";

    	let t340;
    	let br1;
    	let d_math179;

    	let raw179_value = `\\mathcal{X}
` + "";

    	let t341;
    	let d_math180;

    	let raw180_value = `\\mathcal{X}
` + "";

    	let t342;
    	let d_math181;

    	let raw181_value = `\\mathbb{R}^n
` + "";

    	let t343;
    	let t344;
    	let p53;
    	let t345;
    	let d_math182;

    	let raw182_value = `\\mathbb{R}
` + "";

    	let t346;
    	let d_math183;

    	let raw183_value = `\\pi
` + "";

    	let t347;
    	let t348;
    	let p54;
    	let t349;
    	let d_math184;

    	let raw184_value = `K(a,b) \\gt K(a,a)
` + "";

    	let t350;
    	let d_math185;

    	let raw185_value = `a
` + "";

    	let t351;
    	let d_math186;

    	let raw186_value = `b
` + "";

    	let t352;
    	let d_math187;

    	let raw187_value = `K(\\cdot, \\cdot)
` + "";

    	let t353;
    	let d_math188;

    	let raw188_value = `a
` + "";

    	let t354;
    	let d_math189;

    	let raw189_value = `b
` + "";

    	let t355;
    	let t356;
    	let p55;
    	let t357;
    	let em9;
    	let t359;
    	let d_math190;

    	let raw190_value = `\\mathcal{X}
` + "";

    	let t360;
    	let t361;
    	let d_math191;

    	let raw191_value = `
\\begin{aligned}
a, b \\in \\mathcal{X} \\\\
K(a, b) & \\equiv \\|a\\| \\|b\\| \\cos\\theta_{ab} & \\text{The Kernel defines the value of the inner product} \\\\
\\implies \\|a\\| & = K(a,a)^{\\small {1 \\over 2}} \\\\
\\implies \\cos \\theta_{ab} & = \\dfrac{K(a, b)}{K(a, a)^\\frac{1}{2} K(b, b)^\\frac{1}{2}} \\\\[1em]
\\implies \\mathrm{dist}(a, b)^2 & = K(a, a) - 2K(a, b) + K(b, b) \\\\
\\end{aligned}
` + "";

    	let t362;
    	let h11;
    	let t364;
    	let p56;
    	let t366;
    	let p57;
    	let t368;
    	let ul1;
    	let li9;
    	let t369;
    	let d_math192;
    	let raw192_value = `a` + "";
    	let t370;
    	let d_math193;
    	let raw193_value = `b` + "";
    	let t371;
    	let d_math194;
    	let raw194_value = `\\|a-b\\|` + "";
    	let t372;
    	let li10;
    	let t374;
    	let li11;
    	let t376;
    	let li12;
    	let t378;
    	let li13;
    	let t380;
    	let p58;
    	let t381;
    	let d_math195;

    	let raw195_value = `a
` + "";

    	let t382;
    	let d_math196;

    	let raw196_value = `b
` + "";

    	let t383;
    	let d_math197;

    	let raw197_value = `\\|a\\|
` + "";

    	let t384;
    	let d_math198;

    	let raw198_value = `\\|b\\|
` + "";

    	let t385;
    	let d_math199;

    	let raw199_value = `\\theta_{ab}
` + "";

    	let t386;
    	let t387;
    	let d_math200;

    	let raw200_value = `
\\begin{aligned}
\\|b\\| \\cos\\theta_{ab} & \\equiv \\|\\mathrm{proj}_a b\\| & \\text{geometric definition of cosine} \\\\
\\|b\\| \\sin\\theta_{ab} & \\equiv \\|\\mathrm{proj}_{a\\bot\\| b} & \\text{geometric definition of sin} \\\\[1em]
\\|a-b\\|^2 & = (\\|a\\| - \\|\\mathrm{proj}_a b\\|)^2 + \\|\\mathrm{proj}_{a\\bot\\| b})^2 & \\text{Pythagoras definition of distance}\\\\
& = (\\|a\\| - \\|b\\|\\cos\\theta_{ab})^2 + (\\|b\\|\\sin\\theta_{ab})^2 \\\\
& = \\|a\\|^2 - 2\\|a\\|\\|b\\|\\cos\\theta_{ab} + \\|b\\|^2\\cos^2\\theta_{ab} + \\|b\\|^2\\sin^2\\theta_{ab} \\\\
& = \\|a\\|^2 - 2\\|a\\|\\|b\\|\\cos\\theta_{ab} + \\|b\\|^2 \\\\[1em]
& = \\|a\\|\\|a\\|\\cos\\theta_{aa} - 2\\|a\\|\\|b\\|\\cos\\theta_{ab} + \\|b\\|\\|b\\|\\cos\\theta_{bb} & \\text{Expand terms to same form} \\\\[1em]
f(a,b) & \\equiv \\|a\\|\\|b\\|\\cos\\theta_{ab} & \\text{Define $f$, the "inner product"} \\\\[1em]
\\|a-b\\|^2 & = f(a,a) -2f(a,b) + f(b,b) & \\text{Substituting in $f$} \\\\[1em]
\\end{aligned}
` + "";

    	let t388;
    	let p59;
    	let t389;
    	let d_math201;

    	let raw201_value = `f(a,b)
` + "";

    	let t390;
    	let d_math202;

    	let raw202_value = `a
` + "";

    	let t391;
    	let d_math203;

    	let raw203_value = `b
` + "";

    	let t392;
    	let t393;
    	let d_math204;

    	let raw204_value = `
\\begin{aligned}
& = f(a,a) -f(a,b) + f(-a,b) + f(b,b) & \\text{f is symmetric and bilinear} \\\\
& = f(a,a-b) + f(b-a,b) \\\\
& = f(a,a-b) + f(-b,a-b) \\\\
& = f(a-b,a-b) \\\\[1em]
\\|a-b\\|^2 & = f(a,a) - 2f(a,b) + f(b,b) & \\text{Formula that doesn't require any expression $a-b$} \\\\
\\end{aligned}
` + "";

    	let t394;
    	let h29;
    	let t396;
    	let p60;
    	let t397;
    	let d_math205;

    	let raw205_value = `\\langle f_\\bold{p}, f_\\bold{q} \\rangle \\equiv \\bold{p} \\cdot \\bold{q}
` + "";

    	let t398;
    	let t399;
    	let p61;
    	let t400;
    	let d_math206;

    	let raw206_value = `f_\\bold{p}(\\cdot)
` + "";

    	let t401;
    	let d_math207;

    	let raw207_value = `\\bold{\\phi}(\\cdot)
` + "";

    	let t402;
    	let d_math208;

    	let raw208_value = `\\bold{p}
` + "";

    	let t403;
    	let d_math209;

    	let raw209_value = `f_\\bold{p}(\\cdot)
` + "";

    	let t404;
    	let t405;
    	let p62;
    	let t406;
    	let d_math210;

    	let raw210_value = `\\mathcal{F}
` + "";

    	let t407;
    	let d_math211;

    	let raw211_value = `\\bold{\\phi}(\\cdot) = \\{\\phi_1(\\cdot), \\phi_2(\\cdot), \\cdots\\}
` + "";

    	let t408;
    	let d_math212;

    	let raw212_value = `\\phi_i(\\cdot)
` + "";

    	let t409;
    	let d_math213;

    	let raw213_value = `\\mathcal{F}
` + "";

    	let t410;
    	let d_math214;

    	let raw214_value = `\\mathcal{F} = \\mathbb{R}^{\\{\\phi_1(\\cdot), \\phi_2(\\cdot), \\cdots\\}}
` + "";

    	let t411;
    	let t412;
    	let p63;
    	let t413;
    	let d_math215;

    	let raw215_value = `f: \\mathcal{X} \\mapsto \\mathbb{R}
` + "";

    	let t414;
    	let d_math216;

    	let raw216_value = `\\mathcal{H}
` + "";

    	let t415;
    	let em10;
    	let t417;
    	let d_math217;

    	let raw217_value = `\\mathcal{H} = \\mathbb{R}^\\mathcal{X}
` + "";

    	let t418;
    	let d_math218;

    	let raw218_value = `\\langle f_\\bold{p}, f_\\bold{q} \\rangle_\\mathcal{H} \\equiv \\bold{p} \\cdot \\bold{q}
` + "";

    	let t419;
    	let d_math219;

    	let raw219_value = `n
` + "";

    	let t420;
    	let d_math220;

    	let raw220_value = `\\mathcal{H}
` + "";

    	let t421;
    	let d_math221;

    	let raw221_value = `n
` + "";

    	let t422;
    	let t423;
    	let p64;
    	let t424;
    	let d_math222;

    	let raw222_value = `\\mathcal{F} \\equiv \\mathbb{R}^{\\{\\phi_1(\\cdot), \\phi_2(\\cdot), \\cdots\\}}
` + "";

    	let t425;
    	let em11;
    	let t427;
    	let d_math223;

    	let raw223_value = `\\mathcal{X}
` + "";

    	let t428;
    	let d_math224;

    	let raw224_value = `\\mathcal{F}
` + "";

    	let t429;
    	let em12;
    	let t431;
    	let d_math225;

    	let raw225_value = `\\mathcal{H}
` + "";

    	let t432;
    	let d_math226;

    	let raw226_value = `\\mathcal{F}
` + "";

    	let t433;
    	let t434;
    	let p65;
    	let t435;
    	let d_math227;

    	let raw227_value = `\\mathcal{H} \\equiv \\mathbb{R}^\\mathcal{X}
` + "";

    	let t436;
    	let d_math228;

    	let raw228_value = `\\mathcal{F}
` + "";

    	let t437;
    	let d_math229;

    	let raw229_value = `\\mathcal{H}
` + "";

    	let t438;
    	let t439;
    	let h210;
    	let t440;
    	let d_math230;
    	let raw230_value = `\\mathcal{X}` + "";
    	let t441;
    	let p66;
    	let t442;
    	let d_math231;

    	let raw231_value = `\\mathbb{R}
` + "";

    	let t443;
    	let d_math232;

    	let raw232_value = `\\mathcal{X}
` + "";

    	let t444;
    	let d_math233;

    	let raw233_value = `\\mathcal{X}
` + "";

    	let t445;
    	let d_math234;

    	let raw234_value = `x \\in \\mathcal{X}
` + "";

    	let t446;
    	let d_math235;

    	let raw235_value = `\\mathcal{X}
` + "";

    	let t447;
    	let d_math236;

    	let raw236_value = `\\mathcal{X} \\times \\mathcal{X} \\mapsto \\mathbb{R}
` + "";

    	let t448;
    	let d_math237;

    	let raw237_value = `k_i(x)
` + "";

    	let t449;
    	let d_math238;

    	let raw238_value = `\\sigma
` + "";

    	let t450;
    	let d_math239;

    	let raw239_value = `x_i
` + "";

    	let t451;
    	let t452;
    	let p67;
    	let t454;
    	let p68;
    	let t455;
    	let d_math240;

    	let raw240_value = `n
` + "";

    	let t456;
    	let d_math241;

    	let raw241_value = `\\sigma
` + "";

    	let t457;
    	let d_math242;

    	let raw242_value = `n
` + "";

    	let t458;
    	let d_math243;

    	let raw243_value = `n
` + "";

    	let t459;
    	let d_math244;

    	let raw244_value = `n
` + "";

    	let t460;
    	let t461;
    	let h211;
    	let t463;
    	let p69;
    	let t465;
    	let h212;
    	let t467;
    	let h213;
    	let t469;
    	let h214;
    	let t471;
    	let p70;
    	let t473;
    	let h215;
    	let t475;
    	let p71;
    	let t477;
    	let p72;
    	let d_math245;

    	let raw245_value = `\\max\\limits_{\\alpha \\in \\mathbb{R}^n, \\beta \\in \\mathbb{R}^n} \\dfrac{\\alpha^T K_\\alpha K_\\beta \\beta}{(\\alpha^TK_\\alpha^2 \\alpha)^{\\frac{1}{2}} (\\beta^T K_\\beta^2 \\beta)^{\\frac{1}{2}} }
` + "";

    	let t478;
    	let p73;
    	let t479;
    	let a0;
    	let t481;
    	let h216;
    	let t483;
    	let p74;
    	let t484;
    	let em13;
    	let t486;
    	let d_math246;

    	let raw246_value = `f
` + "";

    	let t487;
    	let d_math247;

    	let raw247_value = `(x, y)
` + "";

    	let t488;
    	let d_math248;

    	let raw248_value = `\\mu = y f(x)
` + "";

    	let t489;
    	let d_math249;

    	let raw249_value = `\\phi(\\mu)
` + "";

    	let t490;
    	let t491;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t493;
    	let th1;
    	let d_math250;
    	let raw250_value = `\\phi(\\mu)` + "";
    	let t494;
    	let tbody;
    	let tr1;
    	let td0;
    	let t496;
    	let td1;
    	let d_math251;
    	let raw251_value = `\\log(1 + e^{-\\mu}` + "";
    	let t497;
    	let tr2;
    	let td2;
    	let t499;
    	let td3;
    	let d_math252;
    	let raw252_value = `\\max(1-\\mu, 0)` + "";
    	let t500;
    	let tr3;
    	let td4;
    	let t502;
    	let td5;
    	let d_math253;
    	let raw253_value = ` \\max(1-\\mu, 0)^2` + "";
    	let t503;
    	let tr4;
    	let td6;
    	let t505;
    	let td7;
    	let d_math254;
    	let raw254_value = `e^{-\\mu}` + "";
    	let t506;
    	let p75;
    	let t508;
    	let d_math255;

    	let raw255_value = `
\\begin{aligned}
& \\min_{f \\in \\mathcal{H}} { \\dfrac{1}{\\mu} \\sum { \\phi(y_i f(x_i)) + \\lambda \\|f\\|^2_{\\mathcal{H}} } } \\\\
f(x) & = \\sum { \\alpha_i K(x_i, x) } & \\text{By representer theorem}\\\\
& \\min_{\\alpha \\in \\mathbb{R}^n} { \\dfrac{1}{n} \\sum { \\phi(y_i [K\\alpha]_i) + \\lambda \\alpha^T K \\alpha } } & \\text{plugging in}\\\\
\\end{aligned}
` + "";

    	let t509;
    	let p76;
    	let t510;
    	let d_math256;

    	let raw256_value = `\\alpha
` + "";

    	let t511;
    	let t512;
    	let p77;
    	let d_math257;

    	let raw257_value = `f(x) = \\sum { \\alpha_i K(x_i, x) } = \\sum\\limits_{i \\in SV} { \\alpha_i K(x_i, x) }
` + "";

    	let t513;
    	let p78;
    	let t515;
    	let h217;
    	let t517;
    	let p79;
    	let t518;
    	let a1;

    	const block = {
    		c: function create() {
    			h10 = element("h1");
    			h10.textContent = "An illustration of Kernel Regression";
    			t1 = space();
    			p0 = element("p");
    			d_math0 = element("d-math");
    			t2 = space();
    			p1 = element("p");
    			t3 = text$1("In the interactive figure, data points \n");
    			d_math1 = element("d-math");
    			t4 = text$1(" are shown as black dots.  There is one Gaussian centered at each \n");
    			d_math2 = element("d-math");
    			t5 = text$1(".  The blue curve is a linear combination \n");
    			d_math3 = element("d-math");
    			t6 = text$1(" of these Gaussians.  Each slider controls one of the \n");
    			d_math4 = element("d-math");
    			t7 = text$1(".");
    			t8 = space();
    			p2 = element("p");
    			t9 = text$1("You can adjust the sliders to make the blue curve perfectly fit the \n");
    			d_math5 = element("d-math");
    			t10 = text$1(".  It may be surprising to note that a unique, perfect-fitting \n");
    			d_math6 = element("d-math");
    			t11 = text$1(" exists for any set of \n");
    			d_math7 = element("d-math");
    			t12 = text$1(" and for any number of points.");
    			t13 = space();
    			p3 = element("p");
    			t14 = text$1("To see why, note that each gray curve's set of values along the \n");
    			d_math8 = element("d-math");
    			t15 = text$1(" produces a vector.  (You can toggle the 'points' checkbox to see these.  Denoting the j'th curve as \n");
    			d_math9 = element("d-math");
    			t16 = text$1(", the set of values it produces is \n");
    			d_math10 = element("d-math");
    			t17 = text$1(".  Particularly for a collection of Gaussians all with the same \n");
    			d_math11 = element("d-math");
    			t18 = text$1(", the set of these \n");
    			d_math12 = element("d-math");
    			t19 = text$1(" vectors are linearly independent.  This is not at all obvious, but please accept it for now.  Then, by the linear algebra expansion theorem, they span \n");
    			d_math13 = element("d-math");
    			t20 = text$1(" and so can form any set of \n");
    			d_math14 = element("d-math");
    			t21 = text$1(".");
    			t22 = space();
    			p4 = element("p");
    			p4.textContent = "Explicitly:";
    			t24 = space();
    			d_math15 = element("d-math");
    			t25 = space();
    			p5 = element("p");
    			t26 = text$1("The \n");
    			d_math16 = element("d-math");
    			t27 = text$1(" that fits the data perfectly is found by inverting \n");
    			d_math17 = element("d-math");
    			t28 = text$1(", which is possible because \n");
    			d_math18 = element("d-math");
    			t29 = text$1(" is full-rank.  That is, its rows are linearly independent, due to the property of a collections of Gaussians of the same \n");
    			d_math19 = element("d-math");
    			t30 = text$1(".  Even though we are taking linear combinations of functions, it is only the tuple of function values \n");
    			d_math20 = element("d-math");
    			t31 = text$1(" which affects the choice of \n");
    			d_math21 = element("d-math");
    			t32 = text$1(".");
    			t33 = space();
    			h20 = element("h2");
    			h20.textContent = "Some Observations";
    			t35 = space();
    			p6 = element("p");
    			strong0 = element("strong");
    			t36 = text$1("This method can fit any set of data in \n");
    			d_math22 = element("d-math");
    			t37 = text$1(".");
    			t38 = text$1("  Given a ");
    			em0 = element("em");
    			em0.textContent = "particular";
    			t40 = text$1(" set \n");
    			d_math23 = element("d-math");
    			t41 = text$1(", you could hand-pick a set of functions \n");
    			d_math24 = element("d-math");
    			t42 = text$1(" which happen to produce linearly independent vectors \n");
    			d_math25 = element("d-math");
    			t43 = text$1(" of evaluation on that particular data set.  However, the procedure shown above can fit any data set \n");
    			d_math26 = element("d-math");
    			t44 = text$1(".  This is useful because it would be laborious to have to hand-pick functions for each new data set.");
    			t45 = space();
    			p7 = element("p");
    			strong1 = element("strong");
    			t46 = text$1("There is nothing (yet) special about the Gaussians being centered at the \n");
    			d_math27 = element("d-math");
    			t47 = text$1(".  It turns out that ");
    			em1 = element("em");
    			em1.textContent = "any";
    			t49 = text$1(" choice of \n");
    			d_math28 = element("d-math");
    			t50 = text$1(" Gaussians will span \n");
    			d_math29 = element("d-math");
    			t51 = text$1(" when evaluated at any \n");
    			d_math30 = element("d-math");
    			t52 = text$1(" values.  There ");
    			em2 = element("em");
    			em2.textContent = "is";
    			t54 = text$1(" indeed something special about the Gaussians being centered at the \n");
    			d_math31 = element("d-math");
    			t55 = text$1(", but it has nothing to do with the ability to fit arbitrary data.");
    			t56 = space();
    			p8 = element("p");
    			strong2 = element("strong");
    			strong2.textContent = "Many functions have this infinite capacity";
    			t58 = text$1(".  Not just Gaussians, but many other families of functions have this capacity to perfectly fit any data, due to the vectors of evaluation being linearly independent.  Not only that, but families of functions can be found for many different domains, not just \n");
    			d_math32 = element("d-math");
    			t59 = text$1(" as shown above.   Both discrete and continuous domains, and of arbitrary dimensions.");
    			t60 = space();
    			p9 = element("p");
    			strong3 = element("strong");
    			strong3.textContent = "Linear independence is preserved under permutation of components";
    			t62 = text$1(".  The Gaussians are able to fit any data because they produce vectors that are linearly independent.  But, note that vectors that are linearly independent would still be so, after you permute their elements all in the same way.  For vectors, there is no meaning to the ordering of the elements.  To illustrate, click the 'scramble' button.  This reorders the x-axis in one-to-one fashion by reversing the order of every other interval of some fixed size.  Or think of it as re-ordering the components of the Gaussian \"vectors\" all in the same way, preserving their linear independence.  You can still click 'solve' and a unique solution exists.");
    			t63 = space();
    			p10 = element("p");
    			t64 = text$1("Of course, these permuted Gaussians don't have the same relationship with the original data, so there will be a different \n");
    			d_math33 = element("d-math");
    			t65 = text$1(" solution.  This is only to show that the continuity or shape of the original Gaussians is not what gives them this capacity to fit arbitrary data.");
    			t66 = space();
    			h21 = element("h2");
    			h21.textContent = "The three design choices underlying all Kernel methods";
    			t68 = space();
    			p11 = element("p");
    			p11.textContent = "Underlying all Kernel methods are three choices for how to construct the function to fit a given data set.  Like all machine learning methods, these chocies are guided by classic requirements.  First, the approach must be a \"universal approximator\", thus be able to fit any data set.  Second, it should be possible to regularize.  Finally, it should be computationally tractable.  The three design choices serve these requirements as you will see.";
    			t70 = space();
    			p12 = element("p");
    			t71 = text$1("The ");
    			strong4 = element("strong");
    			strong4.textContent = "first design choice";
    			t73 = text$1(" is, we specify a family of functions \n");
    			d_math34 = element("d-math");
    			t74 = text$1(", such that there is exactly one member of the family, \n");
    			d_math35 = element("d-math");
    			t75 = text$1(", corresponding to each element \n");
    			d_math36 = element("d-math");
    			t76 = text$1(".  We then use the subset of this family corresponding to our \n");
    			d_math37 = element("d-math");
    			t77 = text$1(" to build a solution function as a linear combination of them.  The fact that the functions are already indexed makes the approach automatic.  There is no hand-specifying a set of functions tailor made for each new data set.  This choice also serves the purpose of regularization, to be proved later.");
    			t78 = space();
    			p13 = element("p");
    			t79 = text$1("The ");
    			strong5 = element("strong");
    			strong5.textContent = "second choice";
    			t81 = text$1(" is that the family of functions should have the following property:  For any value of \n");
    			d_math38 = element("d-math");
    			t82 = text$1(", and for any \n");
    			d_math39 = element("d-math");
    			t83 = text$1(" functions from the family, and for any choice of \n");
    			d_math40 = element("d-math");
    			t84 = text$1(" evaluation points in \n");
    			d_math41 = element("d-math");
    			t85 = text$1(", the set of \n");
    			d_math42 = element("d-math");
    			t86 = space();
    			em3 = element("em");
    			em3.textContent = "vectors of evaluation";
    			t88 = text$1(" of the chosen functions should be linearly independent.  A \"vector of evaluation\" is my term for the vector of function values in some order of data set points.  For example, \n");
    			d_math43 = element("d-math");
    			t89 = text$1(" is function \n");
    			d_math44 = element("d-math");
    			t90 = text$1("'s vector of evaluation.  This choice allows the approach to fit any data set, as argued above by appealing to the linear algebra expansion theorem.  This makes the approach a \"universal approximator\".  As an aside, there are choices of families that don't have this property, but since we are speaking generally about the approach of Kernel methods, it is important that some families do exhibit this property.");
    			t91 = space();
    			p14 = element("p");
    			t92 = text$1("The ");
    			strong6 = element("strong");
    			strong6.textContent = "third choice";
    			t94 = text$1(" is the biggest leap.  It is that the functions in the family have the following form:");
    			br0 = element("br");
    			d_math45 = element("d-math");
    			t95 = text$1(".  That is, each function is identified by a distinct \"parameter vector\" \n");
    			d_math46 = element("d-math");
    			t96 = text$1(", and the function is defined as the dot product between its parameter vector and some as-yet undefined vector-valued function of the input.  As I will show soon, this third provides a way to regularize the method, and makes finding the solution function readily computable.  It also maintains the first goal of having arbitrary capacity to fit any data.");
    			t97 = space();
    			p15 = element("p");
    			t98 = text$1("To motivate these ideas and make the discussion more concrete, I will show that the gaussian family of functions, all with the same \n");
    			d_math47 = element("d-math");
    			t99 = text$1(" and indexed over \n");
    			d_math48 = element("d-math");
    			t100 = text$1(", fit these three design requirements.");
    			t101 = space();
    			h22 = element("h2");
    			t102 = text$1("The set of gaussians sharing the same ");
    			d_math49 = element("d-math");
    			t103 = space();
    			p16 = element("p");
    			t104 = text$1("The values of the gaussian distribution turn out to be a dot product between two infinite dimensional vectors.  The first vector is a function of \n");
    			d_math50 = element("d-math");
    			t105 = text$1(", and the second, the same function of \n");
    			d_math51 = element("d-math");
    			t106 = text$1(".  To show this, we first show how the simpler formula \n");
    			d_math52 = element("d-math");
    			t107 = text$1(" can be written as a dot product.  Then, using this first result, we show that \n");
    			d_math53 = element("d-math");
    			t108 = text$1(" can also be written as a dot product.  The gaussian is just a scaled version with a special choice for \n");
    			d_math54 = element("d-math");
    			t109 = text$1(".");
    			t110 = space();
    			d_math55 = element("d-math");
    			t111 = space();
    			p17 = element("p");
    			t112 = text$1("We've shown that \n");
    			d_math56 = element("d-math");
    			t113 = text$1(" can be written as a dot product between the vector valued function of \n");
    			d_math57 = element("d-math");
    			t114 = text$1(" and the same function of \n");
    			d_math58 = element("d-math");
    			t115 = text$1(".  Now:");
    			t116 = space();
    			d_math59 = element("d-math");
    			t117 = space();
    			p18 = element("p");
    			t118 = text$1("Letting \n");
    			d_math60 = element("d-math");
    			t119 = text$1(", we have \n");
    			d_math61 = element("d-math");
    			t120 = text$1(" and all that remains is to scale both vectors by \n");
    			d_math62 = element("d-math");
    			t121 = space();
    			p19 = element("p");
    			t122 = text$1("In particular, this emphasizes the symmetric roles of \n");
    			d_math63 = element("d-math");
    			t123 = text$1(" and \n");
    			d_math64 = element("d-math");
    			t124 = text$1(" in a gaussian:  evaluating a gaussian centered at \n");
    			d_math65 = element("d-math");
    			t125 = text$1(" at \n");
    			d_math66 = element("d-math");
    			t126 = text$1(" is the same as one centered at \n");
    			d_math67 = element("d-math");
    			t127 = text$1(" evaluated at \n");
    			d_math68 = element("d-math");
    			t128 = text$1(".  So, each member of the family of gaussians corresponds to some \n");
    			d_math69 = element("d-math");
    			t129 = text$1(".  This doesn't prove that gaussians have an arbitrary ability to produce linearly independent vectors of evaluation, but for the moment, just accept it.");
    			t130 = space();
    			p20 = element("p");
    			t131 = text$1("Another thing that is apparent from this is that the height at the peak of every gaussian, the location where \n");
    			d_math70 = element("d-math");
    			t132 = text$1(", is the value of \n");
    			d_math71 = element("d-math");
    			t133 = text$1(".  Since all the heights are the same, this means all the feature vectors are the same length.  The value of the gaussian as you move away from the peak approaches zero.  This represents the angle between two vectors \n");
    			d_math72 = element("d-math");
    			t134 = text$1(" and \n");
    			d_math73 = element("d-math");
    			t135 = text$1(" approaching \n");
    			d_math74 = element("d-math");
    			t136 = text$1(".  And, since the gaussian is positive everywhere, the angle ranges in \n");
    			d_math75 = element("d-math");
    			t137 = text$1(" in the infinite dimensional feature space.");
    			t138 = space();
    			p21 = element("p");
    			t139 = text$1("Note also that, although \n");
    			d_math76 = element("d-math");
    			t140 = text$1(" is also called a \"parameter\" of the gaussian, \n");
    			d_math77 = element("d-math");
    			t141 = text$1("'s role here is a constant baked into the \n");
    			d_math78 = element("d-math");
    			t142 = text$1(" function induced by the gaussian, while \n");
    			d_math79 = element("d-math");
    			t143 = text$1(" is an ");
    			em4 = element("em");
    			em4.textContent = "argument";
    			t145 = text$1(" to the function, and treated in a symmetric role with the \n");
    			d_math80 = element("d-math");
    			t146 = text$1(".");
    			t147 = space();
    			h23 = element("h2");
    			h23.textContent = "Things to do in the plot to build intuition";
    			t149 = space();
    			ol = element("ol");
    			li0 = element("li");
    			p22 = element("p");
    			p22.textContent = "Illustrate in the Kernel figure how a selection of data induces a matrix";
    			t151 = space();
    			li8 = element("li");
    			p23 = element("p");
    			p23.textContent = "Describe tasks to try on the interactive chart:\nA.  Function Norm";
    			t153 = space();
    			ul0 = element("ul");
    			li1 = element("li");
    			li1.textContent = "Shrink sigma until the gray curves are well separated, so that at each\ncurve's peak, all the other curves are near zero";
    			t155 = space();
    			li2 = element("li");
    			li2.textContent = "Reset the alphas to 1.0";
    			t157 = space();
    			li3 = element("li");
    			li3.textContent = "Notice that the function norm for that function is just sqrt(num points)\nB.  Exploding Norm";
    			t159 = space();
    			li4 = element("li");
    			li4.textContent = "Start with a data set that has a reasonable norm solution";
    			t161 = space();
    			li5 = element("li");
    			li5.textContent = "In auto-solve mode, drag one of the data points circularly around another\npoint";
    			t163 = space();
    			li6 = element("li");
    			li6.textContent = "Notice that the function norm explodes as the second point passes over\nthe first";
    			t165 = space();
    			li7 = element("li");
    			li7.textContent = "Adjust the sigma to be small, and notice that, with smaller sigma, the\nnorm doesn't explode as fast\nC.";
    			t167 = space();
    			h24 = element("h2");
    			h24.textContent = "Consequences of the choice of a Kernel";
    			t169 = space();
    			p24 = element("p");
    			t170 = text$1("There are a few exercises you can do in the interactive chart that are illuminating.  Try dragging one of the black dots while ");
    			em5 = element("em");
    			em5.textContent = "auto solve";
    			t172 = text$1(" is checked.  You will notice that if you drag the dot near another dot, the blue curve is forced to become almost vertical, and the function norm explodes.  In kernel terms, what is happening is that two data points that are extremely close according to the kernel, are in fact distant in terms of their y-values.  The kernel's idea of distance is mismatched with that of the data labels.");
    			t173 = space();
    			p25 = element("p");
    			p25.textContent = "Leaving one pair of black dots close to each other on the X-axis, you can reduce the function norm by reducing the Sigma slider.  This changes the kernel so that it considers those two data points far apart.  This allows a smaller norm function to fit the data.  In the limit of small sigma, the kernel considers every pair of points to be maximally far away (orthogonal in feature space).  Thus, the contributions of each individual curve to the overall function have no influence on each other.  But, the function also doesn't interpolate at all.  In other words, if you consider a particular pair of points to be \"close\", you would then expect their y-values to be similar, but the kernel does not, so the resulting solution function will be useless for predicting values of unseen data.";
    			t175 = space();
    			p26 = element("p");
    			p26.textContent = "When you hit the 'scramble' button, you can see that the kernel has a definition of distance that runs counter to the spatial distance of the graph.  A pair of points that are nearly adjacent along the X-axis, but span a jump in the kernel values are considered distant, while a pair of points separated along the X-axis might have nearly the same kernel value.  Consequently, with this \"kernel\" (it is actually not a proper kernel, but it still is capable of perfectly fitting the data), one can set a pair of points such that they are far in X-axis distance, but very close in kernel distance.  In that case, the function norm will be very sensitive to the difference in y-values of the two points.  And, you can adjust a pair of points to be on either side of a discontinuity.  In that case, the two points may have very different y-values and still allow to be fit with a small-norm solution function (blue curve).";
    			t177 = space();
    			p27 = element("p");
    			p27.textContent = "All of this is to emphasize that it is the Kernel's notion of distance which determines the interpolation behavior of kernel methods.";
    			t179 = space();
    			h25 = element("h2");
    			h25.textContent = "A Natural choice for parameter vectors";
    			t181 = space();
    			p28 = element("p");
    			t182 = text$1("Below we write the vectors of evaluation of the \n");
    			d_math81 = element("d-math");
    			t183 = text$1(" as row vectors.  We would like them to be linearly independent.  Given the definition of the functions as dot products of feature vectors, this expression is simply a product of matrices.");
    			t184 = space();
    			d_math82 = element("d-math");
    			t185 = space();
    			p29 = element("p");
    			t186 = text$1("It is apparent that we need the \n");
    			d_math83 = element("d-math");
    			t187 = text$1(" to be linearly independent at least.  Indeed, the arbitrary capacity of this family of functions to fit any data comes directly from the capacity of \n");
    			d_math84 = element("d-math");
    			t188 = text$1(" to generate linearly independent vectors for any set of \n");
    			d_math85 = element("d-math");
    			t189 = text$1(", however large.  To achieve this, \n");
    			d_math86 = element("d-math");
    			t190 = text$1(" must be infinite-dimensional.  If, for example, \n");
    			d_math87 = element("d-math");
    			t191 = text$1(" were 10-dimensional, the resulting family would only have the capacity to perfectly fit up to 10 data points.");
    			t192 = space();
    			p30 = element("p");
    			t193 = text$1("Besides this property of \n");
    			d_math88 = element("d-math");
    			t194 = text$1(", we need to choose the \n");
    			d_math89 = element("d-math");
    			t195 = text$1(" such that their projection onto \n");
    			d_math90 = element("d-math");
    			t196 = text$1(" is also linearly independent.  Explicitly:");
    			t197 = space();
    			d_math91 = element("d-math");
    			t198 = space();
    			p31 = element("p");
    			t199 = text$1("Explicitly, the above is decomposing each \n");
    			d_math92 = element("d-math");
    			t200 = text$1(", relative to \n");
    			d_math93 = element("d-math");
    			t201 = text$1(".   In order for the vectors of evaluation to be linearly independent and thus achieve the goal of arbitrary fitting capacity, the \n");
    			d_math94 = element("d-math");
    			t202 = text$1(" must be chosen such that \n");
    			d_math95 = element("d-math");
    			t203 = text$1(".  Furthermore, for any function in the space, any values of \n");
    			d_math96 = element("d-math");
    			t204 = text$1(" has zero contribution to the vectors of evaluation.  Although it will have a non-zero contribution to values elsewhere, since we have no labeled data, we have no criterion for preferring one choice over another.");
    			t205 = space();
    			p32 = element("p");
    			t206 = text$1("Finally, we want to find some linear combination \n");
    			d_math97 = element("d-math");
    			t207 = text$1(" of the vectors of evaluation \n");
    			d_math98 = element("d-math");
    			t208 = text$1(" that equals the target values \n");
    			d_math99 = element("d-math");
    			t209 = text$1(".  If \n");
    			d_math100 = element("d-math");
    			t210 = text$1(" is full rank, must exist for any \n");
    			d_math101 = element("d-math");
    			t211 = text$1(".  Notice that, because the functions \n");
    			d_math102 = element("d-math");
    			t212 = text$1(" are defined as dot products of feature vectors, a linear combination of functions is equivalent to the function whose parameter vector is the ");
    			em6 = element("em");
    			em6.textContent = "same";
    			t214 = text$1(" linear combination of the combining functions' feature vectors:");
    			t215 = space();
    			d_math103 = element("d-math");
    			t216 = space();
    			p33 = element("p");
    			t217 = text$1("So, the parameter vector associated with the solution function \n");
    			d_math104 = element("d-math");
    			t218 = text$1(" is of the form \n");
    			d_math105 = element("d-math");
    			t219 = text$1(".  The vector of evaluation of \n");
    			d_math106 = element("d-math");
    			t220 = text$1(" on each \n");
    			d_math107 = element("d-math");
    			t221 = text$1(" is simply \n");
    			d_math108 = element("d-math");
    			t222 = text$1(".");
    			t223 = space();
    			p34 = element("p");
    			t224 = text$1("But notice that because we are restricted to choose \n");
    			d_math109 = element("d-math");
    			t225 = text$1(" to satisfy \n");
    			d_math110 = element("d-math");
    			t226 = text$1(", \n");
    			d_math111 = element("d-math");
    			t227 = text$1(" can be written as \n");
    			d_math112 = element("d-math");
    			t228 = text$1(" for some \n");
    			d_math113 = element("d-math");
    			t229 = text$1(" transformation matrix \n");
    			d_math114 = element("d-math");
    			t230 = text$1(".  But, that means we could express the evaluation as:");
    			t231 = space();
    			d_math115 = element("d-math");
    			t232 = space();
    			p35 = element("p");
    			t233 = text$1("Any solution \n");
    			d_math116 = element("d-math");
    			t234 = text$1(" one finds using \n");
    			d_math117 = element("d-math");
    			t235 = text$1(" as a set of parameter vectors, is equivalent to the solution \n");
    			d_math118 = element("d-math");
    			t236 = text$1(" found using \n");
    			d_math119 = element("d-math");
    			t237 = text$1(" as the set of parameter vectors.  In fact, any permutation of the rows of \n");
    			d_math120 = element("d-math");
    			t238 = text$1(" would also produce an equivalent solution.");
    			t239 = space();
    			p36 = element("p");
    			t240 = text$1("Kernel methods then choose \n");
    			d_math121 = element("d-math");
    			t241 = text$1(" as the set of parameter vectors, thus choosing to set the perpendicular component of all parameter vectors to zero.  It is still not justified why it is actually ");
    			em7 = element("em");
    			em7.textContent = "preferable";
    			t243 = text$1(" to have \n");
    			d_math122 = element("d-math");
    			t244 = text$1(" itself be in the span.  But, setting \n");
    			d_math123 = element("d-math");
    			t245 = text$1(" turns out to find the minimum norm parameter vector for any given set of target values.  It turns out that certain \"smoothness\" properties of the function are related to the norm of its parameter vector.");
    			t246 = space();
    			h26 = element("h2");
    			h26.textContent = "Function Norm as a regularizer";
    			t248 = space();
    			p37 = element("p");
    			t249 = text$1("In Kernel parlance, the term \"function norm\" just means \"norm of the function's associated parameter vector\".  Our solution function \n");
    			d_math124 = element("d-math");
    			t250 = text$1(" has associated parameter vector \n");
    			d_math125 = element("d-math");
    			t251 = text$1(".  Consider two arbitrary inputs \n");
    			d_math126 = element("d-math");
    			t252 = text$1(".  How do the values \n");
    			d_math127 = element("d-math");
    			t253 = text$1(" and absolute difference in values \n");
    			d_math128 = element("d-math");
    			t254 = text$1(" relate to the norm of its parameter vector?");
    			t255 = space();
    			d_math129 = element("d-math");
    			t256 = space();
    			p38 = element("p");
    			t257 = text$1("The first inequality tells us that the magnitude of values of the function \n");
    			d_math130 = element("d-math");
    			t258 = text$1(" is bounded by a fixed multiple of \n");
    			d_math131 = element("d-math");
    			t259 = text$1(".  The multiple itself, \n");
    			d_math132 = element("d-math");
    			t260 = text$1(" we have no control over - it is determined by the choice of \n");
    			d_math133 = element("d-math");
    			t261 = text$1(".  But by controlling \n");
    			d_math134 = element("d-math");
    			t262 = text$1(" we can control the range of values of \n");
    			d_math135 = element("d-math");
    			t263 = text$1(".");
    			t264 = space();
    			p39 = element("p");
    			t265 = text$1("The second inequality tells us that the absolute difference in value between any two points is proportional to \n");
    			d_math136 = element("d-math");
    			t266 = text$1(".  As the distance shrinks, the values will be equal.  By bounding \n");
    			d_math137 = element("d-math");
    			t267 = text$1(", we can control how sensitive the function could be to distance between input feature vectors.");
    			t268 = space();
    			p40 = element("p");
    			t269 = text$1("It also says something about the choice of \n");
    			d_math138 = element("d-math");
    			t270 = text$1(".  Ideally, we would like to choose a \n");
    			d_math139 = element("d-math");
    			t271 = text$1(" such that \n");
    			d_math140 = element("d-math");
    			t272 = text$1(" is roughy proportional to \n");
    			d_math141 = element("d-math");
    			t273 = text$1(" in the data set for all pairs \n");
    			d_math142 = element("d-math");
    			t274 = text$1(".");
    			t275 = space();
    			p41 = element("p");
    			t276 = text$1("It is not yet explained visually how the distance \n");
    			d_math143 = element("d-math");
    			t277 = text$1(" relates to the curves on the plot.  But recall that each gray curve shows one of the \n");
    			d_math144 = element("d-math");
    			t278 = text$1(" functions, defined as:");
    			t279 = space();
    			d_math145 = element("d-math");
    			t280 = space();
    			p42 = element("p");
    			t281 = text$1("It has not been shown yet, (see below section) but the gaussian curves are indeed of this form.  Each gaussian centered at \n");
    			d_math146 = element("d-math");
    			t282 = text$1(" has parameter vector \n");
    			d_math147 = element("d-math");
    			t283 = text$1(" and in fact, the \n");
    			d_math148 = element("d-math");
    			t284 = text$1(" function dictated by the gaussian has the same norm for all inputs \n");
    			d_math149 = element("d-math");
    			t285 = text$1(".  Therefore, each gaussian attains its peak when \n");
    			d_math150 = element("d-math");
    			t286 = text$1(", because then the two feature vectors are facing in the same direction.");
    			t287 = space();
    			p43 = element("p");
    			p43.textContent = "The distance in feature space thus is given indirectly by the height of the gaussian:";
    			t289 = space();
    			d_math151 = element("d-math");
    			t290 = space();
    			p44 = element("p");
    			t291 = text$1("Here, the interactive plot is useful to build intuition.  Selecting 'auto-solve', drag one of the data points, let's call it \n");
    			d_math152 = element("d-math");
    			t292 = text$1(", in a path from one side to the other side of another data point, say \n");
    			d_math153 = element("d-math");
    			t293 = text$1(", passing over it by some non-negligible distance \n");
    			d_math154 = element("d-math");
    			t294 = text$1(".  Because 'auto-solve' is checked, the system is updating \n");
    			d_math155 = element("d-math");
    			t295 = text$1(" so that \n");
    			d_math156 = element("d-math");
    			t296 = text$1(".  But, as \n");
    			d_math157 = element("d-math");
    			t297 = text$1(" approaches \n");
    			d_math158 = element("d-math");
    			t298 = text$1(", \n");
    			d_math159 = element("d-math");
    			t299 = text$1(" shrinks to zero, so \n");
    			d_math160 = element("d-math");
    			t300 = text$1(" must be magnified to infinity to maintain the spread.  It is a case in which the distance as defined by \n");
    			d_math161 = element("d-math");
    			t301 = text$1(" is a gross underestimate of the difference in labels.");
    			t302 = space();
    			h27 = element("h2");
    			h27.textContent = "Finally, enter the Kernel";
    			t304 = space();
    			p45 = element("p");
    			t305 = text$1("Recall from the previous section that using \n");
    			d_math162 = element("d-math");
    			t306 = text$1(" as the set of parameter vectors ensures 1) the method has arbitrary fitting capacity and 2) the solution will be the lowest norm solution possible.  So we have the following:");
    			t307 = space();
    			d_math163 = element("d-math");
    			t308 = space();
    			p46 = element("p");
    			t309 = text$1("To find \n");
    			d_math164 = element("d-math");
    			t310 = text$1(", solve:");
    			t311 = space();
    			d_math165 = element("d-math");
    			t312 = space();
    			p47 = element("p");
    			p47.textContent = "This will minimize to zero if the assumptions above hold.  To compromise between a perfectly fitting function and its smoothness, instead solve:";
    			t314 = space();
    			d_math166 = element("d-math");
    			t315 = space();
    			p48 = element("p");
    			p48.textContent = "Finally, to evaluate the function on new data:";
    			t317 = space();
    			d_math167 = element("d-math");
    			t318 = space();
    			p49 = element("p");
    			t319 = text$1("So we see that the only quantities dependent on the \n");
    			d_math168 = element("d-math");
    			t320 = text$1(" data are dot products \n");
    			d_math169 = element("d-math");
    			t321 = text$1(", appearing in the \n");
    			d_math170 = element("d-math");
    			t322 = text$1(" terms or the solution function.  Finally, we define a function called the \"kernel\" as:");
    			t323 = space();
    			d_math171 = element("d-math");
    			t324 = space();
    			p50 = element("p");
    			p50.textContent = "Then, the general optimization formula simplifies to:";
    			t326 = space();
    			d_math172 = element("d-math");
    			t327 = space();
    			p51 = element("p");
    			p51.textContent = "and evaluating the solution function is now written as:";
    			t329 = space();
    			d_math173 = element("d-math");
    			t330 = space();
    			h28 = element("h2");
    			h28.textContent = "Geometric Considerations of choice of Kernel";
    			t332 = space();
    			p52 = element("p");
    			t333 = text$1("To apply a Kernel method to data \n");
    			d_math174 = element("d-math");
    			t334 = text$1(" is to adopt the assumption that there is a metric defined on the input domain \n");
    			d_math175 = element("d-math");
    			t335 = text$1(".  ");
    			em8 = element("em");
    			em8.textContent = "Metric";
    			t337 = text$1(" means a definition of distances and angles between any two points in \n");
    			d_math176 = element("d-math");
    			t338 = text$1(".  This idea in itself is remarkable.  Although we are used to thinking of the vectors in \n");
    			d_math177 = element("d-math");
    			t339 = text$1(" as having lengths, and pairs of vectors having an angle between them, this idea is even more general.  It does not require \n");
    			d_math178 = element("d-math");
    			t340 = text$1(" to have any particular structure at all.");
    			br1 = element("br");
    			d_math179 = element("d-math");
    			t341 = text$1(" may be continuous or discrete, or mixed.  And it can have any natural ordering of its elements, or none.  And, even if \n");
    			d_math180 = element("d-math");
    			t342 = text$1(" is naturally ordered, such as \n");
    			d_math181 = element("d-math");
    			t343 = text$1(", the metric need not be consistent with that ordering at all.");
    			t344 = space();
    			p53 = element("p");
    			t345 = text$1("Indeed, the very notion of \"ordering\" itself is a weak concept once you go past one dimension.  Ordering of elements in \n");
    			d_math182 = element("d-math");
    			t346 = text$1(" is simply a result of a notion of the length of each element.  Although, the angle is always either zero or \n");
    			d_math183 = element("d-math");
    			t347 = text$1(".");
    			t348 = space();
    			p54 = element("p");
    			t349 = text$1("But, this is worth meditating on, because it is precisely this notion which is the foundation of kernel methods.  A Kernel merely quantifies this intuitive notion.  Most discussions about Kernels say they are a measure of \"similarity\" between two points.  However, I don't like that word since it has no standing in geometry.  It is possible, for instance for \n");
    			d_math184 = element("d-math");
    			t350 = text$1(" for some \n");
    			d_math185 = element("d-math");
    			t351 = text$1(" and \n");
    			d_math186 = element("d-math");
    			t352 = text$1(".  If we called \n");
    			d_math187 = element("d-math");
    			t353 = text$1(" a \"similarity measure\", then \n");
    			d_math188 = element("d-math");
    			t354 = text$1(" would be more similar to \n");
    			d_math189 = element("d-math");
    			t355 = text$1(" than to itself.");
    			t356 = space();
    			p55 = element("p");
    			t357 = text$1("Rather, a kernel defines the ");
    			em9 = element("em");
    			em9.textContent = "inner product";
    			t359 = text$1(" on a set \n");
    			d_math190 = element("d-math");
    			t360 = text$1(", and the notions of length and angle follow indirectly from that:");
    			t361 = space();
    			d_math191 = element("d-math");
    			t362 = space();
    			h11 = element("h1");
    			h11.textContent = "Geometric Justification for the inner product as a concept";
    			t364 = space();
    			p56 = element("p");
    			p56.textContent = "This is due to MathTheBeautiful Youtube Channel.";
    			t366 = space();
    			p57 = element("p");
    			p57.textContent = "The geometric justification for the inner product proceeds in five steps:";
    			t368 = space();
    			ul1 = element("ul");
    			li9 = element("li");
    			t369 = text$1("Given abstract vectors ");
    			d_math192 = element("d-math");
    			t370 = text$1(" and ");
    			d_math193 = element("d-math");
    			t371 = text$1(", write the Pythagorean formula for ");
    			d_math194 = element("d-math");
    			t372 = space();
    			li10 = element("li");
    			li10.textContent = "Expand the terms to the same form";
    			t374 = space();
    			li11 = element("li");
    			li11.textContent = "define the expression for the inner product";
    			t376 = space();
    			li12 = element("li");
    			li12.textContent = "Notice that it is symmetric and bilinear, by definition";
    			t378 = space();
    			li13 = element("li");
    			li13.textContent = "Use these to rewrite and simplify the formula";
    			t380 = space();
    			p58 = element("p");
    			t381 = text$1("Without a visualization, assume we have abstract vectors \n");
    			d_math195 = element("d-math");
    			t382 = text$1(" and \n");
    			d_math196 = element("d-math");
    			t383 = text$1(", and we know their lengths \n");
    			d_math197 = element("d-math");
    			t384 = text$1(" and \n");
    			d_math198 = element("d-math");
    			t385 = text$1(" and the angle \n");
    			d_math199 = element("d-math");
    			t386 = text$1(" between them, but nothing else.  We do not have any notion of the vectors as tuples of coordinates, for example.  They are purely geometric concepts.  Then we have:");
    			t387 = space();
    			d_math200 = element("d-math");
    			t388 = space();
    			p59 = element("p");
    			t389 = text$1("So, by defining \n");
    			d_math201 = element("d-math");
    			t390 = text$1(" in terms of the length of \n");
    			d_math202 = element("d-math");
    			t391 = text$1(" and \n");
    			d_math203 = element("d-math");
    			t392 = text$1(", and the angle between them, we can write the distance between two elements purely in terms of the inner product.  It is completely abstract, not requiring any assumption about internal structure of the elements themselves.  This abstraction of the notion of distance on arbitrary objects is perhaps the key insight of Kernel methods.");
    			t393 = space();
    			d_math204 = element("d-math");
    			t394 = space();
    			h29 = element("h2");
    			h29.textContent = "Distinction between Feature Space and Hilbert Space";
    			t396 = space();
    			p60 = element("p");
    			t397 = text$1("Second, an inner product on the space of functions is defined to be \n");
    			d_math205 = element("d-math");
    			t398 = text$1(".");
    			t399 = space();
    			p61 = element("p");
    			t400 = text$1("The form of the source functions \n");
    			d_math206 = element("d-math");
    			t401 = text$1(" is a dot product between two vectors in a so-called \"feature space\".  The vector valued function \n");
    			d_math207 = element("d-math");
    			t402 = text$1(" is determined at the beginning, and is a fixed function throughout the procedure with no trainable parameters.  Therefore, there is a one-to-one correspondence between the parameters \n");
    			d_math208 = element("d-math");
    			t403 = text$1(" in this feature space, and the resulting functions \n");
    			d_math209 = element("d-math");
    			t404 = text$1(" in the function space.");
    			t405 = space();
    			p62 = element("p");
    			t406 = text$1("The feature space will be denoted \n");
    			d_math210 = element("d-math");
    			t407 = text$1(", equipped with an inner product defined as the dot product.  If we think of \n");
    			d_math211 = element("d-math");
    			t408 = text$1(", then each \n");
    			d_math212 = element("d-math");
    			t409 = text$1(" defines a feature and indexes a different component of the vectors in \n");
    			d_math213 = element("d-math");
    			t410 = text$1(".  So we write \n");
    			d_math214 = element("d-math");
    			t411 = text$1(".");
    			t412 = space();
    			p63 = element("p");
    			t413 = text$1("A different space, the space of functions \n");
    			d_math215 = element("d-math");
    			t414 = text$1(" will be denoted \n");
    			d_math216 = element("d-math");
    			t415 = text$1(", for ");
    			em10 = element("em");
    			em10.textContent = "Hilbert";
    			t417 = text$1(" space.  So, \n");
    			d_math217 = element("d-math");
    			t418 = text$1(".  As mentioned, it is endowed with inner product \n");
    			d_math218 = element("d-math");
    			t419 = text$1(".  Note that our \"solution function\" which fits the data will lie in an \n");
    			d_math219 = element("d-math");
    			t420 = text$1("-dimensional linear subspace of \n");
    			d_math220 = element("d-math");
    			t421 = text$1(" spanned by a set of \n");
    			d_math221 = element("d-math");
    			t422 = text$1(" \"basis functions\", which we define below.");
    			t423 = space();
    			p64 = element("p");
    			t424 = text$1("Note that some literature takes \n");
    			d_math222 = element("d-math");
    			t425 = text$1(" to be ");
    			em11 = element("em");
    			em11.textContent = "the";
    			t427 = text$1(" Hilbert space, and implicitly treats the points in that space as functions on the domain \n");
    			d_math223 = element("d-math");
    			t428 = text$1(" even though they are over the domain of features.  Technically, \n");
    			d_math224 = element("d-math");
    			t429 = space();
    			em12 = element("em");
    			em12.textContent = "is";
    			t431 = text$1(" a Hilbert space, because it is a vector space endowed with an inner product.  But, it is not the Hilbert space where we search for a function.  But as it turns out, there is a bijection between elements in the linear span of basis functions in \n");
    			d_math225 = element("d-math");
    			t432 = text$1(" with the linear span of basis parameter vectors in \n");
    			d_math226 = element("d-math");
    			t433 = text$1(".  So, authors speak as though they are the same.  For example, see Learning with Kernels, Smola and Scholkopf.");
    			t434 = space();
    			p65 = element("p");
    			t435 = text$1("Other authors, especially those focused on the theory of RKHS, speak of the Hilbert space as \n");
    			d_math227 = element("d-math");
    			t436 = text$1(".  For example, see \"A Primer on Reproducing Kernel Hilbert Spaces\" by Manton and Amblard.  I prefer to distinguish \n");
    			d_math228 = element("d-math");
    			t437 = text$1(" from \n");
    			d_math229 = element("d-math");
    			t438 = text$1(" to avoid confusion.");
    			t439 = space();
    			h210 = element("h2");
    			t440 = text$1("A set of spanning functions for general ");
    			d_math230 = element("d-math");
    			t441 = space();
    			p66 = element("p");
    			t442 = text$1("In the plot above, our input domain happened to be \n");
    			d_math231 = element("d-math");
    			t443 = text$1(".  But for an arbitrary data set with input domain \n");
    			d_math232 = element("d-math");
    			t444 = text$1(", we need a source of arbitrarily many distinct functions - as many as there are elements of \n");
    			d_math233 = element("d-math");
    			t445 = text$1(".  So it is natural then, that each function correspond to some \n");
    			d_math234 = element("d-math");
    			t446 = text$1(".  We could plot all of the functions' values on \n");
    			d_math235 = element("d-math");
    			t447 = text$1(" in a heatmap \n");
    			d_math236 = element("d-math");
    			t448 = text$1(".  In the example above, the individual functions \n");
    			d_math237 = element("d-math");
    			t449 = text$1(" were unit \n");
    			d_math238 = element("d-math");
    			t450 = text$1(" Gaussians centered at \n");
    			d_math239 = element("d-math");
    			t451 = text$1(".  So, the curves above would correspond to rows in this heatmap:");
    			t452 = space();
    			p67 = element("p");
    			p67.textContent = "[Show heatmap]";
    			t454 = space();
    			p68 = element("p");
    			t455 = text$1("Recall the statement earlier that any \n");
    			d_math240 = element("d-math");
    			t456 = text$1(" Gaussians of the same \n");
    			d_math241 = element("d-math");
    			t457 = text$1(" produce linearly independent vectors when evaluated at any \n");
    			d_math242 = element("d-math");
    			t458 = text$1(" points.  From the heatmap, this means that, if you choose any \n");
    			d_math243 = element("d-math");
    			t459 = text$1(" rows and any \n");
    			d_math244 = element("d-math");
    			t460 = text$1(" columns, the matrix produced from the intersections will be full-rank, thus will allow a unique solution for any set of desired target values.");
    			t461 = space();
    			h211 = element("h2");
    			h211.textContent = "Part 2 - Examples of linear problems";
    			t463 = space();
    			p69 = element("p");
    			p69.textContent = "Kernel methods are used for PCA, CCA, K-means, Regression, separating hyperplanes (SVM).  All of these involve finding an optimal point in a space using linear optimization methods.  If possible, show how the inner product is used in some of these formulas.";
    			t465 = space();
    			h212 = element("h2");
    			h212.textContent = "Kernel Ridge Regression";
    			t467 = space();
    			h213 = element("h2");
    			h213.textContent = "Kernel Linear Regression";
    			t469 = space();
    			h214 = element("h2");
    			h214.textContent = "Kernel PCA";
    			t471 = space();
    			p70 = element("p");
    			p70.textContent = "Mairal Lecture 9";
    			t473 = space();
    			h215 = element("h2");
    			h215.textContent = "Kernel K-means and CCA";
    			t475 = space();
    			p71 = element("p");
    			p71.textContent = "Mairal Lecture 10";
    			t477 = space();
    			p72 = element("p");
    			d_math245 = element("d-math");
    			t478 = space();
    			p73 = element("p");
    			t479 = text$1("See Gong and Lazebnik:  ");
    			a0 = element("a");
    			a0.textContent = "https://arxiv.org/pdf/1212.4522.pdf";
    			t481 = space();
    			h216 = element("h2");
    			h216.textContent = "Large Margin Classifiers";
    			t483 = space();
    			p74 = element("p");
    			t484 = text$1("In binary classification, the ");
    			em13 = element("em");
    			em13.textContent = "margin";
    			t486 = text$1(" of the function \n");
    			d_math246 = element("d-math");
    			t487 = text$1(" for \n");
    			d_math247 = element("d-math");
    			t488 = text$1(" is \n");
    			d_math248 = element("d-math");
    			t489 = text$1(".  The loss is a decreasing function of the margin: \n");
    			d_math249 = element("d-math");
    			t490 = text$1(".");
    			t491 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Method";
    			t493 = space();
    			th1 = element("th");
    			d_math250 = element("d-math");
    			t494 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "Kernel Logistic Regression";
    			t496 = space();
    			td1 = element("td");
    			d_math251 = element("d-math");
    			t497 = space();
    			tr2 = element("tr");
    			td2 = element("td");
    			td2.textContent = "1-SVM (hinge loss)";
    			t499 = space();
    			td3 = element("td");
    			d_math252 = element("d-math");
    			t500 = space();
    			tr3 = element("tr");
    			td4 = element("td");
    			td4.textContent = "2-SVM";
    			t502 = space();
    			td5 = element("td");
    			d_math253 = element("d-math");
    			t503 = space();
    			tr4 = element("tr");
    			td6 = element("td");
    			td6.textContent = "Boosting";
    			t505 = space();
    			td7 = element("td");
    			d_math254 = element("d-math");
    			t506 = space();
    			p75 = element("p");
    			p75.textContent = "In all these, we solve:";
    			t508 = space();
    			d_math255 = element("d-math");
    			t509 = space();
    			p76 = element("p");
    			t510 = text$1("The idea of support vectors is to make \n");
    			d_math256 = element("d-math");
    			t511 = text$1(" sparse, and only non-zero components for samples that are hard to classify (close to the separating hyperplane):");
    			t512 = space();
    			p77 = element("p");
    			d_math257 = element("d-math");
    			t513 = space();
    			p78 = element("p");
    			p78.textContent = "Kernel Logistic Regression is a large-margin classifier.";
    			t515 = space();
    			h217 = element("h2");
    			h217.textContent = "Neural Tangent Kernel";
    			t517 = space();
    			p79 = element("p");
    			t518 = text$1("See ");
    			a1 = element("a");
    			a1.textContent = "https://arxiv.org/abs/1806.07572";
    			attr_dev(h10, "id", "an-illustration-of-kernel-regression");
    			add_location(h10, file$9, 0, 0, 0);
    			add_location(d_math0, file$9, 1, 3, 91);
    			add_location(p0, file$9, 1, 0, 88);
    			add_location(d_math1, file$9, 4, 0, 187);
    			add_location(d_math2, file$9, 6, 0, 292);
    			add_location(d_math3, file$9, 8, 0, 366);
    			add_location(d_math4, file$9, 10, 0, 480);
    			add_location(p1, file$9, 3, 0, 144);
    			add_location(d_math5, file$9, 13, 0, 595);
    			add_location(d_math6, file$9, 15, 0, 690);
    			add_location(d_math7, file$9, 17, 0, 749);
    			add_location(p2, file$9, 12, 0, 523);
    			add_location(d_math8, file$9, 20, 0, 894);
    			add_location(d_math9, file$9, 22, 0, 1039);
    			add_location(d_math10, file$9, 24, 0, 1109);
    			add_location(d_math11, file$9, 26, 0, 1241);
    			add_location(d_math12, file$9, 28, 0, 1296);
    			add_location(d_math13, file$9, 30, 0, 1478);
    			add_location(d_math14, file$9, 32, 0, 1548);
    			add_location(p3, file$9, 19, 0, 822);
    			add_location(p4, file$9, 34, 0, 1587);
    			set_custom_element_data(d_math15, "block", "");
    			add_location(d_math15, file$9, 35, 0, 1606);
    			add_location(d_math16, file$9, 46, 0, 2044);
    			add_location(d_math17, file$9, 48, 0, 2140);
    			add_location(d_math18, file$9, 50, 0, 2206);
    			add_location(d_math19, file$9, 52, 0, 2366);
    			add_location(d_math20, file$9, 54, 0, 2505);
    			add_location(d_math21, file$9, 56, 0, 2592);
    			add_location(p5, file$9, 45, 0, 2036);
    			attr_dev(h20, "id", "some-observations");
    			add_location(h20, file$9, 58, 0, 2641);
    			add_location(d_math22, file$9, 60, 0, 2742);
    			add_location(strong0, file$9, 59, 3, 2694);
    			add_location(em0, file$9, 61, 31, 2821);
    			add_location(d_math23, file$9, 62, 0, 2846);
    			add_location(d_math24, file$9, 64, 0, 2919);
    			add_location(d_math25, file$9, 66, 0, 3013);
    			add_location(d_math26, file$9, 68, 0, 3153);
    			add_location(p6, file$9, 59, 0, 2691);
    			add_location(d_math27, file$9, 71, 0, 3382);
    			add_location(strong1, file$9, 70, 3, 3300);
    			add_location(em1, file$9, 72, 41, 3443);
    			add_location(d_math28, file$9, 73, 0, 3467);
    			add_location(d_math29, file$9, 75, 0, 3518);
    			add_location(d_math30, file$9, 77, 0, 3583);
    			add_location(em2, file$9, 78, 27, 3628);
    			add_location(d_math31, file$9, 79, 0, 3708);
    			add_location(p7, file$9, 70, 0, 3297);
    			add_location(strong2, file$9, 81, 3, 3813);
    			add_location(d_math32, file$9, 82, 0, 4132);
    			add_location(p8, file$9, 81, 0, 3810);
    			add_location(strong3, file$9, 84, 3, 4264);
    			add_location(p9, file$9, 84, 0, 4261);
    			add_location(d_math33, file$9, 86, 0, 5151);
    			add_location(p10, file$9, 85, 0, 5021);
    			attr_dev(h21, "id", "the-three-design-choices-underlying-all-kernel-methods");
    			add_location(h21, file$9, 88, 0, 5346);
    			add_location(p11, file$9, 89, 0, 5470);
    			add_location(strong4, file$9, 90, 7, 5942);
    			add_location(d_math34, file$9, 91, 0, 6017);
    			add_location(d_math35, file$9, 93, 0, 6140);
    			add_location(d_math36, file$9, 95, 0, 6204);
    			add_location(d_math37, file$9, 97, 0, 6316);
    			add_location(p12, file$9, 90, 0, 5935);
    			add_location(strong5, file$9, 99, 7, 6659);
    			add_location(d_math38, file$9, 100, 0, 6777);
    			add_location(d_math39, file$9, 102, 0, 6821);
    			add_location(d_math40, file$9, 104, 0, 6901);
    			add_location(d_math41, file$9, 106, 0, 6953);
    			add_location(d_math42, file$9, 108, 0, 7007);
    			add_location(em3, file$9, 109, 12, 7037);
    			add_location(d_math43, file$9, 110, 0, 7254);
    			add_location(d_math44, file$9, 112, 0, 7335);
    			add_location(p13, file$9, 99, 0, 6652);
    			add_location(strong6, file$9, 114, 7, 7810);
    			add_location(br0, file$9, 114, 122, 7925);
    			add_location(d_math45, file$9, 114, 126, 7929);
    			add_location(d_math46, file$9, 116, 0, 8091);
    			add_location(p14, file$9, 114, 0, 7803);
    			add_location(d_math47, file$9, 119, 0, 8625);
    			add_location(d_math48, file$9, 121, 0, 8679);
    			add_location(p15, file$9, 118, 0, 8489);
    			add_location(d_math49, file$9, 123, 96, 8850);
    			attr_dev(h22, "id", "the-set-of-gaussians-sharing-the-same-html-sigma");
    			add_location(h22, file$9, 123, 0, 8754);
    			add_location(d_math50, file$9, 125, 0, 9040);
    			add_location(d_math51, file$9, 127, 0, 9112);
    			add_location(d_math52, file$9, 129, 0, 9197);
    			add_location(d_math53, file$9, 131, 0, 9312);
    			add_location(d_math54, file$9, 133, 0, 9481);
    			add_location(p16, file$9, 124, 0, 8890);
    			set_custom_element_data(d_math55, "block", "");
    			add_location(d_math55, file$9, 135, 0, 9516);
    			add_location(d_math56, file$9, 146, 0, 10212);
    			add_location(d_math57, file$9, 148, 0, 10319);
    			add_location(d_math58, file$9, 150, 0, 10375);
    			add_location(p17, file$9, 145, 0, 10187);
    			set_custom_element_data(d_math59, "block", "");
    			add_location(d_math59, file$9, 152, 0, 10416);
    			add_location(d_math60, file$9, 164, 0, 11157);
    			add_location(d_math61, file$9, 166, 0, 11221);
    			add_location(d_math62, file$9, 168, 0, 11352);
    			add_location(p18, file$9, 163, 0, 11145);
    			add_location(d_math63, file$9, 171, 0, 11515);
    			add_location(d_math64, file$9, 173, 0, 11550);
    			add_location(d_math65, file$9, 175, 0, 11634);
    			add_location(d_math66, file$9, 177, 0, 11671);
    			add_location(d_math67, file$9, 179, 0, 11733);
    			add_location(d_math68, file$9, 181, 0, 11777);
    			add_location(d_math69, file$9, 183, 0, 11876);
    			add_location(p19, file$9, 170, 0, 11457);
    			add_location(d_math70, file$9, 186, 0, 12202);
    			add_location(d_math71, file$9, 188, 0, 12257);
    			add_location(d_math72, file$9, 190, 0, 12551);
    			add_location(d_math73, file$9, 192, 0, 12602);
    			add_location(d_math74, file$9, 194, 0, 12664);
    			add_location(d_math75, file$9, 196, 0, 12773);
    			add_location(p20, file$9, 185, 0, 12088);
    			add_location(d_math76, file$9, 199, 0, 12899);
    			add_location(d_math77, file$9, 201, 0, 12992);
    			add_location(d_math78, file$9, 203, 0, 13074);
    			add_location(d_math79, file$9, 205, 0, 13166);
    			add_location(em4, file$9, 206, 18, 13205);
    			add_location(d_math80, file$9, 207, 0, 13282);
    			add_location(p21, file$9, 198, 0, 12870);
    			attr_dev(h23, "id", "things-to-do-in-the-plot-to-build-intuition");
    			add_location(h23, file$9, 209, 0, 13317);
    			add_location(p22, file$9, 211, 4, 13438);
    			add_location(li0, file$9, 211, 0, 13434);
    			add_location(p23, file$9, 213, 4, 13528);
    			add_location(li1, file$9, 216, 0, 13606);
    			add_location(li2, file$9, 218, 0, 13739);
    			add_location(li3, file$9, 219, 0, 13772);
    			add_location(li4, file$9, 221, 0, 13873);
    			add_location(li5, file$9, 222, 0, 13940);
    			add_location(li6, file$9, 224, 0, 14029);
    			add_location(li7, file$9, 226, 0, 14119);
    			add_location(ul0, file$9, 215, 0, 13601);
    			add_location(li8, file$9, 213, 0, 13524);
    			attr_dev(ol, "start", "3");
    			add_location(ol, file$9, 210, 0, 13419);
    			attr_dev(h24, "id", "consequences-of-the-choice-of-a-kernel");
    			add_location(h24, file$9, 232, 0, 14255);
    			add_location(em5, file$9, 233, 130, 14477);
    			add_location(p24, file$9, 233, 0, 14347);
    			add_location(p25, file$9, 234, 0, 14894);
    			add_location(p26, file$9, 235, 0, 15706);
    			add_location(p27, file$9, 236, 0, 16650);
    			attr_dev(h25, "id", "a-natural-choice-for-parameter-vectors");
    			add_location(h25, file$9, 237, 0, 16795);
    			add_location(d_math81, file$9, 239, 0, 16939);
    			add_location(p28, file$9, 238, 0, 16887);
    			set_custom_element_data(d_math82, "block", "");
    			add_location(d_math82, file$9, 241, 0, 17168);
    			add_location(d_math83, file$9, 286, 0, 18417);
    			add_location(d_math84, file$9, 288, 0, 18614);
    			add_location(d_math85, file$9, 290, 0, 18721);
    			add_location(d_math86, file$9, 292, 0, 18788);
    			add_location(d_math87, file$9, 294, 0, 18887);
    			add_location(p29, file$9, 285, 0, 18381);
    			add_location(d_math88, file$9, 297, 0, 19080);
    			add_location(d_math89, file$9, 299, 0, 19154);
    			add_location(d_math90, file$9, 301, 0, 19227);
    			add_location(p30, file$9, 296, 0, 19051);
    			set_custom_element_data(d_math91, "block", "");
    			add_location(d_math91, file$9, 303, 0, 19337);
    			add_location(d_math92, file$9, 320, 0, 19956);
    			add_location(d_math93, file$9, 322, 0, 20060);
    			add_location(d_math94, file$9, 324, 0, 20245);
    			add_location(d_math95, file$9, 326, 0, 20311);
    			add_location(d_math96, file$9, 328, 0, 20465);
    			add_location(p31, file$9, 319, 0, 19910);
    			add_location(d_math97, file$9, 331, 0, 20779);
    			add_location(d_math98, file$9, 333, 0, 20853);
    			add_location(d_math99, file$9, 335, 0, 20922);
    			add_location(d_math100, file$9, 337, 0, 20966);
    			add_location(d_math101, file$9, 339, 0, 21038);
    			add_location(d_math102, file$9, 341, 0, 21114);
    			add_location(em6, file$9, 342, 154, 21291);
    			add_location(p32, file$9, 330, 0, 20726);
    			set_custom_element_data(d_math103, "block", "");
    			add_location(d_math103, file$9, 343, 0, 21377);
    			add_location(d_math104, file$9, 354, 0, 21851);
    			add_location(d_math105, file$9, 356, 0, 21900);
    			add_location(d_math106, file$9, 358, 0, 21977);
    			add_location(d_math107, file$9, 360, 0, 22019);
    			add_location(d_math108, file$9, 362, 0, 22062);
    			add_location(p33, file$9, 353, 0, 21784);
    			add_location(d_math109, file$9, 365, 0, 22175);
    			add_location(d_math110, file$9, 367, 0, 22225);
    			add_location(d_math111, file$9, 369, 0, 22320);
    			add_location(d_math112, file$9, 371, 0, 22388);
    			add_location(d_math113, file$9, 373, 0, 22469);
    			add_location(d_math114, file$9, 375, 0, 22532);
    			add_location(p34, file$9, 364, 0, 22119);
    			set_custom_element_data(d_math115, "block", "");
    			add_location(d_math115, file$9, 377, 0, 22628);
    			add_location(d_math116, file$9, 388, 0, 23091);
    			add_location(d_math117, file$9, 390, 0, 23152);
    			add_location(d_math118, file$9, 392, 0, 23252);
    			add_location(d_math119, file$9, 394, 0, 23311);
    			add_location(d_math120, file$9, 396, 0, 23424);
    			add_location(p35, file$9, 387, 0, 23074);
    			add_location(d_math121, file$9, 399, 0, 23540);
    			add_location(em7, file$9, 400, 174, 23758);
    			add_location(d_math122, file$9, 401, 0, 23787);
    			add_location(d_math123, file$9, 403, 0, 23863);
    			add_location(p36, file$9, 398, 0, 23509);
    			attr_dev(h26, "id", "function-norm-as-a-regularizer");
    			add_location(h26, file$9, 405, 0, 24137);
    			add_location(d_math124, file$9, 407, 0, 24374);
    			add_location(d_math125, file$9, 409, 0, 24471);
    			add_location(d_math126, file$9, 411, 0, 24578);
    			add_location(d_math127, file$9, 413, 0, 24650);
    			add_location(d_math128, file$9, 415, 0, 24718);
    			add_location(p37, file$9, 406, 0, 24213);
    			set_custom_element_data(d_math129, "block", "");
    			add_location(d_math129, file$9, 417, 0, 24808);
    			add_location(d_math130, file$9, 432, 0, 25871);
    			add_location(d_math131, file$9, 434, 0, 25936);
    			add_location(d_math132, file$9, 436, 0, 26004);
    			add_location(d_math133, file$9, 438, 0, 26117);
    			add_location(d_math134, file$9, 440, 0, 26189);
    			add_location(d_math135, file$9, 442, 0, 26272);
    			add_location(p38, file$9, 431, 0, 25792);
    			add_location(d_math136, file$9, 445, 0, 26424);
    			add_location(d_math137, file$9, 447, 0, 26563);
    			add_location(p39, file$9, 444, 0, 26309);
    			add_location(d_math138, file$9, 450, 0, 26753);
    			add_location(d_math139, file$9, 452, 0, 26841);
    			add_location(d_math140, file$9, 454, 0, 26902);
    			add_location(d_math141, file$9, 456, 0, 27001);
    			add_location(d_math142, file$9, 458, 0, 27072);
    			add_location(p40, file$9, 449, 0, 26706);
    			add_location(d_math143, file$9, 461, 0, 27184);
    			add_location(d_math144, file$9, 463, 0, 27342);
    			add_location(p41, file$9, 460, 0, 27130);
    			set_custom_element_data(d_math145, "block", "");
    			add_location(d_math145, file$9, 465, 0, 27404);
    			add_location(d_math146, file$9, 474, 0, 27699);
    			add_location(d_math147, file$9, 476, 0, 27754);
    			add_location(d_math148, file$9, 478, 0, 27820);
    			add_location(d_math149, file$9, 480, 0, 27938);
    			add_location(d_math150, file$9, 482, 0, 28036);
    			add_location(p42, file$9, 473, 0, 27572);
    			add_location(p43, file$9, 484, 0, 28149);
    			set_custom_element_data(d_math151, "block", "");
    			add_location(d_math151, file$9, 485, 0, 28242);
    			add_location(d_math152, file$9, 496, 0, 29009);
    			add_location(d_math153, file$9, 498, 0, 29119);
    			add_location(d_math154, file$9, 500, 0, 29208);
    			add_location(d_math155, file$9, 502, 0, 29315);
    			add_location(d_math156, file$9, 504, 0, 29362);
    			add_location(d_math157, file$9, 506, 0, 29428);
    			add_location(d_math158, file$9, 508, 0, 29472);
    			add_location(d_math159, file$9, 510, 0, 29506);
    			add_location(d_math160, file$9, 512, 0, 29603);
    			add_location(d_math161, file$9, 514, 0, 29752);
    			add_location(p44, file$9, 495, 0, 28868);
    			attr_dev(h27, "id", "finally-enter-the-kernel");
    			add_location(h27, file$9, 516, 0, 29860);
    			add_location(d_math162, file$9, 518, 0, 29973);
    			add_location(p45, file$9, 517, 0, 29925);
    			set_custom_element_data(d_math163, "block", "");
    			add_location(d_math163, file$9, 520, 0, 30208);
    			add_location(d_math164, file$9, 536, 0, 30667);
    			add_location(p46, file$9, 535, 0, 30655);
    			set_custom_element_data(d_math165, "block", "");
    			add_location(d_math165, file$9, 538, 0, 30723);
    			add_location(p47, file$9, 545, 0, 30881);
    			set_custom_element_data(d_math166, "block", "");
    			add_location(d_math166, file$9, 546, 0, 31033);
    			add_location(p48, file$9, 554, 0, 31416);
    			set_custom_element_data(d_math167, "block", "");
    			add_location(d_math167, file$9, 555, 0, 31470);
    			add_location(d_math168, file$9, 564, 0, 31696);
    			add_location(d_math169, file$9, 566, 0, 31760);
    			add_location(d_math170, file$9, 568, 0, 31852);
    			add_location(p49, file$9, 563, 0, 31640);
    			set_custom_element_data(d_math171, "block", "");
    			add_location(d_math171, file$9, 570, 0, 31995);
    			add_location(p50, file$9, 579, 0, 32315);
    			set_custom_element_data(d_math172, "block", "");
    			add_location(d_math172, file$9, 580, 0, 32376);
    			add_location(p51, file$9, 587, 0, 32576);
    			set_custom_element_data(d_math173, "block", "");
    			add_location(d_math173, file$9, 588, 0, 32639);
    			attr_dev(h28, "id", "geometric-considerations-of-choice-of-kernel");
    			add_location(h28, file$9, 595, 0, 32761);
    			add_location(d_math174, file$9, 597, 0, 32902);
    			add_location(d_math175, file$9, 599, 0, 33043);
    			add_location(em8, file$9, 600, 14, 33086);
    			add_location(d_math176, file$9, 601, 0, 33172);
    			add_location(d_math177, file$9, 603, 0, 33303);
    			add_location(d_math178, file$9, 605, 0, 33469);
    			add_location(br1, file$9, 606, 52, 33550);
    			add_location(d_math179, file$9, 606, 56, 33554);
    			add_location(d_math180, file$9, 608, 0, 33715);
    			add_location(d_math181, file$9, 610, 0, 33787);
    			add_location(p52, file$9, 596, 0, 32865);
    			add_location(d_math182, file$9, 613, 0, 34029);
    			add_location(d_math183, file$9, 615, 0, 34178);
    			add_location(p53, file$9, 612, 0, 33895);
    			add_location(d_math184, file$9, 618, 0, 34594);
    			add_location(d_math185, file$9, 620, 0, 34651);
    			add_location(d_math186, file$9, 622, 0, 34686);
    			add_location(d_math187, file$9, 624, 0, 34732);
    			add_location(d_math188, file$9, 626, 0, 34818);
    			add_location(d_math189, file$9, 628, 0, 34874);
    			add_location(p54, file$9, 617, 0, 34216);
    			add_location(em9, file$9, 630, 32, 34956);
    			add_location(d_math190, file$9, 631, 0, 34989);
    			add_location(p55, file$9, 630, 0, 34924);
    			set_custom_element_data(d_math191, "block", "");
    			add_location(d_math191, file$9, 633, 0, 35100);
    			attr_dev(h11, "id", "geometric-justification-for-the-inner-product-as-a-concept");
    			add_location(h11, file$9, 644, 0, 35545);
    			add_location(p56, file$9, 645, 0, 35677);
    			add_location(p57, file$9, 646, 0, 35733);
    			add_location(d_math192, file$9, 648, 27, 35846);
    			add_location(d_math193, file$9, 648, 60, 35879);
    			add_location(d_math194, file$9, 648, 124, 35943);
    			add_location(li9, file$9, 648, 0, 35819);
    			add_location(li10, file$9, 649, 0, 35985);
    			add_location(li11, file$9, 650, 0, 36028);
    			add_location(li12, file$9, 651, 0, 36081);
    			add_location(li13, file$9, 652, 0, 36146);
    			add_location(ul1, file$9, 647, 0, 35814);
    			add_location(d_math195, file$9, 655, 0, 36268);
    			add_location(d_math196, file$9, 657, 0, 36303);
    			add_location(d_math197, file$9, 659, 0, 36361);
    			add_location(d_math198, file$9, 661, 0, 36402);
    			add_location(d_math199, file$9, 663, 0, 36453);
    			add_location(p58, file$9, 654, 0, 36207);
    			set_custom_element_data(d_math200, "block", "");
    			add_location(d_math200, file$9, 665, 0, 36663);
    			add_location(d_math201, file$9, 681, 0, 37714);
    			add_location(d_math202, file$9, 683, 0, 37776);
    			add_location(d_math203, file$9, 685, 0, 37811);
    			add_location(p59, file$9, 680, 0, 37694);
    			set_custom_element_data(d_math204, "block", "");
    			add_location(d_math204, file$9, 687, 0, 38180);
    			attr_dev(h29, "id", "distinction-between-feature-space-and-hilbert-space");
    			add_location(h29, file$9, 698, 0, 38521);
    			add_location(d_math205, file$9, 700, 0, 38711);
    			add_location(p60, file$9, 699, 0, 38639);
    			add_location(d_math206, file$9, 703, 0, 38859);
    			add_location(d_math207, file$9, 705, 0, 39015);
    			add_location(d_math208, file$9, 707, 0, 39249);
    			add_location(d_math209, file$9, 709, 0, 39339);
    			add_location(p61, file$9, 702, 0, 38822);
    			add_location(d_math210, file$9, 712, 0, 39452);
    			add_location(d_math211, file$9, 714, 0, 39570);
    			add_location(d_math212, file$9, 716, 0, 39682);
    			add_location(d_math213, file$9, 718, 0, 39797);
    			add_location(d_math214, file$9, 720, 0, 39853);
    			add_location(p62, file$9, 711, 0, 39414);
    			add_location(d_math215, file$9, 723, 0, 40009);
    			add_location(d_math216, file$9, 725, 0, 40091);
    			add_location(em10, file$9, 726, 17, 40137);
    			add_location(d_math217, file$9, 727, 0, 40167);
    			add_location(d_math218, file$9, 729, 0, 40285);
    			add_location(d_math219, file$9, 731, 0, 40486);
    			add_location(d_math220, file$9, 733, 0, 40548);
    			add_location(d_math221, file$9, 735, 0, 40610);
    			add_location(p63, file$9, 722, 0, 39963);
    			add_location(d_math222, file$9, 738, 0, 40732);
    			add_location(em11, file$9, 739, 18, 40849);
    			add_location(d_math223, file$9, 740, 0, 40952);
    			add_location(d_math224, file$9, 742, 0, 41058);
    			add_location(em12, file$9, 743, 12, 41099);
    			add_location(d_math225, file$9, 744, 0, 41356);
    			add_location(d_math226, file$9, 746, 0, 41449);
    			add_location(p64, file$9, 737, 0, 40696);
    			add_location(d_math227, file$9, 749, 0, 41702);
    			add_location(d_math228, file$9, 751, 0, 41902);
    			add_location(d_math229, file$9, 753, 0, 41949);
    			add_location(p65, file$9, 748, 0, 41605);
    			add_location(d_math230, file$9, 755, 103, 42117);
    			attr_dev(h210, "id", "a-set-of-spanning-functions-for-general-html-mathcalx");
    			add_location(h210, file$9, 755, 0, 42014);
    			add_location(d_math231, file$9, 757, 0, 42217);
    			add_location(d_math232, file$9, 759, 0, 42308);
    			add_location(d_math233, file$9, 761, 0, 42442);
    			add_location(d_math234, file$9, 763, 0, 42547);
    			add_location(d_math235, file$9, 765, 0, 42648);
    			add_location(d_math236, file$9, 767, 0, 42703);
    			add_location(d_math237, file$9, 769, 0, 42836);
    			add_location(d_math238, file$9, 771, 0, 42882);
    			add_location(d_math239, file$9, 773, 0, 42941);
    			add_location(p66, file$9, 756, 0, 42162);
    			add_location(p67, file$9, 775, 0, 43042);
    			add_location(d_math240, file$9, 777, 0, 43106);
    			add_location(d_math241, file$9, 779, 0, 43159);
    			add_location(d_math242, file$9, 781, 0, 43255);
    			add_location(d_math243, file$9, 783, 0, 43348);
    			add_location(d_math244, file$9, 785, 0, 43392);
    			add_location(p68, file$9, 776, 0, 43064);
    			attr_dev(h211, "id", "part-2---examples-of-linear-problems");
    			add_location(h211, file$9, 787, 0, 43569);
    			add_location(p69, file$9, 788, 0, 43657);
    			attr_dev(h212, "id", "kernel-ridge-regression");
    			add_location(h212, file$9, 789, 0, 43922);
    			attr_dev(h213, "id", "kernel-linear-regression");
    			add_location(h213, file$9, 790, 0, 43984);
    			attr_dev(h214, "id", "kernel-pca");
    			add_location(h214, file$9, 791, 0, 44048);
    			add_location(p70, file$9, 792, 0, 44084);
    			attr_dev(h215, "id", "kernel-k-means-and-cca");
    			add_location(h215, file$9, 793, 0, 44108);
    			add_location(p71, file$9, 794, 0, 44168);
    			add_location(d_math245, file$9, 795, 3, 44196);
    			add_location(p72, file$9, 795, 0, 44193);
    			attr_dev(a0, "href", "https://arxiv.org/pdf/1212.4522.pdf");
    			add_location(a0, file$9, 797, 27, 44462);
    			add_location(p73, file$9, 797, 0, 44435);
    			attr_dev(h216, "id", "large-margin-classifiers");
    			add_location(h216, file$9, 798, 0, 44552);
    			add_location(em13, file$9, 799, 33, 44649);
    			add_location(d_math246, file$9, 800, 0, 44682);
    			add_location(d_math247, file$9, 802, 0, 44717);
    			add_location(d_math248, file$9, 804, 0, 44756);
    			add_location(d_math249, file$9, 806, 0, 44850);
    			add_location(p74, file$9, 799, 0, 44616);
    			add_location(th0, file$9, 811, 0, 44916);
    			add_location(d_math250, file$9, 812, 4, 44936);
    			add_location(th1, file$9, 812, 0, 44932);
    			add_location(tr0, file$9, 810, 0, 44911);
    			add_location(thead, file$9, 809, 0, 44903);
    			add_location(td0, file$9, 816, 0, 45007);
    			add_location(d_math251, file$9, 817, 4, 45047);
    			add_location(td1, file$9, 817, 0, 45043);
    			add_location(tr1, file$9, 815, 7, 45002);
    			add_location(td2, file$9, 820, 0, 45110);
    			add_location(d_math252, file$9, 821, 4, 45142);
    			add_location(td3, file$9, 821, 0, 45138);
    			add_location(tr2, file$9, 819, 0, 45105);
    			add_location(td4, file$9, 824, 0, 45202);
    			add_location(d_math253, file$9, 825, 4, 45221);
    			add_location(td5, file$9, 825, 0, 45217);
    			add_location(tr3, file$9, 823, 0, 45197);
    			add_location(td6, file$9, 828, 0, 45284);
    			add_location(d_math254, file$9, 829, 4, 45306);
    			add_location(td7, file$9, 829, 0, 45302);
    			add_location(tr4, file$9, 827, 0, 45279);
    			add_location(tbody, file$9, 815, 0, 44995);
    			add_location(table, file$9, 808, 0, 44895);
    			add_location(p75, file$9, 832, 0, 45371);
    			set_custom_element_data(d_math255, "block", "");
    			add_location(d_math255, file$9, 833, 0, 45402);
    			add_location(d_math256, file$9, 843, 0, 45856);
    			add_location(p76, file$9, 842, 0, 45813);
    			add_location(d_math257, file$9, 845, 3, 46012);
    			add_location(p77, file$9, 845, 0, 46009);
    			add_location(p78, file$9, 847, 0, 46133);
    			attr_dev(h217, "id", "neural-tangent-kernel");
    			add_location(h217, file$9, 848, 0, 46197);
    			attr_dev(a1, "href", "https://arxiv.org/abs/1806.07572");
    			add_location(a1, file$9, 849, 7, 46262);
    			add_location(p79, file$9, 849, 0, 46255);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h10, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, d_math0);
    			d_math0.innerHTML = raw0_value;
    			insert_dev(target, t2, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t3);
    			append_dev(p1, d_math1);
    			d_math1.innerHTML = raw1_value;
    			append_dev(p1, t4);
    			append_dev(p1, d_math2);
    			d_math2.innerHTML = raw2_value;
    			append_dev(p1, t5);
    			append_dev(p1, d_math3);
    			d_math3.innerHTML = raw3_value;
    			append_dev(p1, t6);
    			append_dev(p1, d_math4);
    			d_math4.innerHTML = raw4_value;
    			append_dev(p1, t7);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t9);
    			append_dev(p2, d_math5);
    			d_math5.innerHTML = raw5_value;
    			append_dev(p2, t10);
    			append_dev(p2, d_math6);
    			d_math6.innerHTML = raw6_value;
    			append_dev(p2, t11);
    			append_dev(p2, d_math7);
    			d_math7.innerHTML = raw7_value;
    			append_dev(p2, t12);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, p3, anchor);
    			append_dev(p3, t14);
    			append_dev(p3, d_math8);
    			d_math8.innerHTML = raw8_value;
    			append_dev(p3, t15);
    			append_dev(p3, d_math9);
    			d_math9.innerHTML = raw9_value;
    			append_dev(p3, t16);
    			append_dev(p3, d_math10);
    			d_math10.innerHTML = raw10_value;
    			append_dev(p3, t17);
    			append_dev(p3, d_math11);
    			d_math11.innerHTML = raw11_value;
    			append_dev(p3, t18);
    			append_dev(p3, d_math12);
    			d_math12.innerHTML = raw12_value;
    			append_dev(p3, t19);
    			append_dev(p3, d_math13);
    			d_math13.innerHTML = raw13_value;
    			append_dev(p3, t20);
    			append_dev(p3, d_math14);
    			d_math14.innerHTML = raw14_value;
    			append_dev(p3, t21);
    			insert_dev(target, t22, anchor);
    			insert_dev(target, p4, anchor);
    			insert_dev(target, t24, anchor);
    			insert_dev(target, d_math15, anchor);
    			d_math15.innerHTML = raw15_value;
    			insert_dev(target, t25, anchor);
    			insert_dev(target, p5, anchor);
    			append_dev(p5, t26);
    			append_dev(p5, d_math16);
    			d_math16.innerHTML = raw16_value;
    			append_dev(p5, t27);
    			append_dev(p5, d_math17);
    			d_math17.innerHTML = raw17_value;
    			append_dev(p5, t28);
    			append_dev(p5, d_math18);
    			d_math18.innerHTML = raw18_value;
    			append_dev(p5, t29);
    			append_dev(p5, d_math19);
    			d_math19.innerHTML = raw19_value;
    			append_dev(p5, t30);
    			append_dev(p5, d_math20);
    			d_math20.innerHTML = raw20_value;
    			append_dev(p5, t31);
    			append_dev(p5, d_math21);
    			d_math21.innerHTML = raw21_value;
    			append_dev(p5, t32);
    			insert_dev(target, t33, anchor);
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t35, anchor);
    			insert_dev(target, p6, anchor);
    			append_dev(p6, strong0);
    			append_dev(strong0, t36);
    			append_dev(strong0, d_math22);
    			d_math22.innerHTML = raw22_value;
    			append_dev(strong0, t37);
    			append_dev(p6, t38);
    			append_dev(p6, em0);
    			append_dev(p6, t40);
    			append_dev(p6, d_math23);
    			d_math23.innerHTML = raw23_value;
    			append_dev(p6, t41);
    			append_dev(p6, d_math24);
    			d_math24.innerHTML = raw24_value;
    			append_dev(p6, t42);
    			append_dev(p6, d_math25);
    			d_math25.innerHTML = raw25_value;
    			append_dev(p6, t43);
    			append_dev(p6, d_math26);
    			d_math26.innerHTML = raw26_value;
    			append_dev(p6, t44);
    			insert_dev(target, t45, anchor);
    			insert_dev(target, p7, anchor);
    			append_dev(p7, strong1);
    			append_dev(strong1, t46);
    			append_dev(strong1, d_math27);
    			d_math27.innerHTML = raw27_value;
    			append_dev(p7, t47);
    			append_dev(p7, em1);
    			append_dev(p7, t49);
    			append_dev(p7, d_math28);
    			d_math28.innerHTML = raw28_value;
    			append_dev(p7, t50);
    			append_dev(p7, d_math29);
    			d_math29.innerHTML = raw29_value;
    			append_dev(p7, t51);
    			append_dev(p7, d_math30);
    			d_math30.innerHTML = raw30_value;
    			append_dev(p7, t52);
    			append_dev(p7, em2);
    			append_dev(p7, t54);
    			append_dev(p7, d_math31);
    			d_math31.innerHTML = raw31_value;
    			append_dev(p7, t55);
    			insert_dev(target, t56, anchor);
    			insert_dev(target, p8, anchor);
    			append_dev(p8, strong2);
    			append_dev(p8, t58);
    			append_dev(p8, d_math32);
    			d_math32.innerHTML = raw32_value;
    			append_dev(p8, t59);
    			insert_dev(target, t60, anchor);
    			insert_dev(target, p9, anchor);
    			append_dev(p9, strong3);
    			append_dev(p9, t62);
    			insert_dev(target, t63, anchor);
    			insert_dev(target, p10, anchor);
    			append_dev(p10, t64);
    			append_dev(p10, d_math33);
    			d_math33.innerHTML = raw33_value;
    			append_dev(p10, t65);
    			insert_dev(target, t66, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t68, anchor);
    			insert_dev(target, p11, anchor);
    			insert_dev(target, t70, anchor);
    			insert_dev(target, p12, anchor);
    			append_dev(p12, t71);
    			append_dev(p12, strong4);
    			append_dev(p12, t73);
    			append_dev(p12, d_math34);
    			d_math34.innerHTML = raw34_value;
    			append_dev(p12, t74);
    			append_dev(p12, d_math35);
    			d_math35.innerHTML = raw35_value;
    			append_dev(p12, t75);
    			append_dev(p12, d_math36);
    			d_math36.innerHTML = raw36_value;
    			append_dev(p12, t76);
    			append_dev(p12, d_math37);
    			d_math37.innerHTML = raw37_value;
    			append_dev(p12, t77);
    			insert_dev(target, t78, anchor);
    			insert_dev(target, p13, anchor);
    			append_dev(p13, t79);
    			append_dev(p13, strong5);
    			append_dev(p13, t81);
    			append_dev(p13, d_math38);
    			d_math38.innerHTML = raw38_value;
    			append_dev(p13, t82);
    			append_dev(p13, d_math39);
    			d_math39.innerHTML = raw39_value;
    			append_dev(p13, t83);
    			append_dev(p13, d_math40);
    			d_math40.innerHTML = raw40_value;
    			append_dev(p13, t84);
    			append_dev(p13, d_math41);
    			d_math41.innerHTML = raw41_value;
    			append_dev(p13, t85);
    			append_dev(p13, d_math42);
    			d_math42.innerHTML = raw42_value;
    			append_dev(p13, t86);
    			append_dev(p13, em3);
    			append_dev(p13, t88);
    			append_dev(p13, d_math43);
    			d_math43.innerHTML = raw43_value;
    			append_dev(p13, t89);
    			append_dev(p13, d_math44);
    			d_math44.innerHTML = raw44_value;
    			append_dev(p13, t90);
    			insert_dev(target, t91, anchor);
    			insert_dev(target, p14, anchor);
    			append_dev(p14, t92);
    			append_dev(p14, strong6);
    			append_dev(p14, t94);
    			append_dev(p14, br0);
    			append_dev(p14, d_math45);
    			d_math45.innerHTML = raw45_value;
    			append_dev(p14, t95);
    			append_dev(p14, d_math46);
    			d_math46.innerHTML = raw46_value;
    			append_dev(p14, t96);
    			insert_dev(target, t97, anchor);
    			insert_dev(target, p15, anchor);
    			append_dev(p15, t98);
    			append_dev(p15, d_math47);
    			d_math47.innerHTML = raw47_value;
    			append_dev(p15, t99);
    			append_dev(p15, d_math48);
    			d_math48.innerHTML = raw48_value;
    			append_dev(p15, t100);
    			insert_dev(target, t101, anchor);
    			insert_dev(target, h22, anchor);
    			append_dev(h22, t102);
    			append_dev(h22, d_math49);
    			d_math49.innerHTML = raw49_value;
    			insert_dev(target, t103, anchor);
    			insert_dev(target, p16, anchor);
    			append_dev(p16, t104);
    			append_dev(p16, d_math50);
    			d_math50.innerHTML = raw50_value;
    			append_dev(p16, t105);
    			append_dev(p16, d_math51);
    			d_math51.innerHTML = raw51_value;
    			append_dev(p16, t106);
    			append_dev(p16, d_math52);
    			d_math52.innerHTML = raw52_value;
    			append_dev(p16, t107);
    			append_dev(p16, d_math53);
    			d_math53.innerHTML = raw53_value;
    			append_dev(p16, t108);
    			append_dev(p16, d_math54);
    			d_math54.innerHTML = raw54_value;
    			append_dev(p16, t109);
    			insert_dev(target, t110, anchor);
    			insert_dev(target, d_math55, anchor);
    			d_math55.innerHTML = raw55_value;
    			insert_dev(target, t111, anchor);
    			insert_dev(target, p17, anchor);
    			append_dev(p17, t112);
    			append_dev(p17, d_math56);
    			d_math56.innerHTML = raw56_value;
    			append_dev(p17, t113);
    			append_dev(p17, d_math57);
    			d_math57.innerHTML = raw57_value;
    			append_dev(p17, t114);
    			append_dev(p17, d_math58);
    			d_math58.innerHTML = raw58_value;
    			append_dev(p17, t115);
    			insert_dev(target, t116, anchor);
    			insert_dev(target, d_math59, anchor);
    			d_math59.innerHTML = raw59_value;
    			insert_dev(target, t117, anchor);
    			insert_dev(target, p18, anchor);
    			append_dev(p18, t118);
    			append_dev(p18, d_math60);
    			d_math60.innerHTML = raw60_value;
    			append_dev(p18, t119);
    			append_dev(p18, d_math61);
    			d_math61.innerHTML = raw61_value;
    			append_dev(p18, t120);
    			append_dev(p18, d_math62);
    			d_math62.innerHTML = raw62_value;
    			insert_dev(target, t121, anchor);
    			insert_dev(target, p19, anchor);
    			append_dev(p19, t122);
    			append_dev(p19, d_math63);
    			d_math63.innerHTML = raw63_value;
    			append_dev(p19, t123);
    			append_dev(p19, d_math64);
    			d_math64.innerHTML = raw64_value;
    			append_dev(p19, t124);
    			append_dev(p19, d_math65);
    			d_math65.innerHTML = raw65_value;
    			append_dev(p19, t125);
    			append_dev(p19, d_math66);
    			d_math66.innerHTML = raw66_value;
    			append_dev(p19, t126);
    			append_dev(p19, d_math67);
    			d_math67.innerHTML = raw67_value;
    			append_dev(p19, t127);
    			append_dev(p19, d_math68);
    			d_math68.innerHTML = raw68_value;
    			append_dev(p19, t128);
    			append_dev(p19, d_math69);
    			d_math69.innerHTML = raw69_value;
    			append_dev(p19, t129);
    			insert_dev(target, t130, anchor);
    			insert_dev(target, p20, anchor);
    			append_dev(p20, t131);
    			append_dev(p20, d_math70);
    			d_math70.innerHTML = raw70_value;
    			append_dev(p20, t132);
    			append_dev(p20, d_math71);
    			d_math71.innerHTML = raw71_value;
    			append_dev(p20, t133);
    			append_dev(p20, d_math72);
    			d_math72.innerHTML = raw72_value;
    			append_dev(p20, t134);
    			append_dev(p20, d_math73);
    			d_math73.innerHTML = raw73_value;
    			append_dev(p20, t135);
    			append_dev(p20, d_math74);
    			d_math74.innerHTML = raw74_value;
    			append_dev(p20, t136);
    			append_dev(p20, d_math75);
    			d_math75.innerHTML = raw75_value;
    			append_dev(p20, t137);
    			insert_dev(target, t138, anchor);
    			insert_dev(target, p21, anchor);
    			append_dev(p21, t139);
    			append_dev(p21, d_math76);
    			d_math76.innerHTML = raw76_value;
    			append_dev(p21, t140);
    			append_dev(p21, d_math77);
    			d_math77.innerHTML = raw77_value;
    			append_dev(p21, t141);
    			append_dev(p21, d_math78);
    			d_math78.innerHTML = raw78_value;
    			append_dev(p21, t142);
    			append_dev(p21, d_math79);
    			d_math79.innerHTML = raw79_value;
    			append_dev(p21, t143);
    			append_dev(p21, em4);
    			append_dev(p21, t145);
    			append_dev(p21, d_math80);
    			d_math80.innerHTML = raw80_value;
    			append_dev(p21, t146);
    			insert_dev(target, t147, anchor);
    			insert_dev(target, h23, anchor);
    			insert_dev(target, t149, anchor);
    			insert_dev(target, ol, anchor);
    			append_dev(ol, li0);
    			append_dev(li0, p22);
    			append_dev(ol, t151);
    			append_dev(ol, li8);
    			append_dev(li8, p23);
    			append_dev(li8, t153);
    			append_dev(li8, ul0);
    			append_dev(ul0, li1);
    			append_dev(ul0, t155);
    			append_dev(ul0, li2);
    			append_dev(ul0, t157);
    			append_dev(ul0, li3);
    			append_dev(ul0, t159);
    			append_dev(ul0, li4);
    			append_dev(ul0, t161);
    			append_dev(ul0, li5);
    			append_dev(ul0, t163);
    			append_dev(ul0, li6);
    			append_dev(ul0, t165);
    			append_dev(ul0, li7);
    			insert_dev(target, t167, anchor);
    			insert_dev(target, h24, anchor);
    			insert_dev(target, t169, anchor);
    			insert_dev(target, p24, anchor);
    			append_dev(p24, t170);
    			append_dev(p24, em5);
    			append_dev(p24, t172);
    			insert_dev(target, t173, anchor);
    			insert_dev(target, p25, anchor);
    			insert_dev(target, t175, anchor);
    			insert_dev(target, p26, anchor);
    			insert_dev(target, t177, anchor);
    			insert_dev(target, p27, anchor);
    			insert_dev(target, t179, anchor);
    			insert_dev(target, h25, anchor);
    			insert_dev(target, t181, anchor);
    			insert_dev(target, p28, anchor);
    			append_dev(p28, t182);
    			append_dev(p28, d_math81);
    			d_math81.innerHTML = raw81_value;
    			append_dev(p28, t183);
    			insert_dev(target, t184, anchor);
    			insert_dev(target, d_math82, anchor);
    			d_math82.innerHTML = raw82_value;
    			insert_dev(target, t185, anchor);
    			insert_dev(target, p29, anchor);
    			append_dev(p29, t186);
    			append_dev(p29, d_math83);
    			d_math83.innerHTML = raw83_value;
    			append_dev(p29, t187);
    			append_dev(p29, d_math84);
    			d_math84.innerHTML = raw84_value;
    			append_dev(p29, t188);
    			append_dev(p29, d_math85);
    			d_math85.innerHTML = raw85_value;
    			append_dev(p29, t189);
    			append_dev(p29, d_math86);
    			d_math86.innerHTML = raw86_value;
    			append_dev(p29, t190);
    			append_dev(p29, d_math87);
    			d_math87.innerHTML = raw87_value;
    			append_dev(p29, t191);
    			insert_dev(target, t192, anchor);
    			insert_dev(target, p30, anchor);
    			append_dev(p30, t193);
    			append_dev(p30, d_math88);
    			d_math88.innerHTML = raw88_value;
    			append_dev(p30, t194);
    			append_dev(p30, d_math89);
    			d_math89.innerHTML = raw89_value;
    			append_dev(p30, t195);
    			append_dev(p30, d_math90);
    			d_math90.innerHTML = raw90_value;
    			append_dev(p30, t196);
    			insert_dev(target, t197, anchor);
    			insert_dev(target, d_math91, anchor);
    			d_math91.innerHTML = raw91_value;
    			insert_dev(target, t198, anchor);
    			insert_dev(target, p31, anchor);
    			append_dev(p31, t199);
    			append_dev(p31, d_math92);
    			d_math92.innerHTML = raw92_value;
    			append_dev(p31, t200);
    			append_dev(p31, d_math93);
    			d_math93.innerHTML = raw93_value;
    			append_dev(p31, t201);
    			append_dev(p31, d_math94);
    			d_math94.innerHTML = raw94_value;
    			append_dev(p31, t202);
    			append_dev(p31, d_math95);
    			d_math95.innerHTML = raw95_value;
    			append_dev(p31, t203);
    			append_dev(p31, d_math96);
    			d_math96.innerHTML = raw96_value;
    			append_dev(p31, t204);
    			insert_dev(target, t205, anchor);
    			insert_dev(target, p32, anchor);
    			append_dev(p32, t206);
    			append_dev(p32, d_math97);
    			d_math97.innerHTML = raw97_value;
    			append_dev(p32, t207);
    			append_dev(p32, d_math98);
    			d_math98.innerHTML = raw98_value;
    			append_dev(p32, t208);
    			append_dev(p32, d_math99);
    			d_math99.innerHTML = raw99_value;
    			append_dev(p32, t209);
    			append_dev(p32, d_math100);
    			d_math100.innerHTML = raw100_value;
    			append_dev(p32, t210);
    			append_dev(p32, d_math101);
    			d_math101.innerHTML = raw101_value;
    			append_dev(p32, t211);
    			append_dev(p32, d_math102);
    			d_math102.innerHTML = raw102_value;
    			append_dev(p32, t212);
    			append_dev(p32, em6);
    			append_dev(p32, t214);
    			insert_dev(target, t215, anchor);
    			insert_dev(target, d_math103, anchor);
    			d_math103.innerHTML = raw103_value;
    			insert_dev(target, t216, anchor);
    			insert_dev(target, p33, anchor);
    			append_dev(p33, t217);
    			append_dev(p33, d_math104);
    			d_math104.innerHTML = raw104_value;
    			append_dev(p33, t218);
    			append_dev(p33, d_math105);
    			d_math105.innerHTML = raw105_value;
    			append_dev(p33, t219);
    			append_dev(p33, d_math106);
    			d_math106.innerHTML = raw106_value;
    			append_dev(p33, t220);
    			append_dev(p33, d_math107);
    			d_math107.innerHTML = raw107_value;
    			append_dev(p33, t221);
    			append_dev(p33, d_math108);
    			d_math108.innerHTML = raw108_value;
    			append_dev(p33, t222);
    			insert_dev(target, t223, anchor);
    			insert_dev(target, p34, anchor);
    			append_dev(p34, t224);
    			append_dev(p34, d_math109);
    			d_math109.innerHTML = raw109_value;
    			append_dev(p34, t225);
    			append_dev(p34, d_math110);
    			d_math110.innerHTML = raw110_value;
    			append_dev(p34, t226);
    			append_dev(p34, d_math111);
    			d_math111.innerHTML = raw111_value;
    			append_dev(p34, t227);
    			append_dev(p34, d_math112);
    			d_math112.innerHTML = raw112_value;
    			append_dev(p34, t228);
    			append_dev(p34, d_math113);
    			d_math113.innerHTML = raw113_value;
    			append_dev(p34, t229);
    			append_dev(p34, d_math114);
    			d_math114.innerHTML = raw114_value;
    			append_dev(p34, t230);
    			insert_dev(target, t231, anchor);
    			insert_dev(target, d_math115, anchor);
    			d_math115.innerHTML = raw115_value;
    			insert_dev(target, t232, anchor);
    			insert_dev(target, p35, anchor);
    			append_dev(p35, t233);
    			append_dev(p35, d_math116);
    			d_math116.innerHTML = raw116_value;
    			append_dev(p35, t234);
    			append_dev(p35, d_math117);
    			d_math117.innerHTML = raw117_value;
    			append_dev(p35, t235);
    			append_dev(p35, d_math118);
    			d_math118.innerHTML = raw118_value;
    			append_dev(p35, t236);
    			append_dev(p35, d_math119);
    			d_math119.innerHTML = raw119_value;
    			append_dev(p35, t237);
    			append_dev(p35, d_math120);
    			d_math120.innerHTML = raw120_value;
    			append_dev(p35, t238);
    			insert_dev(target, t239, anchor);
    			insert_dev(target, p36, anchor);
    			append_dev(p36, t240);
    			append_dev(p36, d_math121);
    			d_math121.innerHTML = raw121_value;
    			append_dev(p36, t241);
    			append_dev(p36, em7);
    			append_dev(p36, t243);
    			append_dev(p36, d_math122);
    			d_math122.innerHTML = raw122_value;
    			append_dev(p36, t244);
    			append_dev(p36, d_math123);
    			d_math123.innerHTML = raw123_value;
    			append_dev(p36, t245);
    			insert_dev(target, t246, anchor);
    			insert_dev(target, h26, anchor);
    			insert_dev(target, t248, anchor);
    			insert_dev(target, p37, anchor);
    			append_dev(p37, t249);
    			append_dev(p37, d_math124);
    			d_math124.innerHTML = raw124_value;
    			append_dev(p37, t250);
    			append_dev(p37, d_math125);
    			d_math125.innerHTML = raw125_value;
    			append_dev(p37, t251);
    			append_dev(p37, d_math126);
    			d_math126.innerHTML = raw126_value;
    			append_dev(p37, t252);
    			append_dev(p37, d_math127);
    			d_math127.innerHTML = raw127_value;
    			append_dev(p37, t253);
    			append_dev(p37, d_math128);
    			d_math128.innerHTML = raw128_value;
    			append_dev(p37, t254);
    			insert_dev(target, t255, anchor);
    			insert_dev(target, d_math129, anchor);
    			d_math129.innerHTML = raw129_value;
    			insert_dev(target, t256, anchor);
    			insert_dev(target, p38, anchor);
    			append_dev(p38, t257);
    			append_dev(p38, d_math130);
    			d_math130.innerHTML = raw130_value;
    			append_dev(p38, t258);
    			append_dev(p38, d_math131);
    			d_math131.innerHTML = raw131_value;
    			append_dev(p38, t259);
    			append_dev(p38, d_math132);
    			d_math132.innerHTML = raw132_value;
    			append_dev(p38, t260);
    			append_dev(p38, d_math133);
    			d_math133.innerHTML = raw133_value;
    			append_dev(p38, t261);
    			append_dev(p38, d_math134);
    			d_math134.innerHTML = raw134_value;
    			append_dev(p38, t262);
    			append_dev(p38, d_math135);
    			d_math135.innerHTML = raw135_value;
    			append_dev(p38, t263);
    			insert_dev(target, t264, anchor);
    			insert_dev(target, p39, anchor);
    			append_dev(p39, t265);
    			append_dev(p39, d_math136);
    			d_math136.innerHTML = raw136_value;
    			append_dev(p39, t266);
    			append_dev(p39, d_math137);
    			d_math137.innerHTML = raw137_value;
    			append_dev(p39, t267);
    			insert_dev(target, t268, anchor);
    			insert_dev(target, p40, anchor);
    			append_dev(p40, t269);
    			append_dev(p40, d_math138);
    			d_math138.innerHTML = raw138_value;
    			append_dev(p40, t270);
    			append_dev(p40, d_math139);
    			d_math139.innerHTML = raw139_value;
    			append_dev(p40, t271);
    			append_dev(p40, d_math140);
    			d_math140.innerHTML = raw140_value;
    			append_dev(p40, t272);
    			append_dev(p40, d_math141);
    			d_math141.innerHTML = raw141_value;
    			append_dev(p40, t273);
    			append_dev(p40, d_math142);
    			d_math142.innerHTML = raw142_value;
    			append_dev(p40, t274);
    			insert_dev(target, t275, anchor);
    			insert_dev(target, p41, anchor);
    			append_dev(p41, t276);
    			append_dev(p41, d_math143);
    			d_math143.innerHTML = raw143_value;
    			append_dev(p41, t277);
    			append_dev(p41, d_math144);
    			d_math144.innerHTML = raw144_value;
    			append_dev(p41, t278);
    			insert_dev(target, t279, anchor);
    			insert_dev(target, d_math145, anchor);
    			d_math145.innerHTML = raw145_value;
    			insert_dev(target, t280, anchor);
    			insert_dev(target, p42, anchor);
    			append_dev(p42, t281);
    			append_dev(p42, d_math146);
    			d_math146.innerHTML = raw146_value;
    			append_dev(p42, t282);
    			append_dev(p42, d_math147);
    			d_math147.innerHTML = raw147_value;
    			append_dev(p42, t283);
    			append_dev(p42, d_math148);
    			d_math148.innerHTML = raw148_value;
    			append_dev(p42, t284);
    			append_dev(p42, d_math149);
    			d_math149.innerHTML = raw149_value;
    			append_dev(p42, t285);
    			append_dev(p42, d_math150);
    			d_math150.innerHTML = raw150_value;
    			append_dev(p42, t286);
    			insert_dev(target, t287, anchor);
    			insert_dev(target, p43, anchor);
    			insert_dev(target, t289, anchor);
    			insert_dev(target, d_math151, anchor);
    			d_math151.innerHTML = raw151_value;
    			insert_dev(target, t290, anchor);
    			insert_dev(target, p44, anchor);
    			append_dev(p44, t291);
    			append_dev(p44, d_math152);
    			d_math152.innerHTML = raw152_value;
    			append_dev(p44, t292);
    			append_dev(p44, d_math153);
    			d_math153.innerHTML = raw153_value;
    			append_dev(p44, t293);
    			append_dev(p44, d_math154);
    			d_math154.innerHTML = raw154_value;
    			append_dev(p44, t294);
    			append_dev(p44, d_math155);
    			d_math155.innerHTML = raw155_value;
    			append_dev(p44, t295);
    			append_dev(p44, d_math156);
    			d_math156.innerHTML = raw156_value;
    			append_dev(p44, t296);
    			append_dev(p44, d_math157);
    			d_math157.innerHTML = raw157_value;
    			append_dev(p44, t297);
    			append_dev(p44, d_math158);
    			d_math158.innerHTML = raw158_value;
    			append_dev(p44, t298);
    			append_dev(p44, d_math159);
    			d_math159.innerHTML = raw159_value;
    			append_dev(p44, t299);
    			append_dev(p44, d_math160);
    			d_math160.innerHTML = raw160_value;
    			append_dev(p44, t300);
    			append_dev(p44, d_math161);
    			d_math161.innerHTML = raw161_value;
    			append_dev(p44, t301);
    			insert_dev(target, t302, anchor);
    			insert_dev(target, h27, anchor);
    			insert_dev(target, t304, anchor);
    			insert_dev(target, p45, anchor);
    			append_dev(p45, t305);
    			append_dev(p45, d_math162);
    			d_math162.innerHTML = raw162_value;
    			append_dev(p45, t306);
    			insert_dev(target, t307, anchor);
    			insert_dev(target, d_math163, anchor);
    			d_math163.innerHTML = raw163_value;
    			insert_dev(target, t308, anchor);
    			insert_dev(target, p46, anchor);
    			append_dev(p46, t309);
    			append_dev(p46, d_math164);
    			d_math164.innerHTML = raw164_value;
    			append_dev(p46, t310);
    			insert_dev(target, t311, anchor);
    			insert_dev(target, d_math165, anchor);
    			d_math165.innerHTML = raw165_value;
    			insert_dev(target, t312, anchor);
    			insert_dev(target, p47, anchor);
    			insert_dev(target, t314, anchor);
    			insert_dev(target, d_math166, anchor);
    			d_math166.innerHTML = raw166_value;
    			insert_dev(target, t315, anchor);
    			insert_dev(target, p48, anchor);
    			insert_dev(target, t317, anchor);
    			insert_dev(target, d_math167, anchor);
    			d_math167.innerHTML = raw167_value;
    			insert_dev(target, t318, anchor);
    			insert_dev(target, p49, anchor);
    			append_dev(p49, t319);
    			append_dev(p49, d_math168);
    			d_math168.innerHTML = raw168_value;
    			append_dev(p49, t320);
    			append_dev(p49, d_math169);
    			d_math169.innerHTML = raw169_value;
    			append_dev(p49, t321);
    			append_dev(p49, d_math170);
    			d_math170.innerHTML = raw170_value;
    			append_dev(p49, t322);
    			insert_dev(target, t323, anchor);
    			insert_dev(target, d_math171, anchor);
    			d_math171.innerHTML = raw171_value;
    			insert_dev(target, t324, anchor);
    			insert_dev(target, p50, anchor);
    			insert_dev(target, t326, anchor);
    			insert_dev(target, d_math172, anchor);
    			d_math172.innerHTML = raw172_value;
    			insert_dev(target, t327, anchor);
    			insert_dev(target, p51, anchor);
    			insert_dev(target, t329, anchor);
    			insert_dev(target, d_math173, anchor);
    			d_math173.innerHTML = raw173_value;
    			insert_dev(target, t330, anchor);
    			insert_dev(target, h28, anchor);
    			insert_dev(target, t332, anchor);
    			insert_dev(target, p52, anchor);
    			append_dev(p52, t333);
    			append_dev(p52, d_math174);
    			d_math174.innerHTML = raw174_value;
    			append_dev(p52, t334);
    			append_dev(p52, d_math175);
    			d_math175.innerHTML = raw175_value;
    			append_dev(p52, t335);
    			append_dev(p52, em8);
    			append_dev(p52, t337);
    			append_dev(p52, d_math176);
    			d_math176.innerHTML = raw176_value;
    			append_dev(p52, t338);
    			append_dev(p52, d_math177);
    			d_math177.innerHTML = raw177_value;
    			append_dev(p52, t339);
    			append_dev(p52, d_math178);
    			d_math178.innerHTML = raw178_value;
    			append_dev(p52, t340);
    			append_dev(p52, br1);
    			append_dev(p52, d_math179);
    			d_math179.innerHTML = raw179_value;
    			append_dev(p52, t341);
    			append_dev(p52, d_math180);
    			d_math180.innerHTML = raw180_value;
    			append_dev(p52, t342);
    			append_dev(p52, d_math181);
    			d_math181.innerHTML = raw181_value;
    			append_dev(p52, t343);
    			insert_dev(target, t344, anchor);
    			insert_dev(target, p53, anchor);
    			append_dev(p53, t345);
    			append_dev(p53, d_math182);
    			d_math182.innerHTML = raw182_value;
    			append_dev(p53, t346);
    			append_dev(p53, d_math183);
    			d_math183.innerHTML = raw183_value;
    			append_dev(p53, t347);
    			insert_dev(target, t348, anchor);
    			insert_dev(target, p54, anchor);
    			append_dev(p54, t349);
    			append_dev(p54, d_math184);
    			d_math184.innerHTML = raw184_value;
    			append_dev(p54, t350);
    			append_dev(p54, d_math185);
    			d_math185.innerHTML = raw185_value;
    			append_dev(p54, t351);
    			append_dev(p54, d_math186);
    			d_math186.innerHTML = raw186_value;
    			append_dev(p54, t352);
    			append_dev(p54, d_math187);
    			d_math187.innerHTML = raw187_value;
    			append_dev(p54, t353);
    			append_dev(p54, d_math188);
    			d_math188.innerHTML = raw188_value;
    			append_dev(p54, t354);
    			append_dev(p54, d_math189);
    			d_math189.innerHTML = raw189_value;
    			append_dev(p54, t355);
    			insert_dev(target, t356, anchor);
    			insert_dev(target, p55, anchor);
    			append_dev(p55, t357);
    			append_dev(p55, em9);
    			append_dev(p55, t359);
    			append_dev(p55, d_math190);
    			d_math190.innerHTML = raw190_value;
    			append_dev(p55, t360);
    			insert_dev(target, t361, anchor);
    			insert_dev(target, d_math191, anchor);
    			d_math191.innerHTML = raw191_value;
    			insert_dev(target, t362, anchor);
    			insert_dev(target, h11, anchor);
    			insert_dev(target, t364, anchor);
    			insert_dev(target, p56, anchor);
    			insert_dev(target, t366, anchor);
    			insert_dev(target, p57, anchor);
    			insert_dev(target, t368, anchor);
    			insert_dev(target, ul1, anchor);
    			append_dev(ul1, li9);
    			append_dev(li9, t369);
    			append_dev(li9, d_math192);
    			d_math192.innerHTML = raw192_value;
    			append_dev(li9, t370);
    			append_dev(li9, d_math193);
    			d_math193.innerHTML = raw193_value;
    			append_dev(li9, t371);
    			append_dev(li9, d_math194);
    			d_math194.innerHTML = raw194_value;
    			append_dev(ul1, t372);
    			append_dev(ul1, li10);
    			append_dev(ul1, t374);
    			append_dev(ul1, li11);
    			append_dev(ul1, t376);
    			append_dev(ul1, li12);
    			append_dev(ul1, t378);
    			append_dev(ul1, li13);
    			insert_dev(target, t380, anchor);
    			insert_dev(target, p58, anchor);
    			append_dev(p58, t381);
    			append_dev(p58, d_math195);
    			d_math195.innerHTML = raw195_value;
    			append_dev(p58, t382);
    			append_dev(p58, d_math196);
    			d_math196.innerHTML = raw196_value;
    			append_dev(p58, t383);
    			append_dev(p58, d_math197);
    			d_math197.innerHTML = raw197_value;
    			append_dev(p58, t384);
    			append_dev(p58, d_math198);
    			d_math198.innerHTML = raw198_value;
    			append_dev(p58, t385);
    			append_dev(p58, d_math199);
    			d_math199.innerHTML = raw199_value;
    			append_dev(p58, t386);
    			insert_dev(target, t387, anchor);
    			insert_dev(target, d_math200, anchor);
    			d_math200.innerHTML = raw200_value;
    			insert_dev(target, t388, anchor);
    			insert_dev(target, p59, anchor);
    			append_dev(p59, t389);
    			append_dev(p59, d_math201);
    			d_math201.innerHTML = raw201_value;
    			append_dev(p59, t390);
    			append_dev(p59, d_math202);
    			d_math202.innerHTML = raw202_value;
    			append_dev(p59, t391);
    			append_dev(p59, d_math203);
    			d_math203.innerHTML = raw203_value;
    			append_dev(p59, t392);
    			insert_dev(target, t393, anchor);
    			insert_dev(target, d_math204, anchor);
    			d_math204.innerHTML = raw204_value;
    			insert_dev(target, t394, anchor);
    			insert_dev(target, h29, anchor);
    			insert_dev(target, t396, anchor);
    			insert_dev(target, p60, anchor);
    			append_dev(p60, t397);
    			append_dev(p60, d_math205);
    			d_math205.innerHTML = raw205_value;
    			append_dev(p60, t398);
    			insert_dev(target, t399, anchor);
    			insert_dev(target, p61, anchor);
    			append_dev(p61, t400);
    			append_dev(p61, d_math206);
    			d_math206.innerHTML = raw206_value;
    			append_dev(p61, t401);
    			append_dev(p61, d_math207);
    			d_math207.innerHTML = raw207_value;
    			append_dev(p61, t402);
    			append_dev(p61, d_math208);
    			d_math208.innerHTML = raw208_value;
    			append_dev(p61, t403);
    			append_dev(p61, d_math209);
    			d_math209.innerHTML = raw209_value;
    			append_dev(p61, t404);
    			insert_dev(target, t405, anchor);
    			insert_dev(target, p62, anchor);
    			append_dev(p62, t406);
    			append_dev(p62, d_math210);
    			d_math210.innerHTML = raw210_value;
    			append_dev(p62, t407);
    			append_dev(p62, d_math211);
    			d_math211.innerHTML = raw211_value;
    			append_dev(p62, t408);
    			append_dev(p62, d_math212);
    			d_math212.innerHTML = raw212_value;
    			append_dev(p62, t409);
    			append_dev(p62, d_math213);
    			d_math213.innerHTML = raw213_value;
    			append_dev(p62, t410);
    			append_dev(p62, d_math214);
    			d_math214.innerHTML = raw214_value;
    			append_dev(p62, t411);
    			insert_dev(target, t412, anchor);
    			insert_dev(target, p63, anchor);
    			append_dev(p63, t413);
    			append_dev(p63, d_math215);
    			d_math215.innerHTML = raw215_value;
    			append_dev(p63, t414);
    			append_dev(p63, d_math216);
    			d_math216.innerHTML = raw216_value;
    			append_dev(p63, t415);
    			append_dev(p63, em10);
    			append_dev(p63, t417);
    			append_dev(p63, d_math217);
    			d_math217.innerHTML = raw217_value;
    			append_dev(p63, t418);
    			append_dev(p63, d_math218);
    			d_math218.innerHTML = raw218_value;
    			append_dev(p63, t419);
    			append_dev(p63, d_math219);
    			d_math219.innerHTML = raw219_value;
    			append_dev(p63, t420);
    			append_dev(p63, d_math220);
    			d_math220.innerHTML = raw220_value;
    			append_dev(p63, t421);
    			append_dev(p63, d_math221);
    			d_math221.innerHTML = raw221_value;
    			append_dev(p63, t422);
    			insert_dev(target, t423, anchor);
    			insert_dev(target, p64, anchor);
    			append_dev(p64, t424);
    			append_dev(p64, d_math222);
    			d_math222.innerHTML = raw222_value;
    			append_dev(p64, t425);
    			append_dev(p64, em11);
    			append_dev(p64, t427);
    			append_dev(p64, d_math223);
    			d_math223.innerHTML = raw223_value;
    			append_dev(p64, t428);
    			append_dev(p64, d_math224);
    			d_math224.innerHTML = raw224_value;
    			append_dev(p64, t429);
    			append_dev(p64, em12);
    			append_dev(p64, t431);
    			append_dev(p64, d_math225);
    			d_math225.innerHTML = raw225_value;
    			append_dev(p64, t432);
    			append_dev(p64, d_math226);
    			d_math226.innerHTML = raw226_value;
    			append_dev(p64, t433);
    			insert_dev(target, t434, anchor);
    			insert_dev(target, p65, anchor);
    			append_dev(p65, t435);
    			append_dev(p65, d_math227);
    			d_math227.innerHTML = raw227_value;
    			append_dev(p65, t436);
    			append_dev(p65, d_math228);
    			d_math228.innerHTML = raw228_value;
    			append_dev(p65, t437);
    			append_dev(p65, d_math229);
    			d_math229.innerHTML = raw229_value;
    			append_dev(p65, t438);
    			insert_dev(target, t439, anchor);
    			insert_dev(target, h210, anchor);
    			append_dev(h210, t440);
    			append_dev(h210, d_math230);
    			d_math230.innerHTML = raw230_value;
    			insert_dev(target, t441, anchor);
    			insert_dev(target, p66, anchor);
    			append_dev(p66, t442);
    			append_dev(p66, d_math231);
    			d_math231.innerHTML = raw231_value;
    			append_dev(p66, t443);
    			append_dev(p66, d_math232);
    			d_math232.innerHTML = raw232_value;
    			append_dev(p66, t444);
    			append_dev(p66, d_math233);
    			d_math233.innerHTML = raw233_value;
    			append_dev(p66, t445);
    			append_dev(p66, d_math234);
    			d_math234.innerHTML = raw234_value;
    			append_dev(p66, t446);
    			append_dev(p66, d_math235);
    			d_math235.innerHTML = raw235_value;
    			append_dev(p66, t447);
    			append_dev(p66, d_math236);
    			d_math236.innerHTML = raw236_value;
    			append_dev(p66, t448);
    			append_dev(p66, d_math237);
    			d_math237.innerHTML = raw237_value;
    			append_dev(p66, t449);
    			append_dev(p66, d_math238);
    			d_math238.innerHTML = raw238_value;
    			append_dev(p66, t450);
    			append_dev(p66, d_math239);
    			d_math239.innerHTML = raw239_value;
    			append_dev(p66, t451);
    			insert_dev(target, t452, anchor);
    			insert_dev(target, p67, anchor);
    			insert_dev(target, t454, anchor);
    			insert_dev(target, p68, anchor);
    			append_dev(p68, t455);
    			append_dev(p68, d_math240);
    			d_math240.innerHTML = raw240_value;
    			append_dev(p68, t456);
    			append_dev(p68, d_math241);
    			d_math241.innerHTML = raw241_value;
    			append_dev(p68, t457);
    			append_dev(p68, d_math242);
    			d_math242.innerHTML = raw242_value;
    			append_dev(p68, t458);
    			append_dev(p68, d_math243);
    			d_math243.innerHTML = raw243_value;
    			append_dev(p68, t459);
    			append_dev(p68, d_math244);
    			d_math244.innerHTML = raw244_value;
    			append_dev(p68, t460);
    			insert_dev(target, t461, anchor);
    			insert_dev(target, h211, anchor);
    			insert_dev(target, t463, anchor);
    			insert_dev(target, p69, anchor);
    			insert_dev(target, t465, anchor);
    			insert_dev(target, h212, anchor);
    			insert_dev(target, t467, anchor);
    			insert_dev(target, h213, anchor);
    			insert_dev(target, t469, anchor);
    			insert_dev(target, h214, anchor);
    			insert_dev(target, t471, anchor);
    			insert_dev(target, p70, anchor);
    			insert_dev(target, t473, anchor);
    			insert_dev(target, h215, anchor);
    			insert_dev(target, t475, anchor);
    			insert_dev(target, p71, anchor);
    			insert_dev(target, t477, anchor);
    			insert_dev(target, p72, anchor);
    			append_dev(p72, d_math245);
    			d_math245.innerHTML = raw245_value;
    			insert_dev(target, t478, anchor);
    			insert_dev(target, p73, anchor);
    			append_dev(p73, t479);
    			append_dev(p73, a0);
    			insert_dev(target, t481, anchor);
    			insert_dev(target, h216, anchor);
    			insert_dev(target, t483, anchor);
    			insert_dev(target, p74, anchor);
    			append_dev(p74, t484);
    			append_dev(p74, em13);
    			append_dev(p74, t486);
    			append_dev(p74, d_math246);
    			d_math246.innerHTML = raw246_value;
    			append_dev(p74, t487);
    			append_dev(p74, d_math247);
    			d_math247.innerHTML = raw247_value;
    			append_dev(p74, t488);
    			append_dev(p74, d_math248);
    			d_math248.innerHTML = raw248_value;
    			append_dev(p74, t489);
    			append_dev(p74, d_math249);
    			d_math249.innerHTML = raw249_value;
    			append_dev(p74, t490);
    			insert_dev(target, t491, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t493);
    			append_dev(tr0, th1);
    			append_dev(th1, d_math250);
    			d_math250.innerHTML = raw250_value;
    			append_dev(table, t494);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t496);
    			append_dev(tr1, td1);
    			append_dev(td1, d_math251);
    			d_math251.innerHTML = raw251_value;
    			append_dev(tbody, t497);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td2);
    			append_dev(tr2, t499);
    			append_dev(tr2, td3);
    			append_dev(td3, d_math252);
    			d_math252.innerHTML = raw252_value;
    			append_dev(tbody, t500);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td4);
    			append_dev(tr3, t502);
    			append_dev(tr3, td5);
    			append_dev(td5, d_math253);
    			d_math253.innerHTML = raw253_value;
    			append_dev(tbody, t503);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td6);
    			append_dev(tr4, t505);
    			append_dev(tr4, td7);
    			append_dev(td7, d_math254);
    			d_math254.innerHTML = raw254_value;
    			insert_dev(target, t506, anchor);
    			insert_dev(target, p75, anchor);
    			insert_dev(target, t508, anchor);
    			insert_dev(target, d_math255, anchor);
    			d_math255.innerHTML = raw255_value;
    			insert_dev(target, t509, anchor);
    			insert_dev(target, p76, anchor);
    			append_dev(p76, t510);
    			append_dev(p76, d_math256);
    			d_math256.innerHTML = raw256_value;
    			append_dev(p76, t511);
    			insert_dev(target, t512, anchor);
    			insert_dev(target, p77, anchor);
    			append_dev(p77, d_math257);
    			d_math257.innerHTML = raw257_value;
    			insert_dev(target, t513, anchor);
    			insert_dev(target, p78, anchor);
    			insert_dev(target, t515, anchor);
    			insert_dev(target, h217, anchor);
    			insert_dev(target, t517, anchor);
    			insert_dev(target, p79, anchor);
    			append_dev(p79, t518);
    			append_dev(p79, a1);
    		},
    		p: noop$5,
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h10);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t22);
    			if (detaching) detach_dev(p4);
    			if (detaching) detach_dev(t24);
    			if (detaching) detach_dev(d_math15);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(p5);
    			if (detaching) detach_dev(t33);
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t35);
    			if (detaching) detach_dev(p6);
    			if (detaching) detach_dev(t45);
    			if (detaching) detach_dev(p7);
    			if (detaching) detach_dev(t56);
    			if (detaching) detach_dev(p8);
    			if (detaching) detach_dev(t60);
    			if (detaching) detach_dev(p9);
    			if (detaching) detach_dev(t63);
    			if (detaching) detach_dev(p10);
    			if (detaching) detach_dev(t66);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t68);
    			if (detaching) detach_dev(p11);
    			if (detaching) detach_dev(t70);
    			if (detaching) detach_dev(p12);
    			if (detaching) detach_dev(t78);
    			if (detaching) detach_dev(p13);
    			if (detaching) detach_dev(t91);
    			if (detaching) detach_dev(p14);
    			if (detaching) detach_dev(t97);
    			if (detaching) detach_dev(p15);
    			if (detaching) detach_dev(t101);
    			if (detaching) detach_dev(h22);
    			if (detaching) detach_dev(t103);
    			if (detaching) detach_dev(p16);
    			if (detaching) detach_dev(t110);
    			if (detaching) detach_dev(d_math55);
    			if (detaching) detach_dev(t111);
    			if (detaching) detach_dev(p17);
    			if (detaching) detach_dev(t116);
    			if (detaching) detach_dev(d_math59);
    			if (detaching) detach_dev(t117);
    			if (detaching) detach_dev(p18);
    			if (detaching) detach_dev(t121);
    			if (detaching) detach_dev(p19);
    			if (detaching) detach_dev(t130);
    			if (detaching) detach_dev(p20);
    			if (detaching) detach_dev(t138);
    			if (detaching) detach_dev(p21);
    			if (detaching) detach_dev(t147);
    			if (detaching) detach_dev(h23);
    			if (detaching) detach_dev(t149);
    			if (detaching) detach_dev(ol);
    			if (detaching) detach_dev(t167);
    			if (detaching) detach_dev(h24);
    			if (detaching) detach_dev(t169);
    			if (detaching) detach_dev(p24);
    			if (detaching) detach_dev(t173);
    			if (detaching) detach_dev(p25);
    			if (detaching) detach_dev(t175);
    			if (detaching) detach_dev(p26);
    			if (detaching) detach_dev(t177);
    			if (detaching) detach_dev(p27);
    			if (detaching) detach_dev(t179);
    			if (detaching) detach_dev(h25);
    			if (detaching) detach_dev(t181);
    			if (detaching) detach_dev(p28);
    			if (detaching) detach_dev(t184);
    			if (detaching) detach_dev(d_math82);
    			if (detaching) detach_dev(t185);
    			if (detaching) detach_dev(p29);
    			if (detaching) detach_dev(t192);
    			if (detaching) detach_dev(p30);
    			if (detaching) detach_dev(t197);
    			if (detaching) detach_dev(d_math91);
    			if (detaching) detach_dev(t198);
    			if (detaching) detach_dev(p31);
    			if (detaching) detach_dev(t205);
    			if (detaching) detach_dev(p32);
    			if (detaching) detach_dev(t215);
    			if (detaching) detach_dev(d_math103);
    			if (detaching) detach_dev(t216);
    			if (detaching) detach_dev(p33);
    			if (detaching) detach_dev(t223);
    			if (detaching) detach_dev(p34);
    			if (detaching) detach_dev(t231);
    			if (detaching) detach_dev(d_math115);
    			if (detaching) detach_dev(t232);
    			if (detaching) detach_dev(p35);
    			if (detaching) detach_dev(t239);
    			if (detaching) detach_dev(p36);
    			if (detaching) detach_dev(t246);
    			if (detaching) detach_dev(h26);
    			if (detaching) detach_dev(t248);
    			if (detaching) detach_dev(p37);
    			if (detaching) detach_dev(t255);
    			if (detaching) detach_dev(d_math129);
    			if (detaching) detach_dev(t256);
    			if (detaching) detach_dev(p38);
    			if (detaching) detach_dev(t264);
    			if (detaching) detach_dev(p39);
    			if (detaching) detach_dev(t268);
    			if (detaching) detach_dev(p40);
    			if (detaching) detach_dev(t275);
    			if (detaching) detach_dev(p41);
    			if (detaching) detach_dev(t279);
    			if (detaching) detach_dev(d_math145);
    			if (detaching) detach_dev(t280);
    			if (detaching) detach_dev(p42);
    			if (detaching) detach_dev(t287);
    			if (detaching) detach_dev(p43);
    			if (detaching) detach_dev(t289);
    			if (detaching) detach_dev(d_math151);
    			if (detaching) detach_dev(t290);
    			if (detaching) detach_dev(p44);
    			if (detaching) detach_dev(t302);
    			if (detaching) detach_dev(h27);
    			if (detaching) detach_dev(t304);
    			if (detaching) detach_dev(p45);
    			if (detaching) detach_dev(t307);
    			if (detaching) detach_dev(d_math163);
    			if (detaching) detach_dev(t308);
    			if (detaching) detach_dev(p46);
    			if (detaching) detach_dev(t311);
    			if (detaching) detach_dev(d_math165);
    			if (detaching) detach_dev(t312);
    			if (detaching) detach_dev(p47);
    			if (detaching) detach_dev(t314);
    			if (detaching) detach_dev(d_math166);
    			if (detaching) detach_dev(t315);
    			if (detaching) detach_dev(p48);
    			if (detaching) detach_dev(t317);
    			if (detaching) detach_dev(d_math167);
    			if (detaching) detach_dev(t318);
    			if (detaching) detach_dev(p49);
    			if (detaching) detach_dev(t323);
    			if (detaching) detach_dev(d_math171);
    			if (detaching) detach_dev(t324);
    			if (detaching) detach_dev(p50);
    			if (detaching) detach_dev(t326);
    			if (detaching) detach_dev(d_math172);
    			if (detaching) detach_dev(t327);
    			if (detaching) detach_dev(p51);
    			if (detaching) detach_dev(t329);
    			if (detaching) detach_dev(d_math173);
    			if (detaching) detach_dev(t330);
    			if (detaching) detach_dev(h28);
    			if (detaching) detach_dev(t332);
    			if (detaching) detach_dev(p52);
    			if (detaching) detach_dev(t344);
    			if (detaching) detach_dev(p53);
    			if (detaching) detach_dev(t348);
    			if (detaching) detach_dev(p54);
    			if (detaching) detach_dev(t356);
    			if (detaching) detach_dev(p55);
    			if (detaching) detach_dev(t361);
    			if (detaching) detach_dev(d_math191);
    			if (detaching) detach_dev(t362);
    			if (detaching) detach_dev(h11);
    			if (detaching) detach_dev(t364);
    			if (detaching) detach_dev(p56);
    			if (detaching) detach_dev(t366);
    			if (detaching) detach_dev(p57);
    			if (detaching) detach_dev(t368);
    			if (detaching) detach_dev(ul1);
    			if (detaching) detach_dev(t380);
    			if (detaching) detach_dev(p58);
    			if (detaching) detach_dev(t387);
    			if (detaching) detach_dev(d_math200);
    			if (detaching) detach_dev(t388);
    			if (detaching) detach_dev(p59);
    			if (detaching) detach_dev(t393);
    			if (detaching) detach_dev(d_math204);
    			if (detaching) detach_dev(t394);
    			if (detaching) detach_dev(h29);
    			if (detaching) detach_dev(t396);
    			if (detaching) detach_dev(p60);
    			if (detaching) detach_dev(t399);
    			if (detaching) detach_dev(p61);
    			if (detaching) detach_dev(t405);
    			if (detaching) detach_dev(p62);
    			if (detaching) detach_dev(t412);
    			if (detaching) detach_dev(p63);
    			if (detaching) detach_dev(t423);
    			if (detaching) detach_dev(p64);
    			if (detaching) detach_dev(t434);
    			if (detaching) detach_dev(p65);
    			if (detaching) detach_dev(t439);
    			if (detaching) detach_dev(h210);
    			if (detaching) detach_dev(t441);
    			if (detaching) detach_dev(p66);
    			if (detaching) detach_dev(t452);
    			if (detaching) detach_dev(p67);
    			if (detaching) detach_dev(t454);
    			if (detaching) detach_dev(p68);
    			if (detaching) detach_dev(t461);
    			if (detaching) detach_dev(h211);
    			if (detaching) detach_dev(t463);
    			if (detaching) detach_dev(p69);
    			if (detaching) detach_dev(t465);
    			if (detaching) detach_dev(h212);
    			if (detaching) detach_dev(t467);
    			if (detaching) detach_dev(h213);
    			if (detaching) detach_dev(t469);
    			if (detaching) detach_dev(h214);
    			if (detaching) detach_dev(t471);
    			if (detaching) detach_dev(p70);
    			if (detaching) detach_dev(t473);
    			if (detaching) detach_dev(h215);
    			if (detaching) detach_dev(t475);
    			if (detaching) detach_dev(p71);
    			if (detaching) detach_dev(t477);
    			if (detaching) detach_dev(p72);
    			if (detaching) detach_dev(t478);
    			if (detaching) detach_dev(p73);
    			if (detaching) detach_dev(t481);
    			if (detaching) detach_dev(h216);
    			if (detaching) detach_dev(t483);
    			if (detaching) detach_dev(p74);
    			if (detaching) detach_dev(t491);
    			if (detaching) detach_dev(table);
    			if (detaching) detach_dev(t506);
    			if (detaching) detach_dev(p75);
    			if (detaching) detach_dev(t508);
    			if (detaching) detach_dev(d_math255);
    			if (detaching) detach_dev(t509);
    			if (detaching) detach_dev(p76);
    			if (detaching) detach_dev(t512);
    			if (detaching) detach_dev(p77);
    			if (detaching) detach_dev(t513);
    			if (detaching) detach_dev(p78);
    			if (detaching) detach_dev(t515);
    			if (detaching) detach_dev(h217);
    			if (detaching) detach_dev(t517);
    			if (detaching) detach_dev(p79);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Kernel_methods', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Kernel_methods> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Kernel_methods extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Kernel_methods",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$5) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$5) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$5;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const toString$1 = Object.prototype.toString;

    function isAnyArray(object) {
      return toString$1.call(object).endsWith('Array]');
    }

    function max$4(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isAnyArray(input)) {
        throw new TypeError('input must be an array');
      }

      if (input.length === 0) {
        throw new TypeError('input must not be empty');
      }

      var _options$fromIndex = options.fromIndex,
          fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
          _options$toIndex = options.toIndex,
          toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

      if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error('fromIndex must be a positive integer smaller than length');
      }

      if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
      }

      var maxValue = input[fromIndex];

      for (var i = fromIndex + 1; i < toIndex; i++) {
        if (input[i] > maxValue) maxValue = input[i];
      }

      return maxValue;
    }

    function min$3(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isAnyArray(input)) {
        throw new TypeError('input must be an array');
      }

      if (input.length === 0) {
        throw new TypeError('input must not be empty');
      }

      var _options$fromIndex = options.fromIndex,
          fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
          _options$toIndex = options.toIndex,
          toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

      if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
        throw new Error('fromIndex must be a positive integer smaller than length');
      }

      if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
        throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
      }

      var minValue = input[fromIndex];

      for (var i = fromIndex + 1; i < toIndex; i++) {
        if (input[i] < minValue) minValue = input[i];
      }

      return minValue;
    }

    function rescale(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!isAnyArray(input)) {
        throw new TypeError('input must be an array');
      } else if (input.length === 0) {
        throw new TypeError('input must not be empty');
      }

      var output;

      if (options.output !== undefined) {
        if (!isAnyArray(options.output)) {
          throw new TypeError('output option must be an array if specified');
        }

        output = options.output;
      } else {
        output = new Array(input.length);
      }

      var currentMin = min$3(input);
      var currentMax = max$4(input);

      if (currentMin === currentMax) {
        throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
      }

      var _options$min = options.min,
          minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,
          _options$max = options.max,
          maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;

      if (minValue >= maxValue) {
        throw new RangeError('min option must be smaller than max option');
      }

      var factor = (maxValue - minValue) / (currentMax - currentMin);

      for (var i = 0; i < input.length; i++) {
        output[i] = (input[i] - currentMin) * factor + minValue;
      }

      return output;
    }

    /**
     * @class LuDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs
     * @param {Matrix} matrix
     */
    class LuDecomposition {
      constructor(matrix) {
        matrix = WrapperMatrix2D.checkMatrix(matrix);

        var lu = matrix.clone();
        var rows = lu.rows;
        var columns = lu.columns;
        var pivotVector = new Array(rows);
        var pivotSign = 1;
        var i, j, k, p, s, t, v;
        var LUcolj, kmax;

        for (i = 0; i < rows; i++) {
          pivotVector[i] = i;
        }

        LUcolj = new Array(rows);

        for (j = 0; j < columns; j++) {
          for (i = 0; i < rows; i++) {
            LUcolj[i] = lu.get(i, j);
          }

          for (i = 0; i < rows; i++) {
            kmax = Math.min(i, j);
            s = 0;
            for (k = 0; k < kmax; k++) {
              s += lu.get(i, k) * LUcolj[k];
            }
            LUcolj[i] -= s;
            lu.set(i, j, LUcolj[i]);
          }

          p = j;
          for (i = j + 1; i < rows; i++) {
            if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
              p = i;
            }
          }

          if (p !== j) {
            for (k = 0; k < columns; k++) {
              t = lu.get(p, k);
              lu.set(p, k, lu.get(j, k));
              lu.set(j, k, t);
            }

            v = pivotVector[p];
            pivotVector[p] = pivotVector[j];
            pivotVector[j] = v;

            pivotSign = -pivotSign;
          }

          if (j < rows && lu.get(j, j) !== 0) {
            for (i = j + 1; i < rows; i++) {
              lu.set(i, j, lu.get(i, j) / lu.get(j, j));
            }
          }
        }

        this.LU = lu;
        this.pivotVector = pivotVector;
        this.pivotSign = pivotSign;
      }

      /**
       *
       * @return {boolean}
       */
      isSingular() {
        var data = this.LU;
        var col = data.columns;
        for (var j = 0; j < col; j++) {
          if (data[j][j] === 0) {
            return true;
          }
        }
        return false;
      }

      /**
       *
       * @param {Matrix} value
       * @return {Matrix}
       */
      solve(value) {
        value = Matrix.checkMatrix(value);

        var lu = this.LU;
        var rows = lu.rows;

        if (rows !== value.rows) {
          throw new Error('Invalid matrix dimensions');
        }
        if (this.isSingular()) {
          throw new Error('LU matrix is singular');
        }

        var count = value.columns;
        var X = value.subMatrixRow(this.pivotVector, 0, count - 1);
        var columns = lu.columns;
        var i, j, k;

        for (k = 0; k < columns; k++) {
          for (i = k + 1; i < columns; i++) {
            for (j = 0; j < count; j++) {
              X[i][j] -= X[k][j] * lu[i][k];
            }
          }
        }
        for (k = columns - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            X[k][j] /= lu[k][k];
          }
          for (i = 0; i < k; i++) {
            for (j = 0; j < count; j++) {
              X[i][j] -= X[k][j] * lu[i][k];
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {number}
       */
      get determinant() {
        var data = this.LU;
        if (!data.isSquare()) {
          throw new Error('Matrix must be square');
        }
        var determinant = this.pivotSign;
        var col = data.columns;
        for (var j = 0; j < col; j++) {
          determinant *= data[j][j];
        }
        return determinant;
      }

      /**
       *
       * @return {Matrix}
       */
      get lowerTriangularMatrix() {
        var data = this.LU;
        var rows = data.rows;
        var columns = data.columns;
        var X = new Matrix(rows, columns);
        for (var i = 0; i < rows; i++) {
          for (var j = 0; j < columns; j++) {
            if (i > j) {
              X[i][j] = data[i][j];
            } else if (i === j) {
              X[i][j] = 1;
            } else {
              X[i][j] = 0;
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {Matrix}
       */
      get upperTriangularMatrix() {
        var data = this.LU;
        var rows = data.rows;
        var columns = data.columns;
        var X = new Matrix(rows, columns);
        for (var i = 0; i < rows; i++) {
          for (var j = 0; j < columns; j++) {
            if (i <= j) {
              X[i][j] = data[i][j];
            } else {
              X[i][j] = 0;
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {Array<number>}
       */
      get pivotPermutationVector() {
        return this.pivotVector.slice();
      }
    }

    function hypotenuse(a, b) {
      var r = 0;
      if (Math.abs(a) > Math.abs(b)) {
        r = b / a;
        return Math.abs(a) * Math.sqrt(1 + r * r);
      }
      if (b !== 0) {
        r = a / b;
        return Math.abs(b) * Math.sqrt(1 + r * r);
      }
      return 0;
    }

    function getFilled2DArray(rows, columns, value) {
      var array = new Array(rows);
      for (var i = 0; i < rows; i++) {
        array[i] = new Array(columns);
        for (var j = 0; j < columns; j++) {
          array[i][j] = value;
        }
      }
      return array;
    }

    /**
     * @class SingularValueDecomposition
     * @see https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs
     * @param {Matrix} value
     * @param {object} [options]
     * @param {boolean} [options.computeLeftSingularVectors=true]
     * @param {boolean} [options.computeRightSingularVectors=true]
     * @param {boolean} [options.autoTranspose=false]
     */
    class SingularValueDecomposition {
      constructor(value, options = {}) {
        value = WrapperMatrix2D.checkMatrix(value);

        var m = value.rows;
        var n = value.columns;

        const {
          computeLeftSingularVectors = true,
          computeRightSingularVectors = true,
          autoTranspose = false
        } = options;

        var wantu = Boolean(computeLeftSingularVectors);
        var wantv = Boolean(computeRightSingularVectors);

        var swapped = false;
        var a;
        if (m < n) {
          if (!autoTranspose) {
            a = value.clone();
            // eslint-disable-next-line no-console
            console.warn(
              'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose'
            );
          } else {
            a = value.transpose();
            m = a.rows;
            n = a.columns;
            swapped = true;
            var aux = wantu;
            wantu = wantv;
            wantv = aux;
          }
        } else {
          a = value.clone();
        }

        var nu = Math.min(m, n);
        var ni = Math.min(m + 1, n);
        var s = new Array(ni);
        var U = getFilled2DArray(m, nu, 0);
        var V = getFilled2DArray(n, n, 0);

        var e = new Array(n);
        var work = new Array(m);

        var si = new Array(ni);
        for (let i = 0; i < ni; i++) si[i] = i;

        var nct = Math.min(m - 1, n);
        var nrt = Math.max(0, Math.min(n - 2, m));
        var mrc = Math.max(nct, nrt);

        for (let k = 0; k < mrc; k++) {
          if (k < nct) {
            s[k] = 0;
            for (let i = k; i < m; i++) {
              s[k] = hypotenuse(s[k], a[i][k]);
            }
            if (s[k] !== 0) {
              if (a[k][k] < 0) {
                s[k] = -s[k];
              }
              for (let i = k; i < m; i++) {
                a[i][k] /= s[k];
              }
              a[k][k] += 1;
            }
            s[k] = -s[k];
          }

          for (let j = k + 1; j < n; j++) {
            if (k < nct && s[k] !== 0) {
              let t = 0;
              for (let i = k; i < m; i++) {
                t += a[i][k] * a[i][j];
              }
              t = -t / a[k][k];
              for (let i = k; i < m; i++) {
                a[i][j] += t * a[i][k];
              }
            }
            e[j] = a[k][j];
          }

          if (wantu && k < nct) {
            for (let i = k; i < m; i++) {
              U[i][k] = a[i][k];
            }
          }

          if (k < nrt) {
            e[k] = 0;
            for (let i = k + 1; i < n; i++) {
              e[k] = hypotenuse(e[k], e[i]);
            }
            if (e[k] !== 0) {
              if (e[k + 1] < 0) {
                e[k] = 0 - e[k];
              }
              for (let i = k + 1; i < n; i++) {
                e[i] /= e[k];
              }
              e[k + 1] += 1;
            }
            e[k] = -e[k];
            if (k + 1 < m && e[k] !== 0) {
              for (let i = k + 1; i < m; i++) {
                work[i] = 0;
              }
              for (let i = k + 1; i < m; i++) {
                for (let j = k + 1; j < n; j++) {
                  work[i] += e[j] * a[i][j];
                }
              }
              for (let j = k + 1; j < n; j++) {
                let t = -e[j] / e[k + 1];
                for (let i = k + 1; i < m; i++) {
                  a[i][j] += t * work[i];
                }
              }
            }
            if (wantv) {
              for (let i = k + 1; i < n; i++) {
                V[i][k] = e[i];
              }
            }
          }
        }

        let p = Math.min(n, m + 1);
        if (nct < n) {
          s[nct] = a[nct][nct];
        }
        if (m < p) {
          s[p - 1] = 0;
        }
        if (nrt + 1 < p) {
          e[nrt] = a[nrt][p - 1];
        }
        e[p - 1] = 0;

        if (wantu) {
          for (let j = nct; j < nu; j++) {
            for (let i = 0; i < m; i++) {
              U[i][j] = 0;
            }
            U[j][j] = 1;
          }
          for (let k = nct - 1; k >= 0; k--) {
            if (s[k] !== 0) {
              for (let j = k + 1; j < nu; j++) {
                let t = 0;
                for (let i = k; i < m; i++) {
                  t += U[i][k] * U[i][j];
                }
                t = -t / U[k][k];
                for (let i = k; i < m; i++) {
                  U[i][j] += t * U[i][k];
                }
              }
              for (let i = k; i < m; i++) {
                U[i][k] = -U[i][k];
              }
              U[k][k] = 1 + U[k][k];
              for (let i = 0; i < k - 1; i++) {
                U[i][k] = 0;
              }
            } else {
              for (let i = 0; i < m; i++) {
                U[i][k] = 0;
              }
              U[k][k] = 1;
            }
          }
        }

        if (wantv) {
          for (let k = n - 1; k >= 0; k--) {
            if (k < nrt && e[k] !== 0) {
              for (let j = k + 1; j < n; j++) {
                let t = 0;
                for (let i = k + 1; i < n; i++) {
                  t += V[i][k] * V[i][j];
                }
                t = -t / V[k + 1][k];
                for (let i = k + 1; i < n; i++) {
                  V[i][j] += t * V[i][k];
                }
              }
            }
            for (let i = 0; i < n; i++) {
              V[i][k] = 0;
            }
            V[k][k] = 1;
          }
        }

        var pp = p - 1;
        var eps = Number.EPSILON;
        while (p > 0) {
          let k, kase;
          for (k = p - 2; k >= -1; k--) {
            if (k === -1) {
              break;
            }
            const alpha =
              Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
            if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
              e[k] = 0;
              break;
            }
          }
          if (k === p - 2) {
            kase = 4;
          } else {
            let ks;
            for (ks = p - 1; ks >= k; ks--) {
              if (ks === k) {
                break;
              }
              let t =
                (ks !== p ? Math.abs(e[ks]) : 0) +
                (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
              if (Math.abs(s[ks]) <= eps * t) {
                s[ks] = 0;
                break;
              }
            }
            if (ks === k) {
              kase = 3;
            } else if (ks === p - 1) {
              kase = 1;
            } else {
              kase = 2;
              k = ks;
            }
          }

          k++;

          switch (kase) {
            case 1: {
              let f = e[p - 2];
              e[p - 2] = 0;
              for (let j = p - 2; j >= k; j--) {
                let t = hypotenuse(s[j], f);
                let cs = s[j] / t;
                let sn = f / t;
                s[j] = t;
                if (j !== k) {
                  f = -sn * e[j - 1];
                  e[j - 1] = cs * e[j - 1];
                }
                if (wantv) {
                  for (let i = 0; i < n; i++) {
                    t = cs * V[i][j] + sn * V[i][p - 1];
                    V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
                    V[i][j] = t;
                  }
                }
              }
              break;
            }
            case 2: {
              let f = e[k - 1];
              e[k - 1] = 0;
              for (let j = k; j < p; j++) {
                let t = hypotenuse(s[j], f);
                let cs = s[j] / t;
                let sn = f / t;
                s[j] = t;
                f = -sn * e[j];
                e[j] = cs * e[j];
                if (wantu) {
                  for (let i = 0; i < m; i++) {
                    t = cs * U[i][j] + sn * U[i][k - 1];
                    U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
                    U[i][j] = t;
                  }
                }
              }
              break;
            }
            case 3: {
              const scale = Math.max(
                Math.abs(s[p - 1]),
                Math.abs(s[p - 2]),
                Math.abs(e[p - 2]),
                Math.abs(s[k]),
                Math.abs(e[k])
              );
              const sp = s[p - 1] / scale;
              const spm1 = s[p - 2] / scale;
              const epm1 = e[p - 2] / scale;
              const sk = s[k] / scale;
              const ek = e[k] / scale;
              const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
              const c = sp * epm1 * (sp * epm1);
              let shift = 0;
              if (b !== 0 || c !== 0) {
                if (b < 0) {
                  shift = 0 - Math.sqrt(b * b + c);
                } else {
                  shift = Math.sqrt(b * b + c);
                }
                shift = c / (b + shift);
              }
              let f = (sk + sp) * (sk - sp) + shift;
              let g = sk * ek;
              for (let j = k; j < p - 1; j++) {
                let t = hypotenuse(f, g);
                if (t === 0) t = Number.MIN_VALUE;
                let cs = f / t;
                let sn = g / t;
                if (j !== k) {
                  e[j - 1] = t;
                }
                f = cs * s[j] + sn * e[j];
                e[j] = cs * e[j] - sn * s[j];
                g = sn * s[j + 1];
                s[j + 1] = cs * s[j + 1];
                if (wantv) {
                  for (let i = 0; i < n; i++) {
                    t = cs * V[i][j] + sn * V[i][j + 1];
                    V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
                    V[i][j] = t;
                  }
                }
                t = hypotenuse(f, g);
                if (t === 0) t = Number.MIN_VALUE;
                cs = f / t;
                sn = g / t;
                s[j] = t;
                f = cs * e[j] + sn * s[j + 1];
                s[j + 1] = -sn * e[j] + cs * s[j + 1];
                g = sn * e[j + 1];
                e[j + 1] = cs * e[j + 1];
                if (wantu && j < m - 1) {
                  for (let i = 0; i < m; i++) {
                    t = cs * U[i][j] + sn * U[i][j + 1];
                    U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
                    U[i][j] = t;
                  }
                }
              }
              e[p - 2] = f;
              break;
            }
            case 4: {
              if (s[k] <= 0) {
                s[k] = s[k] < 0 ? -s[k] : 0;
                if (wantv) {
                  for (let i = 0; i <= pp; i++) {
                    V[i][k] = -V[i][k];
                  }
                }
              }
              while (k < pp) {
                if (s[k] >= s[k + 1]) {
                  break;
                }
                let t = s[k];
                s[k] = s[k + 1];
                s[k + 1] = t;
                if (wantv && k < n - 1) {
                  for (let i = 0; i < n; i++) {
                    t = V[i][k + 1];
                    V[i][k + 1] = V[i][k];
                    V[i][k] = t;
                  }
                }
                if (wantu && k < m - 1) {
                  for (let i = 0; i < m; i++) {
                    t = U[i][k + 1];
                    U[i][k + 1] = U[i][k];
                    U[i][k] = t;
                  }
                }
                k++;
              }
              p--;
              break;
            }
            // no default
          }
        }

        if (swapped) {
          var tmp = V;
          V = U;
          U = tmp;
        }

        this.m = m;
        this.n = n;
        this.s = s;
        this.U = U;
        this.V = V;
      }

      /**
       * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).
       * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
       * var svd = SingularValueDecomposition(A);
       * var x = svd.solve(b);
       * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
       * @return {Matrix} - The vector x
       */
      solve(value) {
        var Y = value;
        var e = this.threshold;
        var scols = this.s.length;
        var Ls = Matrix.zeros(scols, scols);

        for (let i = 0; i < scols; i++) {
          if (Math.abs(this.s[i]) <= e) {
            Ls[i][i] = 0;
          } else {
            Ls[i][i] = 1 / this.s[i];
          }
        }

        var U = this.U;
        var V = this.rightSingularVectors;

        var VL = V.mmul(Ls);
        var vrows = V.rows;
        var urows = U.length;
        var VLU = Matrix.zeros(vrows, urows);

        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < urows; j++) {
            let sum = 0;
            for (let k = 0; k < scols; k++) {
              sum += VL[i][k] * U[j][k];
            }
            VLU[i][j] = sum;
          }
        }

        return VLU.mmul(Y);
      }

      /**
       *
       * @param {Array<number>} value
       * @return {Matrix}
       */
      solveForDiagonal(value) {
        return this.solve(Matrix.diag(value));
      }

      /**
       * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :
       * var svd = SingularValueDecomposition(A);
       * var inverseA = svd.inverse();
       * @return {Matrix} - The approximation of the inverse of the matrix
       */
      inverse() {
        var V = this.V;
        var e = this.threshold;
        var vrows = V.length;
        var vcols = V[0].length;
        var X = new Matrix(vrows, this.s.length);

        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < vcols; j++) {
            if (Math.abs(this.s[j]) > e) {
              X[i][j] = V[i][j] / this.s[j];
            } else {
              X[i][j] = 0;
            }
          }
        }

        var U = this.U;

        var urows = U.length;
        var ucols = U[0].length;
        var Y = new Matrix(vrows, urows);

        for (let i = 0; i < vrows; i++) {
          for (let j = 0; j < urows; j++) {
            let sum = 0;
            for (let k = 0; k < ucols; k++) {
              sum += X[i][k] * U[j][k];
            }
            Y[i][j] = sum;
          }
        }

        return Y;
      }

      /**
       *
       * @return {number}
       */
      get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
      }

      /**
       *
       * @return {number}
       */
      get norm2() {
        return this.s[0];
      }

      /**
       *
       * @return {number}
       */
      get rank() {
        var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
        var r = 0;
        var s = this.s;
        for (var i = 0, ii = s.length; i < ii; i++) {
          if (s[i] > tol) {
            r++;
          }
        }
        return r;
      }

      /**
       *
       * @return {Array<number>}
       */
      get diagonal() {
        return this.s;
      }

      /**
       *
       * @return {number}
       */
      get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
      }

      /**
       *
       * @return {Matrix}
       */
      get leftSingularVectors() {
        if (!Matrix.isMatrix(this.U)) {
          this.U = new Matrix(this.U);
        }
        return this.U;
      }

      /**
       *
       * @return {Matrix}
       */
      get rightSingularVectors() {
        if (!Matrix.isMatrix(this.V)) {
          this.V = new Matrix(this.V);
        }
        return this.V;
      }

      /**
       *
       * @return {Matrix}
       */
      get diagonalMatrix() {
        return Matrix.diag(this.s);
      }
    }

    /**
     * @private
     * Check that a row index is not out of bounds
     * @param {Matrix} matrix
     * @param {number} index
     * @param {boolean} [outer]
     */
    function checkRowIndex(matrix, index, outer) {
      var max = outer ? matrix.rows : matrix.rows - 1;
      if (index < 0 || index > max) {
        throw new RangeError('Row index out of range');
      }
    }

    /**
     * @private
     * Check that a column index is not out of bounds
     * @param {Matrix} matrix
     * @param {number} index
     * @param {boolean} [outer]
     */
    function checkColumnIndex(matrix, index, outer) {
      var max = outer ? matrix.columns : matrix.columns - 1;
      if (index < 0 || index > max) {
        throw new RangeError('Column index out of range');
      }
    }

    /**
     * @private
     * Check that the provided vector is an array with the right length
     * @param {Matrix} matrix
     * @param {Array|Matrix} vector
     * @return {Array}
     * @throws {RangeError}
     */
    function checkRowVector(matrix, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix.columns) {
        throw new RangeError(
          'vector size must be the same as the number of columns'
        );
      }
      return vector;
    }

    /**
     * @private
     * Check that the provided vector is an array with the right length
     * @param {Matrix} matrix
     * @param {Array|Matrix} vector
     * @return {Array}
     * @throws {RangeError}
     */
    function checkColumnVector(matrix, vector) {
      if (vector.to1DArray) {
        vector = vector.to1DArray();
      }
      if (vector.length !== matrix.rows) {
        throw new RangeError('vector size must be the same as the number of rows');
      }
      return vector;
    }

    function checkIndices(matrix, rowIndices, columnIndices) {
      return {
        row: checkRowIndices(matrix, rowIndices),
        column: checkColumnIndices(matrix, columnIndices)
      };
    }

    function checkRowIndices(matrix, rowIndices) {
      if (typeof rowIndices !== 'object') {
        throw new TypeError('unexpected type for row indices');
      }

      var rowOut = rowIndices.some((r) => {
        return r < 0 || r >= matrix.rows;
      });

      if (rowOut) {
        throw new RangeError('row indices are out of range');
      }

      if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

      return rowIndices;
    }

    function checkColumnIndices(matrix, columnIndices) {
      if (typeof columnIndices !== 'object') {
        throw new TypeError('unexpected type for column indices');
      }

      var columnOut = columnIndices.some((c) => {
        return c < 0 || c >= matrix.columns;
      });

      if (columnOut) {
        throw new RangeError('column indices are out of range');
      }
      if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

      return columnIndices;
    }

    function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
      if (arguments.length !== 5) {
        throw new RangeError('expected 4 arguments');
      }
      checkNumber('startRow', startRow);
      checkNumber('endRow', endRow);
      checkNumber('startColumn', startColumn);
      checkNumber('endColumn', endColumn);
      if (
        startRow > endRow ||
        startColumn > endColumn ||
        startRow < 0 ||
        startRow >= matrix.rows ||
        endRow < 0 ||
        endRow >= matrix.rows ||
        startColumn < 0 ||
        startColumn >= matrix.columns ||
        endColumn < 0 ||
        endColumn >= matrix.columns
      ) {
        throw new RangeError('Submatrix indices are out of range');
      }
    }

    function sumByRow(matrix) {
      var sum = Matrix.zeros(matrix.rows, 1);
      for (var i = 0; i < matrix.rows; ++i) {
        for (var j = 0; j < matrix.columns; ++j) {
          sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));
        }
      }
      return sum;
    }

    function sumByColumn(matrix) {
      var sum = Matrix.zeros(1, matrix.columns);
      for (var i = 0; i < matrix.rows; ++i) {
        for (var j = 0; j < matrix.columns; ++j) {
          sum.set(0, j, sum.get(0, j) + matrix.get(i, j));
        }
      }
      return sum;
    }

    function sumAll(matrix) {
      var v = 0;
      for (var i = 0; i < matrix.rows; i++) {
        for (var j = 0; j < matrix.columns; j++) {
          v += matrix.get(i, j);
        }
      }
      return v;
    }

    function checkNumber(name, value) {
      if (typeof value !== 'number') {
        throw new TypeError(`${name} must be a number`);
      }
    }

    class BaseView extends AbstractMatrix() {
      constructor(matrix, rows, columns) {
        super();
        this.matrix = matrix;
        this.rows = rows;
        this.columns = columns;
      }

      static get [Symbol.species]() {
        return Matrix;
      }
    }

    class MatrixTransposeView extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.columns, matrix.rows);
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(columnIndex, rowIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(columnIndex, rowIndex);
      }
    }

    class MatrixRowView extends BaseView {
      constructor(matrix, row) {
        super(matrix, 1, matrix.columns);
        this.row = row;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.row, columnIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(this.row, columnIndex);
      }
    }

    class MatrixSubView extends BaseView {
      constructor(matrix, startRow, endRow, startColumn, endColumn) {
        checkRange(matrix, startRow, endRow, startColumn, endColumn);
        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
        this.startRow = startRow;
        this.startColumn = startColumn;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.startRow + rowIndex,
          this.startColumn + columnIndex,
          value
        );
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.startRow + rowIndex,
          this.startColumn + columnIndex
        );
      }
    }

    class MatrixSelectionView extends BaseView {
      constructor(matrix, rowIndices, columnIndices) {
        var indices = checkIndices(matrix, rowIndices, columnIndices);
        super(matrix, indices.row.length, indices.column.length);
        this.rowIndices = indices.row;
        this.columnIndices = indices.column;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex],
          value
        );
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(
          this.rowIndices[rowIndex],
          this.columnIndices[columnIndex]
        );
      }
    }

    class MatrixRowSelectionView extends BaseView {
      constructor(matrix, rowIndices) {
        rowIndices = checkRowIndices(matrix, rowIndices);
        super(matrix, rowIndices.length, matrix.columns);
        this.rowIndices = rowIndices;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
      }
    }

    class MatrixColumnSelectionView extends BaseView {
      constructor(matrix, columnIndices) {
        columnIndices = checkColumnIndices(matrix, columnIndices);
        super(matrix, matrix.rows, columnIndices.length);
        this.columnIndices = columnIndices;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
      }
    }

    class MatrixColumnView extends BaseView {
      constructor(matrix, column) {
        super(matrix, matrix.rows, 1);
        this.column = column;
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.column, value);
        return this;
      }

      get(rowIndex) {
        return this.matrix.get(rowIndex, this.column);
      }
    }

    class MatrixFlipRowView extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
      }
    }

    class MatrixFlipColumnView extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }

      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
      }
    }

    function AbstractMatrix(superCtor) {
      if (superCtor === undefined) superCtor = Object;

      /**
       * Real matrix
       * @class Matrix
       * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,
       * 2D array containing the data or Matrix instance to clone
       * @param {number} [nColumns] - Number of columns of the new matrix
       */
      class Matrix extends superCtor {
        static get [Symbol.species]() {
          return this;
        }

        /**
         * Constructs a Matrix with the chosen dimensions from a 1D array
         * @param {number} newRows - Number of rows
         * @param {number} newColumns - Number of columns
         * @param {Array} newData - A 1D array containing data for the matrix
         * @return {Matrix} - The new matrix
         */
        static from1DArray(newRows, newColumns, newData) {
          var length = newRows * newColumns;
          if (length !== newData.length) {
            throw new RangeError('Data length does not match given dimensions');
          }
          var newMatrix = new this(newRows, newColumns);
          for (var row = 0; row < newRows; row++) {
            for (var column = 0; column < newColumns; column++) {
              newMatrix.set(row, column, newData[row * newColumns + column]);
            }
          }
          return newMatrix;
        }

        /**
             * Creates a row vector, a matrix with only one row.
             * @param {Array} newData - A 1D array containing data for the vector
             * @return {Matrix} - The new matrix
             */
        static rowVector(newData) {
          var vector = new this(1, newData.length);
          for (var i = 0; i < newData.length; i++) {
            vector.set(0, i, newData[i]);
          }
          return vector;
        }

        /**
             * Creates a column vector, a matrix with only one column.
             * @param {Array} newData - A 1D array containing data for the vector
             * @return {Matrix} - The new matrix
             */
        static columnVector(newData) {
          var vector = new this(newData.length, 1);
          for (var i = 0; i < newData.length; i++) {
            vector.set(i, 0, newData[i]);
          }
          return vector;
        }

        /**
             * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @return {Matrix} - The new matrix
             */
        static empty(rows, columns) {
          return new this(rows, columns);
        }

        /**
             * Creates a matrix with the given dimensions. Values will be set to zero.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @return {Matrix} - The new matrix
             */
        static zeros(rows, columns) {
          return this.empty(rows, columns).fill(0);
        }

        /**
             * Creates a matrix with the given dimensions. Values will be set to one.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @return {Matrix} - The new matrix
             */
        static ones(rows, columns) {
          return this.empty(rows, columns).fill(1);
        }

        /**
             * Creates a matrix with the given dimensions. Values will be randomly set.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @param {function} [rng=Math.random] - Random number generator
             * @return {Matrix} The new matrix
             */
        static rand(rows, columns, rng) {
          if (rng === undefined) rng = Math.random;
          var matrix = this.empty(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              matrix.set(i, j, rng());
            }
          }
          return matrix;
        }

        /**
             * Creates a matrix with the given dimensions. Values will be random integers.
             * @param {number} rows - Number of rows
             * @param {number} columns - Number of columns
             * @param {number} [maxValue=1000] - Maximum value
             * @param {function} [rng=Math.random] - Random number generator
             * @return {Matrix} The new matrix
             */
        static randInt(rows, columns, maxValue, rng) {
          if (maxValue === undefined) maxValue = 1000;
          if (rng === undefined) rng = Math.random;
          var matrix = this.empty(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              var value = Math.floor(rng() * maxValue);
              matrix.set(i, j, value);
            }
          }
          return matrix;
        }

        /**
             * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.
             * @param {number} rows - Number of rows
             * @param {number} [columns=rows] - Number of columns
             * @param {number} [value=1] - Value to fill the diagonal with
             * @return {Matrix} - The new identity matrix
             */
        static eye(rows, columns, value) {
          if (columns === undefined) columns = rows;
          if (value === undefined) value = 1;
          var min = Math.min(rows, columns);
          var matrix = this.zeros(rows, columns);
          for (var i = 0; i < min; i++) {
            matrix.set(i, i, value);
          }
          return matrix;
        }

        /**
             * Creates a diagonal matrix based on the given array.
             * @param {Array} data - Array containing the data for the diagonal
             * @param {number} [rows] - Number of rows (Default: data.length)
             * @param {number} [columns] - Number of columns (Default: rows)
             * @return {Matrix} - The new diagonal matrix
             */
        static diag(data, rows, columns) {
          var l = data.length;
          if (rows === undefined) rows = l;
          if (columns === undefined) columns = rows;
          var min = Math.min(l, rows, columns);
          var matrix = this.zeros(rows, columns);
          for (var i = 0; i < min; i++) {
            matrix.set(i, i, data[i]);
          }
          return matrix;
        }

        /**
             * Returns a matrix whose elements are the minimum between matrix1 and matrix2
             * @param {Matrix} matrix1
             * @param {Matrix} matrix2
             * @return {Matrix}
             */
        static min(matrix1, matrix2) {
          matrix1 = this.checkMatrix(matrix1);
          matrix2 = this.checkMatrix(matrix2);
          var rows = matrix1.rows;
          var columns = matrix1.columns;
          var result = new this(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
            }
          }
          return result;
        }

        /**
             * Returns a matrix whose elements are the maximum between matrix1 and matrix2
             * @param {Matrix} matrix1
             * @param {Matrix} matrix2
             * @return {Matrix}
             */
        static max(matrix1, matrix2) {
          matrix1 = this.checkMatrix(matrix1);
          matrix2 = this.checkMatrix(matrix2);
          var rows = matrix1.rows;
          var columns = matrix1.columns;
          var result = new this(rows, columns);
          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
              result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
            }
          }
          return result;
        }

        /**
             * Check that the provided value is a Matrix and tries to instantiate one if not
             * @param {*} value - The value to check
             * @return {Matrix}
             */
        static checkMatrix(value) {
          return Matrix.isMatrix(value) ? value : new this(value);
        }

        /**
             * Returns true if the argument is a Matrix, false otherwise
             * @param {*} value - The value to check
             * @return {boolean}
             */
        static isMatrix(value) {
          return (value != null) && (value.klass === 'Matrix');
        }

        /**
             * @prop {number} size - The number of elements in the matrix.
             */
        get size() {
          return this.rows * this.columns;
        }

        /**
             * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.
             * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)
             * @return {Matrix} this
             */
        apply(callback) {
          if (typeof callback !== 'function') {
            throw new TypeError('callback must be a function');
          }
          var ii = this.rows;
          var jj = this.columns;
          for (var i = 0; i < ii; i++) {
            for (var j = 0; j < jj; j++) {
              callback.call(this, i, j);
            }
          }
          return this;
        }

        /**
             * Returns a new 1D array filled row by row with the matrix values
             * @return {Array}
             */
        to1DArray() {
          var array = new Array(this.size);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              array[i * this.columns + j] = this.get(i, j);
            }
          }
          return array;
        }

        /**
             * Returns a 2D array containing a copy of the data
             * @return {Array}
             */
        to2DArray() {
          var copy = new Array(this.rows);
          for (var i = 0; i < this.rows; i++) {
            copy[i] = new Array(this.columns);
            for (var j = 0; j < this.columns; j++) {
              copy[i][j] = this.get(i, j);
            }
          }
          return copy;
        }

        /**
             * @return {boolean} true if the matrix has one row
             */
        isRowVector() {
          return this.rows === 1;
        }

        /**
             * @return {boolean} true if the matrix has one column
             */
        isColumnVector() {
          return this.columns === 1;
        }

        /**
             * @return {boolean} true if the matrix has one row or one column
             */
        isVector() {
          return (this.rows === 1) || (this.columns === 1);
        }

        /**
             * @return {boolean} true if the matrix has the same number of rows and columns
             */
        isSquare() {
          return this.rows === this.columns;
        }

        /**
             * @return {boolean} true if the matrix is square and has the same values on both sides of the diagonal
             */
        isSymmetric() {
          if (this.isSquare()) {
            for (var i = 0; i < this.rows; i++) {
              for (var j = 0; j <= i; j++) {
                if (this.get(i, j) !== this.get(j, i)) {
                  return false;
                }
              }
            }
            return true;
          }
          return false;
        }

        /**
              * @return true if the matrix is in echelon form
              */
        isEchelonForm() {
          let i = 0;
          let j = 0;
          let previousColumn = -1;
          let isEchelonForm = true;
          let checked = false;
          while ((i < this.rows) && (isEchelonForm)) {
            j = 0;
            checked = false;
            while ((j < this.columns) && (checked === false)) {
              if (this.get(i, j) === 0) {
                j++;
              } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
                checked = true;
                previousColumn = j;
              } else {
                isEchelonForm = false;
                checked = true;
              }
            }
            i++;
          }
          return isEchelonForm;
        }

        /**
                 * @return true if the matrix is in reduced echelon form
                 */
        isReducedEchelonForm() {
          let i = 0;
          let j = 0;
          let previousColumn = -1;
          let isReducedEchelonForm = true;
          let checked = false;
          while ((i < this.rows) && (isReducedEchelonForm)) {
            j = 0;
            checked = false;
            while ((j < this.columns) && (checked === false)) {
              if (this.get(i, j) === 0) {
                j++;
              } else if ((this.get(i, j) === 1) && (j > previousColumn)) {
                checked = true;
                previousColumn = j;
              } else {
                isReducedEchelonForm = false;
                checked = true;
              }
            }
            for (let k = j + 1; k < this.rows; k++) {
              if (this.get(i, k) !== 0) {
                isReducedEchelonForm = false;
              }
            }
            i++;
          }
          return isReducedEchelonForm;
        }

        /**
             * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1
             * @abstract
             * @param {number} rowIndex - Index of the row
             * @param {number} columnIndex - Index of the column
             * @param {number} value - The new value for the element
             * @return {Matrix} this
             */
        set(rowIndex, columnIndex, value) { // eslint-disable-line no-unused-vars
          throw new Error('set method is unimplemented');
        }

        /**
             * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]
             * @abstract
             * @param {number} rowIndex - Index of the row
             * @param {number} columnIndex - Index of the column
             * @return {number}
             */
        get(rowIndex, columnIndex) { // eslint-disable-line no-unused-vars
          throw new Error('get method is unimplemented');
        }

        /**
             * Creates a new matrix that is a repetition of the current matrix. New matrix has rowRep times the number of
             * rows of the matrix, and colRep times the number of columns of the matrix
             * @param {number} rowRep - Number of times the rows should be repeated
             * @param {number} colRep - Number of times the columns should be re
             * @return {Matrix}
             * @example
             * var matrix = new Matrix([[1,2]]);
             * matrix.repeat(2); // [[1,2],[1,2]]
             */
        repeat(rowRep, colRep) {
          rowRep = rowRep || 1;
          colRep = colRep || 1;
          var matrix = new this.constructor[Symbol.species](this.rows * rowRep, this.columns * colRep);
          for (var i = 0; i < rowRep; i++) {
            for (var j = 0; j < colRep; j++) {
              matrix.setSubMatrix(this, this.rows * i, this.columns * j);
            }
          }
          return matrix;
        }

        /**
             * Fills the matrix with a given value. All elements will be set to this value.
             * @param {number} value - New value
             * @return {Matrix} this
             */
        fill(value) {
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, value);
            }
          }
          return this;
        }

        /**
             * Negates the matrix. All elements will be multiplied by (-1)
             * @return {Matrix} this
             */
        neg() {
          return this.mulS(-1);
        }

        /**
             * Returns a new array from the given row index
             * @param {number} index - Row index
             * @return {Array}
             */
        getRow(index) {
          checkRowIndex(this, index);
          var row = new Array(this.columns);
          for (var i = 0; i < this.columns; i++) {
            row[i] = this.get(index, i);
          }
          return row;
        }

        /**
             * Returns a new row vector from the given row index
             * @param {number} index - Row index
             * @return {Matrix}
             */
        getRowVector(index) {
          return this.constructor.rowVector(this.getRow(index));
        }

        /**
             * Sets a row at the given index
             * @param {number} index - Row index
             * @param {Array|Matrix} array - Array or vector
             * @return {Matrix} this
             */
        setRow(index, array) {
          checkRowIndex(this, index);
          array = checkRowVector(this, array);
          for (var i = 0; i < this.columns; i++) {
            this.set(index, i, array[i]);
          }
          return this;
        }

        /**
             * Swaps two rows
             * @param {number} row1 - First row index
             * @param {number} row2 - Second row index
             * @return {Matrix} this
             */
        swapRows(row1, row2) {
          checkRowIndex(this, row1);
          checkRowIndex(this, row2);
          for (var i = 0; i < this.columns; i++) {
            var temp = this.get(row1, i);
            this.set(row1, i, this.get(row2, i));
            this.set(row2, i, temp);
          }
          return this;
        }

        /**
             * Returns a new array from the given column index
             * @param {number} index - Column index
             * @return {Array}
             */
        getColumn(index) {
          checkColumnIndex(this, index);
          var column = new Array(this.rows);
          for (var i = 0; i < this.rows; i++) {
            column[i] = this.get(i, index);
          }
          return column;
        }

        /**
             * Returns a new column vector from the given column index
             * @param {number} index - Column index
             * @return {Matrix}
             */
        getColumnVector(index) {
          return this.constructor.columnVector(this.getColumn(index));
        }

        /**
             * Sets a column at the given index
             * @param {number} index - Column index
             * @param {Array|Matrix} array - Array or vector
             * @return {Matrix} this
             */
        setColumn(index, array) {
          checkColumnIndex(this, index);
          array = checkColumnVector(this, array);
          for (var i = 0; i < this.rows; i++) {
            this.set(i, index, array[i]);
          }
          return this;
        }

        /**
             * Swaps two columns
             * @param {number} column1 - First column index
             * @param {number} column2 - Second column index
             * @return {Matrix} this
             */
        swapColumns(column1, column2) {
          checkColumnIndex(this, column1);
          checkColumnIndex(this, column2);
          for (var i = 0; i < this.rows; i++) {
            var temp = this.get(i, column1);
            this.set(i, column1, this.get(i, column2));
            this.set(i, column2, temp);
          }
          return this;
        }

        /**
             * Adds the values of a vector to each row
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        addRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) + vector[j]);
            }
          }
          return this;
        }

        /**
             * Subtracts the values of a vector from each row
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        subRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) - vector[j]);
            }
          }
          return this;
        }

        /**
             * Multiplies the values of a vector with each row
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        mulRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) * vector[j]);
            }
          }
          return this;
        }

        /**
             * Divides the values of each row by those of a vector
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        divRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) / vector[j]);
            }
          }
          return this;
        }

        /**
             * Adds the values of a vector to each column
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        addColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) + vector[i]);
            }
          }
          return this;
        }

        /**
             * Subtracts the values of a vector from each column
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        subColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) - vector[i]);
            }
          }
          return this;
        }

        /**
             * Multiplies the values of a vector with each column
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        mulColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) * vector[i]);
            }
          }
          return this;
        }

        /**
             * Divides the values of each column by those of a vector
             * @param {Array|Matrix} vector - Array or vector
             * @return {Matrix} this
             */
        divColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) / vector[i]);
            }
          }
          return this;
        }

        /**
             * Multiplies the values of a row with a scalar
             * @param {number} index - Row index
             * @param {number} value
             * @return {Matrix} this
             */
        mulRow(index, value) {
          checkRowIndex(this, index);
          for (var i = 0; i < this.columns; i++) {
            this.set(index, i, this.get(index, i) * value);
          }
          return this;
        }

        /**
             * Multiplies the values of a column with a scalar
             * @param {number} index - Column index
             * @param {number} value
             * @return {Matrix} this
             */
        mulColumn(index, value) {
          checkColumnIndex(this, index);
          for (var i = 0; i < this.rows; i++) {
            this.set(i, index, this.get(i, index) * value);
          }
          return this;
        }

        /**
             * Returns the maximum value of the matrix
             * @return {number}
             */
        max() {
          var v = this.get(0, 0);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) > v) {
                v = this.get(i, j);
              }
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value
             * @return {Array}
             */
        maxIndex() {
          var v = this.get(0, 0);
          var idx = [0, 0];
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) > v) {
                v = this.get(i, j);
                idx[0] = i;
                idx[1] = j;
              }
            }
          }
          return idx;
        }

        /**
             * Returns the minimum value of the matrix
             * @return {number}
             */
        min() {
          var v = this.get(0, 0);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) < v) {
                v = this.get(i, j);
              }
            }
          }
          return v;
        }

        /**
             * Returns the index of the minimum value
             * @return {Array}
             */
        minIndex() {
          var v = this.get(0, 0);
          var idx = [0, 0];
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              if (this.get(i, j) < v) {
                v = this.get(i, j);
                idx[0] = i;
                idx[1] = j;
              }
            }
          }
          return idx;
        }

        /**
             * Returns the maximum value of one row
             * @param {number} row - Row index
             * @return {number}
             */
        maxRow(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) > v) {
              v = this.get(row, i);
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value of one row
             * @param {number} row - Row index
             * @return {Array}
             */
        maxRowIndex(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          var idx = [row, 0];
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) > v) {
              v = this.get(row, i);
              idx[1] = i;
            }
          }
          return idx;
        }

        /**
             * Returns the minimum value of one row
             * @param {number} row - Row index
             * @return {number}
             */
        minRow(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) < v) {
              v = this.get(row, i);
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value of one row
             * @param {number} row - Row index
             * @return {Array}
             */
        minRowIndex(row) {
          checkRowIndex(this, row);
          var v = this.get(row, 0);
          var idx = [row, 0];
          for (var i = 1; i < this.columns; i++) {
            if (this.get(row, i) < v) {
              v = this.get(row, i);
              idx[1] = i;
            }
          }
          return idx;
        }

        /**
             * Returns the maximum value of one column
             * @param {number} column - Column index
             * @return {number}
             */
        maxColumn(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) > v) {
              v = this.get(i, column);
            }
          }
          return v;
        }

        /**
             * Returns the index of the maximum value of one column
             * @param {number} column - Column index
             * @return {Array}
             */
        maxColumnIndex(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          var idx = [0, column];
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) > v) {
              v = this.get(i, column);
              idx[0] = i;
            }
          }
          return idx;
        }

        /**
             * Returns the minimum value of one column
             * @param {number} column - Column index
             * @return {number}
             */
        minColumn(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) < v) {
              v = this.get(i, column);
            }
          }
          return v;
        }

        /**
             * Returns the index of the minimum value of one column
             * @param {number} column - Column index
             * @return {Array}
             */
        minColumnIndex(column) {
          checkColumnIndex(this, column);
          var v = this.get(0, column);
          var idx = [0, column];
          for (var i = 1; i < this.rows; i++) {
            if (this.get(i, column) < v) {
              v = this.get(i, column);
              idx[0] = i;
            }
          }
          return idx;
        }

        /**
             * Returns an array containing the diagonal values of the matrix
             * @return {Array}
             */
        diag() {
          var min = Math.min(this.rows, this.columns);
          var diag = new Array(min);
          for (var i = 0; i < min; i++) {
            diag[i] = this.get(i, i);
          }
          return diag;
        }

        /**
             * Returns the sum by the argument given, if no argument given,
             * it returns the sum of all elements of the matrix.
             * @param {string} by - sum by 'row' or 'column'.
             * @return {Matrix|number}
             */
        sum(by) {
          switch (by) {
            case 'row':
              return sumByRow(this);
            case 'column':
              return sumByColumn(this);
            default:
              return sumAll(this);
          }
        }

        /**
             * Returns the mean of all elements of the matrix
             * @return {number}
             */
        mean() {
          return this.sum() / this.size;
        }

        /**
             * Returns the product of all elements of the matrix
             * @return {number}
             */
        prod() {
          var prod = 1;
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              prod *= this.get(i, j);
            }
          }
          return prod;
        }

        /**
             * Returns the norm of a matrix.
             * @param {string} type - "frobenius" (default) or "max" return resp. the Frobenius norm and the max norm.
             * @return {number}
             */
        norm(type = 'frobenius') {
          var result = 0;
          if (type === 'max') {
            return this.max();
          } else if (type === 'frobenius') {
            for (var i = 0; i < this.rows; i++) {
              for (var j = 0; j < this.columns; j++) {
                result = result + this.get(i, j) * this.get(i, j);
              }
            }
            return Math.sqrt(result);
          } else {
            throw new RangeError(`unknown norm type: ${type}`);
          }
        }

        /**
             * Computes the cumulative sum of the matrix elements (in place, row by row)
             * @return {Matrix} this
             */
        cumulativeSum() {
          var sum = 0;
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              sum += this.get(i, j);
              this.set(i, j, sum);
            }
          }
          return this;
        }

        /**
             * Computes the dot (scalar) product between the matrix and another
             * @param {Matrix} vector2 vector
             * @return {number}
             */
        dot(vector2) {
          if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
          var vector1 = this.to1DArray();
          if (vector1.length !== vector2.length) {
            throw new RangeError('vectors do not have the same size');
          }
          var dot = 0;
          for (var i = 0; i < vector1.length; i++) {
            dot += vector1[i] * vector2[i];
          }
          return dot;
        }

        /**
             * Returns the matrix product between this and other
             * @param {Matrix} other
             * @return {Matrix}
             */
        mmul(other) {
          other = this.constructor.checkMatrix(other);
          if (this.columns !== other.rows) {
            // eslint-disable-next-line no-console
            console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');
          }

          var m = this.rows;
          var n = this.columns;
          var p = other.columns;

          var result = new this.constructor[Symbol.species](m, p);

          var Bcolj = new Array(n);
          for (var j = 0; j < p; j++) {
            for (var k = 0; k < n; k++) {
              Bcolj[k] = other.get(k, j);
            }

            for (var i = 0; i < m; i++) {
              var s = 0;
              for (k = 0; k < n; k++) {
                s += this.get(i, k) * Bcolj[k];
              }

              result.set(i, j, s);
            }
          }
          return result;
        }

        strassen2x2(other) {
          var result = new this.constructor[Symbol.species](2, 2);
          const a11 = this.get(0, 0);
          const b11 = other.get(0, 0);
          const a12 = this.get(0, 1);
          const b12 = other.get(0, 1);
          const a21 = this.get(1, 0);
          const b21 = other.get(1, 0);
          const a22 = this.get(1, 1);
          const b22 = other.get(1, 1);

          // Compute intermediate values.
          const m1 = (a11 + a22) * (b11 + b22);
          const m2 = (a21 + a22) * b11;
          const m3 = a11 * (b12 - b22);
          const m4 = a22 * (b21 - b11);
          const m5 = (a11 + a12) * b22;
          const m6 = (a21 - a11) * (b11 + b12);
          const m7 = (a12 - a22) * (b21 + b22);

          // Combine intermediate values into the output.
          const c00 = m1 + m4 - m5 + m7;
          const c01 = m3 + m5;
          const c10 = m2 + m4;
          const c11 = m1 - m2 + m3 + m6;

          result.set(0, 0, c00);
          result.set(0, 1, c01);
          result.set(1, 0, c10);
          result.set(1, 1, c11);
          return result;
        }

        strassen3x3(other) {
          var result = new this.constructor[Symbol.species](3, 3);

          const a00 = this.get(0, 0);
          const a01 = this.get(0, 1);
          const a02 = this.get(0, 2);
          const a10 = this.get(1, 0);
          const a11 = this.get(1, 1);
          const a12 = this.get(1, 2);
          const a20 = this.get(2, 0);
          const a21 = this.get(2, 1);
          const a22 = this.get(2, 2);

          const b00 = other.get(0, 0);
          const b01 = other.get(0, 1);
          const b02 = other.get(0, 2);
          const b10 = other.get(1, 0);
          const b11 = other.get(1, 1);
          const b12 = other.get(1, 2);
          const b20 = other.get(2, 0);
          const b21 = other.get(2, 1);
          const b22 = other.get(2, 2);

          const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
          const m2 = (a00 - a10) * (-b01 + b11);
          const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
          const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
          const m5 = (a10 + a11) * (-b00 + b01);
          const m6 = a00 * b00;
          const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
          const m8 = (-a00 + a20) * (b02 - b12);
          const m9 = (a20 + a21) * (-b00 + b02);
          const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
          const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
          const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
          const m13 = (a02 - a22) * (b11 - b21);
          const m14 = a02 * b20;
          const m15 = (a21 + a22) * (-b20 + b21);
          const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
          const m17 = (a02 - a12) * (b12 - b22);
          const m18 = (a11 + a12) * (-b20 + b22);
          const m19 = a01 * b10;
          const m20 = a12 * b21;
          const m21 = a10 * b02;
          const m22 = a20 * b01;
          const m23 = a22 * b22;

          const c00 = m6 + m14 + m19;
          const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
          const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
          const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
          const c11 = m2 + m4 + m5 + m6 + m20;
          const c12 = m14 + m16 + m17 + m18 + m21;
          const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
          const c21 = m12 + m13 + m14 + m15 + m22;
          const c22 = m6 + m7 + m8 + m9 + m23;

          result.set(0, 0, c00);
          result.set(0, 1, c01);
          result.set(0, 2, c02);
          result.set(1, 0, c10);
          result.set(1, 1, c11);
          result.set(1, 2, c12);
          result.set(2, 0, c20);
          result.set(2, 1, c21);
          result.set(2, 2, c22);
          return result;
        }

        /**
             * Returns the matrix product between x and y. More efficient than mmul(other) only when we multiply squared matrix and when the size of the matrix is > 1000.
             * @param {Matrix} y
             * @return {Matrix}
             */
        mmulStrassen(y) {
          var x = this.clone();
          var r1 = x.rows;
          var c1 = x.columns;
          var r2 = y.rows;
          var c2 = y.columns;
          if (c1 !== r2) {
            // eslint-disable-next-line no-console
            console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);
          }

          // Put a matrix into the top left of a matrix of zeros.
          // `rows` and `cols` are the dimensions of the output matrix.
          function embed(mat, rows, cols) {
            var r = mat.rows;
            var c = mat.columns;
            if ((r === rows) && (c === cols)) {
              return mat;
            } else {
              var resultat = Matrix.zeros(rows, cols);
              resultat = resultat.setSubMatrix(mat, 0, 0);
              return resultat;
            }
          }


          // Make sure both matrices are the same size.
          // This is exclusively for simplicity:
          // this algorithm can be implemented with matrices of different sizes.

          var r = Math.max(r1, r2);
          var c = Math.max(c1, c2);
          x = embed(x, r, c);
          y = embed(y, r, c);

          // Our recursive multiplication function.
          function blockMult(a, b, rows, cols) {
            // For small matrices, resort to naive multiplication.
            if (rows <= 512 || cols <= 512) {
              return a.mmul(b); // a is equivalent to this
            }

            // Apply dynamic padding.
            if ((rows % 2 === 1) && (cols % 2 === 1)) {
              a = embed(a, rows + 1, cols + 1);
              b = embed(b, rows + 1, cols + 1);
            } else if (rows % 2 === 1) {
              a = embed(a, rows + 1, cols);
              b = embed(b, rows + 1, cols);
            } else if (cols % 2 === 1) {
              a = embed(a, rows, cols + 1);
              b = embed(b, rows, cols + 1);
            }

            var halfRows = parseInt(a.rows / 2, 10);
            var halfCols = parseInt(a.columns / 2, 10);
            // Subdivide input matrices.
            var a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
            var b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);

            var a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
            var b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);

            var a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
            var b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);

            var a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
            var b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);

            // Compute intermediate values.
            var m1 = blockMult(Matrix.add(a11, a22), Matrix.add(b11, b22), halfRows, halfCols);
            var m2 = blockMult(Matrix.add(a21, a22), b11, halfRows, halfCols);
            var m3 = blockMult(a11, Matrix.sub(b12, b22), halfRows, halfCols);
            var m4 = blockMult(a22, Matrix.sub(b21, b11), halfRows, halfCols);
            var m5 = blockMult(Matrix.add(a11, a12), b22, halfRows, halfCols);
            var m6 = blockMult(Matrix.sub(a21, a11), Matrix.add(b11, b12), halfRows, halfCols);
            var m7 = blockMult(Matrix.sub(a12, a22), Matrix.add(b21, b22), halfRows, halfCols);

            // Combine intermediate values into the output.
            var c11 = Matrix.add(m1, m4);
            c11.sub(m5);
            c11.add(m7);
            var c12 = Matrix.add(m3, m5);
            var c21 = Matrix.add(m2, m4);
            var c22 = Matrix.sub(m1, m2);
            c22.add(m3);
            c22.add(m6);

            // Crop output to the desired size (undo dynamic padding).
            var resultat = Matrix.zeros(2 * c11.rows, 2 * c11.columns);
            resultat = resultat.setSubMatrix(c11, 0, 0);
            resultat = resultat.setSubMatrix(c12, c11.rows, 0);
            resultat = resultat.setSubMatrix(c21, 0, c11.columns);
            resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);
            return resultat.subMatrix(0, rows - 1, 0, cols - 1);
          }
          return blockMult(x, y, r, c);
        }

        /**
             * Returns a row-by-row scaled matrix
             * @param {number} [min=0] - Minimum scaled value
             * @param {number} [max=1] - Maximum scaled value
             * @return {Matrix} - The scaled matrix
             */
        scaleRows(min, max) {
          min = min === undefined ? 0 : min;
          max = max === undefined ? 1 : max;
          if (min >= max) {
            throw new RangeError('min should be strictly smaller than max');
          }
          var newMatrix = this.constructor.empty(this.rows, this.columns);
          for (var i = 0; i < this.rows; i++) {
            var scaled = rescale(this.getRow(i), { min, max });
            newMatrix.setRow(i, scaled);
          }
          return newMatrix;
        }

        /**
             * Returns a new column-by-column scaled matrix
             * @param {number} [min=0] - Minimum scaled value
             * @param {number} [max=1] - Maximum scaled value
             * @return {Matrix} - The new scaled matrix
             * @example
             * var matrix = new Matrix([[1,2],[-1,0]]);
             * var scaledMatrix = matrix.scaleColumns(); // [[1,1],[0,0]]
             */
        scaleColumns(min, max) {
          min = min === undefined ? 0 : min;
          max = max === undefined ? 1 : max;
          if (min >= max) {
            throw new RangeError('min should be strictly smaller than max');
          }
          var newMatrix = this.constructor.empty(this.rows, this.columns);
          for (var i = 0; i < this.columns; i++) {
            var scaled = rescale(this.getColumn(i), {
              min: min,
              max: max
            });
            newMatrix.setColumn(i, scaled);
          }
          return newMatrix;
        }


        /**
             * Returns the Kronecker product (also known as tensor product) between this and other
             * See https://en.wikipedia.org/wiki/Kronecker_product
             * @param {Matrix} other
             * @return {Matrix}
             */
        kroneckerProduct(other) {
          other = this.constructor.checkMatrix(other);

          var m = this.rows;
          var n = this.columns;
          var p = other.rows;
          var q = other.columns;

          var result = new this.constructor[Symbol.species](m * p, n * q);
          for (var i = 0; i < m; i++) {
            for (var j = 0; j < n; j++) {
              for (var k = 0; k < p; k++) {
                for (var l = 0; l < q; l++) {
                  result[p * i + k][q * j + l] = this.get(i, j) * other.get(k, l);
                }
              }
            }
          }
          return result;
        }

        /**
             * Transposes the matrix and returns a new one containing the result
             * @return {Matrix}
             */
        transpose() {
          var result = new this.constructor[Symbol.species](this.columns, this.rows);
          for (var i = 0; i < this.rows; i++) {
            for (var j = 0; j < this.columns; j++) {
              result.set(j, i, this.get(i, j));
            }
          }
          return result;
        }

        /**
             * Sorts the rows (in place)
             * @param {function} compareFunction - usual Array.prototype.sort comparison function
             * @return {Matrix} this
             */
        sortRows(compareFunction) {
          if (compareFunction === undefined) compareFunction = compareNumbers;
          for (var i = 0; i < this.rows; i++) {
            this.setRow(i, this.getRow(i).sort(compareFunction));
          }
          return this;
        }

        /**
             * Sorts the columns (in place)
             * @param {function} compareFunction - usual Array.prototype.sort comparison function
             * @return {Matrix} this
             */
        sortColumns(compareFunction) {
          if (compareFunction === undefined) compareFunction = compareNumbers;
          for (var i = 0; i < this.columns; i++) {
            this.setColumn(i, this.getColumn(i).sort(compareFunction));
          }
          return this;
        }

        /**
             * Returns a subset of the matrix
             * @param {number} startRow - First row index
             * @param {number} endRow - Last row index
             * @param {number} startColumn - First column index
             * @param {number} endColumn - Last column index
             * @return {Matrix}
             */
        subMatrix(startRow, endRow, startColumn, endColumn) {
          checkRange(this, startRow, endRow, startColumn, endColumn);
          var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, endColumn - startColumn + 1);
          for (var i = startRow; i <= endRow; i++) {
            for (var j = startColumn; j <= endColumn; j++) {
              newMatrix[i - startRow][j - startColumn] = this.get(i, j);
            }
          }
          return newMatrix;
        }

        /**
             * Returns a subset of the matrix based on an array of row indices
             * @param {Array} indices - Array containing the row indices
             * @param {number} [startColumn = 0] - First column index
             * @param {number} [endColumn = this.columns-1] - Last column index
             * @return {Matrix}
             */
        subMatrixRow(indices, startColumn, endColumn) {
          if (startColumn === undefined) startColumn = 0;
          if (endColumn === undefined) endColumn = this.columns - 1;
          if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {
            throw new RangeError('Argument out of range');
          }

          var newMatrix = new this.constructor[Symbol.species](indices.length, endColumn - startColumn + 1);
          for (var i = 0; i < indices.length; i++) {
            for (var j = startColumn; j <= endColumn; j++) {
              if (indices[i] < 0 || indices[i] >= this.rows) {
                throw new RangeError(`Row index out of range: ${indices[i]}`);
              }
              newMatrix.set(i, j - startColumn, this.get(indices[i], j));
            }
          }
          return newMatrix;
        }

        /**
             * Returns a subset of the matrix based on an array of column indices
             * @param {Array} indices - Array containing the column indices
             * @param {number} [startRow = 0] - First row index
             * @param {number} [endRow = this.rows-1] - Last row index
             * @return {Matrix}
             */
        subMatrixColumn(indices, startRow, endRow) {
          if (startRow === undefined) startRow = 0;
          if (endRow === undefined) endRow = this.rows - 1;
          if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {
            throw new RangeError('Argument out of range');
          }

          var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, indices.length);
          for (var i = 0; i < indices.length; i++) {
            for (var j = startRow; j <= endRow; j++) {
              if (indices[i] < 0 || indices[i] >= this.columns) {
                throw new RangeError(`Column index out of range: ${indices[i]}`);
              }
              newMatrix.set(j - startRow, i, this.get(j, indices[i]));
            }
          }
          return newMatrix;
        }

        /**
             * Set a part of the matrix to the given sub-matrix
             * @param {Matrix|Array< Array >} matrix - The source matrix from which to extract values.
             * @param {number} startRow - The index of the first row to set
             * @param {number} startColumn - The index of the first column to set
             * @return {Matrix}
             */
        setSubMatrix(matrix, startRow, startColumn) {
          matrix = this.constructor.checkMatrix(matrix);
          var endRow = startRow + matrix.rows - 1;
          var endColumn = startColumn + matrix.columns - 1;
          checkRange(this, startRow, endRow, startColumn, endColumn);
          for (var i = 0; i < matrix.rows; i++) {
            for (var j = 0; j < matrix.columns; j++) {
              this[startRow + i][startColumn + j] = matrix.get(i, j);
            }
          }
          return this;
        }

        /**
             * Return a new matrix based on a selection of rows and columns
             * @param {Array<number>} rowIndices - The row indices to select. Order matters and an index can be more than once.
             * @param {Array<number>} columnIndices - The column indices to select. Order matters and an index can be use more than once.
             * @return {Matrix} The new matrix
             */
        selection(rowIndices, columnIndices) {
          var indices = checkIndices(this, rowIndices, columnIndices);
          var newMatrix = new this.constructor[Symbol.species](rowIndices.length, columnIndices.length);
          for (var i = 0; i < indices.row.length; i++) {
            var rowIndex = indices.row[i];
            for (var j = 0; j < indices.column.length; j++) {
              var columnIndex = indices.column[j];
              newMatrix[i][j] = this.get(rowIndex, columnIndex);
            }
          }
          return newMatrix;
        }

        /**
             * Returns the trace of the matrix (sum of the diagonal elements)
             * @return {number}
             */
        trace() {
          var min = Math.min(this.rows, this.columns);
          var trace = 0;
          for (var i = 0; i < min; i++) {
            trace += this.get(i, i);
          }
          return trace;
        }

        /*
             Matrix views
             */

        /**
             * Returns a view of the transposition of the matrix
             * @return {MatrixTransposeView}
             */
        transposeView() {
          return new MatrixTransposeView(this);
        }

        /**
             * Returns a view of the row vector with the given index
             * @param {number} row - row index of the vector
             * @return {MatrixRowView}
             */
        rowView(row) {
          checkRowIndex(this, row);
          return new MatrixRowView(this, row);
        }

        /**
             * Returns a view of the column vector with the given index
             * @param {number} column - column index of the vector
             * @return {MatrixColumnView}
             */
        columnView(column) {
          checkColumnIndex(this, column);
          return new MatrixColumnView(this, column);
        }

        /**
             * Returns a view of the matrix flipped in the row axis
             * @return {MatrixFlipRowView}
             */
        flipRowView() {
          return new MatrixFlipRowView(this);
        }

        /**
             * Returns a view of the matrix flipped in the column axis
             * @return {MatrixFlipColumnView}
             */
        flipColumnView() {
          return new MatrixFlipColumnView(this);
        }

        /**
             * Returns a view of a submatrix giving the index boundaries
             * @param {number} startRow - first row index of the submatrix
             * @param {number} endRow - last row index of the submatrix
             * @param {number} startColumn - first column index of the submatrix
             * @param {number} endColumn - last column index of the submatrix
             * @return {MatrixSubView}
             */
        subMatrixView(startRow, endRow, startColumn, endColumn) {
          return new MatrixSubView(this, startRow, endRow, startColumn, endColumn);
        }

        /**
             * Returns a view of the cross of the row indices and the column indices
             * @example
             * // resulting vector is [[2], [2]]
             * var matrix = new Matrix([[1,2,3], [4,5,6]]).selectionView([0, 0], [1])
             * @param {Array<number>} rowIndices
             * @param {Array<number>} columnIndices
             * @return {MatrixSelectionView}
             */
        selectionView(rowIndices, columnIndices) {
          return new MatrixSelectionView(this, rowIndices, columnIndices);
        }

        /**
             * Returns a view of the row indices
             * @example
             * // resulting vector is [[1,2,3], [1,2,3]]
             * var matrix = new Matrix([[1,2,3], [4,5,6]]).rowSelectionView([0, 0])
             * @param {Array<number>} rowIndices
             * @return {MatrixRowSelectionView}
             */
        rowSelectionView(rowIndices) {
          return new MatrixRowSelectionView(this, rowIndices);
        }

        /**
             * Returns a view of the column indices
             * @example
             * // resulting vector is [[2, 2], [5, 5]]
             * var matrix = new Matrix([[1,2,3], [4,5,6]]).columnSelectionView([1, 1])
             * @param {Array<number>} columnIndices
             * @return {MatrixColumnSelectionView}
             */
        columnSelectionView(columnIndices) {
          return new MatrixColumnSelectionView(this, columnIndices);
        }


        /**
            * Calculates and returns the determinant of a matrix as a Number
            * @example
            *   new Matrix([[1,2,3], [4,5,6]]).det()
            * @return {number}
            */
        det() {
          if (this.isSquare()) {
            var a, b, c, d;
            if (this.columns === 2) {
              // 2 x 2 matrix
              a = this.get(0, 0);
              b = this.get(0, 1);
              c = this.get(1, 0);
              d = this.get(1, 1);

              return a * d - (b * c);
            } else if (this.columns === 3) {
              // 3 x 3 matrix
              var subMatrix0, subMatrix1, subMatrix2;
              subMatrix0 = this.selectionView([1, 2], [1, 2]);
              subMatrix1 = this.selectionView([1, 2], [0, 2]);
              subMatrix2 = this.selectionView([1, 2], [0, 1]);
              a = this.get(0, 0);
              b = this.get(0, 1);
              c = this.get(0, 2);

              return a * subMatrix0.det() - b * subMatrix1.det() + c * subMatrix2.det();
            } else {
              // general purpose determinant using the LU decomposition
              return new LuDecomposition(this).determinant;
            }
          } else {
            throw Error('Determinant can only be calculated for a square matrix.');
          }
        }

        /**
             * Returns inverse of a matrix if it exists or the pseudoinverse
             * @param {number} threshold - threshold for taking inverse of singular values (default = 1e-15)
             * @return {Matrix} the (pseudo)inverted matrix.
             */
        pseudoInverse(threshold) {
          if (threshold === undefined) threshold = Number.EPSILON;
          var svdSolution = new SingularValueDecomposition(this, { autoTranspose: true });

          var U = svdSolution.leftSingularVectors;
          var V = svdSolution.rightSingularVectors;
          var s = svdSolution.diagonal;

          for (var i = 0; i < s.length; i++) {
            if (Math.abs(s[i]) > threshold) {
              s[i] = 1.0 / s[i];
            } else {
              s[i] = 0.0;
            }
          }

          // convert list to diagonal
          s = this.constructor[Symbol.species].diag(s);
          return V.mmul(s.mmul(U.transposeView()));
        }

        /**
             * Creates an exact and independent copy of the matrix
             * @return {Matrix}
             */
        clone() {
          var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);
          for (var row = 0; row < this.rows; row++) {
            for (var column = 0; column < this.columns; column++) {
              newMatrix.set(row, column, this.get(row, column));
            }
          }
          return newMatrix;
        }
      }

      Matrix.prototype.klass = 'Matrix';

      function compareNumbers(a, b) {
        return a - b;
      }

      /*
         Synonyms
         */

      Matrix.random = Matrix.rand;
      Matrix.diagonal = Matrix.diag;
      Matrix.prototype.diagonal = Matrix.prototype.diag;
      Matrix.identity = Matrix.eye;
      Matrix.prototype.negate = Matrix.prototype.neg;
      Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;
      Matrix.prototype.determinant = Matrix.prototype.det;

      /*
         Add dynamically instance and static methods for mathematical operations
         */

      var inplaceOperator = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;

      var inplaceOperatorScalar = `
(function %name%S(value) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) %op% value);
        }
    }
    return this;
})
`;

      var inplaceOperatorMatrix = `
(function %name%M(matrix) {
    matrix = this.constructor.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
        this.columns !== matrix.columns) {
        throw new RangeError('Matrices dimensions must be equal');
    }
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));
        }
    }
    return this;
})
`;

      var staticOperator = `
(function %name%(matrix, value) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%(value);
})
`;

      var inplaceMethod = `
(function %name%() {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j)));
        }
    }
    return this;
})
`;

      var staticMethod = `
(function %name%(matrix) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%();
})
`;

      var inplaceMethodWithArgs = `
(function %name%(%args%) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), %args%));
        }
    }
    return this;
})
`;

      var staticMethodWithArgs = `
(function %name%(matrix, %args%) {
    var newMatrix = new this[Symbol.species](matrix);
    return newMatrix.%name%(%args%);
})
`;


      var inplaceMethodWithOneArgScalar = `
(function %name%S(value) {
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), value));
        }
    }
    return this;
})
`;
      var inplaceMethodWithOneArgMatrix = `
(function %name%M(matrix) {
    matrix = this.constructor.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
        this.columns !== matrix.columns) {
        throw new RangeError('Matrices dimensions must be equal');
    }
    for (var i = 0; i < this.rows; i++) {
        for (var j = 0; j < this.columns; j++) {
            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));
        }
    }
    return this;
})
`;

      var inplaceMethodWithOneArg = `
(function %name%(value) {
    if (typeof value === 'number') return this.%name%S(value);
    return this.%name%M(value);
})
`;

      var staticMethodWithOneArg = staticMethodWithArgs;

      var operators = [
        // Arithmetic operators
        ['+', 'add'],
        ['-', 'sub', 'subtract'],
        ['*', 'mul', 'multiply'],
        ['/', 'div', 'divide'],
        ['%', 'mod', 'modulus'],
        // Bitwise operators
        ['&', 'and'],
        ['|', 'or'],
        ['^', 'xor'],
        ['<<', 'leftShift'],
        ['>>', 'signPropagatingRightShift'],
        ['>>>', 'rightShift', 'zeroFillRightShift']
      ];

      var i;
      var eval2 = eval; // eslint-disable-line no-eval
      for (var operator of operators) {
        var inplaceOp = eval2(fillTemplateFunction(inplaceOperator, { name: operator[1], op: operator[0] }));
        var inplaceOpS = eval2(fillTemplateFunction(inplaceOperatorScalar, { name: `${operator[1]}S`, op: operator[0] }));
        var inplaceOpM = eval2(fillTemplateFunction(inplaceOperatorMatrix, { name: `${operator[1]}M`, op: operator[0] }));
        var staticOp = eval2(fillTemplateFunction(staticOperator, { name: operator[1] }));
        for (i = 1; i < operator.length; i++) {
          Matrix.prototype[operator[i]] = inplaceOp;
          Matrix.prototype[`${operator[i]}S`] = inplaceOpS;
          Matrix.prototype[`${operator[i]}M`] = inplaceOpM;
          Matrix[operator[i]] = staticOp;
        }
      }

      var methods = [['~', 'not']];

      [
        'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil',
        'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p',
        'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'
      ].forEach(function (mathMethod) {
        methods.push([`Math.${mathMethod}`, mathMethod]);
      });

      for (var method of methods) {
        var inplaceMeth = eval2(fillTemplateFunction(inplaceMethod, { name: method[1], method: method[0] }));
        var staticMeth = eval2(fillTemplateFunction(staticMethod, { name: method[1] }));
        for (i = 1; i < method.length; i++) {
          Matrix.prototype[method[i]] = inplaceMeth;
          Matrix[method[i]] = staticMeth;
        }
      }

      var methodsWithArgs = [['Math.pow', 1, 'pow']];

      for (var methodWithArg of methodsWithArgs) {
        var args = 'arg0';
        for (i = 1; i < methodWithArg[1]; i++) {
          args += `, arg${i}`;
        }
        if (methodWithArg[1] !== 1) {
          var inplaceMethWithArgs = eval2(fillTemplateFunction(inplaceMethodWithArgs, {
            name: methodWithArg[2],
            method: methodWithArg[0],
            args: args
          }));
          var staticMethWithArgs = eval2(fillTemplateFunction(staticMethodWithArgs, { name: methodWithArg[2], args: args }));
          for (i = 2; i < methodWithArg.length; i++) {
            Matrix.prototype[methodWithArg[i]] = inplaceMethWithArgs;
            Matrix[methodWithArg[i]] = staticMethWithArgs;
          }
        } else {
          var tmplVar = {
            name: methodWithArg[2],
            args: args,
            method: methodWithArg[0]
          };
          var inplaceMethod2 = eval2(fillTemplateFunction(inplaceMethodWithOneArg, tmplVar));
          var inplaceMethodS = eval2(fillTemplateFunction(inplaceMethodWithOneArgScalar, tmplVar));
          var inplaceMethodM = eval2(fillTemplateFunction(inplaceMethodWithOneArgMatrix, tmplVar));
          var staticMethod2 = eval2(fillTemplateFunction(staticMethodWithOneArg, tmplVar));
          for (i = 2; i < methodWithArg.length; i++) {
            Matrix.prototype[methodWithArg[i]] = inplaceMethod2;
            Matrix.prototype[`${methodWithArg[i]}M`] = inplaceMethodM;
            Matrix.prototype[`${methodWithArg[i]}S`] = inplaceMethodS;
            Matrix[methodWithArg[i]] = staticMethod2;
          }
        }
      }

      function fillTemplateFunction(template, values) {
        for (var value in values) {
          template = template.replace(new RegExp(`%${value}%`, 'g'), values[value]);
        }
        return template;
      }

      return Matrix;
    }

    class Matrix extends AbstractMatrix(Array) {
      constructor(nRows, nColumns) {
        var i;
        if (arguments.length === 1 && typeof nRows === 'number') {
          return new Array(nRows);
        }
        if (Matrix.isMatrix(nRows)) {
          return nRows.clone();
        } else if (Number.isInteger(nRows) && nRows > 0) {
          // Create an empty matrix
          super(nRows);
          if (Number.isInteger(nColumns) && nColumns > 0) {
            for (i = 0; i < nRows; i++) {
              this[i] = new Array(nColumns);
            }
          } else {
            throw new TypeError('nColumns must be a positive integer');
          }
        } else if (Array.isArray(nRows)) {
          // Copy the values from the 2D array
          const matrix = nRows;
          nRows = matrix.length;
          nColumns = matrix[0].length;
          if (typeof nColumns !== 'number' || nColumns === 0) {
            throw new TypeError(
              'Data must be a 2D array with at least one element'
            );
          }
          super(nRows);
          for (i = 0; i < nRows; i++) {
            if (matrix[i].length !== nColumns) {
              throw new RangeError('Inconsistent array dimensions');
            }
            this[i] = [].concat(matrix[i]);
          }
        } else {
          throw new TypeError(
            'First argument must be a positive number or an array'
          );
        }
        this.rows = nRows;
        this.columns = nColumns;
        return this;
      }

      set(rowIndex, columnIndex, value) {
        this[rowIndex][columnIndex] = value;
        return this;
      }

      get(rowIndex, columnIndex) {
        return this[rowIndex][columnIndex];
      }

      /**
       * Removes a row from the given index
       * @param {number} index - Row index
       * @return {Matrix} this
       */
      removeRow(index) {
        checkRowIndex(this, index);
        if (this.rows === 1) {
          throw new RangeError('A matrix cannot have less than one row');
        }
        this.splice(index, 1);
        this.rows -= 1;
        return this;
      }

      /**
       * Adds a row at the given index
       * @param {number} [index = this.rows] - Row index
       * @param {Array|Matrix} array - Array or vector
       * @return {Matrix} this
       */
      addRow(index, array) {
        if (array === undefined) {
          array = index;
          index = this.rows;
        }
        checkRowIndex(this, index, true);
        array = checkRowVector(this, array);
        this.splice(index, 0, array);
        this.rows += 1;
        return this;
      }

      /**
       * Removes a column from the given index
       * @param {number} index - Column index
       * @return {Matrix} this
       */
      removeColumn(index) {
        checkColumnIndex(this, index);
        if (this.columns === 1) {
          throw new RangeError('A matrix cannot have less than one column');
        }
        for (var i = 0; i < this.rows; i++) {
          this[i].splice(index, 1);
        }
        this.columns -= 1;
        return this;
      }

      /**
       * Adds a column at the given index
       * @param {number} [index = this.columns] - Column index
       * @param {Array|Matrix} array - Array or vector
       * @return {Matrix} this
       */
      addColumn(index, array) {
        if (typeof array === 'undefined') {
          array = index;
          index = this.columns;
        }
        checkColumnIndex(this, index, true);
        array = checkColumnVector(this, array);
        for (var i = 0; i < this.rows; i++) {
          this[i].splice(index, 0, array[i]);
        }
        this.columns += 1;
        return this;
      }
    }

    class WrapperMatrix1D extends AbstractMatrix() {
      /**
       * @class WrapperMatrix1D
       * @param {Array<number>} data
       * @param {object} [options]
       * @param {object} [options.rows = 1]
       */
      constructor(data, options = {}) {
        const { rows = 1 } = options;

        if (data.length % rows !== 0) {
          throw new Error('the data length is not divisible by the number of rows');
        }
        super();
        this.rows = rows;
        this.columns = data.length / rows;
        this.data = data;
      }

      set(rowIndex, columnIndex, value) {
        var index = this._calculateIndex(rowIndex, columnIndex);
        this.data[index] = value;
        return this;
      }

      get(rowIndex, columnIndex) {
        var index = this._calculateIndex(rowIndex, columnIndex);
        return this.data[index];
      }

      _calculateIndex(row, column) {
        return row * this.columns + column;
      }

      static get [Symbol.species]() {
        return Matrix;
      }
    }

    class WrapperMatrix2D extends AbstractMatrix() {
      /**
       * @class WrapperMatrix2D
       * @param {Array<Array<number>>} data
       */
      constructor(data) {
        super();
        this.data = data;
        this.rows = data.length;
        this.columns = data[0].length;
      }

      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }

      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }

      static get [Symbol.species]() {
        return Matrix;
      }
    }

    /**
     * @class QrDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs
     * @param {Matrix} value
     */
    class QrDecomposition {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);

        var qr = value.clone();
        var m = value.rows;
        var n = value.columns;
        var rdiag = new Array(n);
        var i, j, k, s;

        for (k = 0; k < n; k++) {
          var nrm = 0;
          for (i = k; i < m; i++) {
            nrm = hypotenuse(nrm, qr.get(i, k));
          }
          if (nrm !== 0) {
            if (qr.get(k, k) < 0) {
              nrm = -nrm;
            }
            for (i = k; i < m; i++) {
              qr.set(i, k, qr.get(i, k) / nrm);
            }
            qr.set(k, k, qr.get(k, k) + 1);
            for (j = k + 1; j < n; j++) {
              s = 0;
              for (i = k; i < m; i++) {
                s += qr.get(i, k) * qr.get(i, j);
              }
              s = -s / qr.get(k, k);
              for (i = k; i < m; i++) {
                qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
              }
            }
          }
          rdiag[k] = -nrm;
        }

        this.QR = qr;
        this.Rdiag = rdiag;
      }

      /**
       * Solve a problem of least square (Ax=b) by using the QR decomposition. Useful when A is rectangular, but not working when A is singular.
       * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :
       * var qr = QrDecomposition(A);
       * var x = qr.solve(b);
       * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)
       * @return {Matrix} - The vector x
       */
      solve(value) {
        value = Matrix.checkMatrix(value);

        var qr = this.QR;
        var m = qr.rows;

        if (value.rows !== m) {
          throw new Error('Matrix row dimensions must agree');
        }
        if (!this.isFullRank()) {
          throw new Error('Matrix is rank deficient');
        }

        var count = value.columns;
        var X = value.clone();
        var n = qr.columns;
        var i, j, k, s;

        for (k = 0; k < n; k++) {
          for (j = 0; j < count; j++) {
            s = 0;
            for (i = k; i < m; i++) {
              s += qr[i][k] * X[i][j];
            }
            s = -s / qr[k][k];
            for (i = k; i < m; i++) {
              X[i][j] += s * qr[i][k];
            }
          }
        }
        for (k = n - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            X[k][j] /= this.Rdiag[k];
          }
          for (i = 0; i < k; i++) {
            for (j = 0; j < count; j++) {
              X[i][j] -= X[k][j] * qr[i][k];
            }
          }
        }

        return X.subMatrix(0, n - 1, 0, count - 1);
      }

      /**
       *
       * @return {boolean}
       */
      isFullRank() {
        var columns = this.QR.columns;
        for (var i = 0; i < columns; i++) {
          if (this.Rdiag[i] === 0) {
            return false;
          }
        }
        return true;
      }

      /**
       *
       * @return {Matrix}
       */
      get upperTriangularMatrix() {
        var qr = this.QR;
        var n = qr.columns;
        var X = new Matrix(n, n);
        var i, j;
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            if (i < j) {
              X[i][j] = qr[i][j];
            } else if (i === j) {
              X[i][j] = this.Rdiag[i];
            } else {
              X[i][j] = 0;
            }
          }
        }
        return X;
      }

      /**
       *
       * @return {Matrix}
       */
      get orthogonalMatrix() {
        var qr = this.QR;
        var rows = qr.rows;
        var columns = qr.columns;
        var X = new Matrix(rows, columns);
        var i, j, k, s;

        for (k = columns - 1; k >= 0; k--) {
          for (i = 0; i < rows; i++) {
            X[i][k] = 0;
          }
          X[k][k] = 1;
          for (j = k; j < columns; j++) {
            if (qr[k][k] !== 0) {
              s = 0;
              for (i = k; i < rows; i++) {
                s += qr[i][k] * X[i][j];
              }

              s = -s / qr[k][k];

              for (i = k; i < rows; i++) {
                X[i][j] += s * qr[i][k];
              }
            }
          }
        }
        return X;
      }
    }

    /**
     * Computes the inverse of a Matrix
     * @param {Matrix} matrix
     * @param {boolean} [useSVD=false]
     * @return {Matrix}
     */
    function inverse(matrix, useSVD = false) {
      matrix = WrapperMatrix2D.checkMatrix(matrix);
      if (useSVD) {
        return new SingularValueDecomposition(matrix).inverse();
      } else {
        return solve(matrix, Matrix.eye(matrix.rows));
      }
    }

    /**
     *
     * @param {Matrix} leftHandSide
     * @param {Matrix} rightHandSide
     * @param {boolean} [useSVD = false]
     * @return {Matrix}
     */
    function solve(leftHandSide, rightHandSide, useSVD = false) {
      leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
      rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
      if (useSVD) {
        return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);
      } else {
        return leftHandSide.isSquare()
          ? new LuDecomposition(leftHandSide).solve(rightHandSide)
          : new QrDecomposition(leftHandSide).solve(rightHandSide);
      }
    }

    /**
     * @class EigenvalueDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs
     * @param {Matrix} matrix
     * @param {object} [options]
     * @param {boolean} [options.assumeSymmetric=false]
     */
    class EigenvalueDecomposition {
      constructor(matrix, options = {}) {
        const { assumeSymmetric = false } = options;

        matrix = WrapperMatrix2D.checkMatrix(matrix);
        if (!matrix.isSquare()) {
          throw new Error('Matrix is not a square matrix');
        }

        var n = matrix.columns;
        var V = getFilled2DArray(n, n, 0);
        var d = new Array(n);
        var e = new Array(n);
        var value = matrix;
        var i, j;

        var isSymmetric = false;
        if (assumeSymmetric) {
          isSymmetric = true;
        } else {
          isSymmetric = matrix.isSymmetric();
        }

        if (isSymmetric) {
          for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
              V[i][j] = value.get(i, j);
            }
          }
          tred2(n, e, d, V);
          tql2(n, e, d, V);
        } else {
          var H = getFilled2DArray(n, n, 0);
          var ort = new Array(n);
          for (j = 0; j < n; j++) {
            for (i = 0; i < n; i++) {
              H[i][j] = value.get(i, j);
            }
          }
          orthes(n, H, ort, V);
          hqr2(n, e, d, V, H);
        }

        this.n = n;
        this.e = e;
        this.d = d;
        this.V = V;
      }

      /**
       *
       * @return {Array<number>}
       */
      get realEigenvalues() {
        return this.d;
      }

      /**
       *
       * @return {Array<number>}
       */
      get imaginaryEigenvalues() {
        return this.e;
      }

      /**
       *
       * @return {Matrix}
       */
      get eigenvectorMatrix() {
        if (!Matrix.isMatrix(this.V)) {
          this.V = new Matrix(this.V);
        }
        return this.V;
      }

      /**
       *
       * @return {Matrix}
       */
      get diagonalMatrix() {
        var n = this.n;
        var e = this.e;
        var d = this.d;
        var X = new Matrix(n, n);
        var i, j;
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            X[i][j] = 0;
          }
          X[i][i] = d[i];
          if (e[i] > 0) {
            X[i][i + 1] = e[i];
          } else if (e[i] < 0) {
            X[i][i - 1] = e[i];
          }
        }
        return X;
      }
    }

    function tred2(n, e, d, V) {
      var f, g, h, i, j, k, hh, scale;

      for (j = 0; j < n; j++) {
        d[j] = V[n - 1][j];
      }

      for (i = n - 1; i > 0; i--) {
        scale = 0;
        h = 0;
        for (k = 0; k < i; k++) {
          scale = scale + Math.abs(d[k]);
        }

        if (scale === 0) {
          e[i] = d[i - 1];
          for (j = 0; j < i; j++) {
            d[j] = V[i - 1][j];
            V[i][j] = 0;
            V[j][i] = 0;
          }
        } else {
          for (k = 0; k < i; k++) {
            d[k] /= scale;
            h += d[k] * d[k];
          }

          f = d[i - 1];
          g = Math.sqrt(h);
          if (f > 0) {
            g = -g;
          }

          e[i] = scale * g;
          h = h - f * g;
          d[i - 1] = f - g;
          for (j = 0; j < i; j++) {
            e[j] = 0;
          }

          for (j = 0; j < i; j++) {
            f = d[j];
            V[j][i] = f;
            g = e[j] + V[j][j] * f;
            for (k = j + 1; k <= i - 1; k++) {
              g += V[k][j] * d[k];
              e[k] += V[k][j] * f;
            }
            e[j] = g;
          }

          f = 0;
          for (j = 0; j < i; j++) {
            e[j] /= h;
            f += e[j] * d[j];
          }

          hh = f / (h + h);
          for (j = 0; j < i; j++) {
            e[j] -= hh * d[j];
          }

          for (j = 0; j < i; j++) {
            f = d[j];
            g = e[j];
            for (k = j; k <= i - 1; k++) {
              V[k][j] -= f * e[k] + g * d[k];
            }
            d[j] = V[i - 1][j];
            V[i][j] = 0;
          }
        }
        d[i] = h;
      }

      for (i = 0; i < n - 1; i++) {
        V[n - 1][i] = V[i][i];
        V[i][i] = 1;
        h = d[i + 1];
        if (h !== 0) {
          for (k = 0; k <= i; k++) {
            d[k] = V[k][i + 1] / h;
          }

          for (j = 0; j <= i; j++) {
            g = 0;
            for (k = 0; k <= i; k++) {
              g += V[k][i + 1] * V[k][j];
            }
            for (k = 0; k <= i; k++) {
              V[k][j] -= g * d[k];
            }
          }
        }

        for (k = 0; k <= i; k++) {
          V[k][i + 1] = 0;
        }
      }

      for (j = 0; j < n; j++) {
        d[j] = V[n - 1][j];
        V[n - 1][j] = 0;
      }

      V[n - 1][n - 1] = 1;
      e[0] = 0;
    }

    function tql2(n, e, d, V) {
      var g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2;

      for (i = 1; i < n; i++) {
        e[i - 1] = e[i];
      }

      e[n - 1] = 0;

      var f = 0;
      var tst1 = 0;
      var eps = Number.EPSILON;

      for (l = 0; l < n; l++) {
        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
        m = l;
        while (m < n) {
          if (Math.abs(e[m]) <= eps * tst1) {
            break;
          }
          m++;
        }

        if (m > l) {
          do {

            g = d[l];
            p = (d[l + 1] - g) / (2 * e[l]);
            r = hypotenuse(p, 1);
            if (p < 0) {
              r = -r;
            }

            d[l] = e[l] / (p + r);
            d[l + 1] = e[l] * (p + r);
            dl1 = d[l + 1];
            h = g - d[l];
            for (i = l + 2; i < n; i++) {
              d[i] -= h;
            }

            f = f + h;

            p = d[m];
            c = 1;
            c2 = c;
            c3 = c;
            el1 = e[l + 1];
            s = 0;
            s2 = 0;
            for (i = m - 1; i >= l; i--) {
              c3 = c2;
              c2 = c;
              s2 = s;
              g = c * e[i];
              h = c * p;
              r = hypotenuse(p, e[i]);
              e[i + 1] = s * r;
              s = e[i] / r;
              c = p / r;
              p = c * d[i] - s * g;
              d[i + 1] = h + s * (c * g + s * d[i]);

              for (k = 0; k < n; k++) {
                h = V[k][i + 1];
                V[k][i + 1] = s * V[k][i] + c * h;
                V[k][i] = c * V[k][i] - s * h;
              }
            }

            p = -s * s2 * c3 * el1 * e[l] / dl1;
            e[l] = s * p;
            d[l] = c * p;
          } while (Math.abs(e[l]) > eps * tst1);
        }
        d[l] = d[l] + f;
        e[l] = 0;
      }

      for (i = 0; i < n - 1; i++) {
        k = i;
        p = d[i];
        for (j = i + 1; j < n; j++) {
          if (d[j] < p) {
            k = j;
            p = d[j];
          }
        }

        if (k !== i) {
          d[k] = d[i];
          d[i] = p;
          for (j = 0; j < n; j++) {
            p = V[j][i];
            V[j][i] = V[j][k];
            V[j][k] = p;
          }
        }
      }
    }

    function orthes(n, H, ort, V) {
      var low = 0;
      var high = n - 1;
      var f, g, h, i, j, m;
      var scale;

      for (m = low + 1; m <= high - 1; m++) {
        scale = 0;
        for (i = m; i <= high; i++) {
          scale = scale + Math.abs(H[i][m - 1]);
        }

        if (scale !== 0) {
          h = 0;
          for (i = high; i >= m; i--) {
            ort[i] = H[i][m - 1] / scale;
            h += ort[i] * ort[i];
          }

          g = Math.sqrt(h);
          if (ort[m] > 0) {
            g = -g;
          }

          h = h - ort[m] * g;
          ort[m] = ort[m] - g;

          for (j = m; j < n; j++) {
            f = 0;
            for (i = high; i >= m; i--) {
              f += ort[i] * H[i][j];
            }

            f = f / h;
            for (i = m; i <= high; i++) {
              H[i][j] -= f * ort[i];
            }
          }

          for (i = 0; i <= high; i++) {
            f = 0;
            for (j = high; j >= m; j--) {
              f += ort[j] * H[i][j];
            }

            f = f / h;
            for (j = m; j <= high; j++) {
              H[i][j] -= f * ort[j];
            }
          }

          ort[m] = scale * ort[m];
          H[m][m - 1] = scale * g;
        }
      }

      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          V[i][j] = i === j ? 1 : 0;
        }
      }

      for (m = high - 1; m >= low + 1; m--) {
        if (H[m][m - 1] !== 0) {
          for (i = m + 1; i <= high; i++) {
            ort[i] = H[i][m - 1];
          }

          for (j = m; j <= high; j++) {
            g = 0;
            for (i = m; i <= high; i++) {
              g += ort[i] * V[i][j];
            }

            g = g / ort[m] / H[m][m - 1];
            for (i = m; i <= high; i++) {
              V[i][j] += g * ort[i];
            }
          }
        }
      }
    }

    function hqr2(nn, e, d, V, H) {
      var n = nn - 1;
      var low = 0;
      var high = nn - 1;
      var eps = Number.EPSILON;
      var exshift = 0;
      var norm = 0;
      var p = 0;
      var q = 0;
      var r = 0;
      var s = 0;
      var z = 0;
      var iter = 0;
      var i, j, k, l, m, t, w, x, y;
      var ra, sa, vr, vi;
      var notlast, cdivres;

      for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
          d[i] = H[i][i];
          e[i] = 0;
        }

        for (j = Math.max(i - 1, 0); j < nn; j++) {
          norm = norm + Math.abs(H[i][j]);
        }
      }

      while (n >= low) {
        l = n;
        while (l > low) {
          s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);
          if (s === 0) {
            s = norm;
          }
          if (Math.abs(H[l][l - 1]) < eps * s) {
            break;
          }
          l--;
        }

        if (l === n) {
          H[n][n] = H[n][n] + exshift;
          d[n] = H[n][n];
          e[n] = 0;
          n--;
          iter = 0;
        } else if (l === n - 1) {
          w = H[n][n - 1] * H[n - 1][n];
          p = (H[n - 1][n - 1] - H[n][n]) / 2;
          q = p * p + w;
          z = Math.sqrt(Math.abs(q));
          H[n][n] = H[n][n] + exshift;
          H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;
          x = H[n][n];

          if (q >= 0) {
            z = p >= 0 ? p + z : p - z;
            d[n - 1] = x + z;
            d[n] = d[n - 1];
            if (z !== 0) {
              d[n] = x - w / z;
            }
            e[n - 1] = 0;
            e[n] = 0;
            x = H[n][n - 1];
            s = Math.abs(x) + Math.abs(z);
            p = x / s;
            q = z / s;
            r = Math.sqrt(p * p + q * q);
            p = p / r;
            q = q / r;

            for (j = n - 1; j < nn; j++) {
              z = H[n - 1][j];
              H[n - 1][j] = q * z + p * H[n][j];
              H[n][j] = q * H[n][j] - p * z;
            }

            for (i = 0; i <= n; i++) {
              z = H[i][n - 1];
              H[i][n - 1] = q * z + p * H[i][n];
              H[i][n] = q * H[i][n] - p * z;
            }

            for (i = low; i <= high; i++) {
              z = V[i][n - 1];
              V[i][n - 1] = q * z + p * V[i][n];
              V[i][n] = q * V[i][n] - p * z;
            }
          } else {
            d[n - 1] = x + p;
            d[n] = x + p;
            e[n - 1] = z;
            e[n] = -z;
          }

          n = n - 2;
          iter = 0;
        } else {
          x = H[n][n];
          y = 0;
          w = 0;
          if (l < n) {
            y = H[n - 1][n - 1];
            w = H[n][n - 1] * H[n - 1][n];
          }

          if (iter === 10) {
            exshift += x;
            for (i = low; i <= n; i++) {
              H[i][i] -= x;
            }
            s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);
            x = y = 0.75 * s;
            w = -0.4375 * s * s;
          }

          if (iter === 30) {
            s = (y - x) / 2;
            s = s * s + w;
            if (s > 0) {
              s = Math.sqrt(s);
              if (y < x) {
                s = -s;
              }
              s = x - w / ((y - x) / 2 + s);
              for (i = low; i <= n; i++) {
                H[i][i] -= s;
              }
              exshift += s;
              x = y = w = 0.964;
            }
          }

          iter = iter + 1;

          m = n - 2;
          while (m >= l) {
            z = H[m][m];
            r = x - z;
            s = y - z;
            p = (r * s - w) / H[m + 1][m] + H[m][m + 1];
            q = H[m + 1][m + 1] - z - r - s;
            r = H[m + 2][m + 1];
            s = Math.abs(p) + Math.abs(q) + Math.abs(r);
            p = p / s;
            q = q / s;
            r = r / s;
            if (m === l) {
              break;
            }
            if (
              Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) <
              eps *
                (Math.abs(p) *
                  (Math.abs(H[m - 1][m - 1]) +
                    Math.abs(z) +
                    Math.abs(H[m + 1][m + 1])))
            ) {
              break;
            }
            m--;
          }

          for (i = m + 2; i <= n; i++) {
            H[i][i - 2] = 0;
            if (i > m + 2) {
              H[i][i - 3] = 0;
            }
          }

          for (k = m; k <= n - 1; k++) {
            notlast = k !== n - 1;
            if (k !== m) {
              p = H[k][k - 1];
              q = H[k + 1][k - 1];
              r = notlast ? H[k + 2][k - 1] : 0;
              x = Math.abs(p) + Math.abs(q) + Math.abs(r);
              if (x !== 0) {
                p = p / x;
                q = q / x;
                r = r / x;
              }
            }

            if (x === 0) {
              break;
            }

            s = Math.sqrt(p * p + q * q + r * r);
            if (p < 0) {
              s = -s;
            }

            if (s !== 0) {
              if (k !== m) {
                H[k][k - 1] = -s * x;
              } else if (l !== m) {
                H[k][k - 1] = -H[k][k - 1];
              }

              p = p + s;
              x = p / s;
              y = q / s;
              z = r / s;
              q = q / p;
              r = r / p;

              for (j = k; j < nn; j++) {
                p = H[k][j] + q * H[k + 1][j];
                if (notlast) {
                  p = p + r * H[k + 2][j];
                  H[k + 2][j] = H[k + 2][j] - p * z;
                }

                H[k][j] = H[k][j] - p * x;
                H[k + 1][j] = H[k + 1][j] - p * y;
              }

              for (i = 0; i <= Math.min(n, k + 3); i++) {
                p = x * H[i][k] + y * H[i][k + 1];
                if (notlast) {
                  p = p + z * H[i][k + 2];
                  H[i][k + 2] = H[i][k + 2] - p * r;
                }

                H[i][k] = H[i][k] - p;
                H[i][k + 1] = H[i][k + 1] - p * q;
              }

              for (i = low; i <= high; i++) {
                p = x * V[i][k] + y * V[i][k + 1];
                if (notlast) {
                  p = p + z * V[i][k + 2];
                  V[i][k + 2] = V[i][k + 2] - p * r;
                }

                V[i][k] = V[i][k] - p;
                V[i][k + 1] = V[i][k + 1] - p * q;
              }
            }
          }
        }
      }

      if (norm === 0) {
        return;
      }

      for (n = nn - 1; n >= 0; n--) {
        p = d[n];
        q = e[n];

        if (q === 0) {
          l = n;
          H[n][n] = 1;
          for (i = n - 1; i >= 0; i--) {
            w = H[i][i] - p;
            r = 0;
            for (j = l; j <= n; j++) {
              r = r + H[i][j] * H[j][n];
            }

            if (e[i] < 0) {
              z = w;
              s = r;
            } else {
              l = i;
              if (e[i] === 0) {
                H[i][n] = w !== 0 ? -r / w : -r / (eps * norm);
              } else {
                x = H[i][i + 1];
                y = H[i + 1][i];
                q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
                t = (x * s - z * r) / q;
                H[i][n] = t;
                H[i + 1][n] =
                  Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z;
              }

              t = Math.abs(H[i][n]);
              if (eps * t * t > 1) {
                for (j = i; j <= n; j++) {
                  H[j][n] = H[j][n] / t;
                }
              }
            }
          }
        } else if (q < 0) {
          l = n - 1;

          if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {
            H[n - 1][n - 1] = q / H[n][n - 1];
            H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];
          } else {
            cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);
            H[n - 1][n - 1] = cdivres[0];
            H[n - 1][n] = cdivres[1];
          }

          H[n][n - 1] = 0;
          H[n][n] = 1;
          for (i = n - 2; i >= 0; i--) {
            ra = 0;
            sa = 0;
            for (j = l; j <= n; j++) {
              ra = ra + H[i][j] * H[j][n - 1];
              sa = sa + H[i][j] * H[j][n];
            }

            w = H[i][i] - p;

            if (e[i] < 0) {
              z = w;
              r = ra;
              s = sa;
            } else {
              l = i;
              if (e[i] === 0) {
                cdivres = cdiv(-ra, -sa, w, q);
                H[i][n - 1] = cdivres[0];
                H[i][n] = cdivres[1];
              } else {
                x = H[i][i + 1];
                y = H[i + 1][i];
                vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
                vi = (d[i] - p) * 2 * q;
                if (vr === 0 && vi === 0) {
                  vr =
                    eps *
                    norm *
                    (Math.abs(w) +
                      Math.abs(q) +
                      Math.abs(x) +
                      Math.abs(y) +
                      Math.abs(z));
                }
                cdivres = cdiv(
                  x * r - z * ra + q * sa,
                  x * s - z * sa - q * ra,
                  vr,
                  vi
                );
                H[i][n - 1] = cdivres[0];
                H[i][n] = cdivres[1];
                if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
                  H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;
                  H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;
                } else {
                  cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);
                  H[i + 1][n - 1] = cdivres[0];
                  H[i + 1][n] = cdivres[1];
                }
              }

              t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));
              if (eps * t * t > 1) {
                for (j = i; j <= n; j++) {
                  H[j][n - 1] = H[j][n - 1] / t;
                  H[j][n] = H[j][n] / t;
                }
              }
            }
          }
        }
      }

      for (i = 0; i < nn; i++) {
        if (i < low || i > high) {
          for (j = i; j < nn; j++) {
            V[i][j] = H[i][j];
          }
        }
      }

      for (j = nn - 1; j >= low; j--) {
        for (i = low; i <= high; i++) {
          z = 0;
          for (k = low; k <= Math.min(j, high); k++) {
            z = z + V[i][k] * H[k][j];
          }
          V[i][j] = z;
        }
      }
    }

    function cdiv(xr, xi, yr, yi) {
      var r, d;
      if (Math.abs(yr) > Math.abs(yi)) {
        r = yi / yr;
        d = yr + r * yi;
        return [(xr + r * xi) / d, (xi - r * xr) / d];
      } else {
        r = yr / yi;
        d = yi + r * yr;
        return [(r * xr + xi) / d, (r * xi - xr) / d];
      }
    }

    /**
     * @class CholeskyDecomposition
     * @link https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs
     * @param {Matrix} value
     */
    class CholeskyDecomposition {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        if (!value.isSymmetric()) {
          throw new Error('Matrix is not symmetric');
        }

        var a = value;
        var dimension = a.rows;
        var l = new Matrix(dimension, dimension);
        var positiveDefinite = true;
        var i, j, k;

        for (j = 0; j < dimension; j++) {
          var Lrowj = l[j];
          var d = 0;
          for (k = 0; k < j; k++) {
            var Lrowk = l[k];
            var s = 0;
            for (i = 0; i < k; i++) {
              s += Lrowk[i] * Lrowj[i];
            }
            Lrowj[k] = s = (a.get(j, k) - s) / l[k][k];
            d = d + s * s;
          }

          d = a.get(j, j) - d;

          positiveDefinite &= d > 0;
          l[j][j] = Math.sqrt(Math.max(d, 0));
          for (k = j + 1; k < dimension; k++) {
            l[j][k] = 0;
          }
        }

        if (!positiveDefinite) {
          throw new Error('Matrix is not positive definite');
        }

        this.L = l;
      }

      /**
       *
       * @param {Matrix} value
       * @return {Matrix}
       */
      solve(value) {
        value = WrapperMatrix2D.checkMatrix(value);

        var l = this.L;
        var dimension = l.rows;

        if (value.rows !== dimension) {
          throw new Error('Matrix dimensions do not match');
        }

        var count = value.columns;
        var B = value.clone();
        var i, j, k;

        for (k = 0; k < dimension; k++) {
          for (j = 0; j < count; j++) {
            for (i = 0; i < k; i++) {
              B[k][j] -= B[i][j] * l[k][i];
            }
            B[k][j] /= l[k][k];
          }
        }

        for (k = dimension - 1; k >= 0; k--) {
          for (j = 0; j < count; j++) {
            for (i = k + 1; i < dimension; i++) {
              B[k][j] -= B[i][j] * l[i][k];
            }
            B[k][j] /= l[k][k];
          }
        }

        return B;
      }

      /**
       *
       * @return {Matrix}
       */
      get lowerTriangularMatrix() {
        return this.L;
      }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var func$3 = Symbol('func');
    var validate = Symbol('validate');

    var symbols$1 = {
    	func: func$3,
    	validate: validate
    };

    const { func: func$2 } = symbols$1;

    const numberPredicates = {
      positive: (value) => (value > 0),
      negative: (value) => (value < 0),
      nonNegative: (value) => (value >= 0),
      integer: (value) => (value === (value | 0)),

      [func$2]: {
        is: (fn) => fn,
        eq: (v) => (value) => (value === v),
        gt: (v) => (value) => (value > v),
        gte: (v) => (value) => (value >= v),
        lt: (v) => (value) => (value < v),
        lte: (v) => (value) => (value <= v)
      }
    };

    var number$4 = {
      predicates: numberPredicates,
      validator: (value) => {
        return typeof value === 'number'
      }
    };

    const { func: func$1 } = symbols$1;

    const stringPredicates = {
      empty: (value) => (value === ''),
      nonEmpty: (value) => (value !== ''),

      [func$1]: {
        is: (fn) => fn,
        eq: (v) => (value) => (value === v),
        length: (v) => (value) => (value.length === v),
        minLength: (v) => (value) => (value.length >= v),
        maxLength: (v) => (value) => (value.length <= v),
        matches: (v) => (value) => v.test(value),
        startsWith: (v) => (value) => value.startsWith(v),
        endsWith: (v) => (value) => value.endsWith(v)
      }
    };

    var string = {
      predicates: stringPredicates,
      validator: (value) => {
        return typeof value === 'string'
      }
    };

    const { func } = symbols$1;

    const objectPredicates = {
      plain: (value) => {
        if (typeof value !== 'object') return false

        const proto = Object.getPrototypeOf(value);
        return proto === null || proto === Object.getPrototypeOf({})
      },
      empty: (value) => Object.keys(value).length === 0,
      nonEmpty: (value) => Object.keys(value).length > 0,

      [func]: {
        is: (fn) => fn,
        instanceOf: (v) => (value) => (value instanceof v)
      }
    };

    var object$2 = {
      predicates: objectPredicates,
      validator: (value) => {
        return typeof value === 'object'
      }
    };

    const typePredicates = {
      number: number$4,
      string,
      object: object$2
    };

    const createOw = ({
      validators = [],
      predicates = typePredicates,
      type = null
    } = { }) => {
      const ow = new Proxy(function () { }, {
        get: (obj, key) => {
          if (key === symbols$1.validate) {
            return (value, label = 'argument') => {
              if (!type) {
                return new Error('missing required type specifier')
              }

              for (let i = 0; i < validators.length; ++i) {
                const validator = validators[i];
                const result = validator.fn(value);

                if (!result) {
                  if (i === 0) {
                    throw new Error(`Expected ${label} \`${value}\` to be of type \`${type}\`, but received type \`${typeof value}\``)
                  } else {
                    throw new Error(`Expected ${type} \`${label}\` \`${value}\` failed predicate \`${validator.key}\``)
                  }
                }
              }
            }
          }

          const predicate = predicates[key];

          if (predicate) {
            if (typeof predicate === 'function') {
              validators.push({
                key,
                fn: predicate
              });

              return ow
            } else {
              return createOw({
                type: key,
                validators: [
                  {
                    key,
                    fn: predicate.validator
                  }
                ],
                predicates: predicate.predicates
              })
            }
          } else {
            const fn = predicates[symbols$1.func] && predicates[symbols$1.func][key];

            if (fn) {
              return new Proxy(function () { }, {
                get: () => {
                  throw new Error(`invalid use of functional predicate "${key}"`)
                },

                apply: (obj, thisArg, args) => {
                  validators.push({
                    key,
                    fn: fn(...args)
                  });

                  return ow
                }
              })
            } else {
              if (key === 'default' || key === '__esModule') {
                return ow
              }

              return ow
              // throw new Error(`unrecognized predicate "${key}"`)
            }
          }
        },

        apply: (obj, thisArg, args) => {
          if (args.length !== 2 && args.length !== 3) {
            throw new Error('invalid number of arguments to "ow"')
          } else {
            args[1][symbols$1.validate](args[0], args[2]);
          }
        }
      });

      return ow
    };

    var owLite = createOw();

    var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var RNG = function () {
      function RNG() {
        _classCallCheck$1(this, RNG);
      }

      _createClass$1(RNG, [{
        key: 'next',
        value: function next() {
          throw new Error('RNG.next must be overridden');
        }
      }, {
        key: 'seed',
        value: function seed(_seed, opts) {
          throw new Error('RNG.seed must be overridden');
        }
      }, {
        key: 'clone',
        value: function clone(seed, opts) {
          throw new Error('RNG.clone must be overridden');
        }
      }, {
        key: '_seed',
        value: function _seed(seed, opts) {
          // TODO: add entropy and stuff

          if (seed === (seed | 0)) {
            return seed;
          } else {
            var strSeed = '' + seed;
            var s = 0;

            for (var k = 0; k < strSeed.length; ++k) {
              s ^= strSeed.charCodeAt(k) | 0;
            }

            return s;
          }
        }
      }, {
        key: 'name',
        get: function get() {
          throw new Error('RNG.name must be overridden');
        }
      }]);

      return RNG;
    }();

    var _default$g = RNG;


    var rng = /*#__PURE__*/Object.defineProperty({
    	default: _default$g
    }, '__esModule', {value: true});

    var alea = createCommonjsModule(function (module) {
    // A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
    // http://baagoe.com/en/RandomMusings/javascript/
    // https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
    // Original work is under MIT license -

    // Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.



    (function(global, module, define) {

    function Alea(seed) {
      var me = this, mash = Mash();

      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };

      // Apply the seeding algorithm from Baagoe.
      me.c = 1;
      me.s0 = mash(' ');
      me.s1 = mash(' ');
      me.s2 = mash(' ');
      me.s0 -= mash(seed);
      if (me.s0 < 0) { me.s0 += 1; }
      me.s1 -= mash(seed);
      if (me.s1 < 0) { me.s1 += 1; }
      me.s2 -= mash(seed);
      if (me.s2 < 0) { me.s2 += 1; }
      mash = null;
    }

    function copy(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }

    function impl(seed, opts) {
      var xg = new Alea(seed),
          state = opts && opts.state,
          prng = xg.next;
      prng.int32 = function() { return (xg.next() * 0x100000000) | 0; };
      prng.double = function() {
        return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
      };
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    function Mash() {
      var n = 0xefc8249d;

      var mash = function(data) {
        data = String(data);
        for (var i = 0; i < data.length; i++) {
          n += data.charCodeAt(i);
          var h = 0.02519603282416938 * n;
          n = h >>> 0;
          h -= n;
          h *= n;
          n = h >>> 0;
          h -= n;
          n += h * 0x100000000; // 2^32
        }
        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
      };

      return mash;
    }


    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.alea = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xor128 = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xor128" prng algorithm by
    // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;

      // Set up generator function.
      me.next = function() {
        var t = me.x ^ (me.x << 11);
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
      };

      if (seed === (seed | 0)) {
        // Integer seed.
        me.x = seed;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }

    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }

    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xor128 = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xorwow = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xorwow" prng algorithm by
    // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      // Set up generator function.
      me.next = function() {
        var t = (me.x ^ (me.x >>> 2));
        me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
        return (me.d = (me.d + 362437 | 0)) +
           (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
      };

      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;

      if (seed === (seed | 0)) {
        // Integer seed.
        me.x = seed;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }

    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }

    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xorwow = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xorshift7 = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xorshift7" algorithm by
    // Franois Panneton and Pierre L'ecuyer:
    // "On the Xorgshift Random Number Generators"
    // http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this;

      // Set up generator function.
      me.next = function() {
        // Update xor generator.
        var X = me.x, i = me.i, t, v;
        t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
        t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
        t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
        t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
        t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
        X[i] = v;
        me.i = (i + 1) & 7;
        return v;
      };

      function init(me, seed) {
        var j, X = [];

        if (seed === (seed | 0)) {
          // Seed state array using a 32-bit integer.
          X[0] = seed;
        } else {
          // Seed state using a string.
          seed = '' + seed;
          for (j = 0; j < seed.length; ++j) {
            X[j & 7] = (X[j & 7] << 15) ^
                (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
          }
        }
        // Enforce an array length of 8, not all zeroes.
        while (X.length < 8) X.push(0);
        for (j = 0; j < 8 && X[j] === 0; ++j);
        if (j == 8) X[7] = -1;

        me.x = X;
        me.i = 0;

        // Discard an initial 256 values.
        for (j = 256; j > 0; --j) {
          me.next();
        }
      }

      init(me, seed);
    }

    function copy(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }

    function impl(seed, opts) {
      if (seed == null) seed = +(new Date);
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.x) copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xorshift7 = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var xor4096 = createCommonjsModule(function (module) {
    // A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
    //
    // This fast non-cryptographic random number generator is designed for
    // use in Monte-Carlo algorithms. It combines a long-period xorshift
    // generator with a Weyl generator, and it passes all common batteries
    // of stasticial tests for randomness while consuming only a few nanoseconds
    // for each prng generated.  For background on the generator, see Brent's
    // paper: "Some long-period random number generators using shifts and xors."
    // http://arxiv.org/pdf/1004.3115v1.pdf
    //
    // Usage:
    //
    // var xor4096 = require('xor4096');
    // random = xor4096(1);                        // Seed with int32 or string.
    // assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
    // assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
    //
    // For nonzero numeric keys, this impelementation provides a sequence
    // identical to that by Brent's xorgens 3 implementaion in C.  This
    // implementation also provides for initalizing the generator with
    // string seeds, or for saving and restoring the state of the generator.
    //
    // On Chrome, this prng benchmarks about 2.1 times slower than
    // Javascript's built-in Math.random().

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this;

      // Set up generator function.
      me.next = function() {
        var w = me.w,
            X = me.X, i = me.i, t, v;
        // Update Weyl generator.
        me.w = w = (w + 0x61c88647) | 0;
        // Update xor generator.
        v = X[(i + 34) & 127];
        t = X[i = ((i + 1) & 127)];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        // Update Xor generator array state.
        v = X[i] = v ^ t;
        me.i = i;
        // Result is the combination.
        return (v + (w ^ (w >>> 16))) | 0;
      };

      function init(me, seed) {
        var t, v, i, j, w, X = [], limit = 128;
        if (seed === (seed | 0)) {
          // Numeric seeds initialize v, which is used to generates X.
          v = seed;
          seed = null;
        } else {
          // String seeds are mixed into v and X one character at a time.
          seed = seed + '\0';
          v = 0;
          limit = Math.max(limit, seed.length);
        }
        // Initialize circular array and weyl value.
        for (i = 0, j = -32; j < limit; ++j) {
          // Put the unicode characters into the array, and shuffle them.
          if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
          // After 32 shuffles, take v as the starting w value.
          if (j === 0) w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = (w + 0x61c88647) | 0;     // Weyl.
            t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
            i = (0 == t) ? i + 1 : 0;     // Count zeroes.
          }
        }
        // We have detected all zeroes; make the key nonzero.
        if (i >= 128) {
          X[(seed && seed.length || 0) & 127] = -1;
        }
        // Run the generator 512 times to further mix the state before using it.
        // Factoring this as a function slows the main generator, so it is just
        // unrolled here.  The weyl generator is not advanced while warming up.
        i = 127;
        for (j = 4 * 128; j > 0; --j) {
          v = X[(i + 34) & 127];
          t = X[i = ((i + 1) & 127)];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i] = v ^ t;
        }
        // Storing state as object members is faster than using closure variables.
        me.w = w;
        me.X = X;
        me.i = i;
      }

      init(me, seed);
    }

    function copy(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null) seed = +(new Date);
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.X) copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xor4096 = impl;
    }

    })(
      commonjsGlobal,                                     // window object or global
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var tychei = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "Tyche-i" prng algorithm by
    // Samuel Neves and Filipe Araujo.
    // See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      // Set up generator function.
      me.next = function() {
        var b = me.b, c = me.c, d = me.d, a = me.a;
        b = (b << 25) ^ (b >>> 7) ^ c;
        c = (c - d) | 0;
        d = (d << 24) ^ (d >>> 8) ^ a;
        a = (a - b) | 0;
        me.b = b = (b << 20) ^ (b >>> 12) ^ c;
        me.c = c = (c - d) | 0;
        me.d = (d << 16) ^ (c >>> 16) ^ a;
        return me.a = (a - b) | 0;
      };

      /* The following is non-inverted tyche, which has better internal
       * bit diffusion, but which is about 25% slower than tyche-i in JS.
      me.next = function() {
        var a = me.a, b = me.b, c = me.c, d = me.d;
        a = (me.a + me.b | 0) >>> 0;
        d = me.d ^ a; d = d << 16 ^ d >>> 16;
        c = me.c + d | 0;
        b = me.b ^ c; b = b << 12 ^ d >>> 20;
        me.a = a = a + b | 0;
        d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
        me.c = c = c + d | 0;
        b = b ^ c;
        return me.b = (b << 7 ^ b >>> 25);
      }
      */

      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;

      if (seed === Math.floor(seed)) {
        // Integer seed.
        me.a = (seed / 0x100000000) | 0;
        me.b = seed | 0;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }

    function copy(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.tychei = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function'    // present with an AMD loader
    );
    });

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

    /*
    Copyright 2019 David Bau.

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    */

    var seedrandom$1 = createCommonjsModule(function (module) {
    (function (global, pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //

    var width = 256,        // each RC4 output is 0 <= x < 256
        chunks = 6,         // at least six RC4 outputs for each double
        digits = 52,        // there are 52 significant digits in a double
        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks),
        significance = math.pow(2, digits),
        overflow = significance * 2,
        mask = width - 1,
        nodecrypto;         // node.js crypto module, initialized at the bottom.

    //
    // seedrandom()
    // This is the seedrandom function described above.
    //
    function seedrandom(seed, options, callback) {
      var key = [];
      options = (options == true) ? { entropy: true } : (options || {});

      // Flatten the seed string or build one from local entropy if needed.
      var shortseed = mixkey(flatten(
        options.entropy ? [seed, tostring(pool)] :
        (seed == null) ? autoseed() : seed, 3), key);

      // Use the seed to initialize an ARC4 generator.
      var arc4 = new ARC4(key);

      // This function returns a random double in [0, 1) that contains
      // randomness in every bit of the mantissa of the IEEE 754 value.
      var prng = function() {
        var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
            d = startdenom,                 //   and denominator d = 2 ^ 48.
            x = 0;                          //   and no 'extra last byte'.
        while (n < significance) {          // Fill up all significant digits by
          n = (n + x) * width;              //   shifting numerator and
          d *= width;                       //   denominator and generating a
          x = arc4.g(1);                    //   new least-significant-byte.
        }
        while (n >= overflow) {             // To avoid rounding up, before adding
          n /= 2;                           //   last byte, shift everything
          d /= 2;                           //   right using integer math until
          x >>>= 1;                         //   we have exactly the desired bits.
        }
        return (n + x) / d;                 // Form the number within [0, 1).
      };

      prng.int32 = function() { return arc4.g(4) | 0; };
      prng.quick = function() { return arc4.g(4) / 0x100000000; };
      prng.double = prng;

      // Mix the randomness into accumulated entropy.
      mixkey(tostring(arc4.S), pool);

      // Calling convention: what to return as a function of prng, seed, is_math.
      return (options.pass || callback ||
          function(prng, seed, is_math_call, state) {
            if (state) {
              // Load the arc4 state from the given state if it has an S array.
              if (state.S) { copy(state, arc4); }
              // Only provide the .state method if requested via options.state.
              prng.state = function() { return copy(arc4, {}); };
            }

            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) { math[rngname] = prng; return seed; }

            // Otherwise, it is a newer calling convention, so return the
            // prng directly.
            else return prng;
          })(
      prng,
      shortseed,
      'global' in options ? options.global : (this == math),
      options.state);
    }

    //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
    function ARC4(key) {
      var t, keylen = key.length,
          me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

      // The empty key [] is treated as [0].
      if (!keylen) { key = [keylen++]; }

      // Set up S using the standard key scheduling algorithm.
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0; i < width; i++) {
        s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
        s[j] = t;
      }

      // The "g" method returns the next (count) outputs as one number.
      (me.g = function(count) {
        // Using instance members instead of closure state nearly doubles speed.
        var t, r = 0,
            i = me.i, j = me.j, s = me.S;
        while (count--) {
          t = s[i = mask & (i + 1)];
          r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
        }
        me.i = i; me.j = j;
        return r;
        // For robust unpredictability, the function call below automatically
        // discards an initial batch of values.  This is called RC4-drop[256].
        // See http://google.com/search?q=rsa+fluhrer+response&btnI
      })(width);
    }

    //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //
    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //
    function flatten(obj, depth) {
      var result = [], typ = (typeof obj), prop;
      if (depth && typ == 'object') {
        for (prop in obj) {
          try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
        }
      }
      return (result.length ? result : typ == 'string' ? obj : obj + '\0');
    }

    //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //
    function mixkey(seed, key) {
      var stringseed = seed + '', smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] =
          mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
      }
      return tostring(key);
    }

    //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          // The use of 'out' to remember randomBytes makes tight minified code.
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global.crypto || global.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e) {
        var browser = global.navigator,
            plugins = browser && browser.plugins;
        return [+new Date, global, plugins, global.screen, tostring(pool)];
      }
    }

    //
    // tostring()
    // Converts an array of charcodes to a string
    //
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }

    //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //
    mixkey(math.random(), pool);

    //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //
    if (module.exports) {
      module.exports = seedrandom;
      // When in node.js, try using crypto package for autoseeding.
      try {
        nodecrypto = require$$0;
      } catch (ex) {}
    } else {
      // When included as a plain script, set up Math.seedrandom global.
      math['seed' + rngname] = seedrandom;
    }


    // End anonymous scope, and pass initial values.
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      (typeof self !== 'undefined') ? self : commonjsGlobal,
      [],     // pool: entropy pool starts empty
      Math    // math: package containing random, pow, and seedrandom
    );
    });

    // A library of seedable RNGs implemented in Javascript.
    //
    // Usage:
    //
    // var seedrandom = require('seedrandom');
    // var random = seedrandom(1); // or any seed.
    // var x = random();       // 0 <= x < 1.  Every bit is random.
    // var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

    // alea, a 53-bit multiply-with-carry generator by Johannes Baage.
    // Period: ~2^116
    // Reported to pass all BigCrush tests.


    // xor128, a pure xor-shift generator by George Marsaglia.
    // Period: 2^128-1.
    // Reported to fail: MatrixRank and LinearComp.


    // xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
    // Period: 2^192-2^32
    // Reported to fail: CollisionOver, SimpPoker, and LinearComp.


    // xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
    // a different approach: it adds robustness by allowing more shifts
    // than Marsaglia's original three.  It is a 7-shift generator
    // with 256 bits, that passes BigCrush with no systmatic failures.
    // Period 2^256-1.
    // No systematic BigCrush failures reported.


    // xor4096, by Richard Brent, is a 4096-bit xor-shift with a
    // very long period that also adds a Weyl generator. It also passes
    // BigCrush with no systematic failures.  Its long period may
    // be useful if you have many generators and need to avoid
    // collisions.
    // Period: 2^4128-2^32.
    // No systematic BigCrush failures reported.


    // Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
    // number generator derived from ChaCha, a modern stream cipher.
    // https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
    // Period: ~2^127
    // No systematic BigCrush failures reported.


    // The original ARC4-based prng included in this library.
    // Period: ~2^1600


    seedrandom$1.alea = alea;
    seedrandom$1.xor128 = xor128;
    seedrandom$1.xorwow = xorwow;
    seedrandom$1.xorshift7 = xorshift7;
    seedrandom$1.xor4096 = xor4096;
    seedrandom$1.tychei = tychei;

    var seedrandom = seedrandom$1;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



    var _owLite2$b = _interopRequireDefault$c(owLite);



    var _rng2$1 = _interopRequireDefault$c(rng);

    function _interopRequireDefault$c(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var RNGFunction = function (_RNG) {
      _inherits(RNGFunction, _RNG);

      function RNGFunction(thunk, opts) {
        _classCallCheck(this, RNGFunction);

        var _this = _possibleConstructorReturn(this, (RNGFunction.__proto__ || Object.getPrototypeOf(RNGFunction)).call(this));

        _this.seed(thunk, opts);
        return _this;
      }

      _createClass(RNGFunction, [{
        key: 'next',
        value: function next() {
          return this._rng();
        }
      }, {
        key: 'seed',
        value: function seed(thunk) {
          (0, _owLite2$b.default)(thunk, _owLite2$b.default.function);
          this._rng = thunk;
        }
      }, {
        key: 'clone',
        value: function clone() {
          for (var _len = arguments.length, opts = Array(_len), _key = 0; _key < _len; _key++) {
            opts[_key] = arguments[_key];
          }

          return new (Function.prototype.bind.apply(RNGFunction, [null].concat([this._rng], opts)))();
        }
      }, {
        key: 'name',
        get: function get() {
          return 'function';
        }
      }]);

      return RNGFunction;
    }(_rng2$1.default);

    var _default$f = RNGFunction;


    var _function = /*#__PURE__*/Object.defineProperty({
    	default: _default$f
    }, '__esModule', {value: true});

    var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



    var _seedrandom2 = _interopRequireDefault$b(seedrandom);



    var _rng2 = _interopRequireDefault$b(rng);



    var _function2 = _interopRequireDefault$b(_function);

    function _interopRequireDefault$b(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    var _default$e = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _args$ = args[0],
          arg0 = _args$ === undefined ? 'default' : _args$,
          rest = args.slice(1);


      switch (typeof arg0 === 'undefined' ? 'undefined' : _typeof$1(arg0)) {
        case 'object':
          if (arg0 instanceof _rng2.default) {
            return arg0;
          }
          break;

        case 'function':
          return new _function2.default(arg0);

        case 'string':
        case 'number':
          return new _function2.default(_seedrandom2.default.apply(undefined, _toConsumableArray(rest)));
      }

      throw new Error('invalid RNG "' + arg0 + '"');
    };


    var rngFactory = /*#__PURE__*/Object.defineProperty({
    	default: _default$e
    }, '__esModule', {value: true});

    var _owLite2$a = _interopRequireDefault$a(owLite);

    function _interopRequireDefault$a(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$d = function (random, min, max) {
      if (max === undefined) {
        max = min === undefined ? 1 : min;
        min = 0;
      }

      (0, _owLite2$a.default)(min, _owLite2$a.default.number);
      (0, _owLite2$a.default)(max, _owLite2$a.default.number);

      return function () {
        return random.next() * (max - min) + min;
      };
    };


    var uniform$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$d
    }, '__esModule', {value: true});

    var _owLite2$9 = _interopRequireDefault$9(owLite);

    function _interopRequireDefault$9(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$c = function (random, min, max) {
      if (max === undefined) {
        max = min === undefined ? 1 : min;
        min = 0;
      }

      (0, _owLite2$9.default)(min, _owLite2$9.default.number.integer);
      (0, _owLite2$9.default)(max, _owLite2$9.default.number.integer);

      return function () {
        return random.next() * (max - min + 1) + min | 0;
      };
    };


    var uniformInt = /*#__PURE__*/Object.defineProperty({
    	default: _default$c
    }, '__esModule', {value: true});

    var _default$b = function (random) {
      return function () {
        return random.next() >= 0.5;
      };
    };


    var uniformBoolean = /*#__PURE__*/Object.defineProperty({
    	default: _default$b
    }, '__esModule', {value: true});

    var _owLite2$8 = _interopRequireDefault$8(owLite);

    function _interopRequireDefault$8(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$a = function (random) {
      var mu = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var sigma = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      (0, _owLite2$8.default)(mu, _owLite2$8.default.number);
      (0, _owLite2$8.default)(sigma, _owLite2$8.default.number);

      return function () {
        var x = void 0,
            y = void 0,
            r = void 0;

        do {
          x = random.next() * 2 - 1;
          y = random.next() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);

        return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
      };
    };


    var normal$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$a
    }, '__esModule', {value: true});

    var _default$9 = function (random) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var normal = random.normal.apply(random, args);

      return function () {
        return Math.exp(normal());
      };
    };


    var logNormal$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$9
    }, '__esModule', {value: true});

    var _owLite2$7 = _interopRequireDefault$7(owLite);

    function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$8 = function (random) {
      var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

      (0, _owLite2$7.default)(p, _owLite2$7.default.number.gte(0).lt(1));

      return function () {
        return random.next() + p | 0;
      };
    };


    var bernoulli$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$8
    }, '__esModule', {value: true});

    var _owLite2$6 = _interopRequireDefault$6(owLite);

    function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$7 = function (random) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;

      (0, _owLite2$6.default)(n, _owLite2$6.default.number.positive.integer);
      (0, _owLite2$6.default)(p, _owLite2$6.default.number.gte(0).lte(1));

      return function () {
        var i = 0;
        var x = 0;

        while (i++ < n) {
          x += random.next() < p;
        }

        return x;
      };
    };


    var binomial$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$7
    }, '__esModule', {value: true});

    var _owLite2$5 = _interopRequireDefault$5(owLite);

    function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$6 = function (random) {
      var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

      (0, _owLite2$5.default)(p, _owLite2$5.default.number.gt(0).lte(1));
      var invLogP = 1.0 / Math.log(1.0 - p);

      return function () {
        return 1 + Math.log(random.next()) * invLogP | 0;
      };
    };


    var geometric$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$6
    }, '__esModule', {value: true});

    var _owLite2$4 = _interopRequireDefault$4(owLite);

    function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var logFactorialTable = [0.0, 0.0, 0.69314718055994529, 1.7917594692280550, 3.1780538303479458, 4.7874917427820458, 6.5792512120101012, 8.5251613610654147, 10.604602902745251, 12.801827480081469];

    var logFactorial = function logFactorial(k) {
      return logFactorialTable[k];
    };

    var logSqrt2PI = 0.91893853320467267;

    var _default$5 = function (random) {
      var lambda = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$4.default)(lambda, _owLite2$4.default.number.positive);

      if (lambda < 10) {
        // inversion method
        var expMean = Math.exp(-lambda);

        return function () {
          var p = expMean;
          var x = 0;
          var u = random.next();

          while (u > p) {
            u = u - p;
            p = lambda * p / ++x;
          }

          return x;
        };
      } else {
        // generative method
        var smu = Math.sqrt(lambda);
        var b = 0.931 + 2.53 * smu;
        var a = -0.059 + 0.02483 * b;
        var invAlpha = 1.1239 + 1.1328 / (b - 3.4);
        var vR = 0.9277 - 3.6224 / (b - 2);

        return function () {
          while (true) {
            var u = void 0;
            var v = random.next();

            if (v <= 0.86 * vR) {
              u = v / vR - 0.43;
              return Math.floor((2 * a / (0.5 - Math.abs(u)) + b) * u + lambda + 0.445);
            }

            if (v >= vR) {
              u = random.next() - 0.5;
            } else {
              u = v / vR - 0.93;
              u = (u < 0 ? -0.5 : 0.5) - u;
              v = random.next() * vR;
            }

            var us = 0.5 - Math.abs(u);
            if (us < 0.013 && v > us) {
              continue;
            }

            var k = Math.floor((2 * a / us + b) * u + lambda + 0.445) | 0;
            v = v * invAlpha / (a / (us * us) + b);

            if (k >= 10) {
              var t = (k + 0.5) * Math.log(lambda / k) - lambda - logSqrt2PI + k - (1 / 12.0 - (1 / 360.0 - 1 / (1260.0 * k * k)) / (k * k)) / k;

              if (Math.log(v * smu) <= t) {
                return k;
              }
            } else if (k >= 0) {
              if (Math.log(v) <= k * Math.log(lambda) - lambda - logFactorial(k)) {
                return k;
              }
            }
          }
        };
      }
    };


    var poisson$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$5
    }, '__esModule', {value: true});

    var _owLite2$3 = _interopRequireDefault$3(owLite);

    function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$4 = function (random) {
      var lambda = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$3.default)(lambda, _owLite2$3.default.number.positive);

      return function () {
        return -Math.log(1 - random.next()) / lambda;
      };
    };


    var exponential$2 = /*#__PURE__*/Object.defineProperty({
    	default: _default$4
    }, '__esModule', {value: true});

    var _owLite2$2 = _interopRequireDefault$2(owLite);

    function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$3 = function (random) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$2.default)(n, _owLite2$2.default.number.integer.gte(0));

      return function () {
        var sum = 0;
        for (var i = 0; i < n; ++i) {
          sum += random.next();
        }

        return sum;
      };
    };


    var irwinHall$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$3
    }, '__esModule', {value: true});

    var _owLite2$1 = _interopRequireDefault$1(owLite);

    function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$2 = function (random) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2$1.default)(n, _owLite2$1.default.number.integer.positive);
      var irwinHall = random.irwinHall(n);

      return function () {
        return irwinHall() / n;
      };
    };


    var bates$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$2
    }, '__esModule', {value: true});

    var _owLite2 = _interopRequireDefault(owLite);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var _default$1 = function (random) {
      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      (0, _owLite2.default)(alpha, _owLite2.default.number.gte(0));
      var invAlpha = 1.0 / alpha;

      return function () {
        return 1.0 / Math.pow(1.0 - random.next(), invAlpha);
      };
    };


    var pareto$1 = /*#__PURE__*/Object.defineProperty({
    	default: _default$1
    }, '__esModule', {value: true});

    var random$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RNGFactory = exports.RNG = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



    var _owLite2 = _interopRequireDefault(owLite);



    var _rng2 = _interopRequireDefault(rng);



    var _rngFactory2 = _interopRequireDefault(rngFactory);



    var _uniform3 = _interopRequireDefault(uniform$1);



    var _uniformInt3 = _interopRequireDefault(uniformInt);



    var _uniformBoolean3 = _interopRequireDefault(uniformBoolean);



    var _normal3 = _interopRequireDefault(normal$1);



    var _logNormal3 = _interopRequireDefault(logNormal$1);



    var _bernoulli3 = _interopRequireDefault(bernoulli$1);



    var _binomial3 = _interopRequireDefault(binomial$1);



    var _geometric3 = _interopRequireDefault(geometric$1);



    var _poisson3 = _interopRequireDefault(poisson$1);



    var _exponential3 = _interopRequireDefault(exponential$2);



    var _irwinHall3 = _interopRequireDefault(irwinHall$1);



    var _bates3 = _interopRequireDefault(bates$1);



    var _pareto3 = _interopRequireDefault(pareto$1);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    exports.RNG = _rng2.default;
    exports.RNGFactory = _rngFactory2.default;

    /**
     * Seedable random number generator supporting many common distributions.
     *
     * Defaults to Math.random as its underlying pseudorandom number generator.
     *
     * @name Random
     * @class
     *
     * @param {RNG|function} [rng=Math.random] - Underlying pseudorandom number generator.
     */

    var Random = function () {
      function Random(rng) {
        _classCallCheck(this, Random);

        if (rng) (0, _owLite2.default)(rng, _owLite2.default.object.instanceOf(_rng2.default));

        this._cache = {};
        this.use(rng);
      }

      /**
       * @member {RNG} Underlying pseudo-random number generator
       */


      _createClass(Random, [{
        key: 'clone',


        /**
         * Creates a new `Random` instance, optionally specifying parameters to
         * set a new seed.
         *
         * @see RNG.clone
         *
         * @param {string} [seed] - Optional seed for new RNG.
         * @param {object} [opts] - Optional config for new RNG options.
         * @return {Random}
         */
        value: function clone() {
          if (arguments.length) {
            return new Random(_rngFactory2.default.apply(undefined, arguments));
          } else {
            return new Random(this.rng.clone());
          }
        }

        /**
         * Sets the underlying pseudorandom number generator used via
         * either an instance of `seedrandom`, a custom instance of RNG
         * (for PRNG plugins), or a string specifying the PRNG to use
         * along with an optional `seed` and `opts` to initialize the
         * RNG.
         *
         * @example
         * const random = require('random')
         *
         * random.use('example_seedrandom_string')
         * // or
         * random.use(seedrandom('kittens'))
         * // or
         * random.use(Math.random)
         *
         * @param {...*} args
         */

      }, {
        key: 'use',
        value: function use() {
          this._rng = _rngFactory2.default.apply(undefined, arguments);
        }

        /**
         * Patches `Math.random` with this Random instance's PRNG.
         */

      }, {
        key: 'patch',
        value: function patch() {
          if (this._patch) {
            throw new Error('Math.random already patched');
          }

          this._patch = Math.random;
          Math.random = this.uniform();
        }

        /**
         * Restores a previously patched `Math.random` to its original value.
         */

      }, {
        key: 'unpatch',
        value: function unpatch() {
          if (this._patch) {
            Math.random = this._patch;
            delete this._patch;
          }
        }

        // --------------------------------------------------------------------------
        // Uniform utility functions
        // --------------------------------------------------------------------------

        /**
         * Convenience wrapper around `this.rng.next()`
         *
         * Returns a floating point number in [0, 1).
         *
         * @return {number}
         */

      }, {
        key: 'next',
        value: function next() {
          return this._rng.next();
        }

        /**
         * Samples a uniform random floating point number, optionally specifying
         * lower and upper bounds.
         *
         * Convence wrapper around `random.uniform()`
         *
         * @param {number} [min=0] - Lower bound (float, inclusive)
         * @param {number} [max=1] - Upper bound (float, exclusive)
         * @return {number}
         */

      }, {
        key: 'float',
        value: function float(min, max) {
          return this.uniform(min, max)();
        }

        /**
         * Samples a uniform random integer, optionally specifying lower and upper
         * bounds.
         *
         * Convence wrapper around `random.uniformInt()`
         *
         * @param {number} [min=0] - Lower bound (integer, inclusive)
         * @param {number} [max=1] - Upper bound (integer, inclusive)
         * @return {number}
         */

      }, {
        key: 'int',
        value: function int(min, max) {
          return this.uniformInt(min, max)();
        }

        /**
         * Samples a uniform random integer, optionally specifying lower and upper
         * bounds.
         *
         * Convence wrapper around `random.uniformInt()`
         *
         * @alias `random.int`
         *
         * @param {number} [min=0] - Lower bound (integer, inclusive)
         * @param {number} [max=1] - Upper bound (integer, inclusive)
         * @return {number}
         */

      }, {
        key: 'integer',
        value: function integer(min, max) {
          return this.uniformInt(min, max)();
        }

        /**
         * Samples a uniform random boolean value.
         *
         * Convence wrapper around `random.uniformBoolean()`
         *
         * @alias `random.boolean`
         *
         * @return {boolean}
         */

      }, {
        key: 'bool',
        value: function bool() {
          return this.uniformBoolean()();
        }

        /**
         * Samples a uniform random boolean value.
         *
         * Convence wrapper around `random.uniformBoolean()`
         *
         * @return {boolean}
         */

      }, {
        key: 'boolean',
        value: function boolean() {
          return this.uniformBoolean()();
        }

        // --------------------------------------------------------------------------
        // Uniform distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Continuous uniform distribution](https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)).
         *
         * @param {number} [min=0] - Lower bound (float, inclusive)
         * @param {number} [max=1] - Upper bound (float, exclusive)
         * @return {function}
         */

      }, {
        key: 'uniform',
        value: function uniform(min, max) {
          return this._memoize('uniform', _uniform3.default, min, max);
        }

        /**
         * Generates a [Discrete uniform distribution](https://en.wikipedia.org/wiki/Discrete_uniform_distribution).
         *
         * @param {number} [min=0] - Lower bound (integer, inclusive)
         * @param {number} [max=1] - Upper bound (integer, inclusive)
         * @return {function}
         */

      }, {
        key: 'uniformInt',
        value: function uniformInt(min, max) {
          return this._memoize('uniformInt', _uniformInt3.default, min, max);
        }

        /**
         * Generates a [Discrete uniform distribution](https://en.wikipedia.org/wiki/Discrete_uniform_distribution),
         * with two possible outcomes, `true` or `false.
         *
         * This method is analogous to flipping a coin.
         *
         * @return {function}
         */

      }, {
        key: 'uniformBoolean',
        value: function uniformBoolean() {
          return this._memoize('uniformBoolean', _uniformBoolean3.default);
        }

        // --------------------------------------------------------------------------
        // Normal distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Normal distribution](https://en.wikipedia.org/wiki/Normal_distribution).
         *
         * @param {number} [mu=0] - Mean
         * @param {number} [sigma=1] - Standard deviation
         * @return {function}
         */

      }, {
        key: 'normal',
        value: function normal(mu, sigma) {
          return (0, _normal3.default)(this, mu, sigma);
        }

        /**
         * Generates a [Log-normal distribution](https://en.wikipedia.org/wiki/Log-normal_distribution).
         *
         * @param {number} [mu=0] - Mean of underlying normal distribution
         * @param {number} [sigma=1] - Standard deviation of underlying normal distribution
         * @return {function}
         */

      }, {
        key: 'logNormal',
        value: function logNormal(mu, sigma) {
          return (0, _logNormal3.default)(this, mu, sigma);
        }

        // --------------------------------------------------------------------------
        // Bernoulli distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution).
         *
         * @param {number} [p=0.5] - Success probability of each trial.
         * @return {function}
         */

      }, {
        key: 'bernoulli',
        value: function bernoulli(p) {
          return (0, _bernoulli3.default)(this, p);
        }

        /**
         * Generates a [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution).
         *
         * @param {number} [n=1] - Number of trials.
         * @param {number} [p=0.5] - Success probability of each trial.
         * @return {function}
         */

      }, {
        key: 'binomial',
        value: function binomial(n, p) {
          return (0, _binomial3.default)(this, n, p);
        }

        /**
         * Generates a [Geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution).
         *
         * @param {number} [p=0.5] - Success probability of each trial.
         * @return {function}
         */

      }, {
        key: 'geometric',
        value: function geometric(p) {
          return (0, _geometric3.default)(this, p);
        }

        // --------------------------------------------------------------------------
        // Poisson distributions
        // --------------------------------------------------------------------------

        /**
         * Generates a [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution).
         *
         * @param {number} [lambda=1] - Mean (lambda > 0)
         * @return {function}
         */

      }, {
        key: 'poisson',
        value: function poisson(lambda) {
          return (0, _poisson3.default)(this, lambda);
        }

        /**
         * Generates an [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution).
         *
         * @param {number} [lambda=1] - Inverse mean (lambda > 0)
         * @return {function}
         */

      }, {
        key: 'exponential',
        value: function exponential(lambda) {
          return (0, _exponential3.default)(this, lambda);
        }

        // --------------------------------------------------------------------------
        // Misc distributions
        // --------------------------------------------------------------------------

        /**
         * Generates an [Irwin Hall distribution](https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution).
         *
         * @param {number} [n=1] - Number of uniform samples to sum (n >= 0)
         * @return {function}
         */

      }, {
        key: 'irwinHall',
        value: function irwinHall(n) {
          return (0, _irwinHall3.default)(this, n);
        }

        /**
         * Generates a [Bates distribution](https://en.wikipedia.org/wiki/Bates_distribution).
         *
         * @param {number} [n=1] - Number of uniform samples to average (n >= 1)
         * @return {function}
         */

      }, {
        key: 'bates',
        value: function bates(n) {
          return (0, _bates3.default)(this, n);
        }

        /**
         * Generates a [Pareto distribution](https://en.wikipedia.org/wiki/Pareto_distribution).
         *
         * @param {number} [alpha=1] - Alpha
         * @return {function}
         */

      }, {
        key: 'pareto',
        value: function pareto(alpha) {
          return (0, _pareto3.default)(this, alpha);
        }

        // --------------------------------------------------------------------------
        // Internal
        // --------------------------------------------------------------------------

        /**
         * Memoizes distributions to ensure they're only created when necessary.
         *
         * Returns a thunk which that returns independent, identically distributed
         * samples from the specified distribution.
         *
         * @private
         *
         * @param {string} label - Name of distribution
         * @param {function} getter - Function which generates a new distribution
         * @param {...*} args - Distribution-specific arguments
         *
         * @return {function}
         */

      }, {
        key: '_memoize',
        value: function _memoize(label, getter) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          var key = '' + args.join(';');
          var value = this._cache[label];

          if (value === undefined || value.key !== key) {
            value = { key: key, distribution: getter.apply(undefined, [this].concat(args)) };
            this._cache[label] = value;
          }

          return value.distribution;
        }
      }, {
        key: 'rng',
        get: function get() {
          return this._rng;
        }
      }]);

      return Random;
    }();

    // defaults to Math.random as its RNG


    exports.default = new Random();

    });

    var random = random$1.default;

    class Gaussian {
      constructor(mean, cov) {
        // TODO: Consider saving the dimension
        if ((mean instanceof Matrix) && (cov instanceof Matrix)) {
          this.mean = mean;
          this.cov = cov;
        } else {
          this.mean = new Matrix([mean]).transpose();
          this.cov = new Matrix(cov);
        }
      }

      at(x) {
        const diff = (new Matrix([x])).transpose().sub(this.mean);
        const n = diff.transpose().mmul(inverse(this.cov)).mmul(diff).mul(-0.5).exp();
        const d = Math.sqrt(Math.pow(2*Math.PI, this.mean.rows)*this.cov.det());
        return (n * (1 / d));
      }

      // idx is the first row of b
      marginalize(idx) {
        // FIXME: Rewrite with Array.slice() for speed
        const aMean = sliceMat(this.mean,0,0,idx,1);
        const bMean = sliceMat(this.mean,idx,0,this.mean.rows,1);
        const aCov = sliceMat(this.cov,0,0,idx,idx);
        const bCov = sliceMat(this.cov,idx,idx,this.mean.rows,this.mean.rows);
        return [new Gaussian(aMean, aCov), new Gaussian(bMean, bCov)];
      }

      // Also refer to: https://stats.stackexchange.com/questions/232959/simulating-the-posterior-of-a-gaussian-process
      // FIXME: Currently only works with \mu_e = 0
      condition(X) {
        const idx = X.length;
        const x0 = new Matrix([X]).transpose();
        const Exx = sliceMat(this.cov,0,0,idx,idx);
        const Exy = sliceMat(this.cov,0,idx,idx,this.mean.rows);
        const Eyx = Exy.transpose();
        const Eyy = sliceMat(this.cov,idx,idx,this.mean.rows,this.mean.rows);

        // Compute new zero
        const Lxx = new CholeskyDecomposition(Exx).lowerTriangularMatrix;
        const mLy = solve(Lxx, x0);
        const Lk = solve(Lxx, Exy);
        const condMean = Lk.transpose().mmul(mLy); // Hack

        // FIXME: Make this more performant (use cholesky and slove instead of inverse)
        const condCov = Eyy.sub(Eyx.mmul(inverse(Exx)).mmul(Exy));
        return new Gaussian(condMean, condCov);
      }

      // Uses Eigenvalue decomposition to compute t from Cov = tt^T
      transformationMatrix() {
        const e = new EigenvalueDecomposition(this.cov);
        const r = e.eigenvectorMatrix;
        const d = Matrix.zeros(r.rows, r.columns);
        for(let i = 0; i < d.rows; ++i) {
          d.set(i,i, Math.sqrt(e.realEigenvalues[i]));
        }
        return r.mmul(d);
      }

      sample() {
        const z = Matrix.zeros(this.mean.rows, 1);
        const normal = random.normal();
        for(let i = 0; i < this.mean.rows; ++i)
          z.set(i,0,normal());

        const samples = Matrix.add(this.mean, this.transformationMatrix().mmul(z));
        return samples;
      }

      getMean() {
        return this.mean.transpose()[0];
      }

      getSd() {
        return this.cov.diag().map(s2 => Math.sqrt(s2));
      }
    }

    // ranges from [i1,i2) & [j1,j2)
    function sliceMat(mat,i1,j1,i2,j2) {
      const result = new Matrix(i2-i1,j2-j1);
      for(let i = i1; i < i2; ++i) 
        for(let j = j1; j < j2; ++j) {
          result.set(i-i1, j-j1, mat.get(i,j)); 
        }
      return result;
    }

    class RBFKernel {
      constructor() {
        this.g = new Gaussian([0], [[1]]);
        this.scale = 1.0 / this.g.at([0]);
      }

      call(x1, x2) {
        return this.g.at([x1 - x2]) * this.scale;
      }

      // find +x solving call(0, x) = y
      inv0(y) {
        var sigma2 = this.get_sigma2();
        var ys = y / this.scale;
        const sspi = Math.sqrt(sigma2 * 2.0 * Math.PI);
        const dssq = -2.0 * sigma2; 
        var x = Math.sqrt(dssq * Math.log(ys * sspi));
        return x;
      }

      set_sigma(sigma) {
        this.g = new Gaussian([0], [[sigma * sigma]]);
        this.scale = 1.0 / this.g.at([0]);
      }

      get_sigma2() {
        return this.g.cov[0][0];
      }

      cuts(x, beg, end) {
        return [];
      }
    }

    class RBFShuffleKernel {
      constructor(cut_size) {
        this.g = new Gaussian([0], [[1]]);
        this.scale = 1.0 / this.g.at([0]);
        this.cut_size = cut_size;
      }

      call(x1, x2) {
        var c = this.cut_size;
        var d = Math.floor(x2 / c);
        var r = x2 - d * c;
        if (Math.abs(d % 2) == 1) 
          x2 += c - 2 * r;

        return this.g.at([x2 - x1]) * this.scale;
      }

      set_sigma(sigma) {
        this.g = new Gaussian([0], [[sigma * sigma]]);
        this.scale = 1.0 / this.g.at([0]);
      }

      get_sigma2() {
        return this.g.cov[0][0];
      }

      // return a list of points of discontinuity in [beg, end] for the
      // representer function of x
      cuts(x, beg, end) {
        var s = beg; 
        var p = [];
        while (s < end) {
          p.push(s);
          s += this.cut_size;
        }
        return p;
      }
    }

    function ascending$3(a, b) {
      return a == null || b == null ? NaN
        : a < b ? -1
        : a > b ? 1
        : a >= b ? 0
        : NaN;
    }

    function bisector(f) {
      let delta = f;
      let compare = f;

      if (f.length === 1) {
        delta = (d, x) => f(d) - x;
        compare = ascendingComparator(f);
      }

      function left(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          const mid = (lo + hi) >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        }
        return lo;
      }

      function right(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          const mid = (lo + hi) >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;
          else lo = mid + 1;
        }
        return lo;
      }

      function center(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {left, center, right};
    }

    function ascendingComparator(f) {
      return (d, x) => ascending$3(f(d), x);
    }

    function number$3(x) {
      return x === null ? NaN : +x;
    }

    function* numbers(values, valueof) {
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            yield value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            yield value;
          }
        }
      }
    }

    const ascendingBisect = bisector(ascending$3);
    const bisectRight = ascendingBisect.right;
    const bisectLeft = ascendingBisect.left;
    const bisectCenter = bisector(number$3).center;

    function count$1(values, valueof) {
      let count = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count;
          }
        }
      }
      return count;
    }

    function length$3(array) {
      return array.length | 0;
    }

    function empty$2(length) {
      return !(length > 0);
    }

    function arrayify(values) {
      return typeof values !== "object" || "length" in values ? values : Array.from(values);
    }

    function reducer(reduce) {
      return values => reduce(...values);
    }

    function cross$2(...values) {
      const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
      values = values.map(arrayify);
      const lengths = values.map(length$3);
      const j = values.length - 1;
      const index = new Array(j + 1).fill(0);
      const product = [];
      if (j < 0 || lengths.some(empty$2)) return product;
      while (true) {
        product.push(index.map((j, i) => values[i][j]));
        let i = j;
        while (++index[i] === lengths[i]) {
          if (i === 0) return reduce ? product.map(reduce) : product;
          index[i--] = 0;
        }
      }
    }

    function cumsum(values, valueof) {
      var sum = 0, index = 0;
      return Float64Array.from(values, valueof === undefined
        ? v => (sum += +v || 0)
        : v => (sum += +valueof(v, index++, values) || 0));
    }

    function descending$2(a, b) {
      return a == null || b == null ? NaN
        : b < a ? -1
        : b > a ? 1
        : b >= a ? 0
        : NaN;
    }

    function variance(values, valueof) {
      let count = 0;
      let delta;
      let mean = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      }
      if (count > 1) return sum / (count - 1);
    }

    function deviation(values, valueof) {
      const v = variance(values, valueof);
      return v ? Math.sqrt(v) : v;
    }

    function extent$1(values, valueof) {
      let min;
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
      return [min, max];
    }

    // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
    class Adder {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
          if (lo) p[i++] = lo;
          x = hi;
        }
        p[i] = x;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x, y, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x = hi;
            y = p[--n];
            hi = x + y;
            lo = y - (hi - x);
            if (lo) break;
          }
          if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
            y = lo * 2;
            x = hi + y;
            if (y == x - hi) hi = x;
          }
        }
        return hi;
      }
    }

    function fsum(values, valueof) {
      const adder = new Adder();
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            adder.add(value);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            adder.add(value);
          }
        }
      }
      return +adder;
    }

    function fcumsum(values, valueof) {
      const adder = new Adder();
      let index = -1;
      return Float64Array.from(values, valueof === undefined
          ? v => adder.add(+v || 0)
          : v => adder.add(+valueof(v, ++index, values) || 0)
      );
    }

    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (entries != null) for (const [key, value] of entries) this.set(key, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }

    class InternSet extends Set {
      constructor(values, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (values != null) for (const value of values) this.add(value);
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    }

    function intern_get({_intern, _key}, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }

    function intern_set({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }

    function intern_delete({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(value);
        _intern.delete(key);
      }
      return value;
    }

    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function identity$9(x) {
      return x;
    }

    function group(values, ...keys) {
      return nest(values, identity$9, identity$9, keys);
    }

    function groups(values, ...keys) {
      return nest(values, Array.from, identity$9, keys);
    }

    function flatten$1(groups, keys) {
      for (let i = 1, n = keys.length; i < n; ++i) {
        groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));
      }
      return groups;
    }

    function flatGroup(values, ...keys) {
      return flatten$1(groups(values, ...keys), keys);
    }

    function flatRollup(values, reduce, ...keys) {
      return flatten$1(rollups(values, reduce, ...keys), keys);
    }

    function rollup(values, reduce, ...keys) {
      return nest(values, identity$9, reduce, keys);
    }

    function rollups(values, reduce, ...keys) {
      return nest(values, Array.from, reduce, keys);
    }

    function index$4(values, ...keys) {
      return nest(values, identity$9, unique, keys);
    }

    function indexes(values, ...keys) {
      return nest(values, Array.from, unique, keys);
    }

    function unique(values) {
      if (values.length !== 1) throw new Error("duplicate key");
      return values[0];
    }

    function nest(values, map, reduce, keys) {
      return (function regroup(values, i) {
        if (i >= keys.length) return reduce(values);
        const groups = new InternMap();
        const keyof = keys[i++];
        let index = -1;
        for (const value of values) {
          const key = keyof(value, ++index, values);
          const group = groups.get(key);
          if (group) group.push(value);
          else groups.set(key, [value]);
        }
        for (const [key, values] of groups) {
          groups.set(key, regroup(values, i));
        }
        return map(groups);
      })(values, 0);
    }

    function permute(source, keys) {
      return Array.from(keys, key => source[key]);
    }

    function sort(values, ...F) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      values = Array.from(values);
      let [f = ascending$3] = F;
      if (f.length === 1 || F.length > 1) {
        const index = Uint32Array.from(values, (d, i) => i);
        if (F.length > 1) {
          F = F.map(f => values.map(f));
          index.sort((i, j) => {
            for (const f of F) {
              const c = ascending$3(f[i], f[j]);
              if (c) return c;
            }
          });
        } else {
          f = values.map(f);
          index.sort((i, j) => ascending$3(f[i], f[j]));
        }
        return permute(values, index);
      }
      return values.sort(f);
    }

    function groupSort(values, reduce, key) {
      return (reduce.length === 1
        ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending$3(av, bv) || ascending$3(ak, bk)))
        : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending$3(ak, bk))))
        .map(([key]) => key);
    }

    var array$5 = Array.prototype;

    var slice$3 = array$5.slice;

    function constant$b(x) {
      return function() {
        return x;
      };
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        let r0 = Math.round(start / step), r1 = Math.round(stop / step);
        if (r0 * step < start) ++r0;
        if (r1 * step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.round(start * step), r1 = Math.round(stop * step);
        if (r0 / step < start) ++r0;
        if (r1 / step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function nice$1(start, stop, count) {
      let prestep;
      while (true) {
        const step = tickIncrement(start, stop, count);
        if (step === prestep || step === 0 || !isFinite(step)) {
          return [start, stop];
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        }
        prestep = step;
      }
    }

    function thresholdSturges(values) {
      return Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1;
    }

    function bin() {
      var value = identity$9,
          domain = extent$1,
          threshold = thresholdSturges;

      function histogram(data) {
        if (!Array.isArray(data)) data = Array.from(data);

        var i,
            n = data.length,
            x,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds, and nice the
        // default domain accordingly.
        if (!Array.isArray(tz)) {
          const max = x1, tn = +tz;
          if (domain === extent$1) [x0, x1] = nice$1(x0, x1, tn);
          tz = ticks(x0, x1, tn);

          // If the last threshold is coincident with the domains upper bound, the
          // last bin will be zero-width. If the default domain is used, and this
          // last threshold is coincident with the maximum input value, we can
          // extend the niced upper bound by one tick to ensure uniform bin widths;
          // otherwise, we simply remove the last threshold. Note that we dont
          // coerce values or the domain to numbers, and thus must be careful to
          // compare order (>=) rather than strict equality (===)!
          if (tz[tz.length - 1] >= x1) {
            if (max >= x1 && domain === extent$1) {
              const step = tickIncrement(x0, x1, tn);
              if (isFinite(step)) {
                if (step > 0) {
                  x1 = (Math.floor(x1 / step) + 1) * step;
                } else if (step < 0) {
                  x1 = (Math.ceil(x1 * -step) + 1) / -step;
                }
              }
            } else {
              tz.pop();
            }
          }
        }

        // Remove any thresholds outside the domain.
        var m = tz.length;
        while (tz[0] <= x0) tz.shift(), --m;
        while (tz[m - 1] > x1) tz.pop(), --m;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        for (i = 0; i < n; ++i) {
          x = values[i];
          if (x != null && x0 <= x && x <= x1) {
            bins[bisectRight(tz, x, 0, m)].push(data[i]);
          }
        }

        return bins;
      }

      histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$b(_), histogram) : value;
      };

      histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant$b([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$b(slice$3.call(_)) : constant$b(_), histogram) : threshold;
      };

      return histogram;
    }

    function max$3(values, valueof) {
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      }
      return max;
    }

    function min$2(values, valueof) {
      let min;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      }
      return min;
    }

    // Based on https://github.com/mourner/quickselect
    // ISC license, Copyright 2018 Vladimir Agafonkin.
    function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending$3) {
      while (right > left) {
        if (right - left > 600) {
          const n = right - left + 1;
          const m = k - left + 1;
          const z = Math.log(n);
          const s = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
          const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
          quickselect(array, k, newLeft, newRight, compare);
        }

        const t = array[k];
        let i = left;
        let j = right;

        swap$1(array, left, k);
        if (compare(array[right], t) > 0) swap$1(array, left, right);

        while (i < j) {
          swap$1(array, i, j), ++i, --j;
          while (compare(array[i], t) < 0) ++i;
          while (compare(array[j], t) > 0) --j;
        }

        if (compare(array[left], t) === 0) swap$1(array, left, j);
        else ++j, swap$1(array, j, right);

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
      }
      return array;
    }

    function swap$1(array, i, j) {
      const t = array[i];
      array[i] = array[j];
      array[j] = t;
    }

    function quantile$1(values, p, valueof) {
      values = Float64Array.from(numbers(values, valueof));
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return min$2(values);
      if (p >= 1) return max$3(values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = max$3(quickselect(values, i0).subarray(0, i0 + 1)),
          value1 = min$2(values.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileSorted(values, p, valueof = number$3) {
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
      if (p >= 1) return +valueof(values[n - 1], n - 1, values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    }

    function freedmanDiaconis(values, min, max) {
      return Math.ceil((max - min) / (2 * (quantile$1(values, 0.75) - quantile$1(values, 0.25)) * Math.pow(count$1(values), -1 / 3)));
    }

    function scott(values, min, max) {
      return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(count$1(values), -1 / 3)));
    }

    function maxIndex(values, valueof) {
      let max;
      let maxIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      }
      return maxIndex;
    }

    function mean(values, valueof) {
      let count = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      }
      if (count) return sum / count;
    }

    function median(values, valueof) {
      return quantile$1(values, 0.5, valueof);
    }

    function* flatten(arrays) {
      for (const array of arrays) {
        yield* array;
      }
    }

    function merge(arrays) {
      return Array.from(flatten(arrays));
    }

    function minIndex(values, valueof) {
      let min;
      let minIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      }
      return minIndex;
    }

    function mode(values, valueof) {
      const counts = new InternMap();
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      }
      let modeValue;
      let modeCount = 0;
      for (const [value, count] of counts) {
        if (count > modeCount) {
          modeCount = count;
          modeValue = value;
        }
      }
      return modeValue;
    }

    function pairs(values, pairof = pair) {
      const pairs = [];
      let previous;
      let first = false;
      for (const value of values) {
        if (first) pairs.push(pairof(previous, value));
        previous = value;
        first = true;
      }
      return pairs;
    }

    function pair(a, b) {
      return [a, b];
    }

    function range$3(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    function least(values, compare = ascending$3) {
      let min;
      let defined = false;
      if (compare.length === 1) {
        let minValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, minValue) < 0
              : ascending$3(value, value) === 0) {
            min = element;
            minValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, min) < 0
              : compare(value, value) === 0) {
            min = value;
            defined = true;
          }
        }
      }
      return min;
    }

    function leastIndex(values, compare = ascending$3) {
      if (compare.length === 1) return minIndex(values, compare);
      let minValue;
      let min = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (min < 0
            ? compare(value, value) === 0
            : compare(value, minValue) < 0) {
          minValue = value;
          min = index;
        }
      }
      return min;
    }

    function greatest(values, compare = ascending$3) {
      let max;
      let defined = false;
      if (compare.length === 1) {
        let maxValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, maxValue) > 0
              : ascending$3(value, value) === 0) {
            max = element;
            maxValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, max) > 0
              : compare(value, value) === 0) {
            max = value;
            defined = true;
          }
        }
      }
      return max;
    }

    function greatestIndex(values, compare = ascending$3) {
      if (compare.length === 1) return maxIndex(values, compare);
      let maxValue;
      let max = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (max < 0
            ? compare(value, value) === 0
            : compare(value, maxValue) > 0) {
          maxValue = value;
          max = index;
        }
      }
      return max;
    }

    function scan(values, compare) {
      const index = leastIndex(values, compare);
      return index < 0 ? undefined : index;
    }

    var shuffle$1 = shuffler(Math.random);

    function shuffler(random) {
      return function shuffle(array, i0 = 0, i1 = array.length) {
        let m = i1 - (i0 = +i0);
        while (m) {
          const i = random() * m-- | 0, t = array[m + i0];
          array[m + i0] = array[i + i0];
          array[i + i0] = t;
        }
        return array;
      };
    }

    function sum$2(values, valueof) {
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            sum += value;
          }
        }
      }
      return sum;
    }

    function transpose(matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min$2(matrix, length$2), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    }

    function length$2(d) {
      return d.length;
    }

    function zip() {
      return transpose(arguments);
    }

    function every(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (!test(value, ++index, values)) {
          return false;
        }
      }
      return true;
    }

    function some(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          return true;
        }
      }
      return false;
    }

    function filter$1(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      const array = [];
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          array.push(value);
        }
      }
      return array;
    }

    function map$1(values, mapper) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
      return Array.from(values, (value, index) => mapper(value, index, values));
    }

    function reduce(values, reducer, value) {
      if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
      const iterator = values[Symbol.iterator]();
      let done, next, index = -1;
      if (arguments.length < 3) {
        ({done, value} = iterator.next());
        if (done) return;
        ++index;
      }
      while (({done, value: next} = iterator.next()), !done) {
        value = reducer(value, next, ++index, values);
      }
      return value;
    }

    function reverse$1(values) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      return Array.from(values).reverse();
    }

    function difference(values, ...others) {
      values = new Set(values);
      for (const other of others) {
        for (const value of other) {
          values.delete(value);
        }
      }
      return values;
    }

    function disjoint(values, other) {
      const iterator = other[Symbol.iterator](), set = new Set();
      for (const v of values) {
        if (set.has(v)) return false;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) break;
          if (Object.is(v, value)) return false;
          set.add(value);
        }
      }
      return true;
    }

    function set$2(values) {
      return values instanceof Set ? values : new Set(values);
    }

    function intersection(values, ...others) {
      values = new Set(values);
      others = others.map(set$2);
      out: for (const value of values) {
        for (const other of others) {
          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      }
      return values;
    }

    function superset(values, other) {
      const iterator = values[Symbol.iterator](), set = new Set();
      for (const o of other) {
        if (set.has(o)) continue;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) return false;
          set.add(value);
          if (Object.is(o, value)) break;
        }
      }
      return true;
    }

    function subset(values, other) {
      return superset(other, values);
    }

    function union(...others) {
      const set = new Set();
      for (const other of others) {
        for (const o of other) {
          set.add(o);
        }
      }
      return set;
    }

    function identity$8(x) {
      return x;
    }

    var top = 1,
        right = 2,
        bottom = 3,
        left = 4,
        epsilon$6 = 1e-6;

    function translateX(x) {
      return "translate(" + x + ",0)";
    }

    function translateY(y) {
      return "translate(0," + y + ")";
    }

    function number$2(scale) {
      return d => +scale(d);
    }

    function center$1(scale, offset) {
      offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
      if (scale.round()) offset = Math.round(offset);
      return d => +scale(d) + offset;
    }

    function entering() {
      return !this.__axis;
    }

    function axis(orient, scale) {
      var tickArguments = [],
          tickValues = null,
          tickFormat = null,
          tickSizeInner = 6,
          tickSizeOuter = 6,
          tickPadding = 3,
          offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
          k = orient === top || orient === left ? -1 : 1,
          x = orient === left || orient === right ? "x" : "y",
          transform = orient === top || orient === bottom ? translateX : translateY;

      function axis(context) {
        var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
            format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8) : tickFormat,
            spacing = Math.max(tickSizeInner, 0) + tickPadding,
            range = scale.range(),
            range0 = +range[0] + offset,
            range1 = +range[range.length - 1] + offset,
            position = (scale.bandwidth ? center$1 : number$2)(scale.copy(), offset),
            selection = context.selection ? context.selection() : context,
            path = selection.selectAll(".domain").data([null]),
            tick = selection.selectAll(".tick").data(values, scale).order(),
            tickExit = tick.exit(),
            tickEnter = tick.enter().append("g").attr("class", "tick"),
            line = tick.select("line"),
            text = tick.select("text");

        path = path.merge(path.enter().insert("path", ".tick")
            .attr("class", "domain")
            .attr("stroke", "currentColor"));

        tick = tick.merge(tickEnter);

        line = line.merge(tickEnter.append("line")
            .attr("stroke", "currentColor")
            .attr(x + "2", k * tickSizeInner));

        text = text.merge(tickEnter.append("text")
            .attr("fill", "currentColor")
            .attr(x, k * spacing)
            .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

        if (context !== selection) {
          path = path.transition(context);
          tick = tick.transition(context);
          line = line.transition(context);
          text = text.transition(context);

          tickExit = tickExit.transition(context)
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

          tickEnter
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
        }

        tickExit.remove();

        path
            .attr("d", orient === left || orient === right
                ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
                : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

        tick
            .attr("opacity", 1)
            .attr("transform", function(d) { return transform(position(d) + offset); });

        line
            .attr(x + "2", k * tickSizeInner);

        text
            .attr(x, k * spacing)
            .text(format);

        selection.filter(entering)
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

        selection
            .each(function() { this.__axis = position; });
      }

      axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
      };

      axis.ticks = function() {
        return tickArguments = Array.from(arguments), axis;
      };

      axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
      };

      axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
      };

      axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
      };

      axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
      };

      axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
      };

      axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
      };

      axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
      };

      axis.offset = function(_) {
        return arguments.length ? (offset = +_, axis) : offset;
      };

      return axis;
    }

    function axisTop(scale) {
      return axis(top, scale);
    }

    function axisRight(scale) {
      return axis(right, scale);
    }

    function axisBottom(scale) {
      return axis(bottom, scale);
    }

    function axisLeft(scale) {
      return axis(left, scale);
    }

    var noop$4 = {value: () => {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames$1(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$1(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$4, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none$2() {}

    function selector(selector) {
      return selector == null ? none$2 : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we dont ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array$4(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty$1() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty$1 : function() {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function() {
        return array$4(select.apply(this, arguments));
      };
    }

    function selection_selectAll(select) {
      if (typeof select === "function") select = arrayAll(select);
      else select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function childMatcher(selector) {
      return function(node) {
        return node.matches(selector);
      };
    }

    var find$1 = Array.prototype.find;

    function childFind(match) {
      return function() {
        return find$1.call(this.children, match);
      };
    }

    function childFirst() {
      return this.firstElementChild;
    }

    function selection_selectChild(match) {
      return this.select(match == null ? childFirst
          : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter = Array.prototype.filter;

    function children() {
      return Array.from(this.children);
    }

    function childrenFilter(match) {
      return function() {
        return filter.call(this.children, match);
      };
    }

    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children
          : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$a(x) {
      return function() {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that dont fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = new Map,
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
          exit[i] = node;
        }
      }
    }

    function datum(node) {
      return node.__data__;
    }

    function selection_data(value, key) {
      if (!arguments.length) return Array.from(this, datum);

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$a(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isnt worried about live collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // dont; wed rather avoid a gratuitous copy.)
    function arraylike(data) {
      return typeof data === "object" && "length" in data
        ? data // Array, TypedArray, NodeList, array-like
        : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(context) {
      var selection = context.selection ? context.selection() : context;

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending$2;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending$2(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      return Array.from(this);
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      let size = 0;
      for (const node of this) ++size; // eslint-disable-line no-unused-vars
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }

    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, options) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root$1 = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root$1);
    }

    function selection_selection() {
      return this;
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root$1);
    }

    function create$1(name) {
      return select(creator(name).call(document.documentElement));
    }

    var nextId = 0;

    function local$1() {
      return new Local;
    }

    function Local() {
      this._ = "@" + (++nextId).toString(36);
    }

    Local.prototype = local$1.prototype = {
      constructor: Local,
      get: function(node) {
        var id = this._;
        while (!(id in node)) if (!(node = node.parentNode)) return;
        return node[id];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };

    function sourceEvent(event) {
      let sourceEvent;
      while (sourceEvent = event.sourceEvent) event = sourceEvent;
      return event;
    }

    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }

    function pointers(events, node) {
      if (events.target) { // i.e., instanceof Event, not TouchList or iterable
        events = sourceEvent(events);
        if (node === undefined) node = events.currentTarget;
        events = events.touches || [events];
      }
      return Array.from(events, event => pointer(event, node));
    }

    function selectAll(selector) {
      return typeof selector === "string"
          ? new Selection$1([document.querySelectorAll(selector)], [document.documentElement])
          : new Selection$1([array$4(selector)], root$1);
    }

    // These are typically used in conjunction with noevent to ensure that we can
    // preventDefault on the event.
    const nonpassive = {passive: false};
    const nonpassivecapture = {capture: true, passive: false};

    function nopropagation$2(event) {
      event.stopImmediatePropagation();
    }

    function noevent$2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable(view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent$2, nonpassivecapture);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$2, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent$2, nonpassivecapture);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var constant$9 = x => () => x;

    function DragEvent(type, {
      sourceEvent,
      subject,
      target,
      identifier,
      active,
      x, y, dx, dy,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        subject: {value: subject, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        identifier: {value: identifier, enumerable: true, configurable: true},
        active: {value: active, enumerable: true, configurable: true},
        x: {value: x, enumerable: true, configurable: true},
        y: {value: y, enumerable: true, configurable: true},
        dx: {value: dx, enumerable: true, configurable: true},
        dy: {value: dy, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$2(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(event, d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable$2() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
      var filter = defaultFilter$2,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable$2,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved, nonpassive)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned(event, d) {
        if (touchending || !filter.call(this, event, d)) return;
        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
        if (!gesture) return;
        select(event.view)
          .on("mousemove.drag", mousemoved, nonpassivecapture)
          .on("mouseup.drag", mouseupped, nonpassivecapture);
        dragDisable(event.view);
        nopropagation$2(event);
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start", event);
      }

      function mousemoved(event) {
        noevent$2(event);
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag", event);
      }

      function mouseupped(event) {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent$2(event);
        gestures.mouse("end", event);
      }

      function touchstarted(event, d) {
        if (!filter.call(this, event, d)) return;
        var touches = event.changedTouches,
            c = container.call(this, event, d),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
            nopropagation$2(event);
            gesture("start", event, touches[i]);
          }
        }
      }

      function touchmoved(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent$2(event);
            gesture("drag", event, touches[i]);
          }
        }
      }

      function touchended(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation$2(event);
            gesture("end", event, touches[i]);
          }
        }
      }

      function beforestart(that, container, event, d, identifier, touch) {
        var dispatch = listeners.copy(),
            p = pointer(touch || event, container), dx, dy,
            s;

        if ((s = subject.call(that, new DragEvent("beforestart", {
            sourceEvent: event,
            target: drag,
            identifier,
            active,
            x: p[0],
            y: p[1],
            dx: 0,
            dy: 0,
            dispatch
          }), d)) == null) return;

        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;

        return function gesture(type, event, touch) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[identifier] = gesture, n = active++; break;
            case "end": delete gestures[identifier], --active; // falls through
            case "drag": p = pointer(touch || event, container), n = active; break;
          }
          dispatch.call(
            type,
            that,
            new DragEvent(type, {
              sourceEvent: event,
              subject: s,
              target: drag,
              identifier,
              active: n,
              x: p[0] + dx,
              y: p[1] + dy,
              dx: p[0] - p0[0],
              dy: p[1] - p0[1],
              dispatch
            }),
            d
          );
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$9(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$9(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$9(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$9(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend$1(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color$1, {
      copy: function(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color$1(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color$1(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend$1(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color$1(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl$2(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl$2, extend$1(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    const radians$1 = Math.PI / 180;
    const degrees$2 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    const K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0$1 = 4 / 29,
        t1$1 = 6 / 29,
        t2 = 3 * t1$1 * t1$1,
        t3 = t1$1 * t1$1 * t1$1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function gray(l, opacity) {
      return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
    }

    function lab$1(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab$1, extend$1(Color, {
      brighter: function(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker: function(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb: function() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
    }

    function lab2xyz(t) {
      return t > t1$1 ? t * t * t : t2 * (t - t0$1);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * degrees$2;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function lch(l, c, h, opacity) {
      return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function hcl$2(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * radians$1;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl$2, extend$1(Color, {
      brighter: function(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker: function(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb: function() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B$1 = +1.78277,
        C = -0.29227,
        D$1 = -0.90649,
        E = +1.97294,
        ED = E * D$1,
        EB = E * B$1,
        BC_DA = B$1 * C - D$1 * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D$1,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * degrees$2 - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix$3(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix$3, extend$1(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians$1,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B$1 * sinh)),
          255 * (l + a * (C * cosh + D$1 * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function basis$1(t1, v0, v1, v2, v3) {
      var t2 = t1 * t1, t3 = t2 * t1;
      return ((1 - 3 * t1 + 3 * t2 - t3) * v0
          + (4 - 6 * t2 + 3 * t3) * v1
          + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
          + t3 * v3) / 6;
    }

    function basis$2(values) {
      var n = values.length - 1;
      return function(t) {
        var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function basisClosed$1(values) {
      var n = values.length;
      return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
            v0 = values[(i + n - 1) % n],
            v1 = values[i % n],
            v2 = values[(i + 1) % n],
            v3 = values[(i + 2) % n];
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    var constant$8 = x => () => x;

    function linear$2(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential$1(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue$1(a, b) {
      var d = b - a;
      return d ? linear$2(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$8(isNaN(a) ? b : a);
    }

    function gamma$1(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential$1(a, b, y) : constant$8(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$2(a, d) : constant$8(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma$1(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function rgbSpline(spline) {
      return function(colors) {
        var n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n),
            i, color;
        for (i = 0; i < n; ++i) {
          color = rgb(colors[i]);
          r[i] = color.r || 0;
          g[i] = color.g || 0;
          b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
          color.r = r(t);
          color.g = g(t);
          color.b = b(t);
          return color + "";
        };
      };
    }

    var rgbBasis = rgbSpline(basis$2);
    var rgbBasisClosed = rgbSpline(basisClosed$1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function array$3(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate$2(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date$1(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object$1(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate$2(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate$2(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$8(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color$1(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color$1 ? interpolateRgb
          : b instanceof Date ? date$1
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1
          : interpolateNumber)(a, b);
    }

    function discrete(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    function hue(a, b) {
      var i = hue$1(+a, +b);
      return function(t) {
        var x = i(t);
        return x - 360 * Math.floor(x / 360);
      };
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees$1 = 180 / Math.PI;

    var identity$7 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees$1,
        skewX: Math.atan(skewX) * degrees$1,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;

    /* eslint-disable no-undef */
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$7 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }

    function parseSvg(value) {
      if (value == null) return identity$7;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$7;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var epsilon2$1 = 1e-12;

    function cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }

    function sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }

    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }

    var interpolateZoom = (function zoomRho(rho, rho2, rho4) {

      // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]
      function zoom(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
            ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;

        // Special case for u0  u1.
        if (d2 < epsilon2$1) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        }

        // General case.
        else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
              b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s = t * S,
                coshr0 = cosh(r0),
                u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh(rho * s + r0)
            ];
          };
        }

        i.duration = S * 1000 * rho / Math.SQRT2;

        return i;
      }

      zoom.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };

      return zoom;
    })(Math.SQRT2, 2, 4);

    function hsl(hue) {
      return function(start, end) {
        var h = hue((start = hsl$2(start)).h, (end = hsl$2(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hsl$1 = hsl(hue$1);
    var hslLong = hsl(nogamma);

    function lab(start, end) {
      var l = nogamma((start = lab$1(start)).l, (end = lab$1(end)).l),
          a = nogamma(start.a, end.a),
          b = nogamma(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.l = l(t);
        start.a = a(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    function hcl(hue) {
      return function(start, end) {
        var h = hue((start = hcl$2(start)).h, (end = hcl$2(end)).h),
            c = nogamma(start.c, end.c),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.c = c(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hcl$1 = hcl(hue$1);
    var hclLong = hcl(nogamma);

    function cubehelix$1(hue) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix(start, end) {
          var h = hue((start = cubehelix$3(start)).h, (end = cubehelix$3(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix.gamma = cubehelixGamma;

        return cubehelix;
      })(1);
    }

    var cubehelix$2 = cubehelix$1(hue$1);
    var cubehelixLong = cubehelix$1(nogamma);

    function piecewise(interpolate, values) {
      if (values === undefined) values = interpolate, interpolate = interpolate$2;
      var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
      while (i < n) I[i] = interpolate(v, v = values[++i]);
      return function(t) {
        var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i](t - i);
      };
    }

    function quantize$1(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
      return samples;
    }

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval$1 = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend weve set an alarm, if we havent already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval$1) interval$1 = clearInterval(interval$1);
      } else {
        if (!interval$1) clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    function interval(callback, delay, time) {
      var t = new Timer, total = delay;
      if (delay == null) return t.restart(callback, delay, time), t;
      t._restart = t.restart;
      t.restart = function(callback, delay, time) {
        delay = +delay, time = time == null ? now() : +time;
        t._restart(function tick(elapsed) {
          elapsed += total;
          t._restart(tick, total += delay, time);
          callback(elapsed);
        }, delay, time);
      };
      t.restart(callback, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get(node, id).value[name];
      };
    }

    function interpolate$1(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color$1 ? interpolateRgb
          : (c = color$1(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error;
        set(this, id).ease = v;
      };
    }

    function transition_easeVarying(value) {
      if (typeof value !== "function") throw new Error;
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and were done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });

        // The selection was empty, resolve end immediately
        if (size === 0) resolve();
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    const linear$1 = t => +t;

    function quadIn(t) {
      return t * t;
    }

    function quadOut(t) {
      return t * (2 - t);
    }

    function quadInOut(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
      return t * t * t;
    }

    function cubicOut(t) {
      return --t * t * t + 1;
    }

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent$1 = 3;

    var polyIn = (function custom(e) {
      e = +e;

      function polyIn(t) {
        return Math.pow(t, e);
      }

      polyIn.exponent = custom;

      return polyIn;
    })(exponent$1);

    var polyOut = (function custom(e) {
      e = +e;

      function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
      }

      polyOut.exponent = custom;

      return polyOut;
    })(exponent$1);

    var polyInOut = (function custom(e) {
      e = +e;

      function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      polyInOut.exponent = custom;

      return polyInOut;
    })(exponent$1);

    var pi$4 = Math.PI,
        halfPi$3 = pi$4 / 2;

    function sinIn(t) {
      return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi$3);
    }

    function sinOut(t) {
      return Math.sin(t * halfPi$3);
    }

    function sinInOut(t) {
      return (1 - Math.cos(pi$4 * t)) / 2;
    }

    // tpmt is two power minus ten times t scaled to [0,1]
    function tpmt(x) {
      return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
    }

    function expIn(t) {
      return tpmt(1 - +t);
    }

    function expOut(t) {
      return 1 - tpmt(t);
    }

    function expInOut(t) {
      return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
    }

    function circleIn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function circleOut(t) {
      return Math.sqrt(1 - --t * t);
    }

    function circleInOut(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1 = 4 / 11,
        b2 = 6 / 11,
        b3 = 8 / 11,
        b4 = 3 / 4,
        b5 = 9 / 11,
        b6 = 10 / 11,
        b7 = 15 / 16,
        b8 = 21 / 22,
        b9 = 63 / 64,
        b0 = 1 / b1 / b1;

    function bounceIn(t) {
      return 1 - bounceOut(1 - t);
    }

    function bounceOut(t) {
      return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }

    function bounceInOut(t) {
      return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;

    var backIn = (function custom(s) {
      s = +s;

      function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
      }

      backIn.overshoot = custom;

      return backIn;
    })(overshoot);

    var backOut = (function custom(s) {
      s = +s;

      function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
      }

      backOut.overshoot = custom;

      return backOut;
    })(overshoot);

    var backInOut = (function custom(s) {
      s = +s;

      function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
      }

      backInOut.overshoot = custom;

      return backInOut;
    })(overshoot);

    var tau$5 = 2 * Math.PI,
        amplitude = 1,
        period = 0.3;

    var elasticIn = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticIn(t) {
        return a * tpmt(-(--t)) * Math.sin((s - t) / p);
      }

      elasticIn.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticIn.period = function(p) { return custom(a, p); };

      return elasticIn;
    })(amplitude, period);

    var elasticOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticOut(t) {
        return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
      }

      elasticOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticOut.period = function(p) { return custom(a, p); };

      return elasticOut;
    })(amplitude, period);

    var elasticInOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0
            ? a * tpmt(-t) * Math.sin((s - t) / p)
            : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
      }

      elasticInOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticInOut.period = function(p) { return custom(a, p); };

      return elasticInOut;
    })(amplitude, period);

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var root = [null];

    function active(node, name) {
      var schedules = node.__transition,
          schedule,
          i;

      if (schedules) {
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
            return new Transition([[node]], root, name, +i);
          }
        }
      }

      return null;
    }

    var constant$7 = x => () => x;

    function BrushEvent(type, {
      sourceEvent,
      target,
      selection,
      mode,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        selection: {value: selection, enumerable: true, configurable: true},
        mode: {value: mode, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function nopropagation$1(event) {
      event.stopImmediatePropagation();
    }

    function noevent$1(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    var MODE_DRAG = {name: "drag"},
        MODE_SPACE = {name: "space"},
        MODE_HANDLE = {name: "handle"},
        MODE_CENTER = {name: "center"};

    const {abs: abs$3, max: max$2, min: min$1} = Math;

    function number1(e) {
      return [+e[0], +e[1]];
    }

    function number2(e) {
      return [number1(e[0]), number1(e[1])];
    }

    var X = {
      name: "x",
      handles: ["w", "e"].map(type),
      input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
      output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
    };

    var Y = {
      name: "y",
      handles: ["n", "s"].map(type),
      input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
      output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
    };

    var XY = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
      input: function(xy) { return xy == null ? null : number2(xy); },
      output: function(xy) { return xy; }
    };

    var cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };

    var flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };

    var flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };

    var signsX = {
      overlay: +1,
      selection: +1,
      n: null,
      e: +1,
      s: null,
      w: -1,
      nw: -1,
      ne: +1,
      se: +1,
      sw: -1
    };

    var signsY = {
      overlay: +1,
      selection: +1,
      n: -1,
      e: null,
      s: +1,
      w: null,
      nw: -1,
      ne: -1,
      se: +1,
      sw: +1
    };

    function type(t) {
      return {type: t};
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$1(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultExtent$1() {
      var svg = this.ownerSVGElement || this;
      if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
      }
      return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }

    function defaultTouchable$1() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    // Like d3.local, but with the name __brush rather than auto-generated.
    function local(node) {
      while (!node.__brush) if (!(node = node.parentNode)) return;
      return node.__brush;
    }

    function empty(extent) {
      return extent[0][0] === extent[1][0]
          || extent[0][1] === extent[1][1];
    }

    function brushSelection(node) {
      var state = node.__brush;
      return state ? state.dim.output(state.selection) : null;
    }

    function brushX() {
      return brush$1(X);
    }

    function brushY() {
      return brush$1(Y);
    }

    function brush() {
      return brush$1(XY);
    }

    function brush$1(dim) {
      var extent = defaultExtent$1,
          filter = defaultFilter$1,
          touchable = defaultTouchable$1,
          keys = true,
          listeners = dispatch("start", "brush", "end"),
          handleSize = 6,
          touchending;

      function brush(group) {
        var overlay = group
            .property("__brush", initialize)
          .selectAll(".overlay")
          .data([type("overlay")]);

        overlay.enter().append("rect")
            .attr("class", "overlay")
            .attr("pointer-events", "all")
            .attr("cursor", cursors.overlay)
          .merge(overlay)
            .each(function() {
              var extent = local(this).extent;
              select(this)
                  .attr("x", extent[0][0])
                  .attr("y", extent[0][1])
                  .attr("width", extent[1][0] - extent[0][0])
                  .attr("height", extent[1][1] - extent[0][1]);
            });

        group.selectAll(".selection")
          .data([type("selection")])
          .enter().append("rect")
            .attr("class", "selection")
            .attr("cursor", cursors.selection)
            .attr("fill", "#777")
            .attr("fill-opacity", 0.3)
            .attr("stroke", "#fff")
            .attr("shape-rendering", "crispEdges");

        var handle = group.selectAll(".handle")
          .data(dim.handles, function(d) { return d.type; });

        handle.exit().remove();

        handle.enter().append("rect")
            .attr("class", function(d) { return "handle handle--" + d.type; })
            .attr("cursor", function(d) { return cursors[d.type]; });

        group
            .each(redraw)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousedown.brush", started)
          .filter(touchable)
            .on("touchstart.brush", started)
            .on("touchmove.brush", touchmoved)
            .on("touchend.brush touchcancel.brush", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      brush.move = function(group, selection, event) {
        if (group.tween) {
          group
              .on("start.brush", function(event) { emitter(this, arguments).beforestart().start(event); })
              .on("interrupt.brush end.brush", function(event) { emitter(this, arguments).end(event); })
              .tween("brush", function() {
                var that = this,
                    state = that.__brush,
                    emit = emitter(that, arguments),
                    selection0 = state.selection,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                    i = interpolate$2(selection0, selection1);

                function tween(t) {
                  state.selection = t === 1 && selection1 === null ? null : i(t);
                  redraw.call(that);
                  emit.brush();
                }

                return selection0 !== null && selection1 !== null ? tween : tween(1);
              });
        } else {
          group
              .each(function() {
                var that = this,
                    args = arguments,
                    state = that.__brush,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                    emit = emitter(that, args).beforestart();

                interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start(event).brush(event).end(event);
              });
        }
      };

      brush.clear = function(group, event) {
        brush.move(group, null, event);
      };

      function redraw() {
        var group = select(this),
            selection = local(this).selection;

        if (selection) {
          group.selectAll(".selection")
              .style("display", null)
              .attr("x", selection[0][0])
              .attr("y", selection[0][1])
              .attr("width", selection[1][0] - selection[0][0])
              .attr("height", selection[1][1] - selection[0][1]);

          group.selectAll(".handle")
              .style("display", null)
              .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
              .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
              .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
              .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
        }

        else {
          group.selectAll(".selection,.handle")
              .style("display", "none")
              .attr("x", null)
              .attr("y", null)
              .attr("width", null)
              .attr("height", null);
        }
      }

      function emitter(that, args, clean) {
        var emit = that.__brush.emitter;
        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
      }

      function Emitter(that, args, clean) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
        this.clean = clean;
      }

      Emitter.prototype = {
        beforestart: function() {
          if (++this.active === 1) this.state.emitter = this, this.starting = true;
          return this;
        },
        start: function(event, mode) {
          if (this.starting) this.starting = false, this.emit("start", event, mode);
          else this.emit("brush", event);
          return this;
        },
        brush: function(event, mode) {
          this.emit("brush", event, mode);
          return this;
        },
        end: function(event, mode) {
          if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
          return this;
        },
        emit: function(type, event, mode) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new BrushEvent(type, {
              sourceEvent: event,
              target: brush,
              selection: dim.output(this.state.selection),
              mode,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function started(event) {
        if (touchending && !event.touches) return;
        if (!filter.apply(this, arguments)) return;

        var that = this,
            type = event.target.__data__.type,
            mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
            signX = dim === Y ? null : signsX[type],
            signY = dim === X ? null : signsY[type],
            state = local(that),
            extent = state.extent,
            selection = state.selection,
            W = extent[0][0], w0, w1,
            N = extent[0][1], n0, n1,
            E = extent[1][0], e0, e1,
            S = extent[1][1], s0, s1,
            dx = 0,
            dy = 0,
            moving,
            shifting = signX && signY && keys && event.shiftKey,
            lockX,
            lockY,
            points = Array.from(event.touches || [event], t => {
              const i = t.identifier;
              t = pointer(t, that);
              t.point0 = t.slice();
              t.identifier = i;
              return t;
            });

        interrupt(that);
        var emit = emitter(that, arguments, true).beforestart();

        if (type === "overlay") {
          if (selection) moving = true;
          const pts = [points[0], points[1] || points[0]];
          state.selection = selection = [[
              w0 = dim === Y ? W : min$1(pts[0][0], pts[1][0]),
              n0 = dim === X ? N : min$1(pts[0][1], pts[1][1])
            ], [
              e0 = dim === Y ? E : max$2(pts[0][0], pts[1][0]),
              s0 = dim === X ? S : max$2(pts[0][1], pts[1][1])
            ]];
          if (points.length > 1) move(event);
        } else {
          w0 = selection[0][0];
          n0 = selection[0][1];
          e0 = selection[1][0];
          s0 = selection[1][1];
        }

        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;

        var group = select(that)
            .attr("pointer-events", "none");

        var overlay = group.selectAll(".overlay")
            .attr("cursor", cursors[type]);

        if (event.touches) {
          emit.moved = moved;
          emit.ended = ended;
        } else {
          var view = select(event.view)
              .on("mousemove.brush", moved, true)
              .on("mouseup.brush", ended, true);
          if (keys) view
              .on("keydown.brush", keydowned, true)
              .on("keyup.brush", keyupped, true);

          dragDisable(event.view);
        }

        redraw.call(that);
        emit.start(event, mode.name);

        function moved(event) {
          for (const p of event.changedTouches || [event]) {
            for (const d of points)
              if (d.identifier === p.identifier) d.cur = pointer(p, that);
          }
          if (shifting && !lockX && !lockY && points.length === 1) {
            const point = points[0];
            if (abs$3(point.cur[0] - point[0]) > abs$3(point.cur[1] - point[1]))
              lockY = true;
            else
              lockX = true;
          }
          for (const point of points)
            if (point.cur) point[0] = point.cur[0], point[1] = point.cur[1];
          moving = true;
          noevent$1(event);
          move(event);
        }

        function move(event) {
          const point = points[0], point0 = point.point0;
          var t;

          dx = point[0] - point0[0];
          dy = point[1] - point0[1];

          switch (mode) {
            case MODE_SPACE:
            case MODE_DRAG: {
              if (signX) dx = max$2(W - w0, min$1(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
              if (signY) dy = max$2(N - n0, min$1(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
              break;
            }
            case MODE_HANDLE: {
              if (points[1]) {
                if (signX) w1 = max$2(W, min$1(E, points[0][0])), e1 = max$2(W, min$1(E, points[1][0])), signX = 1;
                if (signY) n1 = max$2(N, min$1(S, points[0][1])), s1 = max$2(N, min$1(S, points[1][1])), signY = 1;
              } else {
                if (signX < 0) dx = max$2(W - w0, min$1(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                else if (signX > 0) dx = max$2(W - e0, min$1(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                if (signY < 0) dy = max$2(N - n0, min$1(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                else if (signY > 0) dy = max$2(N - s0, min$1(S - s0, dy)), n1 = n0, s1 = s0 + dy;
              }
              break;
            }
            case MODE_CENTER: {
              if (signX) w1 = max$2(W, min$1(E, w0 - dx * signX)), e1 = max$2(W, min$1(E, e0 + dx * signX));
              if (signY) n1 = max$2(N, min$1(S, n0 - dy * signY)), s1 = max$2(N, min$1(S, s0 + dy * signY));
              break;
            }
          }

          if (e1 < w1) {
            signX *= -1;
            t = w0, w0 = e0, e0 = t;
            t = w1, w1 = e1, e1 = t;
            if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
          }

          if (s1 < n1) {
            signY *= -1;
            t = n0, n0 = s0, s0 = t;
            t = n1, n1 = s1, s1 = t;
            if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
          }

          if (state.selection) selection = state.selection; // May be set by brush.move!
          if (lockX) w1 = selection[0][0], e1 = selection[1][0];
          if (lockY) n1 = selection[0][1], s1 = selection[1][1];

          if (selection[0][0] !== w1
              || selection[0][1] !== n1
              || selection[1][0] !== e1
              || selection[1][1] !== s1) {
            state.selection = [[w1, n1], [e1, s1]];
            redraw.call(that);
            emit.brush(event, mode.name);
          }
        }

        function ended(event) {
          nopropagation$1(event);
          if (event.touches) {
            if (event.touches.length) return;
            if (touchending) clearTimeout(touchending);
            touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
          } else {
            yesdrag(event.view, moving);
            view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
          }
          group.attr("pointer-events", "all");
          overlay.attr("cursor", cursors.overlay);
          if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
          if (empty(selection)) state.selection = null, redraw.call(that);
          emit.end(event, mode.name);
        }

        function keydowned(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              shifting = signX && signY;
              break;
            }
            case 18: { // ALT
              if (mode === MODE_HANDLE) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
                move(event);
              }
              break;
            }
            case 32: { // SPACE; takes priority over ALT
              if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
                if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
                mode = MODE_SPACE;
                overlay.attr("cursor", cursors.selection);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }

        function keyupped(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              if (shifting) {
                lockX = lockY = shifting = false;
                move(event);
              }
              break;
            }
            case 18: { // ALT
              if (mode === MODE_CENTER) {
                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
                move(event);
              }
              break;
            }
            case 32: { // SPACE
              if (mode === MODE_SPACE) {
                if (event.altKey) {
                  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                  mode = MODE_CENTER;
                } else {
                  if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                  if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                  mode = MODE_HANDLE;
                }
                overlay.attr("cursor", cursors[type]);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }
      }

      function touchmoved(event) {
        emitter(this, arguments).moved(event);
      }

      function touchended(event) {
        emitter(this, arguments).ended(event);
      }

      function initialize() {
        var state = this.__brush || {selection: null};
        state.extent = number2(extent.apply(this, arguments));
        state.dim = dim;
        return state;
      }

      brush.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$7(number2(_)), brush) : extent;
      };

      brush.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$7(!!_), brush) : filter;
      };

      brush.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$7(!!_), brush) : touchable;
      };

      brush.handleSize = function(_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
      };

      brush.keyModifiers = function(_) {
        return arguments.length ? (keys = !!_, brush) : keys;
      };

      brush.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
      };

      return brush;
    }

    var abs$2 = Math.abs;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var pi$3 = Math.PI;
    var halfPi$2 = pi$3 / 2;
    var tau$4 = pi$3 * 2;
    var max$1 = Math.max;
    var epsilon$5 = 1e-12;

    function range$2(i, j) {
      return Array.from({length: j - i}, (_, k) => i + k);
    }

    function compareValue(compare) {
      return function(a, b) {
        return compare(
          a.source.value + a.target.value,
          b.source.value + b.target.value
        );
      };
    }

    function chord() {
      return chord$1(false, false);
    }

    function chordTranspose() {
      return chord$1(false, true);
    }

    function chordDirected() {
      return chord$1(true, false);
    }

    function chord$1(directed, transpose) {
      var padAngle = 0,
          sortGroups = null,
          sortSubgroups = null,
          sortChords = null;

      function chord(matrix) {
        var n = matrix.length,
            groupSums = new Array(n),
            groupIndex = range$2(0, n),
            chords = new Array(n * n),
            groups = new Array(n),
            k = 0, dx;

        matrix = Float64Array.from({length: n * n}, transpose
            ? (_, i) => matrix[i % n][i / n | 0]
            : (_, i) => matrix[i / n | 0][i % n]);

        // Compute the scaling factor from value to angle in [0, 2pi].
        for (let i = 0; i < n; ++i) {
          let x = 0;
          for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];
          k += groupSums[i] = x;
        }
        k = max$1(0, tau$4 - padAngle * n) / k;
        dx = k ? padAngle : tau$4 / n;

        // Compute the angles for each group and constituent chord.
        {
          let x = 0;
          if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));
          for (const i of groupIndex) {
            const x0 = x;
            if (directed) {
              const subgroupIndex = range$2(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
              for (const j of subgroupIndex) {
                if (j < 0) {
                  const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};
                } else {
                  const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            } else {
              const subgroupIndex = range$2(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));
              for (const j of subgroupIndex) {
                let chord;
                if (i < j) {
                  chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                } else {
                  chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                  if (i === j) chord.source = chord.target;
                }
                if (chord.source && chord.target && chord.source.value < chord.target.value) {
                  const source = chord.source;
                  chord.source = chord.target;
                  chord.target = source;
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            }
            x += dx;
          }
        }

        // Remove empty chords.
        chords = Object.values(chords);
        chords.groups = groups;
        return sortChords ? chords.sort(sortChords) : chords;
      }

      chord.padAngle = function(_) {
        return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
      };

      chord.sortGroups = function(_) {
        return arguments.length ? (sortGroups = _, chord) : sortGroups;
      };

      chord.sortSubgroups = function(_) {
        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
      };

      chord.sortChords = function(_) {
        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
      };

      return chord;
    }

    const pi$2 = Math.PI,
        tau$3 = 2 * pi$2,
        epsilon$4 = 1e-6,
        tauEpsilon = tau$3 - epsilon$4;

    function Path$1() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }

    function path() {
      return new Path$1;
    }

    Path$1.prototype = path.prototype = {
      constructor: Path$1,
      moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$4));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$4) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$4) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$4 || Math.abs(this._y1 - y0) > epsilon$4) {
          this._ += "L" + x0 + "," + y0;
        }

        // Is this arc empty? Were done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$3 + tau$3;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$4) {
          this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
      },
      toString: function() {
        return this._;
      }
    };

    var slice$2 = Array.prototype.slice;

    function constant$6(x) {
      return function() {
        return x;
      };
    }

    function defaultSource$1(d) {
      return d.source;
    }

    function defaultTarget(d) {
      return d.target;
    }

    function defaultRadius$1(d) {
      return d.radius;
    }

    function defaultStartAngle(d) {
      return d.startAngle;
    }

    function defaultEndAngle(d) {
      return d.endAngle;
    }

    function defaultPadAngle() {
      return 0;
    }

    function defaultArrowheadRadius() {
      return 10;
    }

    function ribbon(headRadius) {
      var source = defaultSource$1,
          target = defaultTarget,
          sourceRadius = defaultRadius$1,
          targetRadius = defaultRadius$1,
          startAngle = defaultStartAngle,
          endAngle = defaultEndAngle,
          padAngle = defaultPadAngle,
          context = null;

      function ribbon() {
        var buffer,
            s = source.apply(this, arguments),
            t = target.apply(this, arguments),
            ap = padAngle.apply(this, arguments) / 2,
            argv = slice$2.call(arguments),
            sr = +sourceRadius.apply(this, (argv[0] = s, argv)),
            sa0 = startAngle.apply(this, argv) - halfPi$2,
            sa1 = endAngle.apply(this, argv) - halfPi$2,
            tr = +targetRadius.apply(this, (argv[0] = t, argv)),
            ta0 = startAngle.apply(this, argv) - halfPi$2,
            ta1 = endAngle.apply(this, argv) - halfPi$2;

        if (!context) context = buffer = path();

        if (ap > epsilon$5) {
          if (abs$2(sa1 - sa0) > ap * 2 + epsilon$5) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
          else sa0 = sa1 = (sa0 + sa1) / 2;
          if (abs$2(ta1 - ta0) > ap * 2 + epsilon$5) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
          else ta0 = ta1 = (ta0 + ta1) / 2;
        }

        context.moveTo(sr * cos$2(sa0), sr * sin$2(sa0));
        context.arc(0, 0, sr, sa0, sa1);
        if (sa0 !== ta0 || sa1 !== ta1) {
          if (headRadius) {
            var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
            context.quadraticCurveTo(0, 0, tr2 * cos$2(ta0), tr2 * sin$2(ta0));
            context.lineTo(tr * cos$2(ta2), tr * sin$2(ta2));
            context.lineTo(tr2 * cos$2(ta1), tr2 * sin$2(ta1));
          } else {
            context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
            context.arc(0, 0, tr, ta0, ta1);
          }
        }
        context.quadraticCurveTo(0, 0, sr * cos$2(sa0), sr * sin$2(sa0));
        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      if (headRadius) ribbon.headRadius = function(_) {
        return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : headRadius;
      };

      ribbon.radius = function(_) {
        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.sourceRadius = function(_) {
        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.targetRadius = function(_) {
        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : targetRadius;
      };

      ribbon.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : startAngle;
      };

      ribbon.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : endAngle;
      };

      ribbon.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : padAngle;
      };

      ribbon.source = function(_) {
        return arguments.length ? (source = _, ribbon) : source;
      };

      ribbon.target = function(_) {
        return arguments.length ? (target = _, ribbon) : target;
      };

      ribbon.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
      };

      return ribbon;
    }

    function ribbon$1() {
      return ribbon();
    }

    function ribbonArrow() {
      return ribbon(defaultArrowheadRadius);
    }

    var array$2 = Array.prototype;

    var slice$1 = array$2.slice;

    function ascending$1(a, b) {
      return a - b;
    }

    function area$3(ring) {
      var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area;
    }

    var constant$5 = x => () => x;

    function contains$2(ring, hole) {
      var i = -1, n = hole.length, c;
      while (++i < n) if (c = ringContains(ring, hole[i])) return c;
      return 0;
    }

    function ringContains(ring, point) {
      var x = point[0], y = point[1], contains = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) return 0;
        if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
      }
      return contains;
    }

    function segmentContains(a, b, c) {
      var i; return collinear$1(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
    }

    function collinear$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
    }

    function within(p, q, r) {
      return p <= q && q <= r || r <= q && q <= p;
    }

    function noop$3() {}

    var cases = [
      [],
      [[[1.0, 1.5], [0.5, 1.0]]],
      [[[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [0.5, 1.0]]],
      [[[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 0.5], [1.0, 1.5]]],
      [[[1.0, 0.5], [0.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 0.5]]],
      [[[1.0, 1.5], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.5, 1.0]]],
      [[[1.0, 1.5], [1.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 1.5]]],
      []
    ];

    function contours() {
      var dx = 1,
          dy = 1,
          threshold = thresholdSturges,
          smooth = smoothLinear;

      function contours(values) {
        var tz = threshold(values);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          const e = extent$1(values), ts = tickStep(e[0], e[1], tz);
          tz = ticks(Math.floor(e[0] / ts) * ts, Math.floor(e[1] / ts - 1) * ts, tz);
        } else {
          tz = tz.slice().sort(ascending$1);
        }

        return tz.map(value => contour(values, value));
      }

      // Accumulate, smooth contour rings, assign holes to exterior rings.
      // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
      function contour(values, value) {
        var polygons = [],
            holes = [];

        isorings(values, value, function(ring) {
          smooth(ring, values, value);
          if (area$3(ring) > 0) polygons.push([ring]);
          else holes.push(ring);
        });

        holes.forEach(function(hole) {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            if (contains$2((polygon = polygons[i])[0], hole) !== -1) {
              polygon.push(hole);
              return;
            }
          }
        });

        return {
          type: "MultiPolygon",
          value: value,
          coordinates: polygons
        };
      }

      // Marching squares with isolines stitched into rings.
      // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
      function isorings(values, value, callback) {
        var fragmentByStart = new Array,
            fragmentByEnd = new Array,
            x, y, t0, t1, t2, t3;

        // Special case for the first row (y = -1, t2 = t3 = 0).
        x = y = -1;
        t1 = values[0] >= value;
        cases[t1 << 1].forEach(stitch);
        while (++x < dx - 1) {
          t0 = t1, t1 = values[x + 1] >= value;
          cases[t0 | t1 << 1].forEach(stitch);
        }
        cases[t1 << 0].forEach(stitch);

        // General case for the intermediate rows.
        while (++y < dy - 1) {
          x = -1;
          t1 = values[y * dx + dx] >= value;
          t2 = values[y * dx] >= value;
          cases[t1 << 1 | t2 << 2].forEach(stitch);
          while (++x < dx - 1) {
            t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
            t3 = t2, t2 = values[y * dx + x + 1] >= value;
            cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
          }
          cases[t1 | t2 << 3].forEach(stitch);
        }

        // Special case for the last row (y = dy - 1, t0 = t1 = 0).
        x = -1;
        t2 = values[y * dx] >= value;
        cases[t2 << 2].forEach(stitch);
        while (++x < dx - 1) {
          t3 = t2, t2 = values[y * dx + x + 1] >= value;
          cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);

        function stitch(line) {
          var start = [line[0][0] + x, line[0][1] + y],
              end = [line[1][0] + x, line[1][1] + y],
              startIndex = index(start),
              endIndex = index(end),
              f, g;
          if (f = fragmentByEnd[startIndex]) {
            if (g = fragmentByStart[endIndex]) {
              delete fragmentByEnd[f.end];
              delete fragmentByStart[g.start];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
              }
            } else {
              delete fragmentByEnd[f.end];
              f.ring.push(end);
              fragmentByEnd[f.end = endIndex] = f;
            }
          } else if (f = fragmentByStart[endIndex]) {
            if (g = fragmentByEnd[startIndex]) {
              delete fragmentByStart[f.start];
              delete fragmentByEnd[g.end];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
              }
            } else {
              delete fragmentByStart[f.start];
              f.ring.unshift(start);
              fragmentByStart[f.start = startIndex] = f;
            }
          } else {
            fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
          }
        }
      }

      function index(point) {
        return point[0] * 2 + point[1] * (dx + 1) * 4;
      }

      function smoothLinear(ring, values, value) {
        ring.forEach(function(point) {
          var x = point[0],
              y = point[1],
              xt = x | 0,
              yt = y | 0,
              v0,
              v1 = values[yt * dx + xt];
          if (x > 0 && x < dx && xt === x) {
            v0 = values[yt * dx + xt - 1];
            point[0] = x + (value - v0) / (v1 - v0) - 0.5;
          }
          if (y > 0 && y < dy && yt === y) {
            v0 = values[(yt - 1) * dx + xt];
            point[1] = y + (value - v0) / (v1 - v0) - 0.5;
          }
        });
      }

      contours.contour = contour;

      contours.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, contours;
      };

      contours.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), contours) : threshold;
      };

      contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop$3, contours) : smooth === smoothLinear;
      };

      return contours;
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurX(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var j = 0; j < m; ++j) {
        for (var i = 0, sr = 0; i < n + r; ++i) {
          if (i < n) {
            sr += source.data[i + j * n];
          }
          if (i >= r) {
            if (i >= w) {
              sr -= source.data[i - w + j * n];
            }
            target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
          }
        }
      }
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurY(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var i = 0; i < n; ++i) {
        for (var j = 0, sr = 0; j < m + r; ++j) {
          if (j < m) {
            sr += source.data[i + j * n];
          }
          if (j >= r) {
            if (j >= w) {
              sr -= source.data[i + (j - w) * n];
            }
            target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
          }
        }
      }
    }

    function defaultX$1(d) {
      return d[0];
    }

    function defaultY$1(d) {
      return d[1];
    }

    function defaultWeight() {
      return 1;
    }

    function density() {
      var x = defaultX$1,
          y = defaultY$1,
          weight = defaultWeight,
          dx = 960,
          dy = 500,
          r = 20, // blur radius
          k = 2, // log2(grid cell size)
          o = r * 3, // grid offset, to pad for blur
          n = (dx + o * 2) >> k, // grid width
          m = (dy + o * 2) >> k, // grid height
          threshold = constant$5(20);

      function density(data) {
        var values0 = new Float32Array(n * m),
            values1 = new Float32Array(n * m),
            pow2k = Math.pow(2, -k);

        data.forEach(function(d, i, data) {
          var xi = (x(d, i, data) + o) * pow2k,
              yi = (y(d, i, data) + o) * pow2k,
              wi = +weight(d, i, data);
          if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
            var x0 = Math.floor(xi),
                y0 = Math.floor(yi),
                xt = xi - x0 - 0.5,
                yt = yi - y0 - 0.5;
            values0[x0 + y0 * n] += (1 - xt) * (1 - yt) * wi;
            values0[x0 + 1 + y0 * n] += xt * (1 - yt) * wi;
            values0[x0 + 1 + (y0 + 1) * n] += xt * yt * wi;
            values0[x0 + (y0 + 1) * n] += (1 - xt) * yt * wi;
          }
        });

        // TODO Optimize.
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

        var tz = threshold(values0);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          var stop = max$3(values0);
          tz = tickStep(0, stop, tz);
          tz = range$3(0, Math.floor(stop / tz) * tz, tz);
          tz.shift();
        }

        return contours()
            .thresholds(tz)
            .size([n, m])
          (values0)
            .map(transform);
      }

      function transform(geometry) {
        geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      }

      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }

      function transformRing(coordinates) {
        coordinates.forEach(transformPoint);
      }

      // TODO Optimize.
      function transformPoint(coordinates) {
        coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
        coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
      }

      function resize() {
        o = r * 3;
        n = (dx + o * 2) >> k;
        m = (dy + o * 2) >> k;
        return density;
      }

      density.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$5(+_), density) : x;
      };

      density.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$5(+_), density) : y;
      };

      density.weight = function(_) {
        return arguments.length ? (weight = typeof _ === "function" ? _ : constant$5(+_), density) : weight;
      };

      density.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = +_[0], _1 = +_[1];
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, resize();
      };

      density.cellSize = function(_) {
        if (!arguments.length) return 1 << k;
        if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
        return k = Math.floor(Math.log(_) / Math.LN2), resize();
      };

      density.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), density) : threshold;
      };

      density.bandwidth = function(_) {
        if (!arguments.length) return Math.sqrt(r * (r + 1));
        if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
        return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
      };

      return density;
    }

    const epsilon$3 = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon$3) * epsilon$3;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum$1(elen, e, flen, f, h) {
        let Q, Qnew, hh, bvirt;
        let enow = e[0];
        let fnow = f[0];
        let eindex = 0;
        let findex = 0;
        if ((fnow > enow) === (fnow > -enow)) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        let hindex = 0;
        if (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
                if ((fnow > enow) === (fnow > -enow)) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) {
                    h[hindex++] = hh;
                }
            }
        }
        while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
        }
        return hindex;
    }

    function estimate(elen, e) {
        let Q = e[0];
        for (let i = 1; i < elen; i++) Q += e[i];
        return Q;
    }

    function vec(n) {
        return new Float64Array(n);
    }

    const ccwerrboundA = (3 + 16 * epsilon$3) * epsilon$3;
    const ccwerrboundB = (2 + 12 * epsilon$3) * epsilon$3;
    const ccwerrboundC = (9 + 64 * epsilon$3) * epsilon$3 * epsilon$3;

    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);

    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        let acxtail, acytail, bcxtail, bcytail;
        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

        const acx = ax - cx;
        const bcx = bx - cx;
        const acy = ay - cy;
        const bcy = by - cy;

        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B[3] = u3;

        let det = estimate(4, B);
        let errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) {
            return det;
        }

        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);

        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
        }

        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) return det;

        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C1len = sum$1(4, B, 4, u, C1);

        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C2len = sum$1(C1len, C1, 4, u, C2);

        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const Dlen = sum$1(C2len, C2, 4, u, D);

        return D[Dlen - 1];
    }

    function orient2d(ax, ay, bx, by, cx, cy) {
        const detleft = (ay - cy) * (bx - cx);
        const detright = (ax - cx) * (by - cy);
        const det = detleft - detright;

        if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;

        const detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) return det;

        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    const EPSILON = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);

    class Delaunator {

        static from(points, getX = defaultGetX, getY = defaultGetY) {
            const n = points.length;
            const coords = new Float64Array(n * 2);

            for (let i = 0; i < n; i++) {
                const p = points[i];
                coords[2 * i] = getX(p);
                coords[2 * i + 1] = getY(p);
            }

            return new Delaunator(coords);
        }

        constructor(coords) {
            const n = coords.length >> 1;
            if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

            this.coords = coords;

            // arrays that will store the triangulation graph
            const maxTriangles = Math.max(2 * n - 5, 0);
            this._triangles = new Uint32Array(maxTriangles * 3);
            this._halfedges = new Int32Array(maxTriangles * 3);

            // temporary arrays for tracking the edges of the advancing convex hull
            this._hashSize = Math.ceil(Math.sqrt(n));
            this._hullPrev = new Uint32Array(n); // edge to prev edge
            this._hullNext = new Uint32Array(n); // edge to next edge
            this._hullTri = new Uint32Array(n); // edge to adjacent triangle
            this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

            // temporary arrays for sorting points
            this._ids = new Uint32Array(n);
            this._dists = new Float64Array(n);

            this.update();
        }

        update() {
            const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
            const n = coords.length >> 1;

            // populate an array of point indices; calculate input data bbox
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            for (let i = 0; i < n; i++) {
                const x = coords[2 * i];
                const y = coords[2 * i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                this._ids[i] = i;
            }
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            let minDist = Infinity;
            let i0, i1, i2;

            // pick a seed point close to the center
            for (let i = 0; i < n; i++) {
                const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist) {
                    i0 = i;
                    minDist = d;
                }
            }
            const i0x = coords[2 * i0];
            const i0y = coords[2 * i0 + 1];

            minDist = Infinity;

            // find the point closest to the seed
            for (let i = 0; i < n; i++) {
                if (i === i0) continue;
                const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist && d > 0) {
                    i1 = i;
                    minDist = d;
                }
            }
            let i1x = coords[2 * i1];
            let i1y = coords[2 * i1 + 1];

            let minRadius = Infinity;

            // find the third point which forms the smallest circumcircle with the first two
            for (let i = 0; i < n; i++) {
                if (i === i0 || i === i1) continue;
                const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
                if (r < minRadius) {
                    i2 = i;
                    minRadius = r;
                }
            }
            let i2x = coords[2 * i2];
            let i2y = coords[2 * i2 + 1];

            if (minRadius === Infinity) {
                // order collinear points by dx (or dy if all x are identical)
                // and return the list as a hull
                for (let i = 0; i < n; i++) {
                    this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
                }
                quicksort(this._ids, this._dists, 0, n - 1);
                const hull = new Uint32Array(n);
                let j = 0;
                for (let i = 0, d0 = -Infinity; i < n; i++) {
                    const id = this._ids[i];
                    if (this._dists[id] > d0) {
                        hull[j++] = id;
                        d0 = this._dists[id];
                    }
                }
                this.hull = hull.subarray(0, j);
                this.triangles = new Uint32Array(0);
                this.halfedges = new Uint32Array(0);
                return;
            }

            // swap the order of the seed points for counter-clockwise orientation
            if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
                const i = i1;
                const x = i1x;
                const y = i1y;
                i1 = i2;
                i1x = i2x;
                i1y = i2y;
                i2 = i;
                i2x = x;
                i2y = y;
            }

            const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
            this._cx = center.x;
            this._cy = center.y;

            for (let i = 0; i < n; i++) {
                this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
            }

            // sort the points by distance from the seed triangle circumcenter
            quicksort(this._ids, this._dists, 0, n - 1);

            // set up the seed triangle as the starting hull
            this._hullStart = i0;
            let hullSize = 3;

            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;

            hullTri[i0] = 0;
            hullTri[i1] = 1;
            hullTri[i2] = 2;

            hullHash.fill(-1);
            hullHash[this._hashKey(i0x, i0y)] = i0;
            hullHash[this._hashKey(i1x, i1y)] = i1;
            hullHash[this._hashKey(i2x, i2y)] = i2;

            this.trianglesLen = 0;
            this._addTriangle(i0, i1, i2, -1, -1, -1);

            for (let k = 0, xp, yp; k < this._ids.length; k++) {
                const i = this._ids[k];
                const x = coords[2 * i];
                const y = coords[2 * i + 1];

                // skip near-duplicate points
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
                xp = x;
                yp = y;

                // skip seed triangle points
                if (i === i0 || i === i1 || i === i2) continue;

                // find a visible edge on the convex hull using edge hash
                let start = 0;
                for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                    start = hullHash[(key + j) % this._hashSize];
                    if (start !== -1 && start !== hullNext[start]) break;
                }

                start = hullPrev[start];
                let e = start, q;
                while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                    e = q;
                    if (e === start) {
                        e = -1;
                        break;
                    }
                }
                if (e === -1) continue; // likely a near-duplicate point; skip it

                // add the first triangle from the point
                let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

                // recursively flip triangles from the point until they satisfy the Delaunay condition
                hullTri[i] = this._legalize(t + 2);
                hullTri[e] = t; // keep track of boundary triangles on the hull
                hullSize++;

                // walk forward through the hull, adding more triangles and flipping recursively
                let n = hullNext[e];
                while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                    t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this._legalize(t + 2);
                    hullNext[n] = n; // mark as removed
                    hullSize--;
                    n = q;
                }

                // walk backward from the other side, adding more triangles and flipping
                if (e === start) {
                    while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                        t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this._legalize(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e; // mark as removed
                        hullSize--;
                        e = q;
                    }
                }

                // update the hull indices
                this._hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;

                // save the two new edges in the hash table
                hullHash[this._hashKey(x, y)] = i;
                hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
            }

            this.hull = new Uint32Array(hullSize);
            for (let i = 0, e = this._hullStart; i < hullSize; i++) {
                this.hull[i] = e;
                e = hullNext[e];
            }

            // trim typed triangle mesh arrays
            this.triangles = this._triangles.subarray(0, this.trianglesLen);
            this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }

        _hashKey(x, y) {
            return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
        }

        _legalize(a) {
            const {_triangles: triangles, _halfedges: halfedges, coords} = this;

            let i = 0;
            let ar = 0;

            // recursion eliminated with a fixed-size stack
            while (true) {
                const b = halfedges[a];

                /* if the pair of triangles doesn't satisfy the Delaunay condition
                 * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
                 * then do the same check/flip recursively for the new pair of triangles
                 *
                 *           pl                    pl
                 *          /||\                  /  \
                 *       al/ || \bl            al/    \a
                 *        /  ||  \              /      \
                 *       /  a||b  \    flip    /___ar___\
                 *     p0\   ||   /p1   =>   p0\---bl---/p1
                 *        \  ||  /              \      /
                 *       ar\ || /br             b\    /br
                 *          \||/                  \  /
                 *           pr                    pr
                 */
                const a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;

                if (b === -1) { // convex hull edge
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                    continue;
                }

                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;

                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];

                const illegal = inCircle(
                    coords[2 * p0], coords[2 * p0 + 1],
                    coords[2 * pr], coords[2 * pr + 1],
                    coords[2 * pl], coords[2 * pl + 1],
                    coords[2 * p1], coords[2 * p1 + 1]);

                if (illegal) {
                    triangles[a] = p1;
                    triangles[b] = p0;

                    const hbl = halfedges[bl];

                    // edge swapped on the other side of the hull (rare); fix the halfedge reference
                    if (hbl === -1) {
                        let e = this._hullStart;
                        do {
                            if (this._hullTri[e] === bl) {
                                this._hullTri[e] = a;
                                break;
                            }
                            e = this._hullPrev[e];
                        } while (e !== this._hullStart);
                    }
                    this._link(a, hbl);
                    this._link(b, halfedges[ar]);
                    this._link(ar, bl);

                    const br = b0 + (b + 1) % 3;

                    // don't worry about hitting the cap: it can only happen on extremely degenerate input
                    if (i < EDGE_STACK.length) {
                        EDGE_STACK[i++] = br;
                    }
                } else {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                }
            }

            return ar;
        }

        _link(a, b) {
            this._halfedges[a] = b;
            if (b !== -1) this._halfedges[b] = a;
        }

        // add a new triangle given vertex indices and adjacent half-edge ids
        _addTriangle(i0, i1, i2, a, b, c) {
            const t = this.trianglesLen;

            this._triangles[t] = i0;
            this._triangles[t + 1] = i1;
            this._triangles[t + 2] = i2;

            this._link(t, a);
            this._link(t + 1, b);
            this._link(t + 2, c);

            this.trianglesLen += 3;

            return t;
        }
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    function pseudoAngle(dx, dy) {
        const p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
    }

    function dist(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return dx * dx + dy * dy;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        const dx = ax - px;
        const dy = ay - py;
        const ex = bx - px;
        const ey = by - py;
        const fx = cx - px;
        const fy = cy - py;

        const ap = dx * dx + dy * dy;
        const bp = ex * ex + ey * ey;
        const cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) -
               dy * (ex * cp - bp * fx) +
               ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = (ey * bl - dy * cl) * d;
        const y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = ax + (ey * bl - dy * cl) * d;
        const y = ay + (dx * cl - ex * bl) * d;

        return {x, y};
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (let i = left + 1; i <= right; i++) {
                const temp = ids[i];
                const tempDist = dists[temp];
                let j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
                ids[j + 1] = temp;
            }
        } else {
            const median = (left + right) >> 1;
            let i = left + 1;
            let j = right;
            swap(ids, median, i);
            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

            const temp = ids[i];
            const tempDist = dists[temp];
            while (true) {
                do i++; while (dists[ids[i]] < tempDist);
                do j--; while (dists[ids[j]] > tempDist);
                if (j < i) break;
                swap(ids, i, j);
            }
            ids[left + 1] = ids[j];
            ids[j] = temp;

            if (right - i + 1 >= j - left) {
                quicksort(ids, dists, i, right);
                quicksort(ids, dists, left, j - 1);
            } else {
                quicksort(ids, dists, left, j - 1);
                quicksort(ids, dists, i, right);
            }
        }
    }

    function swap(arr, i, j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultGetX(p) {
        return p[0];
    }
    function defaultGetY(p) {
        return p[1];
    }

    const epsilon$2 = 1e-6;

    class Path {
      constructor() {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
      }
      moveTo(x, y) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x, y) {
        this._ += `L${this._x1 = +x},${this._y1 = +y}`;
      }
      arc(x, y, r) {
        x = +x, y = +y, r = +r;
        const x0 = x + r;
        const y0 = y;
        if (r < 0) throw new Error("negative radius");
        if (this._x1 === null) this._ += `M${x0},${y0}`;
        else if (Math.abs(this._x1 - x0) > epsilon$2 || Math.abs(this._y1 - y0) > epsilon$2) this._ += "L" + x0 + "," + y0;
        if (!r) return;
        this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
      }
      rect(x, y, w, h) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
      }
      value() {
        return this._ || null;
      }
    }

    class Polygon {
      constructor() {
        this._ = [];
      }
      moveTo(x, y) {
        this._.push([x, y]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x, y) {
        this._.push([x, y]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    }

    class Voronoi {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const {delaunay: {points, hull, triangles}, vectors} = this;

        // Compute circumcenters.
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
          const t1 = triangles[i] * 2;
          const t2 = triangles[i + 1] * 2;
          const t3 = triangles[i + 2] * 2;
          const x1 = points[t1];
          const y1 = points[t1 + 1];
          const x2 = points[t2];
          const y2 = points[t2 + 1];
          const x3 = points[t3];
          const y3 = points[t3 + 1];

          const dx = x2 - x1;
          const dy = y2 - y1;
          const ex = x3 - x1;
          const ey = y3 - y1;
          const ab = (dx * ey - dy * ex) * 2;

          if (Math.abs(ab) < 1e-9) {
            // degenerate case (collinear diagram)
            // almost equal points (degenerate triangle)
            // the circumcenter is at the infinity, in a
            // direction that is:
            // 1. orthogonal to the halfedge.
            let a = 1e9;
            // 2. points away from the center; since the list of triangles starts
            // in the center, the first point of the first triangle
            // will be our reference
            const r = triangles[0] * 2;
            a *= Math.sign((points[r] - x1) * ey - (points[r + 1] - y1) * ex);
            x = (x1 + x3) / 2 - a * ey;
            y = (y1 + y3) / 2 + a * ex;
          } else {
            const d = 1 / ab;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x = x1 + (ey * bl - dy * cl) * d;
            y = y1 + (dx * cl - ex * bl) * d;
          }
          circumcenters[j] = x;
          circumcenters[j + 1] = y;
        }

        // Compute exterior cell rays.
        let h = hull[hull.length - 1];
        let p0, p1 = h * 4;
        let x0, x1 = points[2 * h];
        let y0, y1 = points[2 * h + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h = hull[i];
          p0 = p1, x0 = x1, y0 = y1;
          p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
          vectors[p0 + 2] = vectors[p1] = y0 - y1;
          vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
        }
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
        if (hull.length <= 1) return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t = Math.floor(inedges[h1] / 3) * 2;
          const x = circumcenters[t];
          const y = circumcenters[t + 1];
          const v = h0 * 4;
          const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
          if (p) this._renderSegment(x, y, p[0], p[1], context);
        }
        return buffer && buffer.value();
      }
      renderBounds(context) {
        const buffer = context == null ? context = new Path : undefined;
        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const points = this._clip(i);
        if (points === null || !points.length) return;
        context.moveTo(points[0], points[1]);
        let n = points.length;
        while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
        for (let i = 2; i < n; i += 2) {
          if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
            context.lineTo(points[i], points[i + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const {delaunay: {points}} = this;
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const cell = this.cellPolygon(i);
          if (cell) cell.index = i, yield cell;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon;
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x0, y0, x1, y1, context) {
        let S;
        const c0 = this._regioncode(x0, y0);
        const c1 = this._regioncode(x1, y1);
        if (c0 === 0 && c1 === 0) {
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
        } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
          context.moveTo(S[0], S[1]);
          context.lineTo(S[2], S[3]);
        }
      }
      contains(i, x, y) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
        return this.delaunay._step(i, x, y) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci) for (const j of this.delaunay.neighbors(i)) {
          const cj = this._clip(j);
          // find the common edge
          if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
            for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
              if (ci[ai] == cj[aj]
              && ci[ai + 1] == cj[aj + 1]
              && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
              && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
              ) {
                yield j;
                break loop;
              }
            }
          }
        }
      }
      _cell(i) {
        const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
        const e0 = inedges[i];
        if (e0 === -1) return null; // coincident point
        const points = [];
        let e = e0;
        do {
          const t = Math.floor(e / 3);
          points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
        } while (e !== e0 && e !== -1);
        return points;
      }
      _clip(i) {
        // degenerate case (1 valid point: return the box)
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points = this._cell(i);
        if (points === null) return null;
        const {vectors: V} = this;
        const v = i * 4;
        return V[v] || V[v + 1]
            ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
            : this._clipFinite(i, points);
      }
      _clipFinite(i, points) {
        const n = points.length;
        let P = null;
        let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
        let c0, c1 = this._regioncode(x1, y1);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
          c0 = c1, c1 = this._regioncode(x1, y1);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P) P.push(x1, y1);
            else P = [x1, y1];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1) this._edge(i, e0, e1, P, P.length);
              if (P) P.push(sx0, sy0);
              else P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1) this._edge(i, e0, e1, P, P.length);
            if (P) P.push(sx1, sy1);
            else P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x0, y0, x1, y1, c0, c1) {
        while (true) {
          if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
          if (c0 & c1) return null;
          let x, y, c = c0 || c1;
          if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
          else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
          else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
          else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
          if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
          else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
        }
      }
      _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
        let P = Array.from(points), p;
        if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x, y;
          switch (e0) {
            case 0b0101: e0 = 0b0100; continue; // top-left
            case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
            case 0b0110: e0 = 0b0010; continue; // top-right
            case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
            case 0b1010: e0 = 0b1000; continue; // bottom-right
            case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
            case 0b1001: e0 = 0b0001; continue; // bottom-left
            case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
          }
          // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are
          // undefined, the conditional statement will be executed.
          if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
            P.splice(j, 0, x, y), j += 2;
          }
        }
        if (P.length > 4) {
          for (let i = 0; i < P.length; i+= 2) {
            const j = (i + 2) % P.length, k = (i + 4) % P.length;
            if (P[i] === P[j] && P[j] === P[k]
            || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
              P.splice(j, 2), i -= 2;
          }
        }
        return j;
      }
      _project(x0, y0, vx, vy) {
        let t = Infinity, c, x, y;
        if (vy < 0) { // top
          if (y0 <= this.ymin) return null;
          if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
        } else if (vy > 0) { // bottom
          if (y0 >= this.ymax) return null;
          if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
        }
        if (vx > 0) { // right
          if (x0 >= this.xmax) return null;
          if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
        } else if (vx < 0) { // left
          if (x0 <= this.xmin) return null;
          if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
        }
        return [x, y];
      }
      _edgecode(x, y) {
        return (x === this.xmin ? 0b0001
            : x === this.xmax ? 0b0010 : 0b0000)
            | (y === this.ymin ? 0b0100
            : y === this.ymax ? 0b1000 : 0b0000);
      }
      _regioncode(x, y) {
        return (x < this.xmin ? 0b0001
            : x > this.xmax ? 0b0010 : 0b0000)
            | (y < this.ymin ? 0b0100
            : y > this.ymax ? 0b1000 : 0b0000);
      }
    }

    const tau$2 = 2 * Math.PI, pow$2 = Math.pow;

    function pointX(p) {
      return p[0];
    }

    function pointY(p) {
      return p[1];
    }

    // A triangulation is collinear if all its triangles have a non-null area
    function collinear(d) {
      const {triangles, coords} = d;
      for (let i = 0; i < triangles.length; i += 3) {
        const a = 2 * triangles[i],
              b = 2 * triangles[i + 1],
              c = 2 * triangles[i + 2],
              cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                    - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
        if (cross > 1e-10) return false;
      }
      return true;
    }

    function jitter(x, y, r) {
      return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
    }

    class Delaunay {
      static from(points, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points
            ? flatArray(points, fx, fy, that)
            : Float64Array.from(flatIterable(points, fx, fy, that)));
      }
      constructor(points) {
        this._delaunator = new Delaunator(points);
        this.inedges = new Int32Array(points.length / 2);
        this._hullIndex = new Int32Array(points.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points = this.points;

        // check for collinear
        if (d.hull && d.hull.length > 2 && collinear(d)) {
          this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
            .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
          const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
            bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
          for (let i = 0, n = points.length / 2; i < n; ++i) {
            const p = jitter(points[2 * i], points[2 * i + 1], r);
            points[2 * i] = p[0];
            points[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points);
        } else {
          delete this.collinear;
        }

        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);

        // Compute an index from each point to an (arbitrary) incoming halfedge
        // Used to give the first neighbor of each point; for this reason,
        // on the hull we give priority to exterior halfedges
        for (let e = 0, n = halfedges.length; e < n; ++e) {
          const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
          if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }

        // degenerate case: 1 or 2 (distinct) points
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds) {
        return new Voronoi(this, bounds);
      }
      *neighbors(i) {
        const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

        // degenerate case with several collinear points
        if (collinear) {
          const l = collinear.indexOf(i);
          if (l > 0) yield collinear[l - 1];
          if (l < collinear.length - 1) yield collinear[l + 1];
          return;
        }

        const e0 = inedges[i];
        if (e0 === -1) return; // coincident point
        let e = e0, p0 = -1;
        do {
          yield p0 = triangles[e];
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) return; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p0) yield p;
            return;
          }
        } while (e !== e0);
      }
      find(x, y, i = 0) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
        const i0 = i;
        let c;
        while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
        return c;
      }
      _step(i, x, y) {
        const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
        if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
        let c = i;
        let dc = pow$2(x - points[i * 2], 2) + pow$2(y - points[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e = e0;
        do {
          let t = triangles[e];
          const dt = pow$2(x - points[t * 2], 2) + pow$2(y - points[t * 2 + 1], 2);
          if (dt < dc) dc = dt, c = t;
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            e = hull[(_hullIndex[i] + 1) % hull.length];
            if (e !== t) {
              if (pow$2(x - points[e * 2], 2) + pow$2(y - points[e * 2 + 1], 2) < dc) return e;
            }
            break;
          }
        } while (e !== e0);
        return c;
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, halfedges, triangles} = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context.moveTo(points[ti], points[ti + 1]);
          context.lineTo(points[tj], points[tj + 1]);
        }
        this.renderHull(context);
        return buffer && buffer.value();
      }
      renderPoints(context, r) {
        if (r === undefined && (!context || typeof context.moveTo !== "function")) r = context, context = null;
        r = r == undefined ? 2 : +r;
        const buffer = context == null ? context = new Path : undefined;
        const {points} = this;
        for (let i = 0, n = points.length; i < n; i += 2) {
          const x = points[i], y = points[i + 1];
          context.moveTo(x + r, y);
          context.arc(x, y, r, 0, tau$2);
        }
        return buffer && buffer.value();
      }
      renderHull(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {hull, points} = this;
        const h = hull[0] * 2, n = hull.length;
        context.moveTo(points[h], points[h + 1]);
        for (let i = 1; i < n; ++i) {
          const h = 2 * hull[i];
          context.lineTo(points[h], points[h + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon;
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, triangles} = this;
        const t0 = triangles[i *= 3] * 2;
        const t1 = triangles[i + 1] * 2;
        const t2 = triangles[i + 2] * 2;
        context.moveTo(points[t0], points[t0 + 1]);
        context.lineTo(points[t1], points[t1 + 1]);
        context.lineTo(points[t2], points[t2 + 1]);
        context.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const {triangles} = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon;
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    }

    function flatArray(points, fx, fy, that) {
      const n = points.length;
      const array = new Float64Array(n * 2);
      for (let i = 0; i < n; ++i) {
        const p = points[i];
        array[i * 2] = fx.call(that, p, i, points);
        array[i * 2 + 1] = fy.call(that, p, i, points);
      }
      return array;
    }

    function* flatIterable(points, fx, fy, that) {
      let i = 0;
      for (const p of points) {
        yield fx.call(that, p, i, points);
        yield fy.call(that, p, i, points);
        ++i;
      }
    }

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad$1(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear$1(year) {
      return year < 0 ? "-" + pad$1(-year, 6)
        : year > 9999 ? "+" + pad$1(year, 6)
        : pad$1(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
          : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv$1 = dsvFormat(",");

    var csvParse = csv$1.parse;
    var csvParseRows = csv$1.parseRows;
    var csvFormat = csv$1.format;
    var csvFormatBody = csv$1.formatBody;
    var csvFormatRows = csv$1.formatRows;
    var csvFormatRow = csv$1.formatRow;
    var csvFormatValue = csv$1.formatValue;

    var tsv$1 = dsvFormat("\t");

    var tsvParse = tsv$1.parse;
    var tsvParseRows = tsv$1.parseRows;
    var tsvFormat = tsv$1.format;
    var tsvFormatBody = tsv$1.formatBody;
    var tsvFormatRows = tsv$1.formatRows;
    var tsvFormatRow = tsv$1.formatRow;
    var tsvFormatValue = tsv$1.formatValue;

    function autoType(object) {
      for (var key in object) {
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
          if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
          value = new Date(value);
        }
        else continue;
        object[key] = value;
      }
      return object;
    }

    // https://github.com/d3/d3-dsv/issues/45
    const fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function responseBlob(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.blob();
    }

    function blob(input, init) {
      return fetch(input, init).then(responseBlob);
    }

    function responseArrayBuffer(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.arrayBuffer();
    }

    function buffer(input, init) {
      return fetch(input, init).then(responseArrayBuffer);
    }

    function responseText(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.text();
    }

    function text(input, init) {
      return fetch(input, init).then(responseText);
    }

    function dsvParse(parse) {
      return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return text(input, init).then(function(response) {
          return parse(response, row);
        });
      };
    }

    function dsv(delimiter, input, init, row) {
      if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
      var format = dsvFormat(delimiter);
      return text(input, init).then(function(response) {
        return format.parse(response, row);
      });
    }

    var csv = dsvParse(csvParse);
    var tsv = dsvParse(tsvParse);

    function image(input, init) {
      return new Promise(function(resolve, reject) {
        var image = new Image;
        for (var key in init) image[key] = init[key];
        image.onerror = reject;
        image.onload = function() { resolve(image); };
        image.src = input;
      });
    }

    function responseJson(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      if (response.status === 204 || response.status === 205) return;
      return response.json();
    }

    function json(input, init) {
      return fetch(input, init).then(responseJson);
    }

    function parser(type) {
      return (input, init) => text(input, init)
        .then(text => (new DOMParser).parseFromString(text, type));
    }

    var xml = parser("application/xml");

    var html = parser("text/html");

    var svg = parser("image/svg+xml");

    function center(x, y) {
      var nodes, strength = 1;

      if (x == null) x = 0;
      if (y == null) y = 0;

      function force() {
        var i,
            n = nodes.length,
            node,
            sx = 0,
            sy = 0;

        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }

        for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }

      force.initialize = function(_) {
        nodes = _;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      return force;
    }

    function tree_add(d) {
      const x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add(this.cover(x, y), x, y, d);
    }

    function add(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries dont change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0 || 1,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant cant contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isnt necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function constant$4(x) {
      return function() {
        return x;
      };
    }

    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }

    function x$3(d) {
      return d.x + d.vx;
    }

    function y$3(d) {
      return d.y + d.vy;
    }

    function collide(radius) {
      var nodes,
          radii,
          random,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant$4(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$3, y$3).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(random), l += x * x;
                if (y === 0) y = jiggle(random), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index$3(d) {
      return d.index;
    }

    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("node not found: " + nodeId);
      return node;
    }

    function link$2(links) {
      var id = index$3,
          strength = defaultStrength,
          strengths,
          distance = constant$4(30),
          distances,
          nodes,
          count,
          bias,
          random,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle(random);
            y = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$4(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$1 = 1664525;
    const c$3 = 1013904223;
    const m = 4294967296; // 2^32

    function lcg$1() {
      let s = 1;
      return () => (s = (a$1 * s + c$3) % m) / m;
    }

    function x$2(d) {
      return d.x;
    }

    function y$2(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function simulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = new Map(),
          stepper = timer(step),
          event = dispatch("tick", "end"),
          random = lcg$1();

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.forEach(function(force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes, random);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function manyBody() {
      var nodes,
          node,
          random,
          alpha,
          strength = constant$4(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x$2, y$2).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function radial$1(radius, x, y) {
      var nodes,
          strength = constant$4(0.1),
          strengths,
          radiuses;

      if (typeof radius !== "function") radius = constant$4(+radius);
      if (x == null) x = 0;
      if (y == null) y = 0;

      function force(alpha) {
        for (var i = 0, n = nodes.length; i < n; ++i) {
          var node = nodes[i],
              dx = node.x - x || 1e-6,
              dy = node.y - y || 1e-6,
              r = Math.sqrt(dx * dx + dy * dy),
              k = (radiuses[i] - r) * strengths[i] * alpha / r;
          node.vx += dx * k;
          node.vy += dy * k;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for (i = 0; i < n; ++i) {
          radiuses[i] = +radius(nodes[i], i, nodes);
          strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _, initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function x$1(x) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant$4(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : x;
      };

      return force;
    }

    function y$1(y) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant$4(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : y;
      };

      return force;
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };

    function identity$6(x) {
      return x;
    }

    var map = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale$1(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$6 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$6 : formatNumerals(map.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer value part that can be
            // grouped, and fractional or exponential suffix part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format;
    var formatPrefix;

    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    var epsilon$1 = 1e-6;
    var epsilon2 = 1e-12;
    var pi$1 = Math.PI;
    var halfPi$1 = pi$1 / 2;
    var quarterPi = pi$1 / 4;
    var tau$1 = pi$1 * 2;

    var degrees = 180 / pi$1;
    var radians = pi$1 / 180;

    var abs$1 = Math.abs;
    var atan = Math.atan;
    var atan2$1 = Math.atan2;
    var cos$1 = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;
    var hypot = Math.hypot;
    var log$1 = Math.log;
    var pow$1 = Math.pow;
    var sin$1 = Math.sin;
    var sign$1 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$2 = Math.sqrt;
    var tan = Math.tan;

    function acos$1(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin$1(x) {
      return x > 1 ? halfPi$1 : x < -1 ? -halfPi$1 : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin$1(x / 2)) * x;
    }

    function noop$2() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    var areaRingSum$1 = new Adder();

    // hello?

    var areaSum$1 = new Adder(),
        lambda00$2,
        phi00$2,
        lambda0$2,
        cosPhi0$1,
        sinPhi0$1;

    var areaStream$1 = {
      point: noop$2,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: function() {
        areaRingSum$1 = new Adder();
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum$1;
        areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$2;
      },
      sphere: function() {
        areaSum$1.add(tau$1);
      }
    };

    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }

    function areaRingEnd$1() {
      areaPoint$1(lambda00$2, phi00$2);
    }

    function areaPointFirst$1(lambda, phi) {
      areaStream$1.point = areaPoint$1;
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians, phi *= radians;
      lambda0$2 = lambda, cosPhi0$1 = cos$1(phi = phi / 2 + quarterPi), sinPhi0$1 = sin$1(phi);
    }

    function areaPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      phi = phi / 2 + quarterPi; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnolis
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0$2,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos$1(phi),
          sinPhi = sin$1(phi),
          k = sinPhi0$1 * sinPhi,
          u = cosPhi0$1 * cosPhi + k * cos$1(adLambda),
          v = k * sdLambda * sin$1(adLambda);
      areaRingSum$1.add(atan2$1(v, u));

      // Advance the previous points.
      lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
    }

    function area$2(object) {
      areaSum$1 = new Adder();
      geoStream(object, areaStream$1);
      return areaSum$1 * 2;
    }

    function spherical(cartesian) {
      return [atan2$1(cartesian[1], cartesian[0]), asin$1(cartesian[2])];
    }

    function cartesian(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
      return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0, // previous 3D point
        deltaSum,
        ranges,
        range$1;

    var boundsStream$1 = {
      point: boundsPoint$1,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$1.point = boundsRingPoint;
        boundsStream$1.lineStart = boundsRingStart;
        boundsStream$1.lineEnd = boundsRingEnd;
        deltaSum = new Adder();
        areaStream$1.polygonStart();
      },
      polygonEnd: function() {
        areaStream$1.polygonEnd();
        boundsStream$1.point = boundsPoint$1;
        boundsStream$1.lineStart = boundsLineStart;
        boundsStream$1.lineEnd = boundsLineEnd;
        if (areaRingSum$1 < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$1) phi1 = 90;
        else if (deltaSum < -epsilon$1) phi0 = -90;
        range$1[0] = lambda0$1, range$1[1] = lambda1;
      },
      sphere: function() {
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };

    function boundsPoint$1(lambda, phi) {
      ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian([lambda * radians, phi * radians]);
      if (p0) {
        var normal = cartesianCross(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical(inflection);
        var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees * sign,
            phii,
            antimeridian = abs$1(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = inflection[1] * degrees;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = -inflection[1] * degrees;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream$1.point = linePoint;
    }

    function boundsLineEnd() {
      range$1[0] = lambda0$1, range$1[1] = lambda1;
      boundsStream$1.point = boundsPoint$1;
      p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream$1.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream$1.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream$1.lineEnd();
      if (abs$1(deltaSum) > epsilon$1) lambda0$1 = -(lambda1 = 180);
      range$1[0] = lambda0$1, range$1[1] = lambda1;
      p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
    // the distance between 180 to be 360.
    function angle(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range, x) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function bounds(feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream(feature, boundsStream$1);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range$1 = null;

      return lambda0$1 === Infinity || phi0 === Infinity
          ? [[NaN, NaN], [NaN, NaN]]
          : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1,
        X0$1, Y0$1, Z0$1,
        X1$1, Y1$1, Z1$1,
        X2$1, Y2$1, Z2$1,
        lambda00, phi00, // first point
        x0$4, y0$4, z0; // previous point

    var centroidStream$1 = {
      sphere: noop$2,
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function() {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function() {
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0$1 += (x - X0$1) / W0;
      Y0$1 += (y - Y0$1) / W0;
      Z0$1 += (z - Z0$1) / W0;
    }

    function centroidLineStart$1() {
      centroidStream$1.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidStream$1.point = centroidLinePoint;
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          w = atan2$1(sqrt$2((w = y0$4 * z - z0 * y) * w + (w = z0 * x - x0$4 * z) * w + (w = x0$4 * y - y0$4 * x) * w), x0$4 * x + y0$4 * y + z0 * z);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart$1() {
      centroidStream$1.point = centroidRingPointFirst;
    }

    function centroidRingEnd$1() {
      centroidRingPoint(lambda00, phi00);
      centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00 = lambda, phi00 = phi;
      lambda *= radians, phi *= radians;
      centroidStream$1.point = centroidRingPoint;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          cx = y0$4 * z - z0 * y,
          cy = z0 * x - x0$4 * z,
          cz = x0$4 * y - y0$4 * x,
          m = hypot(cx, cy, cz),
          w = asin$1(m), // line weight = angle
          v = m && -w / m; // area weight multiplier
      X2$1.add(v * cx);
      Y2$1.add(v * cy);
      Z2$1.add(v * cz);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroid$1(object) {
      W0 = W1 =
      X0$1 = Y0$1 = Z0$1 =
      X1$1 = Y1$1 = Z1$1 = 0;
      X2$1 = new Adder();
      Y2$1 = new Adder();
      Z2$1 = new Adder();
      geoStream(object, centroidStream$1);

      var x = +X2$1,
          y = +Y2$1,
          z = +Z2$1,
          m = hypot(x, y, z);

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2) {
        x = X1$1, y = Y1$1, z = Z1$1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon$1) x = X0$1, y = Y0$1, z = Z0$1;
        m = hypot(x, y, z);
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2) return [NaN, NaN];
      }

      return [atan2$1(y, x) * degrees, asin$1(z / m) * degrees];
    }

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    function compose(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity(lambda, phi) {
      return [abs$1(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$1) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
        : rotationLambda(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
        : rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$1(deltaPhi),
          sinDeltaPhi = sin$1(deltaPhi),
          cosDeltaGamma = cos$1(deltaGamma),
          sinDeltaGamma = sin$1(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2$1(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin$1(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2$1(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin$1(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    function rotation(rotate) {
      rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }

      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };

      return forward;
    }

    // Generates a circle centered at [0, 0], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos$1(radius),
          sinRadius = sin$1(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau$1;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$1;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos$1(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau$1 - epsilon$1) % tau$1;
    }

    function circle$2() {
      var center = constant$3([0, 0]),
          radius = constant$3(90),
          precision = constant$3(6),
          ring,
          rotate,
          stream = {point: point};

      function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= degrees, x[1] *= degrees;
      }

      function circle() {
        var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * radians,
            p = precision.apply(this, arguments) * radians;
        ring = [];
        rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
        circleStream(stream, r, p, 1);
        c = {type: "Polygon", coordinates: [ring]};
        ring = rotate = null;
        return c;
      }

      circle.center = function(_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : constant$3([+_[0], +_[1]]), circle) : center;
      };

      circle.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$3(+_), circle) : radius;
      };

      circle.precision = function(_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : constant$3(+_), circle) : precision;
      };

      return circle;
    }

    function clipBuffer() {
      var lines = [],
          line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$2,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function pointEqual(a, b) {
      return abs$1(a[0] - b[0]) < epsilon$1 && abs$1(a[1] - b[1]) < epsilon$1;
    }

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        if (pointEqual(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          // handle degenerate cases by moving the point
          p1[0] += 2 * epsilon$1;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link$1(subject);
      link$1(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link$1(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    function longitude(point) {
      return abs$1(point[0]) <= pi$1 ? point[0] : sign$1(point[0]) * ((abs$1(point[0]) + pi$1) % tau$1 - pi$1);
    }

    function polygonContains(polygon, point) {
      var lambda = longitude(point),
          phi = point[1],
          sinPhi = sin$1(phi),
          normal = [sin$1(lambda), -cos$1(lambda), 0],
          angle = 0,
          winding = 0;

      var sum = new Adder();

      if (sinPhi === 1) phi = halfPi$1 + epsilon$1;
      else if (sinPhi === -1) phi = -halfPi$1 - epsilon$1;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = longitude(point0),
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin$1(phi0),
            cosPhi0 = cos$1(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = longitude(point1),
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin$1(phi1),
              cosPhi1 = cos$1(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi$1,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2$1(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
          angle += antimeridian ? delta + sign * tau$1 : delta;

          // Are the longitudes either side of the points meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon$1 || angle < epsilon$1 && sum < -epsilon2) ^ (winding & 1);
    }

    function clip(pointVisible, clipLine, interpolate, start) {
      return function(sink) {
        var line = clipLine(sink),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge(segments);
            var startInside = polygonContains(polygon, start);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    }

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi$1 - epsilon$1 : halfPi$1 - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$1 : halfPi$1 - b[1]);
    }

    var clipAntimeridian = clip(
      function() { return true; },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$1, -halfPi$1]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$1 : -pi$1,
              delta = abs$1(lambda1 - lambda0);
          if (abs$1(delta - pi$1) < epsilon$1) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$1 : -halfPi$1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$1) { // line crosses antimeridian
            if (abs$1(lambda0 - sign0) < epsilon$1) lambda0 -= sign0 * epsilon$1; // handle degeneracies
            if (abs$1(lambda1 - sign1) < epsilon$1) lambda1 -= sign1 * epsilon$1;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
      return abs$1(sinLambda0Lambda1) > epsilon$1
          ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
              - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi$1;
        stream.point(-pi$1, phi);
        stream.point(0, phi);
        stream.point(pi$1, phi);
        stream.point(pi$1, 0);
        stream.point(pi$1, -phi);
        stream.point(0, -phi);
        stream.point(-pi$1, -phi);
        stream.point(-pi$1, 0);
        stream.point(-pi$1, phi);
      } else if (abs$1(from[0] - to[0]) > epsilon$1) {
        var lambda = from[0] < to[0] ? pi$1 : -pi$1;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle(radius) {
      var cr = cos$1(radius),
          delta = 6 * radians,
          smallRadius = cr > 0,
          notHemisphere = abs$1(cr) > epsilon$1; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos$1(lambda) * cos$1(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian(a),
            pb = cartesian(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross(pa, pb),
            n2n2 = cartesianDot(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot(A, u),
            uu = cartesianDot(u, u),
            t2 = w * w - uu * (cartesianDot(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt$2(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs$1(delta - pi$1) < epsilon$1,
            meridian = polar || delta < epsilon$1;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon$1 ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi$1 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi$1 - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
    }

    function clipLine(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    var clipMax = 1e9, clipMin = -clipMax;

    // TODO Use d3-polygons polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs$1(p[0] - x0) < epsilon$1 ? direction > 0 ? 0 : 3
            : abs$1(p[0] - x1) < epsilon$1 ? direction > 0 ? 2 : 1
            : abs$1(p[1] - y0) < epsilon$1 ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    function extent() {
      var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip;

      return clip = {
        stream: function(stream) {
          return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function(_) {
          return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
        }
      };
    }

    var lengthSum$1,
        lambda0,
        sinPhi0,
        cosPhi0;

    var lengthStream$1 = {
      sphere: noop$2,
      point: noop$2,
      lineStart: lengthLineStart,
      lineEnd: noop$2,
      polygonStart: noop$2,
      polygonEnd: noop$2
    };

    function lengthLineStart() {
      lengthStream$1.point = lengthPointFirst$1;
      lengthStream$1.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream$1.point = lengthStream$1.lineEnd = noop$2;
    }

    function lengthPointFirst$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      lambda0 = lambda, sinPhi0 = sin$1(phi), cosPhi0 = cos$1(phi);
      lengthStream$1.point = lengthPoint$1;
    }

    function lengthPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var sinPhi = sin$1(phi),
          cosPhi = cos$1(phi),
          delta = abs$1(lambda - lambda0),
          cosDelta = cos$1(delta),
          sinDelta = sin$1(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
      lengthSum$1.add(atan2$1(sqrt$2(x * x + y * y), z));
      lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
    }

    function length$1(object) {
      lengthSum$1 = new Adder();
      geoStream(object, lengthStream$1);
      return +lengthSum$1;
    }

    var coordinates = [null, null],
        object = {type: "LineString", coordinates: coordinates};

    function distance(a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length$1(object);
    }

    var containsObjectType = {
      Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function(object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type)
          ? containsGeometryType[geometry.type](geometry, point)
          : false;
    }

    function containsPoint(coordinates, point) {
      return distance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ao, bo, ab;
      for (var i = 0, n = coordinates.length; i < n; i++) {
        bo = distance(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
          ab = distance(coordinates[i], coordinates[i - 1]);
          if (
            ab > 0 &&
            ao <= ab &&
            bo <= ab &&
            (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
          )
            return true;
        }
        ao = bo;
      }
      return false;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }

    function contains$1(object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type)
          ? containsObjectType[object.type]
          : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
      var y = range$3(y0, y1 - epsilon$1, dy).concat(y1);
      return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
      var x = range$3(x0, x1 - epsilon$1, dx).concat(x1);
      return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
      var x1, x0, X1, X0,
          y1, y0, Y1, Y0,
          dx = 10, dy = dx, DX = 90, DY = 360,
          x, y, X, Y,
          precision = 2.5;

      function graticule() {
        return {type: "MultiLineString", coordinates: lines()};
      }

      function lines() {
        return range$3(ceil(X0 / DX) * DX, X1, DX).map(X)
            .concat(range$3(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
            .concat(range$3(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$1(x % DX) > epsilon$1; }).map(x))
            .concat(range$3(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$1(y % DY) > epsilon$1; }).map(y));
      }

      graticule.lines = function() {
        return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
      };

      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X(X0).concat(
            Y(Y1).slice(1),
            X(X1).reverse().slice(1),
            Y(Y0).reverse().slice(1))
          ]
        };
      };

      graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function(_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function(_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function(_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function(_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule
          .extentMajor([[-180, -90 + epsilon$1], [180, 90 - epsilon$1]])
          .extentMinor([[-180, -80 - epsilon$1], [180, 80 + epsilon$1]]);
    }

    function graticule10() {
      return graticule()();
    }

    function interpolate(a, b) {
      var x0 = a[0] * radians,
          y0 = a[1] * radians,
          x1 = b[0] * radians,
          y1 = b[1] * radians,
          cy0 = cos$1(y0),
          sy0 = sin$1(y0),
          cy1 = cos$1(y1),
          sy1 = sin$1(y1),
          kx0 = cy0 * cos$1(x0),
          ky0 = cy0 * sin$1(x0),
          kx1 = cy1 * cos$1(x1),
          ky1 = cy1 * sin$1(x1),
          d = 2 * asin$1(sqrt$2(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin$1(d);

      var interpolate = d ? function(t) {
        var B = sin$1(t *= d) / k,
            A = sin$1(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [
          atan2$1(y, x) * degrees,
          atan2$1(z, sqrt$2(x * x + y * y)) * degrees
        ];
      } : function() {
        return [x0 * degrees, y0 * degrees];
      };

      interpolate.distance = d;

      return interpolate;
    }

    var identity$5 = x => x;

    var areaSum = new Adder(),
        areaRingSum = new Adder(),
        x00$2,
        y00$2,
        x0$3,
        y0$3;

    var areaStream = {
      point: noop$2,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$2;
        areaSum.add(abs$1(areaRingSum));
        areaRingSum = new Adder();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum = new Adder();
        return area;
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00$2 = x0$3 = x, y00$2 = y0$3 = y;
    }

    function areaPoint(x, y) {
      areaRingSum.add(y0$3 * x - x0$3 * y);
      x0$3 = x, y0$3 = y;
    }

    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }

    var x0$2 = Infinity,
        y0$2 = x0$2,
        x1 = -x0$2,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$2,
      lineEnd: noop$2,
      polygonStart: noop$2,
      polygonEnd: noop$2,
      result: function() {
        var bounds = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0$2) x0$2 = x;
      if (x > x1) x1 = x;
      if (y < y0$2) y0$2 = y;
      if (y > y1) y1 = y;
    }

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00$1,
        y00$1,
        x0$1,
        y0$1;

    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
            : Z1 ? [X1 / Z1, Y1 / Z1]
            : Z0 ? [X0 / Z0, Y0 / Z0]
            : [NaN, NaN];
        X0 = Y0 = Z0 =
        X1 = Y1 = Z1 =
        X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };

    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$1, dy = y - y0$1, z = sqrt$2(dx * dx + dy * dy);
      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }

    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$1 = x, y00$1 = y0$1 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$1,
          dy = y - y0$1,
          z = sqrt$2(dx * dx + dy * dy);

      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;

      z = y0$1 * x - x0$1 * y;
      X2 += z * (x0$1 + x);
      Y2 += z * (y0$1 + y);
      Z2 += z * 3;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$1);
            break;
          }
        }
      },
      result: noop$2
    };

    var lengthSum = new Adder(),
        lengthRing,
        x00,
        y00,
        x0,
        y0;

    var lengthStream = {
      point: noop$2,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing) lengthPoint(x00, y00);
        lengthStream.point = noop$2;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length = +lengthSum;
        lengthSum = new Adder();
        return length;
      }
    };

    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00 = x0 = x, y00 = y0 = y;
    }

    function lengthPoint(x, y) {
      x0 -= x, y0 -= y;
      lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
      x0 = x, y0 = y;
    }

    function PathString() {
      this._string = [];
    }

    PathString.prototype = {
      _radius: 4.5,
      _circle: circle$1(4.5),
      pointRadius: function(_) {
        if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._string.push("Z");
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x, ",", y);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x, ",", y);
            break;
          }
          default: {
            if (this._circle == null) this._circle = circle$1(this._radius);
            this._string.push("M", x, ",", y, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };

    function circle$1(radius) {
      return "m0," + radius
          + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
          + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
          + "z";
    }

    function index$2(projection, context) {
      var pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function(object) {
        geoStream(object, projectionStream(areaStream));
        return areaStream.result();
      };

      path.measure = function(object) {
        geoStream(object, projectionStream(lengthStream));
        return lengthStream.result();
      };

      path.bounds = function(object) {
        geoStream(object, projectionStream(boundsStream));
        return boundsStream.result();
      };

      path.centroid = function(object) {
        geoStream(object, projectionStream(centroidStream));
        return centroidStream.result();
      };

      path.projection = function(_) {
        return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$5) : (projection = _).stream, path) : projection;
      };

      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      return path.projection(projection).context(context);
    }

    function transform$1(methods) {
      return {
        stream: transformer$3(methods)
      };
    }

    function transformer$3(methods) {
      return function(stream) {
        var s = new TransformStream;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
      var clip = projection.clipExtent && projection.clipExtent();
      projection.scale(150).translate([0, 0]);
      if (clip != null) projection.clipExtent(null);
      geoStream(object, projection.stream(boundsStream));
      fitBounds(boundsStream.result());
      if (clip != null) projection.clipExtent(clip);
      return projection;
    }

    function fitExtent(projection, extent, object) {
      return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    function fitWidth(projection, width, object) {
      return fit(projection, function(b) {
        var w = +width,
            k = w / (b[1][0] - b[0][0]),
            x = (w - k * (b[1][0] + b[0][0])) / 2,
            y = -k * b[0][1];
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitHeight(projection, height, object) {
      return fit(projection, function(b) {
        var h = +height,
            k = h / (b[1][1] - b[0][1]),
            x = -k * b[0][0],
            y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
      return transformer$3({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt$2(a * a + b * b + c * c),
              phi2 = asin$1(c /= m),
              lambda2 = abs$1(abs$1(c) - 1) < epsilon$1 || abs$1(lambda0 - lambda1) < epsilon$1 ? (lambda0 + lambda1) / 2 : atan2$1(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer$3({
      point: function(x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });

    function transformRotate(rotate) {
      return transformer$3({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx; y *= sy;
        return [dx + k * x, dy - k * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k * sx, (dy - y) / k * sy];
      };
      return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
      var cosAlpha = cos$1(alpha),
          sinAlpha = sin$1(alpha),
          a = cosAlpha * k,
          b = sinAlpha * k,
          ai = cosAlpha / k,
          bi = sinAlpha / k,
          ci = (sinAlpha * dy - cosAlpha * dx) / k,
          fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform(x, y) {
        x *= sx; y *= sy;
        return [a * x - b * y + dx, dy - b * x - a * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }

    function projection(project) {
      return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
          alpha = 0, // post-rotate angle
          sx = 1, // reflectX
          sy = 1, // reflectX
          theta = null, preclip = clipAntimeridian, // pre-clip angle
          x0 = null, y0, x1, y1, postclip = identity$5, // post-clip extent
          delta2 = 0.5, // precision
          projectResample,
          projectTransform,
          projectRotateTransform,
          cache,
          cacheStream;

      function projection(point) {
        return projectRotateTransform(point[0] * radians, point[1] * radians);
      }

      function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [point[0] * degrees, point[1] * degrees];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };

      projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
      };

      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };

      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
      };

      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };

      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$2(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };

      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };

      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
            transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project, transform);
        projectRotateTransform = compose(rotate, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function conicProjection(projectAt) {
      var phi0 = 0,
          phi1 = pi$1 / 3,
          m = projectionMutator(projectAt),
          p = m(phi0, phi1);

      p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
      };

      return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos$1(phi0);

      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
      }

      forward.invert = function(x, y) {
        return [x / cosPhi0, asin$1(y * cosPhi0)];
      };

      return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
      var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

      // Are the parallels symmetrical around the Equator?
      if (abs$1(n) < epsilon$1) return cylindricalEqualAreaRaw(y0);

      var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c) / n;

      function project(x, y) {
        var r = sqrt$2(c - 2 * n * sin$1(y)) / n;
        return [r * sin$1(x *= n), r0 - r * cos$1(x)];
      }

      project.invert = function(x, y) {
        var r0y = r0 - y,
            l = atan2$1(x, abs$1(r0y)) * sign$1(r0y);
        if (r0y * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(r0y);
        return [l / n, asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };

      return project;
    }

    function conicEqualArea() {
      return conicProjection(conicEqualAreaRaw)
          .scale(155.424)
          .center([0, 33.6442]);
    }

    function albers() {
      return conicEqualArea()
          .parallels([29.5, 45.5])
          .scale(1070)
          .translate([480, 250])
          .rotate([96, 0])
          .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
        sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
        lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
        lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
        polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
        polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
      };
    }

    // A composite projection for the United States, configured by default for
    // 960500. The projection also works quite well at 960600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa() {
      var cache,
          cacheStream,
          lower48 = albers(), lower48Point,
          alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
          hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
          point, pointStream = {point: function(x, y) { point = [x, y]; }};

      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point = null,
            (lower48Point.point(x, y), point)
            || (alaskaPoint.point(x, y), point)
            || (hawaiiPoint.point(x, y), point);
      }

      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k;
        return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
            : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
            : lower48).invert(coordinates);
      };

      albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };

      albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };

      albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };

      albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];

        lower48Point = lower48
            .translate(_)
            .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
            .stream(pointStream);

        alaskaPoint = alaska
            .translate([x - 0.307 * k, y + 0.201 * k])
            .clipExtent([[x - 0.425 * k + epsilon$1, y + 0.120 * k + epsilon$1], [x - 0.214 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        hawaiiPoint = hawaii
            .translate([x - 0.205 * k, y + 0.212 * k])
            .clipExtent([[x - 0.214 * k + epsilon$1, y + 0.166 * k + epsilon$1], [x - 0.115 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        return reset();
      };

      albersUsa.fitExtent = function(extent, object) {
        return fitExtent(albersUsa, extent, object);
      };

      albersUsa.fitSize = function(size, object) {
        return fitSize(albersUsa, size, object);
      };

      albersUsa.fitWidth = function(width, object) {
        return fitWidth(albersUsa, width, object);
      };

      albersUsa.fitHeight = function(height, object) {
        return fitHeight(albersUsa, height, object);
      };

      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }

      return albersUsa.scale(1070);
    }

    function azimuthalRaw(scale) {
      return function(x, y) {
        var cx = cos$1(x),
            cy = cos$1(y),
            k = scale(cx * cy);
            if (k === Infinity) return [2, 0];
        return [
          k * cy * sin$1(x),
          k * sin$1(y)
        ];
      }
    }

    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt$2(x * x + y * y),
            c = angle(z),
            sc = sin$1(c),
            cc = cos$1(c);
        return [
          atan2$1(x * sc, z * cc),
          asin$1(z && y * sc / z)
        ];
      }
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt$2(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin$1(z / 2);
    });

    function azimuthalEqualArea() {
      return projection(azimuthalEqualAreaRaw)
          .scale(124.75)
          .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
      return (c = acos$1(c)) && c / sin$1(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });

    function azimuthalEquidistant() {
      return projection(azimuthalEquidistantRaw)
          .scale(79.4188)
          .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
      return [lambda, log$1(tan((halfPi$1 + phi) / 2))];
    }

    mercatorRaw.invert = function(x, y) {
      return [x, 2 * atan(exp(y)) - halfPi$1];
    };

    function mercator() {
      return mercatorProjection(mercatorRaw)
          .scale(961 / tau$1);
    }

    function mercatorProjection(project) {
      var m = projection(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null, y0, x1, y1; // clip extent

      m.scale = function(_) {
        return arguments.length ? (scale(_), reclip()) : scale();
      };

      m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };

      m.center = function(_) {
        return arguments.length ? (center(_), reclip()) : center();
      };

      m.clipExtent = function(_) {
        return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      function reclip() {
        var k = pi$1 * scale(),
            t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x0 == null
            ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
            ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
            : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
      }

      return reclip();
    }

    function tany(y) {
      return tan((halfPi$1 + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : log$1(cy0 / cos$1(y1)) / log$1(tany(y1) / tany(y0)),
          f = cy0 * pow$1(tany(y0), n) / n;

      if (!n) return mercatorRaw;

      function project(x, y) {
        if (f > 0) { if (y < -halfPi$1 + epsilon$1) y = -halfPi$1 + epsilon$1; }
        else { if (y > halfPi$1 - epsilon$1) y = halfPi$1 - epsilon$1; }
        var r = f / pow$1(tany(y), n);
        return [r * sin$1(n * x), f - r * cos$1(n * x)];
      }

      project.invert = function(x, y) {
        var fy = f - y, r = sign$1(n) * sqrt$2(x * x + fy * fy),
          l = atan2$1(x, abs$1(fy)) * sign$1(fy);
        if (fy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(fy);
        return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi$1];
      };

      return project;
    }

    function conicConformal() {
      return conicProjection(conicConformalRaw)
          .scale(109.5)
          .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    function equirectangular() {
      return projection(equirectangularRaw)
          .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
          g = cy0 / n + y0;

      if (abs$1(n) < epsilon$1) return equirectangularRaw;

      function project(x, y) {
        var gy = g - y, nx = n * x;
        return [gy * sin$1(nx), g - gy * cos$1(nx)];
      }

      project.invert = function(x, y) {
        var gy = g - y,
            l = atan2$1(x, abs$1(gy)) * sign$1(gy);
        if (gy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(gy);
        return [l / n, g - sign$1(n) * sqrt$2(x * x + gy * gy)];
      };

      return project;
    }

    function conicEquidistant() {
      return conicProjection(conicEquidistantRaw)
          .scale(131.154)
          .center([0, 13.9389]);
    }

    var A1 = 1.340264,
        A2 = -0.081106,
        A3 = 0.000893,
        A4 = 0.003796,
        M = sqrt$2(3) / 2,
        iterations = 12;

    function equalEarthRaw(lambda, phi) {
      var l = asin$1(M * sin$1(phi)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
      ];
    }

    equalEarthRaw.invert = function(x, y) {
      var l = y, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs$1(delta) < epsilon2) break;
      }
      return [
        M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
        asin$1(sin$1(l) / M)
      ];
    };

    function equalEarth() {
      return projection(equalEarthRaw)
          .scale(177.158);
    }

    function gnomonicRaw(x, y) {
      var cy = cos$1(y), k = cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert(atan);

    function gnomonic() {
      return projection(gnomonicRaw)
          .scale(144.049)
          .clipAngle(60);
    }

    function identity$4() {
      var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
          alpha = 0, ca, sa, // angle
          x0 = null, y0, x1, y1, // clip extent
          kx = 1, ky = 1,
          transform = transformer$3({
            point: function(x, y) {
              var p = projection([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }),
          postclip = identity$5,
          cache,
          cacheStream;

      function reset() {
        kx = k * sx;
        ky = k * sy;
        cache = cacheStream = null;
        return projection;
      }

      function projection (p) {
        var x = p[0] * kx, y = p[1] * ky;
        if (alpha) {
          var t = y * ca - x * sa;
          x = x * ca + y * sa;
          y = t;
        }    
        return [x + tx, y + ty];
      }
      projection.invert = function(p) {
        var x = p[0] - tx, y = p[1] - ty;
        if (alpha) {
          var t = y * ca + x * sa;
          x = x * ca - y * sa;
          y = t;
        }
        return [x / kx, y / ky];
      };
      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
      };
      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };
      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };
      projection.scale = function(_) {
        return arguments.length ? (k = +_, reset()) : k;
      };
      projection.translate = function(_) {
        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
      };
      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, sa = sin$1(alpha), ca = cos$1(alpha), reset()) : alpha * degrees;
      };
      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
      };
      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
      };
      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };
      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };
      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };
      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      return projection;
    }

    function naturalEarth1Raw(lambda, phi) {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      return [
        lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
        phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
      ];
    }

    naturalEarth1Raw.invert = function(x, y) {
      var phi = y, i = 25, delta;
      do {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
            (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
      } while (abs$1(delta) > epsilon$1 && --i > 0);
      return [
        x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
        phi
      ];
    };

    function naturalEarth1() {
      return projection(naturalEarth1Raw)
          .scale(175.295);
    }

    function orthographicRaw(x, y) {
      return [cos$1(y) * sin$1(x), sin$1(y)];
    }

    orthographicRaw.invert = azimuthalInvert(asin$1);

    function orthographic() {
      return projection(orthographicRaw)
          .scale(249.5)
          .clipAngle(90 + epsilon$1);
    }

    function stereographicRaw(x, y) {
      var cy = cos$1(y), k = 1 + cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });

    function stereographic() {
      return projection(stereographicRaw)
          .scale(250)
          .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
      return [log$1(tan((halfPi$1 + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function(x, y) {
      return [-y, 2 * atan(exp(x)) - halfPi$1];
    };

    function transverseMercator() {
      var m = mercatorProjection(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate;

      m.center = function(_) {
        return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
      };

      m.rotate = function(_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };

      return rotate([0, 0, 90])
          .scale(159.155);
    }

    function defaultSeparation$1(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    function meanX(children) {
      return children.reduce(meanXReduce, 0) / children.length;
    }

    function meanXReduce(x, c) {
      return x + c.x;
    }

    function maxY(children) {
      return 1 + children.reduce(maxYReduce, 0);
    }

    function maxYReduce(y, c) {
      return Math.max(y, c.y);
    }

    function leafLeft(node) {
      var children;
      while (children = node.children) node = children[0];
      return node;
    }

    function leafRight(node) {
      var children;
      while (children = node.children) node = children[children.length - 1];
      return node;
    }

    function cluster() {
      var separation = defaultSeparation$1,
          dx = 1,
          dy = 1,
          nodeSize = false;

      function cluster(root) {
        var previousNode,
            x = 0;

        // First walk, computing the initial x & y values.
        root.eachAfter(function(node) {
          var children = node.children;
          if (children) {
            node.x = meanX(children);
            node.y = maxY(children);
          } else {
            node.x = previousNode ? x += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });

        var left = leafLeft(root),
            right = leafRight(root),
            x0 = left.x - separation(left, right) / 2,
            x1 = right.x + separation(right, left) / 2;

        // Second walk, normalizing x & y to the desired size.
        return root.eachAfter(nodeSize ? function(node) {
          node.x = (node.x - root.x) * dx;
          node.y = (root.y - node.y) * dy;
        } : function(node) {
          node.x = (node.x - x0) / (x1 - x0) * dx;
          node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
        });
      }

      cluster.separation = function(x) {
        return arguments.length ? (separation = x, cluster) : separation;
      };

      cluster.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
      };

      cluster.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
      };

      return cluster;
    }

    function count(node) {
      var sum = 0,
          children = node.children,
          i = children && children.length;
      if (!i) sum = 1;
      else while (--i >= 0) sum += children[i].value;
      node.value = sum;
    }

    function node_count() {
      return this.eachAfter(count);
    }

    function node_each(callback, that) {
      let index = -1;
      for (const node of this) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_eachBefore(callback, that) {
      var node = this, nodes = [node], children, i, index = -1;
      while (node = nodes.pop()) {
        callback.call(that, node, ++index, this);
        if (children = node.children) {
          for (i = children.length - 1; i >= 0; --i) {
            nodes.push(children[i]);
          }
        }
      }
      return this;
    }

    function node_eachAfter(callback, that) {
      var node = this, nodes = [node], next = [], children, i, n, index = -1;
      while (node = nodes.pop()) {
        next.push(node);
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            nodes.push(children[i]);
          }
        }
      }
      while (node = next.pop()) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_find(callback, that) {
      let index = -1;
      for (const node of this) {
        if (callback.call(that, node, ++index, this)) {
          return node;
        }
      }
    }

    function node_sum(value) {
      return this.eachAfter(function(node) {
        var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length;
        while (--i >= 0) sum += children[i].value;
        node.value = sum;
      });
    }

    function node_sort(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }

    function node_path(end) {
      var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start];
      while (start !== ancestor) {
        start = start.parent;
        nodes.push(start);
      }
      var k = nodes.length;
      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }
      return nodes;
    }

    function leastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }

    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }

    function node_descendants() {
      return Array.from(this);
    }

    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }

    function node_links() {
      var root = this, links = [];
      root.each(function(node) {
        if (node !== root) { // Dont include the roots parent, if any.
          links.push({source: node.parent, target: node});
        }
      });
      return links;
    }

    function* node_iterator() {
      var node = this, current, next = [node], children, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          yield node;
          if (children = node.children) {
            for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }
        }
      } while (next.length);
    }

    function hierarchy(data, children) {
      if (data instanceof Map) {
        data = [undefined, data];
        if (children === undefined) children = mapChildren;
      } else if (children === undefined) {
        children = objectChildren;
      }

      var root = new Node$1(data),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n;

      while (node = nodes.pop()) {
        if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
          node.children = childs;
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = childs[i] = new Node$1(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }

      return root.eachBefore(computeHeight);
    }

    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }

    function objectChildren(d) {
      return d.children;
    }

    function mapChildren(d) {
      return Array.isArray(d) ? d[1] : null;
    }

    function copyData(node) {
      if (node.data.value !== undefined) node.value = node.data.value;
      node.data = node.data.data;
    }

    function computeHeight(node) {
      var height = 0;
      do node.height = height;
      while ((node = node.parent) && (node.height < ++height));
    }

    function Node$1(data) {
      this.data = data;
      this.depth =
      this.height = 0;
      this.parent = null;
    }

    Node$1.prototype = hierarchy.prototype = {
      constructor: Node$1,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      find: node_find,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy,
      [Symbol.iterator]: node_iterator
    };

    function array$1(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function shuffle(array) {
      var m = array.length,
          t,
          i;

      while (m) {
        i = Math.random() * m-- | 0;
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }

      return array;
    }

    function enclose(circles) {
      var i = 0, n = (circles = shuffle(Array.from(circles))).length, B = [], p, e;

      while (i < n) {
        p = circles[i];
        if (e && enclosesWeak(e, p)) ++i;
        else e = encloseBasis(B = extendBasis(B, p)), i = 0;
      }

      return e;
    }

    function extendBasis(B, p) {
      var i, j;

      if (enclosesWeakAll(p, B)) return [p];

      // If we get here then B must have at least one element.
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i])
            && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }

      // If we get here then B must have at least two elements.
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p)
              && enclosesNot(encloseBasis2(B[i], p), B[j])
              && enclosesNot(encloseBasis2(B[j], p), B[i])
              && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }

      // If we get here then something is very wrong.
      throw new Error;
    }

    function enclosesNot(a, b) {
      var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }

    function enclosesWeak(a, b) {
      var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }

    function encloseBasis(B) {
      switch (B.length) {
        case 1: return encloseBasis1(B[0]);
        case 2: return encloseBasis2(B[0], B[1]);
        case 3: return encloseBasis3(B[0], B[1], B[2]);
      }
    }

    function encloseBasis1(a) {
      return {
        x: a.x,
        y: a.y,
        r: a.r
      };
    }

    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
          l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
        x: (x1 + x2 + x21 / l * r21) / 2,
        y: (y1 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
      };
    }

    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x3 = c.x, y3 = c.y, r3 = c.r,
          a2 = x1 - x2,
          a3 = x1 - x3,
          b2 = y1 - y2,
          b3 = y1 - y3,
          c2 = r2 - r1,
          c3 = r3 - r1,
          d1 = x1 * x1 + y1 * y1 - r1 * r1,
          d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
          d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
          ab = a3 * b2 - a2 * b3,
          xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
          xb = (b3 * c2 - b2 * c3) / ab,
          ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
          yb = (a2 * c3 - a3 * c2) / ab,
          A = xb * xb + yb * yb - 1,
          B = 2 * (r1 + xa * xb + ya * yb),
          C = xa * xa + ya * ya - r1 * r1,
          r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return {
        x: x1 + xa + xb * r,
        y: y1 + ya + yb * r,
        r: r
      };
    }

    function place(b, a, c) {
      var dx = b.x - a.x, x, a2,
          dy = b.y - a.y, y, b2,
          d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r, a2 *= a2;
        b2 = b.r + c.r, b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }

    function intersects(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function score(node) {
      var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab,
          dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }

    function Node(circle) {
      this._ = circle;
      this.next = null;
      this.previous = null;
    }

    function packEnclose(circles) {
      if (!(n = (circles = array$1(circles)).length)) return 0;

      var a, b, c, n, aa, ca, i, j, k, sj, sk;

      // Place the first circle.
      a = circles[0], a.x = 0, a.y = 0;
      if (!(n > 1)) return a.r;

      // Place the second circle.
      b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
      if (!(n > 2)) return a.r + b.r;

      // Place the third circle.
      place(b, a, c = circles[2]);

      // Initialize the front-chain using the first three circles a, b and c.
      a = new Node(a), b = new Node(b), c = new Node(c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;

      // Attempt to place each remaining circle
      pack: for (i = 3; i < n; ++i) {
        place(a._, b._, c = circles[i]), c = new Node(c);

        // Find the closest intersecting circle on the front-chain, if any.
        // Closeness is determined by linear distance along the front-chain.
        // Ahead or behind is likewise determined by linear distance.
        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
        do {
          if (sj <= sk) {
            if (intersects(j._, c._)) {
              b = j, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sj += j._.r, j = j.next;
          } else {
            if (intersects(k._, c._)) {
              a = k, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sk += k._.r, k = k.previous;
          }
        } while (j !== k.next);

        // Success! Insert the new circle c between a and b.
        c.previous = a, c.next = b, a.next = b.previous = b = c;

        // Compute the new closest circle pair to the centroid.
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c, aa = ca;
          }
        }
        b = a.next;
      }

      // Compute the enclosing circle of the front chain.
      a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

      // Translate the circles to put the enclosing circle around the origin.
      for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

      return c.r;
    }

    function siblings(circles) {
      packEnclose(circles);
      return circles;
    }

    function optional(f) {
      return f == null ? null : required(f);
    }

    function required(f) {
      if (typeof f !== "function") throw new Error;
      return f;
    }

    function constantZero() {
      return 0;
    }

    function constant$2(x) {
      return function() {
        return x;
      };
    }

    function defaultRadius(d) {
      return Math.sqrt(d.value);
    }

    function index$1() {
      var radius = null,
          dx = 1,
          dy = 1,
          padding = constantZero;

      function pack(root) {
        root.x = dx / 2, root.y = dy / 2;
        if (radius) {
          root.eachBefore(radiusLeaf(radius))
              .eachAfter(packChildren(padding, 0.5))
              .eachBefore(translateChild(1));
        } else {
          root.eachBefore(radiusLeaf(defaultRadius))
              .eachAfter(packChildren(constantZero, 1))
              .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
              .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
        }
        return root;
      }

      pack.radius = function(x) {
        return arguments.length ? (radius = optional(x), pack) : radius;
      };

      pack.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
      };

      pack.padding = function(x) {
        return arguments.length ? (padding = typeof x === "function" ? x : constant$2(+x), pack) : padding;
      };

      return pack;
    }

    function radiusLeaf(radius) {
      return function(node) {
        if (!node.children) {
          node.r = Math.max(0, +radius(node) || 0);
        }
      };
    }

    function packChildren(padding, k) {
      return function(node) {
        if (children = node.children) {
          var children,
              i,
              n = children.length,
              r = padding(node) * k || 0,
              e;

          if (r) for (i = 0; i < n; ++i) children[i].r += r;
          e = packEnclose(children);
          if (r) for (i = 0; i < n; ++i) children[i].r -= r;
          node.r = e + r;
        }
      };
    }

    function translateChild(k) {
      return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
          node.x = parent.x + k * node.x;
          node.y = parent.y + k * node.y;
        }
      };
    }

    function roundNode(node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }

    function treemapDice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
      }
    }

    function partition() {
      var dx = 1,
          dy = 1,
          padding = 0,
          round = false;

      function partition(root) {
        var n = root.height + 1;
        root.x0 =
        root.y0 = padding;
        root.x1 = dx;
        root.y1 = dy / n;
        root.eachBefore(positionNode(dy, n));
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(dy, n) {
        return function(node) {
          if (node.children) {
            treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
          }
          var x0 = node.x0,
              y0 = node.y0,
              x1 = node.x1 - padding,
              y1 = node.y1 - padding;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
        };
      }

      partition.round = function(x) {
        return arguments.length ? (round = !!x, partition) : round;
      };

      partition.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
      };

      partition.padding = function(x) {
        return arguments.length ? (padding = +x, partition) : padding;
      };

      return partition;
    }

    var preroot = {depth: -1},
        ambiguous = {};

    function defaultId(d) {
      return d.id;
    }

    function defaultParentId(d) {
      return d.parentId;
    }

    function stratify() {
      var id = defaultId,
          parentId = defaultParentId;

      function stratify(data) {
        var nodes = Array.from(data),
            n = nodes.length,
            d,
            i,
            root,
            parent,
            node,
            nodeId,
            nodeKey,
            nodeByKey = new Map;

        for (i = 0; i < n; ++i) {
          d = nodes[i], node = nodes[i] = new Node$1(d);
          if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
            nodeKey = node.id = nodeId;
            nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
          }
          if ((nodeId = parentId(d, i, data)) != null && (nodeId += "")) {
            node.parent = nodeId;
          }
        }

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (nodeId = node.parent) {
            parent = nodeByKey.get(nodeId);
            if (!parent) throw new Error("missing: " + nodeId);
            if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
            if (parent.children) parent.children.push(node);
            else parent.children = [node];
            node.parent = parent;
          } else {
            if (root) throw new Error("multiple roots");
            root = node;
          }
        }

        if (!root) throw new Error("no root");
        root.parent = preroot;
        root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
        root.parent = null;
        if (n > 0) throw new Error("cycle");

        return root;
      }

      stratify.id = function(x) {
        return arguments.length ? (id = required(x), stratify) : id;
      };

      stratify.parentId = function(x) {
        return arguments.length ? (parentId = required(x), stratify) : parentId;
      };

      return stratify;
    }

    function defaultSeparation(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    // function radialSeparation(a, b) {
    //   return (a.parent === b.parent ? 1 : 2) / a.depth;
    // }

    // This function is used to traverse the left contour of a subtree (or
    // subforest). It returns the successor of v on this contour. This successor is
    // either given by the leftmost child of v or by the thread of v. The function
    // returns null if and only if v is on the highest level of its subtree.
    function nextLeft(v) {
      var children = v.children;
      return children ? children[0] : v.t;
    }

    // This function works analogously to nextLeft.
    function nextRight(v) {
      var children = v.children;
      return children ? children[children.length - 1] : v.t;
    }

    // Shifts the current subtree rooted at w+. This is done by increasing
    // prelim(w+) and mod(w+) by shift.
    function moveSubtree(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }

    // All other shifts, applied to the smaller subtrees between w- and w+, are
    // performed by this function. To prepare the shifts, we have to adjust
    // change(w+), shift(w+), and change(w-).
    function executeShifts(v) {
      var shift = 0,
          change = 0,
          children = v.children,
          i = children.length,
          w;
      while (--i >= 0) {
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }

    // If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
    // returns the specified (default) ancestor.
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null; // default ancestor
      this.a = this; // ancestor
      this.z = 0; // prelim
      this.m = 0; // mod
      this.c = 0; // change
      this.s = 0; // shift
      this.t = null; // thread
      this.i = i; // number
    }

    TreeNode.prototype = Object.create(Node$1.prototype);

    function treeRoot(root) {
      var tree = new TreeNode(root, 0),
          node,
          nodes = [tree],
          child,
          children,
          i,
          n;

      while (node = nodes.pop()) {
        if (children = node._.children) {
          node.children = new Array(n = children.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children[i], i));
            child.parent = node;
          }
        }
      }

      (tree.parent = new TreeNode(null, 0)).children = [tree];
      return tree;
    }

    // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
    function tree() {
      var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = null;

      function tree(root) {
        var t = treeRoot(root);

        // Compute the layout using Buchheim et al.s algorithm.
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);

        // If a fixed node size is specified, scale x and y.
        if (nodeSize) root.eachBefore(sizeNode);

        // If a fixed tree size is specified, scale x and y based on the extent.
        // Compute the left-most, right-most, and depth-most nodes for extents.
        else {
          var left = root,
              right = root,
              bottom = root;
          root.eachBefore(function(node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1);
          root.eachBefore(function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }

        return root;
      }

      // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
      // applied recursively to the children of v, as well as the function
      // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
      // node v is placed to the midpoint of its outermost children.
      function firstWalk(v) {
        var children = v.children,
            siblings = v.parent.children,
            w = v.i ? siblings[v.i - 1] : null;
        if (children) {
          executeShifts(v);
          var midpoint = (children[0].z + children[children.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }

      // Computes all real x-coordinates by summing up the modifiers recursively.
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }

      // The core of the algorithm. Here, a new subtree is combined with the
      // previous subtrees. Threads are used to traverse the inside and outside
      // contours of the left and right subtree up to the highest common level. The
      // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
      // superscript o means outside and i means inside, the subscript - means left
      // subtree and + means right subtree. For summing up the modifiers along the
      // contour, we use respective variables si+, si-, so-, and so+. Whenever two
      // nodes of the inside contours conflict, we compute the left one of the
      // greatest uncommon ancestors using the function ANCESTOR and call MOVE
      // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
      // Finally, we add a new thread (if necessary).
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v,
              vop = v,
              vim = w,
              vom = vip.parent.children[0],
              sip = vip.m,
              sop = vop.m,
              sim = vim.m,
              som = vom.m,
              shift;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }

      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }

      tree.separation = function(x) {
        return arguments.length ? (separation = x, tree) : separation;
      };

      tree.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
      };

      tree.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
      };

      return tree;
    }

    function treemapSlice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
      }
    }

    var phi$1 = (1 + Math.sqrt(5)) / 2;

    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx, dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta;

      while (i0 < n) {
        dx = x1 - x0, dy = y1 - y0;

        // Find the next non-empty node.
        do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);

        // Keep adding nodes while the aspect ratio maintains or improves.
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue) minValue = nodeValue;
          if (nodeValue > maxValue) maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) { sumValue -= nodeValue; break; }
          minRatio = newRatio;
        }

        // Position and record the row orientation.
        rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
        else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
      }

      return rows;
    }

    var squarify = (function custom(ratio) {

      function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }

      squarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return squarify;
    })(phi$1);

    function index() {
      var tile = squarify,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = constantZero,
          paddingTop = constantZero,
          paddingRight = constantZero,
          paddingBottom = constantZero,
          paddingLeft = constantZero;

      function treemap(root) {
        root.x0 =
        root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [0];
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(node) {
        var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
          x0 += paddingLeft(node) - p;
          y0 += paddingTop(node) - p;
          x1 -= paddingRight(node) - p;
          y1 -= paddingBottom(node) - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          tile(node, x0, y0, x1, y1);
        }
      }

      treemap.round = function(x) {
        return arguments.length ? (round = !!x, treemap) : round;
      };

      treemap.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
      };

      treemap.tile = function(x) {
        return arguments.length ? (tile = required(x), treemap) : tile;
      };

      treemap.padding = function(x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
      };

      treemap.paddingInner = function(x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$2(+x), treemap) : paddingInner;
      };

      treemap.paddingOuter = function(x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
      };

      treemap.paddingTop = function(x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$2(+x), treemap) : paddingTop;
      };

      treemap.paddingRight = function(x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$2(+x), treemap) : paddingRight;
      };

      treemap.paddingBottom = function(x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$2(+x), treemap) : paddingBottom;
      };

      treemap.paddingLeft = function(x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$2(+x), treemap) : paddingLeft;
      };

      return treemap;
    }

    function binary(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          i, n = nodes.length,
          sum, sums = new Array(n + 1);

      for (sums[0] = sum = i = 0; i < n; ++i) {
        sums[i + 1] = sum += nodes[i].value;
      }

      partition(0, n, parent.value, x0, y0, x1, y1);

      function partition(i, j, value, x0, y0, x1, y1) {
        if (i >= j - 1) {
          var node = nodes[i];
          node.x0 = x0, node.y0 = y0;
          node.x1 = x1, node.y1 = y1;
          return;
        }

        var valueOffset = sums[i],
            valueTarget = (value / 2) + valueOffset,
            k = i + 1,
            hi = j - 1;

        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget) k = mid + 1;
          else hi = mid;
        }

        if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

        var valueLeft = sums[k] - valueOffset,
            valueRight = value - valueLeft;

        if ((x1 - x0) > (y1 - y0)) {
          var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
          partition(i, k, valueLeft, x0, y0, xk, y1);
          partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
          var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
          partition(i, k, valueLeft, x0, y0, x1, yk);
          partition(k, j, valueRight, x0, yk, x1, y1);
        }
      }
    }

    function sliceDice(parent, x0, y0, x1, y1) {
      (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
    }

    var resquarify = (function custom(ratio) {

      function resquarify(parent, x0, y0, x1, y1) {
        if ((rows = parent._squarify) && (rows.ratio === ratio)) {
          var rows,
              row,
              nodes,
              i,
              j = -1,
              n,
              m = rows.length,
              value = parent.value;

          while (++j < m) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
            if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
            else treemapSlice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
            value -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
          rows.ratio = ratio;
        }
      }

      resquarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return resquarify;
    })(phi$1);

    function area$1(polygon) {
      var i = -1,
          n = polygon.length,
          a,
          b = polygon[n - 1],
          area = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        area += a[1] * b[0] - a[0] * b[1];
      }

      return area / 2;
    }

    function centroid(polygon) {
      var i = -1,
          n = polygon.length,
          x = 0,
          y = 0,
          a,
          b = polygon[n - 1],
          c,
          k = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        k += c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }

      return k *= 3, [x / k, y / k];
    }

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
    // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
    // right, +y is up). Returns a positive value if ABC is counter-clockwise,
    // negative if clockwise, and zero if the points are collinear.
    function cross$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }

    function lexicographicOrder(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }

    // Computes the upper convex hull per the monotone chain algorithm.
    // Assumes points.length >= 3, is sorted by x, unique in y.
    // Returns an array of indices into points in left-to-right order.
    function computeUpperHullIndexes(points) {
      const n = points.length,
          indexes = [0, 1];
      let size = 2, i;

      for (i = 2; i < n; ++i) {
        while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
        indexes[size++] = i;
      }

      return indexes.slice(0, size); // remove popped points
    }

    function hull(points) {
      if ((n = points.length) < 3) return null;

      var i,
          n,
          sortedPoints = new Array(n),
          flippedPoints = new Array(n);

      for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
      sortedPoints.sort(lexicographicOrder);
      for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

      var upperIndexes = computeUpperHullIndexes(sortedPoints),
          lowerIndexes = computeUpperHullIndexes(flippedPoints);

      // Construct the hull polygon, removing possible duplicate endpoints.
      var skipLeft = lowerIndexes[0] === upperIndexes[0],
          skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
          hull = [];

      // Add upper hull in right-to-l order.
      // Then add lower hull in left-to-right order.
      for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
      for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

      return hull;
    }

    function contains(polygon, point) {
      var n = polygon.length,
          p = polygon[n - 1],
          x = point[0], y = point[1],
          x0 = p[0], y0 = p[1],
          x1, y1,
          inside = false;

      for (var i = 0; i < n; ++i) {
        p = polygon[i], x1 = p[0], y1 = p[1];
        if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
        x0 = x1, y0 = y1;
      }

      return inside;
    }

    function length(polygon) {
      var i = -1,
          n = polygon.length,
          b = polygon[n - 1],
          xa,
          ya,
          xb = b[0],
          yb = b[1],
          perimeter = 0;

      while (++i < n) {
        xa = xb;
        ya = yb;
        b = polygon[i];
        xb = b[0];
        yb = b[1];
        xa -= xb;
        ya -= yb;
        perimeter += Math.hypot(xa, ya);
      }

      return perimeter;
    }

    var defaultSource = Math.random;

    var uniform = (function sourceRandomUniform(source) {
      function randomUniform(min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;
        else max -= min;
        return function() {
          return source() * max + min;
        };
      }

      randomUniform.source = sourceRandomUniform;

      return randomUniform;
    })(defaultSource);

    var int = (function sourceRandomInt(source) {
      function randomInt(min, max) {
        if (arguments.length < 2) max = min, min = 0;
        min = Math.floor(min);
        max = Math.floor(max) - min;
        return function() {
          return Math.floor(source() * max + min);
        };
      }

      randomInt.source = sourceRandomInt;

      return randomInt;
    })(defaultSource);

    var normal = (function sourceRandomNormal(source) {
      function randomNormal(mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
          var y;

          // If available, use the second previously-generated uniform random.
          if (x != null) y = x, x = null;

          // Otherwise, generate a new x and y.
          else do {
            x = source() * 2 - 1;
            y = source() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);

          return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
      }

      randomNormal.source = sourceRandomNormal;

      return randomNormal;
    })(defaultSource);

    var logNormal = (function sourceRandomLogNormal(source) {
      var N = normal.source(source);

      function randomLogNormal() {
        var randomNormal = N.apply(this, arguments);
        return function() {
          return Math.exp(randomNormal());
        };
      }

      randomLogNormal.source = sourceRandomLogNormal;

      return randomLogNormal;
    })(defaultSource);

    var irwinHall = (function sourceRandomIrwinHall(source) {
      function randomIrwinHall(n) {
        if ((n = +n) <= 0) return () => 0;
        return function() {
          for (var sum = 0, i = n; i > 1; --i) sum += source();
          return sum + i * source();
        };
      }

      randomIrwinHall.source = sourceRandomIrwinHall;

      return randomIrwinHall;
    })(defaultSource);

    var bates = (function sourceRandomBates(source) {
      var I = irwinHall.source(source);

      function randomBates(n) {
        // use limiting distribution at n === 0
        if ((n = +n) === 0) return source;
        var randomIrwinHall = I(n);
        return function() {
          return randomIrwinHall() / n;
        };
      }

      randomBates.source = sourceRandomBates;

      return randomBates;
    })(defaultSource);

    var exponential = (function sourceRandomExponential(source) {
      function randomExponential(lambda) {
        return function() {
          return -Math.log1p(-source()) / lambda;
        };
      }

      randomExponential.source = sourceRandomExponential;

      return randomExponential;
    })(defaultSource);

    var pareto = (function sourceRandomPareto(source) {
      function randomPareto(alpha) {
        if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
        alpha = 1 / -alpha;
        return function() {
          return Math.pow(1 - source(), alpha);
        };
      }

      randomPareto.source = sourceRandomPareto;

      return randomPareto;
    })(defaultSource);

    var bernoulli = (function sourceRandomBernoulli(source) {
      function randomBernoulli(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        return function() {
          return Math.floor(source() + p);
        };
      }

      randomBernoulli.source = sourceRandomBernoulli;

      return randomBernoulli;
    })(defaultSource);

    var geometric = (function sourceRandomGeometric(source) {
      function randomGeometric(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        if (p === 0) return () => Infinity;
        if (p === 1) return () => 1;
        p = Math.log1p(-p);
        return function() {
          return 1 + Math.floor(Math.log1p(-source()) / p);
        };
      }

      randomGeometric.source = sourceRandomGeometric;

      return randomGeometric;
    })(defaultSource);

    var gamma = (function sourceRandomGamma(source) {
      var randomNormal = normal.source(source)();

      function randomGamma(k, theta) {
        if ((k = +k) < 0) throw new RangeError("invalid k");
        // degenerate distribution if k === 0
        if (k === 0) return () => 0;
        theta = theta == null ? 1 : +theta;
        // exponential distribution if k === 1
        if (k === 1) return () => -Math.log1p(-source()) * theta;

        var d = (k < 1 ? k + 1 : k) - 1 / 3,
            c = 1 / (3 * Math.sqrt(d)),
            multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;
        return function() {
          do {
            do {
              var x = randomNormal(),
                  v = 1 + c * x;
            } while (v <= 0);
            v *= v * v;
            var u = 1 - source();
          } while (u >= 1 - 0.0331 * x * x * x * x && Math.log(u) >= 0.5 * x * x + d * (1 - v + Math.log(v)));
          return d * v * multiplier() * theta;
        };
      }

      randomGamma.source = sourceRandomGamma;

      return randomGamma;
    })(defaultSource);

    var beta = (function sourceRandomBeta(source) {
      var G = gamma.source(source);

      function randomBeta(alpha, beta) {
        var X = G(alpha),
            Y = G(beta);
        return function() {
          var x = X();
          return x === 0 ? 0 : x / (x + Y());
        };
      }

      randomBeta.source = sourceRandomBeta;

      return randomBeta;
    })(defaultSource);

    var binomial = (function sourceRandomBinomial(source) {
      var G = geometric.source(source),
          B = beta.source(source);

      function randomBinomial(n, p) {
        n = +n;
        if ((p = +p) >= 1) return () => n;
        if (p <= 0) return () => 0;
        return function() {
          var acc = 0, nn = n, pp = p;
          while (nn * pp > 16 && nn * (1 - pp) > 16) {
            var i = Math.floor((nn + 1) * pp),
                y = B(i, nn - i + 1)();
            if (y <= pp) {
              acc += i;
              nn -= i;
              pp = (pp - y) / (1 - y);
            } else {
              nn = i - 1;
              pp /= y;
            }
          }
          var sign = pp < 0.5,
              pFinal = sign ? pp : 1 - pp,
              g = G(pFinal);
          for (var s = g(), k = 0; s <= nn; ++k) s += g();
          return acc + (sign ? k : nn - k);
        };
      }

      randomBinomial.source = sourceRandomBinomial;

      return randomBinomial;
    })(defaultSource);

    var weibull = (function sourceRandomWeibull(source) {
      function randomWeibull(k, a, b) {
        var outerFunc;
        if ((k = +k) === 0) {
          outerFunc = x => -Math.log(x);
        } else {
          k = 1 / k;
          outerFunc = x => Math.pow(x, k);
        }
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * outerFunc(-Math.log1p(-source()));
        };
      }

      randomWeibull.source = sourceRandomWeibull;

      return randomWeibull;
    })(defaultSource);

    var cauchy = (function sourceRandomCauchy(source) {
      function randomCauchy(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * Math.tan(Math.PI * source());
        };
      }

      randomCauchy.source = sourceRandomCauchy;

      return randomCauchy;
    })(defaultSource);

    var logistic = (function sourceRandomLogistic(source) {
      function randomLogistic(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          var u = source();
          return a + b * Math.log(u / (1 - u));
        };
      }

      randomLogistic.source = sourceRandomLogistic;

      return randomLogistic;
    })(defaultSource);

    var poisson = (function sourceRandomPoisson(source) {
      var G = gamma.source(source),
          B = binomial.source(source);

      function randomPoisson(lambda) {
        return function() {
          var acc = 0, l = lambda;
          while (l > 16) {
            var n = Math.floor(0.875 * l),
                t = G(n)();
            if (t > l) return acc + B(n - 1, l / t)();
            acc += n;
            l -= t;
          }
          for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k) s -= Math.log1p(-source());
          return acc + k;
        };
      }

      randomPoisson.source = sourceRandomPoisson;

      return randomPoisson;
    })(defaultSource);

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const mul = 0x19660D;
    const inc = 0x3C6EF35F;
    const eps = 1 / 0x100000000;

    function lcg(seed = Math.random()) {
      let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
      return () => (state = mul * state + inc | 0, eps * (state >>> 0));
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0: break;
        case 1: {
          if (typeof domain === "function") this.interpolator(domain);
          else this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function") this.interpolator(interpolator);
          else this.range(interpolator);
          break;
        }
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function band() {
      var scale = ordinal().unknown(undefined),
          domain = scale.domain,
          ordinalRange = scale.range,
          r0 = 0,
          r1 = 1,
          step,
          bandwidth,
          round = false,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;

      delete scale.unknown;

      function rescale() {
        var n = domain().length,
            reverse = r1 < r0,
            start = reverse ? r1 : r0,
            stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = range$3(n).map(function(i) { return start + step * i; });
        return ordinalRange(reverse ? values.reverse() : values);
      }

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };

      scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
      };

      scale.bandwidth = function() {
        return bandwidth;
      };

      scale.step = function() {
        return step;
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
      };

      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };

      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };

      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };

      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };

      scale.copy = function() {
        return band(domain(), [r0, r1])
            .round(round)
            .paddingInner(paddingInner)
            .paddingOuter(paddingOuter)
            .align(align);
      };

      return initRange.apply(rescale(), arguments);
    }

    function pointish(scale) {
      var copy = scale.copy;

      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;

      scale.copy = function() {
        return pointish(copy());
      };

      return scale;
    }

    function point$4() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }

    function constants(x) {
      return function() {
        return x;
      };
    }

    function number$1(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$3(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisectRight(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy$1(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer$2() {
      var domain = unit,
          range = unit,
          interpolate = interpolate$2,
          transform,
          untransform,
          unknown,
          clamp = identity$3,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$3) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer$2()(identity$3, identity$3);
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }

        return scale;
      };

      return scale;
    }

    function linear() {
      var scale = continuous();

      scale.copy = function() {
        return copy$1(scale, linear());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function identity$2(domain) {
      var unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : x;
      }

      scale.invert = scale;

      scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return identity$2(domain).unknown(unknown);
      };

      domain = arguments.length ? Array.from(domain, number$1) : [0, 1];

      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();

      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    function transformLog(x) {
      return Math.log(x);
    }

    function transformExp(x) {
      return Math.exp(x);
    }

    function transformLogn(x) {
      return -Math.log(-x);
    }

    function transformExpn(x) {
      return -Math.exp(-x);
    }

    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }

    function powp(base) {
      return base === 10 ? pow10
          : base === Math.E ? Math.exp
          : function(x) { return Math.pow(base, x); };
    }

    function logp(base) {
      return base === Math.E ? Math.log
          : base === 10 && Math.log10
          || base === 2 && Math.log2
          || (base = Math.log(base), function(x) { return Math.log(x) / base; });
    }

    function reflect(f) {
      return function(x) {
        return -f(-x);
      };
    }

    function loggish(transform) {
      var scale = transform(transformLog, transformExp),
          domain = scale.domain,
          base = 10,
          logs,
          pows;

      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog, transformExp);
        }
        return scale;
      }

      scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.ticks = function(count) {
        var d = domain(),
            u = d[0],
            v = d[d.length - 1],
            r;

        if (r = v < u) i = u, u = v, v = i;

        var i = logs(u),
            j = logs(v),
            p,
            k,
            t,
            n = count == null ? 10 : +count,
            z = [];

        if (!(base % 1) && j - i < n) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u > 0) for (; i <= j; ++i) {
            for (k = 1, p = pows(i); k < base; ++k) {
              t = p * k;
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          } else for (; i <= j; ++i) {
            for (k = base - 1, p = pows(i); k >= 1; --k) {
              t = p * k;
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          }
          if (z.length * 2 < n) z = ticks(u, v, n);
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }

        return r ? z.reverse() : z;
      };

      scale.tickFormat = function(count, specifier) {
        if (specifier == null) specifier = base === 10 ? ".0e" : ",";
        if (typeof specifier !== "function") specifier = format(specifier);
        if (count === Infinity) return specifier;
        if (count == null) count = 10;
        var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return function(d) {
          var i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k ? specifier(d) : "";
        };
      };

      scale.nice = function() {
        return domain(nice(domain(), {
          floor: function(x) { return pows(Math.floor(logs(x))); },
          ceil: function(x) { return pows(Math.ceil(logs(x))); }
        }));
      };

      return scale;
    }

    function log() {
      var scale = loggish(transformer$2()).domain([1, 10]);

      scale.copy = function() {
        return copy$1(scale, log()).base(scale.base());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function transformSymlog(c) {
      return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
      };
    }

    function transformSymexp(c) {
      return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
      };
    }

    function symlogish(transform) {
      var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

      scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
      };

      return linearish(scale);
    }

    function symlog() {
      var scale = symlogish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, symlog()).constant(scale.constant());
      };

      return initRange.apply(scale, arguments);
    }

    function transformPow(exponent) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };
    }

    function transformSqrt(x) {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }

    function transformSquare(x) {
      return x < 0 ? -x * x : x * x;
    }

    function powish(transform) {
      var scale = transform(identity$3, identity$3),
          exponent = 1;

      function rescale() {
        return exponent === 1 ? transform(identity$3, identity$3)
            : exponent === 0.5 ? transform(transformSqrt, transformSquare)
            : transform(transformPow(exponent), transformPow(1 / exponent));
      }

      scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
      };

      return linearish(scale);
    }

    function pow() {
      var scale = powish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, pow()).exponent(scale.exponent());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function sqrt$1() {
      return pow.apply(null, arguments).exponent(0.5);
    }

    function square$1(x) {
      return Math.sign(x) * x * x;
    }

    function unsquare(x) {
      return Math.sign(x) * Math.sqrt(Math.abs(x));
    }

    function radial() {
      var squared = continuous(),
          range = [0, 1],
          round = false,
          unknown;

      function scale(x) {
        var y = unsquare(squared(x));
        return isNaN(y) ? unknown : round ? Math.round(y) : y;
      }

      scale.invert = function(y) {
        return squared.invert(square$1(y));
      };

      scale.domain = function(_) {
        return arguments.length ? (squared.domain(_), scale) : squared.domain();
      };

      scale.range = function(_) {
        return arguments.length ? (squared.range((range = Array.from(_, number$1)).map(square$1)), scale) : range.slice();
      };

      scale.rangeRound = function(_) {
        return scale.range(_).round(true);
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, scale) : round;
      };

      scale.clamp = function(_) {
        return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return radial(squared.domain(), range)
            .round(round)
            .clamp(squared.clamp())
            .unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function quantile() {
      var domain = [],
          range = [],
          thresholds = [],
          unknown;

      function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : range[bisectRight(thresholds, x)];
      }

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return rescale();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.quantiles = function() {
        return thresholds.slice();
      };

      scale.copy = function() {
        return quantile()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    function quantize() {
      var x0 = 0,
          x1 = 1,
          n = 1,
          domain = [0.5],
          range = [0, 1],
          unknown;

      function scale(x) {
        return x != null && x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
      }

      function rescale() {
        var i = -1;
        domain = new Array(n);
        while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
      };

      scale.range = function(_) {
        return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN]
            : i < 1 ? [x0, domain[0]]
            : i >= n ? [domain[n - 1], x1]
            : [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
      };

      scale.thresholds = function() {
        return domain.slice();
      };

      scale.copy = function() {
        return quantize()
            .domain([x0, x1])
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(linearish(scale), arguments);
    }

    function threshold() {
      var domain = [0.5],
          range = [0, 1],
          unknown,
          n = 1;

      function scale(x) {
        return x != null && x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
      }

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return threshold()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    var t0 = new Date,
        t1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
      }

      interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };
    var milliseconds = millisecond.range;

    const durationSecond = 1000;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;

    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });
    var seconds = second.range;

    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });
    var minutes = minute.range;

    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });
    var hours = hour.range;

    var day = newInterval(
      date => date.setHours(0, 0, 0, 0),
      (date, step) => date.setDate(date.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
      date => date.getDate() - 1
    );
    var days = day.range;

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var sundays = sunday.range;
    var mondays = monday.range;
    var tuesdays = tuesday.range;
    var wednesdays = wednesday.range;
    var thursdays = thursday.range;
    var fridays = friday.range;
    var saturdays = saturday.range;

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });
    var months = month.range;

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };
    var years = year.range;

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });
    var utcMinutes = utcMinute.range;

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });
    var utcHours = utcHour.range;

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });
    var utcDays = utcDay.range;

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcSundays = utcSunday.range;
    var utcMondays = utcMonday.range;
    var utcTuesdays = utcTuesday.range;
    var utcWednesdays = utcWednesday.range;
    var utcThursdays = utcThursday.range;
    var utcFridays = utcFriday.range;
    var utcSaturdays = utcSaturday.range;

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });
    var utcMonths = utcMonth.range;

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };
    var utcYears = utcYear.range;

    function ticker(year, month, week, day, hour, minute) {

      const tickIntervals = [
        [second,  1,      durationSecond],
        [second,  5,  5 * durationSecond],
        [second, 15, 15 * durationSecond],
        [second, 30, 30 * durationSecond],
        [minute,  1,      durationMinute],
        [minute,  5,  5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [  hour,  1,      durationHour  ],
        [  hour,  3,  3 * durationHour  ],
        [  hour,  6,  6 * durationHour  ],
        [  hour, 12, 12 * durationHour  ],
        [   day,  1,      durationDay   ],
        [   day,  2,  2 * durationDay   ],
        [  week,  1,      durationWeek  ],
        [ month,  1,      durationMonth ],
        [ month,  3,  3 * durationMonth ],
        [  year,  1,      durationYear  ]
      ];

      function ticks(start, stop, count) {
        const reverse = stop < start;
        if (reverse) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
      }

      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector(([,, step]) => step).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }

      return [ticks, tickInterval];
    }

    const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute);
    const [timeTicks, timeTickInterval] = ticker(year, month, sunday, day, hour, minute);

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day$1;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
              week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
              week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
              week = day.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + day.count(year(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(year(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day = d.getDay();
      return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(year(d) - 1, d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day = d.getUTCDay();
      return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    function date(t) {
      return new Date(t);
    }

    function number(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain;

      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
            : hour(date) < date ? formatMinute
            : day(date) < date ? formatHour
            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
            : year(date) < date ? formatMonth
            : formatYear)(date);
      }

      scale.invert = function(y) {
        return new Date(invert(y));
      };

      scale.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };

      scale.ticks = function(interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };

      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function(interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };

      scale.copy = function() {
        return copy$1(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };

      return scale;
    }

    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, year, month, sunday, day, hour, minute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
    }

    function transformer$1() {
      var x0 = 0,
          x1 = 1,
          t0,
          t1,
          k10,
          transform,
          interpolator = identity$3,
          clamp = false,
          unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function sequential() {
      var scale = linearish(transformer$1()(identity$3));

      scale.copy = function() {
        return copy(scale, sequential());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialLog() {
      var scale = loggish(transformer$1()).domain([1, 10]);

      scale.copy = function() {
        return copy(scale, sequentialLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSymlog() {
      var scale = symlogish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialPow() {
      var scale = powish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }

    function sequentialQuantile() {
      var domain = [],
          interpolator = identity$3;

      function scale(x) {
        if (x != null && !isNaN(x = +x)) return interpolator((bisectRight(domain, x, 1) - 1) / (domain.length - 1));
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return scale;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.range = function() {
        return domain.map((d, i) => interpolator(i / (domain.length - 1)));
      };

      scale.quantiles = function(n) {
        return Array.from({length: n + 1}, (_, i) => quantile$1(domain, i / n));
      };

      scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
      };

      return initInterpolator.apply(scale, arguments);
    }

    function transformer() {
      var x0 = 0,
          x1 = 0.5,
          x2 = 1,
          s = 1,
          t0,
          t1,
          t2,
          k10,
          k21,
          interpolator = identity$3,
          transform,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
        return scale;
      };
    }

    function diverging$1() {
      var scale = linearish(transformer()(identity$3));

      scale.copy = function() {
        return copy(scale, diverging$1());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingLog() {
      var scale = loggish(transformer()).domain([0.1, 1, 10]);

      scale.copy = function() {
        return copy(scale, divergingLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSymlog() {
      var scale = symlogish(transformer());

      scale.copy = function() {
        return copy(scale, divergingSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingPow() {
      var scale = powish(transformer());

      scale.copy = function() {
        return copy(scale, divergingPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    var ramp$1 = scheme => rgbBasis(scheme[scheme.length - 1]);

    var scheme$q = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);

    var BrBG = ramp$1(scheme$q);

    var scheme$p = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);

    var PRGn = ramp$1(scheme$p);

    var scheme$o = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);

    var PiYG = ramp$1(scheme$o);

    var scheme$n = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);

    var PuOr = ramp$1(scheme$n);

    var scheme$m = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);

    var RdBu = ramp$1(scheme$m);

    var scheme$l = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);

    var RdGy = ramp$1(scheme$l);

    var scheme$k = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);

    var RdYlBu = ramp$1(scheme$k);

    var scheme$j = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);

    var RdYlGn = ramp$1(scheme$j);

    var scheme$i = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);

    var Spectral = ramp$1(scheme$i);

    var scheme$h = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);

    var BuGn = ramp$1(scheme$h);

    var scheme$g = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);

    var BuPu = ramp$1(scheme$g);

    var scheme$f = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);

    var GnBu = ramp$1(scheme$f);

    var scheme$e = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);

    var OrRd = ramp$1(scheme$e);

    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);

    var PuBuGn = ramp$1(scheme$d);

    var scheme$c = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);

    var PuBu = ramp$1(scheme$c);

    var scheme$b = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);

    var PuRd = ramp$1(scheme$b);

    var scheme$a = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);

    var RdPu = ramp$1(scheme$a);

    var scheme$9 = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);

    var YlGnBu = ramp$1(scheme$9);

    var scheme$8 = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);

    var YlGn = ramp$1(scheme$8);

    var scheme$7 = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);

    var YlOrBr = ramp$1(scheme$7);

    var scheme$6 = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);

    var YlOrRd = ramp$1(scheme$6);

    var scheme$5 = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);

    var Blues = ramp$1(scheme$5);

    var scheme$4 = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);

    var Greens = ramp$1(scheme$4);

    var scheme$3 = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);

    var Greys = ramp$1(scheme$3);

    var scheme$2 = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);

    var Purples = ramp$1(scheme$2);

    var scheme$1 = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);

    var Reds = ramp$1(scheme$1);

    var scheme = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);

    var Oranges = ramp$1(scheme);

    function cividis(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
          + ")";
    }

    var cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0.0), cubehelix$3(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var c$2 = cubehelix$3();

    function rainbow(t) {
      if (t < 0 || t > 1) t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c$2.h = 360 * t - 100;
      c$2.s = 1.5 - 1.5 * ts;
      c$2.l = 0.8 - 0.9 * ts;
      return c$2 + "";
    }

    var c$1 = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function sinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c$1.r = 255 * (x = Math.sin(t)) * x;
      c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c$1 + "";
    }

    function turbo(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
          + ")";
    }

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function constant$1(x) {
      return function constant() {
        return x;
      };
    }

    var abs = Math.abs;
    var atan2 = Math.atan2;
    var cos = Math.cos;
    var max = Math.max;
    var min = Math.min;
    var sin = Math.sin;
    var sqrt = Math.sqrt;

    var epsilon = 1e-12;
    var pi = Math.PI;
    var halfPi = pi / 2;
    var tau = 2 * pi;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
      return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant$1(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null;

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi,
            a1 = endAngle.apply(this, arguments) - halfPi,
            da = abs(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau - epsilon) {
          context.moveTo(r1 * cos(a0), r1 * sin(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon) {
            context.moveTo(r0 * cos(a1), r0 * sin(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
              rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1  r0, da1  da0.
          if (rp > epsilon) {
            var p0 = asin(rp / r0 * sin(ap)),
                p1 = asin(rp / r1 * sin(ap));
            if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos(a01),
              y01 = r1 * sin(a01),
              x10 = r0 * cos(a10),
              y10 = r0 * sin(a10);

          // Apply rounded corners?
          if (rc > epsilon) {
            var x11 = r1 * cos(a11),
                y11 = r1 * sin(a11),
                x00 = r0 * cos(a00),
                y00 = r0 * sin(a00),
                oc;

            // Restrict the corner radius according to the sector angle.
            if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
                  lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min(rc, (r0 - lc) / (kc - 1));
              rc1 = min(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon)) context.moveTo(x01, y01);

          // Does the sectors outer ring have rounded corners?
          else if (rc1 > epsilon) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and its a circular sector?
          // Or perhaps its an annular sector collapsed due to padding?
          if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

          // Does the sectors inner ring (or point) have rounded corners?
          else if (rc0 > epsilon) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
        return [cos(a) * r, sin(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    var slice = Array.prototype.slice;

    function array(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: this._context.lineTo(x, y); break;
        }
      }
    };

    function curveLinear(context) {
      return new Linear(context);
    }

    function x(p) {
      return p[0];
    }

    function y(p) {
      return p[1];
    }

    function line(x$1, y$1) {
      var defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x$1 = typeof x$1 === "function" ? x$1 : (x$1 === undefined) ? x : constant$1(x$1);
      y$1 = typeof y$1 === "function" ? y$1 : (y$1 === undefined) ? y : constant$1(y$1);

      function line(data) {
        var i,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer;

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), line) : x$1;
      };

      line.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), line) : y$1;
      };

      line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), line) : defined;
      };

      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area(x0, y0, y1) {
      var x1 = null,
          defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x : constant$1(+x0);
      y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant$1(0) : constant$1(+y0);
      y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y : constant$1(+y1);

      function area(data) {
        var i,
            j,
            k,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }

      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
      };

      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
      };

      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
      };

      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
      };

      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
      };

      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
      };

      area.lineX0 =
      area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };

      area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), area) : defined;
      };

      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    function descending$1(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$1(d) {
      return d;
    }

    function pie() {
      var value = identity$1,
          sortValues = descending$1,
          sort = null,
          startAngle = constant$1(0),
          endAngle = constant$1(tau),
          padAngle = constant$1(0);

      function pie(data) {
        var i,
            n = (data = array(data)).length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v;

        for (i = 0; i < n; ++i) {
          if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
            sum += v;
          }
        }

        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
        else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

        // Compute the arcs! They are stored in the original data's order.
        for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
          j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
          };
        }

        return arcs;
      }

      pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), pie) : value;
      };

      pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
      };

      pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
      };

      pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : startAngle;
      };

      pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : endAngle;
      };

      pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : padAngle;
      };

      return pie;
    }

    var curveRadialLinear = curveRadial$1(curveLinear);

    function Radial(curve) {
      this._curve = curve;
    }

    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
      }
    };

    function curveRadial$1(curve) {

      function radial(context) {
        return new Radial(curve(context));
      }

      radial._curve = curve;

      return radial;
    }

    function lineRadial(l) {
      var c = l.curve;

      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;

      l.curve = function(_) {
        return arguments.length ? c(curveRadial$1(_)) : c()._curve;
      };

      return l;
    }

    function lineRadial$1() {
      return lineRadial(line().curve(curveRadialLinear));
    }

    function areaRadial() {
      var a = area().curve(curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1;

      a.angle = a.x, delete a.x;
      a.startAngle = a.x0, delete a.x0;
      a.endAngle = a.x1, delete a.x1;
      a.radius = a.y, delete a.y;
      a.innerRadius = a.y0, delete a.y0;
      a.outerRadius = a.y1, delete a.y1;
      a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
      a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
      a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
      a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

      a.curve = function(_) {
        return arguments.length ? c(curveRadial$1(_)) : c()._curve;
      };

      return a;
    }

    function pointRadial(x, y) {
      return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    function linkSource(d) {
      return d.source;
    }

    function linkTarget(d) {
      return d.target;
    }

    function link(curve) {
      var source = linkSource,
          target = linkTarget,
          x$1 = x,
          y$1 = y,
          context = null;

      function link() {
        var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
        if (!context) context = buffer = path();
        curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
        if (buffer) return context = null, buffer + "" || null;
      }

      link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
      };

      link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
      };

      link.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), link) : x$1;
      };

      link.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), link) : y$1;
      };

      link.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), link) : context;
      };

      return link;
    }

    function curveHorizontal(context, x0, y0, x1, y1) {
      context.moveTo(x0, y0);
      context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
    }

    function curveVertical(context, x0, y0, x1, y1) {
      context.moveTo(x0, y0);
      context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
    }

    function curveRadial(context, x0, y0, x1, y1) {
      var p0 = pointRadial(x0, y0),
          p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
          p2 = pointRadial(x1, y0),
          p3 = pointRadial(x1, y1);
      context.moveTo(p0[0], p0[1]);
      context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
    }

    function linkHorizontal() {
      return link(curveHorizontal);
    }

    function linkVertical() {
      return link(curveVertical);
    }

    function linkRadial() {
      var l = link(curveRadial);
      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;
      return l;
    }

    var circle = {
      draw: function(context, size) {
        var r = Math.sqrt(size / pi);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau);
      }
    };

    var cross = {
      draw: function(context, size) {
        var r = Math.sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };

    var tan30 = Math.sqrt(1 / 3),
        tan30_2 = tan30 * 2;

    var diamond = {
      draw: function(context, size) {
        var y = Math.sqrt(size / tan30_2),
            x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };

    var ka = 0.89081309152928522810,
        kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
        kx = Math.sin(tau / 10) * kr,
        ky = -Math.cos(tau / 10) * kr;

    var star = {
      draw: function(context, size) {
        var r = Math.sqrt(size * ka),
            x = kx * r,
            y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (var i = 1; i < 5; ++i) {
          var a = tau * i / 5,
              c = Math.cos(a),
              s = Math.sin(a);
          context.lineTo(s * r, -c * r);
          context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
      }
    };

    var square = {
      draw: function(context, size) {
        var w = Math.sqrt(size),
            x = -w / 2;
        context.rect(x, x, w, w);
      }
    };

    var sqrt3 = Math.sqrt(3);

    var triangle = {
      draw: function(context, size) {
        var y = -Math.sqrt(size / (sqrt3 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3 * y, -y);
        context.lineTo(sqrt3 * y, -y);
        context.closePath();
      }
    };

    var c = -0.5,
        s = Math.sqrt(3) / 2,
        k = 1 / Math.sqrt(12),
        a = (k / 2 + 1) * 3;

    var wye = {
      draw: function(context, size) {
        var r = Math.sqrt(size / a),
            x0 = r / 2,
            y0 = r * k,
            x1 = x0,
            y1 = r * k + r,
            x2 = -x1,
            y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };

    var symbols = [
      circle,
      cross,
      diamond,
      square,
      star,
      triangle,
      wye
    ];

    function symbol(type, size) {
      var context = null;
      type = typeof type === "function" ? type : constant$1(type || circle);
      size = typeof size === "function" ? size : constant$1(size === undefined ? 64 : +size);

      function symbol() {
        var buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$1(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$1(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function noop$1() {}

    function point$3(that, x, y) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x) / 6,
        (that._y0 + 4 * that._y1 + y) / 6
      );
    }

    function Basis(context) {
      this._context = context;
    }

    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3: point$3(this, this._x1, this._y1); // falls through
          case 2: this._context.lineTo(this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basis(context) {
      return new Basis(context);
    }

    function BasisClosed(context) {
      this._context = context;
    }

    BasisClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
          case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
          case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisClosed(context) {
      return new BasisClosed(context);
    }

    function BasisOpen(context) {
      this._context = context;
    }

    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
          case 3: this._point = 4; // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisOpen(context) {
      return new BasisOpen(context);
    }

    class Bump {
      constructor(context, x) {
        this._context = context;
        this._x = x;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line) this._context.lineTo(x, y);
            else this._context.moveTo(x, y);
            break;
          }
          case 1: this._point = 2; // falls through
          default: {
            if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
            else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
            break;
          }
        }
        this._x0 = x, this._y0 = y;
      }
    }

    function bumpX(context) {
      return new Bump(context, true);
    }

    function bumpY(context) {
      return new Bump(context, false);
    }

    function Bundle(context, beta) {
      this._basis = new Basis(context);
      this._beta = beta;
    }

    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            j = x.length - 1;

        if (j > 0) {
          var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t;

          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }

        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    var bundle = (function custom(beta) {

      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }

      bundle.beta = function(beta) {
        return custom(+beta);
      };

      return bundle;
    })(0.85);

    function point$2(that, x, y) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x),
        that._y2 + that._k * (that._y1 - y),
        that._x2,
        that._y2
      );
    }

    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: point$2(this, this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
          case 2: this._point = 3; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinal = (function custom(tension) {

      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalClosed = (function custom(tension) {

      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalOpen = (function custom(tension) {

      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function point$1(that, x, y) {
      var x1 = that._x1,
          y1 = that._y1,
          x2 = that._x2,
          y2 = that._y2;

      if (that._l01_a > epsilon) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
            n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
      }

      if (that._l23_a > epsilon) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
            m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
      }

      that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }

    function CatmullRom(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: this.point(this._x2, this._y2); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRom = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomClosed(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomClosed = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomOpen(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomOpen = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function LinearClosed(context) {
      this._context = context;
    }

    LinearClosed.prototype = {
      areaStart: noop$1,
      areaEnd: noop$1,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
      }
    };

    function linearClosed(context) {
      return new LinearClosed(context);
    }

    function sign(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bzier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    function monotoneX(context) {
      return new MonotoneX(context);
    }

    function monotoneY(context) {
      return new MonotoneY(context);
    }

    function Natural(context) {
      this._context = context;
    }

    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            n = x.length;

        if (n) {
          this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
          if (n === 2) {
            this._context.lineTo(x[1], y[1]);
          } else {
            var px = controlPoints(x),
                py = controlPoints(y);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
          }
        }

        if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
    function controlPoints(x) {
      var i,
          n = x.length - 1,
          m,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n);
      a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
      for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
      a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
      for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
      a[n - 1] = r[n - 1] / b[n - 1];
      for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
      b[n - 1] = (x[n] + a[n - 1]) / 2;
      for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
      return [a, b];
    }

    function natural(context) {
      return new Natural(context);
    }

    function Step(context, t) {
      this._context = context;
      this._t = t;
    }

    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
        }
        this._x = x, this._y = y;
      }
    };

    function step(context) {
      return new Step(context, 0.5);
    }

    function stepBefore(context) {
      return new Step(context, 0);
    }

    function stepAfter(context) {
      return new Step(context, 1);
    }

    function none$1(series, order) {
      if (!((n = series.length) > 1)) return;
      for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
        s0 = s1, s1 = series[order[i]];
        for (j = 0; j < m; ++j) {
          s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
        }
      }
    }

    function none(series) {
      var n = series.length, o = new Array(n);
      while (--n >= 0) o[n] = n;
      return o;
    }

    function stackValue(d, key) {
      return d[key];
    }

    function stackSeries(key) {
      const series = [];
      series.key = key;
      return series;
    }

    function stack() {
      var keys = constant$1([]),
          order = none,
          offset = none$1,
          value = stackValue;

      function stack(data) {
        var sz = Array.from(keys.apply(this, arguments), stackSeries),
            i, n = sz.length, j = -1,
            oz;

        for (const d of data) {
          for (i = 0, ++j; i < n; ++i) {
            (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
          }
        }

        for (i = 0, oz = array(order(sz)); i < n; ++i) {
          sz[oz[i]].index = i;
        }

        offset(sz, oz);
        return sz;
      }

      stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : keys;
      };

      stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), stack) : value;
      };

      stack.order = function(_) {
        return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : order;
      };

      stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
      };

      return stack;
    }

    function expand(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
        for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
        if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
      }
      none$1(series, order);
    }

    function diverging(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
        for (yp = yn = 0, i = 0; i < n; ++i) {
          if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
            d[0] = yp, d[1] = yp += dy;
          } else if (dy < 0) {
            d[1] = yn, d[0] = yn += dy;
          } else {
            d[0] = 0, d[1] = dy;
          }
        }
      }
    }

    function silhouette(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
        for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
      }
      none$1(series, order);
    }

    function wiggle(series, order) {
      if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
      for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
        for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
          var si = series[order[i]],
              sij0 = si[j][1] || 0,
              sij1 = si[j - 1][1] || 0,
              s3 = (sij0 - sij1) / 2;
          for (var k = 0; k < i; ++k) {
            var sk = series[order[k]],
                skj0 = sk[j][1] || 0,
                skj1 = sk[j - 1][1] || 0;
            s3 += skj0 - skj1;
          }
          s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      none$1(series, order);
    }

    function appearance(series) {
      var peaks = series.map(peak);
      return none(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
    }

    function peak(series) {
      var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
      while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
      return j;
    }

    function ascending(series) {
      var sums = series.map(sum);
      return none(series).sort(function(a, b) { return sums[a] - sums[b]; });
    }

    function sum(series) {
      var s = 0, i = -1, n = series.length, v;
      while (++i < n) if (v = +series[i][1]) s += v;
      return s;
    }

    function descending(series) {
      return ascending(series).reverse();
    }

    function insideOut(series) {
      var n = series.length,
          i,
          j,
          sums = series.map(sum),
          order = appearance(series),
          top = 0,
          bottom = 0,
          tops = [],
          bottoms = [];

      for (i = 0; i < n; ++i) {
        j = order[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }

      return bottoms.reverse().concat(tops);
    }

    function reverse(series) {
      return none(series).reverse();
    }

    var constant = x => () => x;

    function ZoomEvent(type, {
      sourceEvent,
      target,
      transform,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        transform: {value: transform, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }

    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };

    var identity = new Transform(1, 0, 0);

    transform.prototype = Transform.prototype;

    function transform(node) {
      while (!node.__zoom) if (!(node = node.parentNode)) return identity;
      return node.__zoom;
    }

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }

    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === 'wheel') && !event.button;
    }

    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }

    function defaultTransform() {
      return this.__zoom || identity;
    }

    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
          dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
          dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
          dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }

    function zoom() {
      var filter = defaultFilter,
          extent = defaultExtent,
          constrain = defaultConstrain,
          wheelDelta = defaultWheelDelta,
          touchable = defaultTouchable,
          scaleExtent = [0, Infinity],
          translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
          duration = 250,
          interpolate = interpolateZoom,
          listeners = dispatch("start", "zoom", "end"),
          touchstarting,
          touchfirst,
          touchending,
          touchDelay = 500,
          wheelDelay = 150,
          clickDistance2 = 0,
          tapDistance = 10;

      function zoom(selection) {
        selection
            .property("__zoom", defaultTransform)
            .on("wheel.zoom", wheeled, {passive: false})
            .on("mousedown.zoom", mousedowned)
            .on("dblclick.zoom", dblclicked)
          .filter(touchable)
            .on("touchstart.zoom", touchstarted)
            .on("touchmove.zoom", touchmoved)
            .on("touchend.zoom touchcancel.zoom", touchended)
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      zoom.transform = function(collection, transform, point, event) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
          schedule(collection, transform, point, event);
        } else {
          selection.interrupt().each(function() {
            gesture(this, arguments)
              .event(event)
              .start()
              .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
              .end();
          });
        }
      };

      zoom.scaleBy = function(selection, k, p, event) {
        zoom.scaleTo(selection, function() {
          var k0 = this.__zoom.k,
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p, event);
      };

      zoom.scaleTo = function(selection, k, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t0 = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
              p1 = t0.invert(p0),
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p, event);
      };

      zoom.translateBy = function(selection, x, y, event) {
        zoom.transform(selection, function() {
          return constrain(this.__zoom.translate(
            typeof x === "function" ? x.apply(this, arguments) : x,
            typeof y === "function" ? y.apply(this, arguments) : y
          ), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };

      zoom.translateTo = function(selection, x, y, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x === "function" ? -x.apply(this, arguments) : -x,
            typeof y === "function" ? -y.apply(this, arguments) : -y
          ), e, translateExtent);
        }, p, event);
      };

      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }

      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }

      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }

      function schedule(transition, transform, point, event) {
        transition
            .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
            .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
            .tween("zoom", function() {
              var that = this,
                  args = arguments,
                  g = gesture(that, args).event(event),
                  e = extent.apply(that, args),
                  p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
                  w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                  a = that.__zoom,
                  b = typeof transform === "function" ? transform.apply(that, args) : transform,
                  i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
              return function(t) {
                if (t === 1) t = b; // Avoid rounding error on end.
                else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
                g.zoom(null, t);
              };
            });
      }

      function gesture(that, args, clean) {
        return (!clean && that.__zooming) || new Gesture(that, args);
      }

      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }

      Gesture.prototype = {
        event: function(event) {
          if (event) this.sourceEvent = event;
          return this;
        },
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new ZoomEvent(type, {
              sourceEvent: this.sourceEvent,
              target: zoom,
              type,
              transform: this.that.__zoom,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function wheeled(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, args).event(event),
            t = this.__zoom,
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
            p = pointer(event);

        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }
          clearTimeout(g.wheel);
        }

        // If this wheel event wont trigger a transform change, ignore it.
        else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }

      function mousedowned(event, ...args) {
        if (touchending || !filter.apply(this, arguments)) return;
        var currentTarget = event.currentTarget,
            g = gesture(this, args, true).event(event),
            v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
            p = pointer(event, currentTarget),
            x0 = event.clientX,
            y0 = event.clientY;

        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();

        function mousemoved(event) {
          noevent(event);
          if (!g.moved) {
            var dx = event.clientX - x0, dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event)
           .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }

        function mouseupped(event) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent(event);
          g.event(event).end();
        }
      }

      function dblclicked(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
            p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
            p1 = t0.invert(p0),
            k1 = t0.k * (event.shiftKey ? 0.5 : 2),
            t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

        noevent(event);
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);
        else select(this).call(zoom.transform, t1, p0, event);
      }

      function touchstarted(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
            n = touches.length,
            g = gesture(this, args, event.changedTouches.length === n).event(event),
            started, i, t, p;

        nopropagation(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }

        if (touchstarting) touchstarting = clearTimeout(touchstarting);

        if (started) {
          if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
          interrupt(this);
          g.start();
        }
      }

      function touchmoved(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t, p, l;

        noevent(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
          else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1],
              p1 = g.touch1[0], l1 = g.touch1[1],
              dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
              dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        }
        else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
        else return;

        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }

      function touchended(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t;

        nopropagation(event);
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
            }
          }
        }
      }

      zoom.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
      };

      zoom.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
      };

      zoom.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
      };

      zoom.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };

      zoom.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };

      zoom.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };

      zoom.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };

      zoom.duration = function(_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };

      zoom.interpolate = function(_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };

      zoom.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };

      zoom.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };

      zoom.tapDistance = function(_) {
        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
      };

      return zoom;
    }

    var d3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bisect: bisectRight,
        bisectRight: bisectRight,
        bisectLeft: bisectLeft,
        bisectCenter: bisectCenter,
        ascending: ascending$3,
        bisector: bisector,
        count: count$1,
        cross: cross$2,
        cumsum: cumsum,
        descending: descending$2,
        deviation: deviation,
        extent: extent$1,
        Adder: Adder,
        fsum: fsum,
        fcumsum: fcumsum,
        group: group,
        flatGroup: flatGroup,
        flatRollup: flatRollup,
        groups: groups,
        index: index$4,
        indexes: indexes,
        rollup: rollup,
        rollups: rollups,
        groupSort: groupSort,
        bin: bin,
        histogram: bin,
        thresholdFreedmanDiaconis: freedmanDiaconis,
        thresholdScott: scott,
        thresholdSturges: thresholdSturges,
        max: max$3,
        maxIndex: maxIndex,
        mean: mean,
        median: median,
        merge: merge,
        min: min$2,
        minIndex: minIndex,
        mode: mode,
        nice: nice$1,
        pairs: pairs,
        permute: permute,
        quantile: quantile$1,
        quantileSorted: quantileSorted,
        quickselect: quickselect,
        range: range$3,
        least: least,
        leastIndex: leastIndex,
        greatest: greatest,
        greatestIndex: greatestIndex,
        scan: scan,
        shuffle: shuffle$1,
        shuffler: shuffler,
        sum: sum$2,
        ticks: ticks,
        tickIncrement: tickIncrement,
        tickStep: tickStep,
        transpose: transpose,
        variance: variance,
        zip: zip,
        every: every,
        some: some,
        filter: filter$1,
        map: map$1,
        reduce: reduce,
        reverse: reverse$1,
        sort: sort,
        difference: difference,
        disjoint: disjoint,
        intersection: intersection,
        subset: subset,
        superset: superset,
        union: union,
        InternMap: InternMap,
        InternSet: InternSet,
        axisTop: axisTop,
        axisRight: axisRight,
        axisBottom: axisBottom,
        axisLeft: axisLeft,
        brush: brush,
        brushX: brushX,
        brushY: brushY,
        brushSelection: brushSelection,
        chord: chord,
        chordTranspose: chordTranspose,
        chordDirected: chordDirected,
        ribbon: ribbon$1,
        ribbonArrow: ribbonArrow,
        color: color$1,
        rgb: rgb,
        hsl: hsl$2,
        lab: lab$1,
        hcl: hcl$2,
        lch: lch,
        gray: gray,
        cubehelix: cubehelix$3,
        contours: contours,
        contourDensity: density,
        Delaunay: Delaunay,
        Voronoi: Voronoi,
        dispatch: dispatch,
        drag: drag,
        dragDisable: dragDisable,
        dragEnable: yesdrag,
        dsvFormat: dsvFormat,
        csvParse: csvParse,
        csvParseRows: csvParseRows,
        csvFormat: csvFormat,
        csvFormatBody: csvFormatBody,
        csvFormatRows: csvFormatRows,
        csvFormatRow: csvFormatRow,
        csvFormatValue: csvFormatValue,
        tsvParse: tsvParse,
        tsvParseRows: tsvParseRows,
        tsvFormat: tsvFormat,
        tsvFormatBody: tsvFormatBody,
        tsvFormatRows: tsvFormatRows,
        tsvFormatRow: tsvFormatRow,
        tsvFormatValue: tsvFormatValue,
        autoType: autoType,
        easeLinear: linear$1,
        easeQuad: quadInOut,
        easeQuadIn: quadIn,
        easeQuadOut: quadOut,
        easeQuadInOut: quadInOut,
        easeCubic: cubicInOut,
        easeCubicIn: cubicIn,
        easeCubicOut: cubicOut,
        easeCubicInOut: cubicInOut,
        easePoly: polyInOut,
        easePolyIn: polyIn,
        easePolyOut: polyOut,
        easePolyInOut: polyInOut,
        easeSin: sinInOut,
        easeSinIn: sinIn,
        easeSinOut: sinOut,
        easeSinInOut: sinInOut,
        easeExp: expInOut,
        easeExpIn: expIn,
        easeExpOut: expOut,
        easeExpInOut: expInOut,
        easeCircle: circleInOut,
        easeCircleIn: circleIn,
        easeCircleOut: circleOut,
        easeCircleInOut: circleInOut,
        easeBounce: bounceOut,
        easeBounceIn: bounceIn,
        easeBounceOut: bounceOut,
        easeBounceInOut: bounceInOut,
        easeBack: backInOut,
        easeBackIn: backIn,
        easeBackOut: backOut,
        easeBackInOut: backInOut,
        easeElastic: elasticOut,
        easeElasticIn: elasticIn,
        easeElasticOut: elasticOut,
        easeElasticInOut: elasticInOut,
        blob: blob,
        buffer: buffer,
        dsv: dsv,
        csv: csv,
        tsv: tsv,
        image: image,
        json: json,
        text: text,
        xml: xml,
        html: html,
        svg: svg,
        forceCenter: center,
        forceCollide: collide,
        forceLink: link$2,
        forceManyBody: manyBody,
        forceRadial: radial$1,
        forceSimulation: simulation,
        forceX: x$1,
        forceY: y$1,
        formatDefaultLocale: defaultLocale$1,
        get format () { return format; },
        get formatPrefix () { return formatPrefix; },
        formatLocale: formatLocale$1,
        formatSpecifier: formatSpecifier,
        FormatSpecifier: FormatSpecifier,
        precisionFixed: precisionFixed,
        precisionPrefix: precisionPrefix,
        precisionRound: precisionRound,
        geoArea: area$2,
        geoBounds: bounds,
        geoCentroid: centroid$1,
        geoCircle: circle$2,
        geoClipAntimeridian: clipAntimeridian,
        geoClipCircle: clipCircle,
        geoClipExtent: extent,
        geoClipRectangle: clipRectangle,
        geoContains: contains$1,
        geoDistance: distance,
        geoGraticule: graticule,
        geoGraticule10: graticule10,
        geoInterpolate: interpolate,
        geoLength: length$1,
        geoPath: index$2,
        geoAlbers: albers,
        geoAlbersUsa: albersUsa,
        geoAzimuthalEqualArea: azimuthalEqualArea,
        geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
        geoAzimuthalEquidistant: azimuthalEquidistant,
        geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
        geoConicConformal: conicConformal,
        geoConicConformalRaw: conicConformalRaw,
        geoConicEqualArea: conicEqualArea,
        geoConicEqualAreaRaw: conicEqualAreaRaw,
        geoConicEquidistant: conicEquidistant,
        geoConicEquidistantRaw: conicEquidistantRaw,
        geoEqualEarth: equalEarth,
        geoEqualEarthRaw: equalEarthRaw,
        geoEquirectangular: equirectangular,
        geoEquirectangularRaw: equirectangularRaw,
        geoGnomonic: gnomonic,
        geoGnomonicRaw: gnomonicRaw,
        geoIdentity: identity$4,
        geoProjection: projection,
        geoProjectionMutator: projectionMutator,
        geoMercator: mercator,
        geoMercatorRaw: mercatorRaw,
        geoNaturalEarth1: naturalEarth1,
        geoNaturalEarth1Raw: naturalEarth1Raw,
        geoOrthographic: orthographic,
        geoOrthographicRaw: orthographicRaw,
        geoStereographic: stereographic,
        geoStereographicRaw: stereographicRaw,
        geoTransverseMercator: transverseMercator,
        geoTransverseMercatorRaw: transverseMercatorRaw,
        geoRotation: rotation,
        geoStream: geoStream,
        geoTransform: transform$1,
        cluster: cluster,
        hierarchy: hierarchy,
        Node: Node$1,
        pack: index$1,
        packSiblings: siblings,
        packEnclose: enclose,
        partition: partition,
        stratify: stratify,
        tree: tree,
        treemap: index,
        treemapBinary: binary,
        treemapDice: treemapDice,
        treemapSlice: treemapSlice,
        treemapSliceDice: sliceDice,
        treemapSquarify: squarify,
        treemapResquarify: resquarify,
        interpolate: interpolate$2,
        interpolateArray: array$3,
        interpolateBasis: basis$2,
        interpolateBasisClosed: basisClosed$1,
        interpolateDate: date$1,
        interpolateDiscrete: discrete,
        interpolateHue: hue,
        interpolateNumber: interpolateNumber,
        interpolateNumberArray: numberArray,
        interpolateObject: object$1,
        interpolateRound: interpolateRound,
        interpolateString: interpolateString,
        interpolateTransformCss: interpolateTransformCss,
        interpolateTransformSvg: interpolateTransformSvg,
        interpolateZoom: interpolateZoom,
        interpolateRgb: interpolateRgb,
        interpolateRgbBasis: rgbBasis,
        interpolateRgbBasisClosed: rgbBasisClosed,
        interpolateHsl: hsl$1,
        interpolateHslLong: hslLong,
        interpolateLab: lab,
        interpolateHcl: hcl$1,
        interpolateHclLong: hclLong,
        interpolateCubehelix: cubehelix$2,
        interpolateCubehelixLong: cubehelixLong,
        piecewise: piecewise,
        quantize: quantize$1,
        path: path,
        polygonArea: area$1,
        polygonCentroid: centroid,
        polygonHull: hull,
        polygonContains: contains,
        polygonLength: length,
        quadtree: quadtree,
        randomUniform: uniform,
        randomInt: int,
        randomNormal: normal,
        randomLogNormal: logNormal,
        randomBates: bates,
        randomIrwinHall: irwinHall,
        randomExponential: exponential,
        randomPareto: pareto,
        randomBernoulli: bernoulli,
        randomGeometric: geometric,
        randomBinomial: binomial,
        randomGamma: gamma,
        randomBeta: beta,
        randomWeibull: weibull,
        randomCauchy: cauchy,
        randomLogistic: logistic,
        randomPoisson: poisson,
        randomLcg: lcg,
        scaleBand: band,
        scalePoint: point$4,
        scaleIdentity: identity$2,
        scaleLinear: linear,
        scaleLog: log,
        scaleSymlog: symlog,
        scaleOrdinal: ordinal,
        scaleImplicit: implicit,
        scalePow: pow,
        scaleSqrt: sqrt$1,
        scaleRadial: radial,
        scaleQuantile: quantile,
        scaleQuantize: quantize,
        scaleThreshold: threshold,
        scaleTime: time,
        scaleUtc: utcTime,
        scaleSequential: sequential,
        scaleSequentialLog: sequentialLog,
        scaleSequentialPow: sequentialPow,
        scaleSequentialSqrt: sequentialSqrt,
        scaleSequentialSymlog: sequentialSymlog,
        scaleSequentialQuantile: sequentialQuantile,
        scaleDiverging: diverging$1,
        scaleDivergingLog: divergingLog,
        scaleDivergingPow: divergingPow,
        scaleDivergingSqrt: divergingSqrt,
        scaleDivergingSymlog: divergingSymlog,
        tickFormat: tickFormat,
        schemeCategory10: category10,
        schemeAccent: Accent,
        schemeDark2: Dark2,
        schemePaired: Paired,
        schemePastel1: Pastel1,
        schemePastel2: Pastel2,
        schemeSet1: Set1,
        schemeSet2: Set2,
        schemeSet3: Set3,
        schemeTableau10: Tableau10,
        interpolateBrBG: BrBG,
        schemeBrBG: scheme$q,
        interpolatePRGn: PRGn,
        schemePRGn: scheme$p,
        interpolatePiYG: PiYG,
        schemePiYG: scheme$o,
        interpolatePuOr: PuOr,
        schemePuOr: scheme$n,
        interpolateRdBu: RdBu,
        schemeRdBu: scheme$m,
        interpolateRdGy: RdGy,
        schemeRdGy: scheme$l,
        interpolateRdYlBu: RdYlBu,
        schemeRdYlBu: scheme$k,
        interpolateRdYlGn: RdYlGn,
        schemeRdYlGn: scheme$j,
        interpolateSpectral: Spectral,
        schemeSpectral: scheme$i,
        interpolateBuGn: BuGn,
        schemeBuGn: scheme$h,
        interpolateBuPu: BuPu,
        schemeBuPu: scheme$g,
        interpolateGnBu: GnBu,
        schemeGnBu: scheme$f,
        interpolateOrRd: OrRd,
        schemeOrRd: scheme$e,
        interpolatePuBuGn: PuBuGn,
        schemePuBuGn: scheme$d,
        interpolatePuBu: PuBu,
        schemePuBu: scheme$c,
        interpolatePuRd: PuRd,
        schemePuRd: scheme$b,
        interpolateRdPu: RdPu,
        schemeRdPu: scheme$a,
        interpolateYlGnBu: YlGnBu,
        schemeYlGnBu: scheme$9,
        interpolateYlGn: YlGn,
        schemeYlGn: scheme$8,
        interpolateYlOrBr: YlOrBr,
        schemeYlOrBr: scheme$7,
        interpolateYlOrRd: YlOrRd,
        schemeYlOrRd: scheme$6,
        interpolateBlues: Blues,
        schemeBlues: scheme$5,
        interpolateGreens: Greens,
        schemeGreens: scheme$4,
        interpolateGreys: Greys,
        schemeGreys: scheme$3,
        interpolatePurples: Purples,
        schemePurples: scheme$2,
        interpolateReds: Reds,
        schemeReds: scheme$1,
        interpolateOranges: Oranges,
        schemeOranges: scheme,
        interpolateCividis: cividis,
        interpolateCubehelixDefault: cubehelix,
        interpolateRainbow: rainbow,
        interpolateWarm: warm,
        interpolateCool: cool,
        interpolateSinebow: sinebow,
        interpolateTurbo: turbo,
        interpolateViridis: viridis,
        interpolateMagma: magma,
        interpolateInferno: inferno,
        interpolatePlasma: plasma,
        create: create$1,
        creator: creator,
        local: local$1,
        matcher: matcher,
        namespace: namespace,
        namespaces: namespaces,
        pointer: pointer,
        pointers: pointers,
        select: select,
        selectAll: selectAll,
        selection: selection,
        selector: selector,
        selectorAll: selectorAll,
        style: styleValue,
        window: defaultView,
        arc: arc,
        area: area,
        line: line,
        pie: pie,
        areaRadial: areaRadial,
        radialArea: areaRadial,
        lineRadial: lineRadial$1,
        radialLine: lineRadial$1,
        pointRadial: pointRadial,
        linkHorizontal: linkHorizontal,
        linkVertical: linkVertical,
        linkRadial: linkRadial,
        symbol: symbol,
        symbols: symbols,
        symbolCircle: circle,
        symbolCross: cross,
        symbolDiamond: diamond,
        symbolSquare: square,
        symbolStar: star,
        symbolTriangle: triangle,
        symbolWye: wye,
        curveBasisClosed: basisClosed,
        curveBasisOpen: basisOpen,
        curveBasis: basis,
        curveBumpX: bumpX,
        curveBumpY: bumpY,
        curveBundle: bundle,
        curveCardinalClosed: cardinalClosed,
        curveCardinalOpen: cardinalOpen,
        curveCardinal: cardinal,
        curveCatmullRomClosed: catmullRomClosed,
        curveCatmullRomOpen: catmullRomOpen,
        curveCatmullRom: catmullRom,
        curveLinearClosed: linearClosed,
        curveLinear: curveLinear,
        curveMonotoneX: monotoneX,
        curveMonotoneY: monotoneY,
        curveNatural: natural,
        curveStep: step,
        curveStepAfter: stepAfter,
        curveStepBefore: stepBefore,
        stack: stack,
        stackOffsetExpand: expand,
        stackOffsetDiverging: diverging,
        stackOffsetNone: none$1,
        stackOffsetSilhouette: silhouette,
        stackOffsetWiggle: wiggle,
        stackOrderAppearance: appearance,
        stackOrderAscending: ascending,
        stackOrderDescending: descending,
        stackOrderInsideOut: insideOut,
        stackOrderNone: none,
        stackOrderReverse: reverse,
        timeInterval: newInterval,
        timeMillisecond: millisecond,
        timeMilliseconds: milliseconds,
        utcMillisecond: millisecond,
        utcMilliseconds: milliseconds,
        timeSecond: second,
        timeSeconds: seconds,
        utcSecond: second,
        utcSeconds: seconds,
        timeMinute: minute,
        timeMinutes: minutes,
        timeHour: hour,
        timeHours: hours,
        timeDay: day,
        timeDays: days,
        timeWeek: sunday,
        timeWeeks: sundays,
        timeSunday: sunday,
        timeSundays: sundays,
        timeMonday: monday,
        timeMondays: mondays,
        timeTuesday: tuesday,
        timeTuesdays: tuesdays,
        timeWednesday: wednesday,
        timeWednesdays: wednesdays,
        timeThursday: thursday,
        timeThursdays: thursdays,
        timeFriday: friday,
        timeFridays: fridays,
        timeSaturday: saturday,
        timeSaturdays: saturdays,
        timeMonth: month,
        timeMonths: months,
        timeYear: year,
        timeYears: years,
        utcMinute: utcMinute,
        utcMinutes: utcMinutes,
        utcHour: utcHour,
        utcHours: utcHours,
        utcDay: utcDay,
        utcDays: utcDays,
        utcWeek: utcSunday,
        utcWeeks: utcSundays,
        utcSunday: utcSunday,
        utcSundays: utcSundays,
        utcMonday: utcMonday,
        utcMondays: utcMondays,
        utcTuesday: utcTuesday,
        utcTuesdays: utcTuesdays,
        utcWednesday: utcWednesday,
        utcWednesdays: utcWednesdays,
        utcThursday: utcThursday,
        utcThursdays: utcThursdays,
        utcFriday: utcFriday,
        utcFridays: utcFridays,
        utcSaturday: utcSaturday,
        utcSaturdays: utcSaturdays,
        utcMonth: utcMonth,
        utcMonths: utcMonths,
        utcYear: utcYear,
        utcYears: utcYears,
        utcTicks: utcTicks,
        utcTickInterval: utcTickInterval,
        timeTicks: timeTicks,
        timeTickInterval: timeTickInterval,
        timeFormatDefaultLocale: defaultLocale,
        get timeFormat () { return timeFormat; },
        get timeParse () { return timeParse; },
        get utcFormat () { return utcFormat; },
        get utcParse () { return utcParse; },
        timeFormatLocale: formatLocale,
        isoFormat: formatIso,
        isoParse: parseIso,
        now: now,
        timer: timer,
        timerFlush: timerFlush,
        timeout: timeout,
        interval: interval,
        transition: transition,
        active: active,
        interrupt: interrupt,
        zoom: zoom,
        zoomTransform: transform,
        zoomIdentity: identity,
        ZoomTransform: Transform
    });

    const STEP = 0.0125;
    // const STEP = 0.5;
    const CUT_SIZE = 2;
    const ALPHA_RANGE = 5;

    class Plot {
      constructor(context, n) {
        this.touch = 0;
        this.ctx = context; 
        this.height = this.ctx.height;
        this.width = this.ctx.width;
        this.unitToAlpha = linear().domain([0, 1]).range([-ALPHA_RANGE, ALPHA_RANGE]);
        this.n = n;
        this.kernels = [null, null];
        this.kernels[0] = new RBFKernel();
        this.kernels[1] = new RBFShuffleKernel(CUT_SIZE);
        this.active_ker = 0;
        this.K = Matrix.zeros(this.n, this.n);
        this.invK = Matrix.zeros(this.n, this.n);
        this.validInv = true;
        this.curveCache = null; // cc[ci][xi] = y.  (curve_idx, x_idx)
        this.xCache = null;

        this.populate();

      }

      get_xrange() {
        return [this.ctx.xmin, this.ctx.xmax];
      }

      initK() {
        var n = this.n, v;
        this.K = Matrix.zeros(this.n, this.n);
        for (let i = 0; i != n; i++) {
          for (let j = 0; j != n; j++) {
            v = this.kernel(this.mu[i], this.x[j]);
            this.K.set(i,j,v);
          }
        }
        this.initInvK();
      }

      initInvK() {
        try {
          var inv = inverse(this.K); 
          this.invK = inv;
          this.validInv = true;
        } catch(err) {
          console.log('could not invert K.  leaving as-is');
          this.validInv = false;
        }
      }

      initXCache() {
        var cuts = [this.ctx.xmin, this.ctx.xmax];
        var xs;
        for (let i = 0; i != this.n; i++)
          cuts.push(...this.jumps(this.x[i]));
        cuts.sort((a, b) => a - b);

        this.xCache = new Array(0);
        for (let s = 0; s != cuts.length - 1; s++) {
          xs = range$3(cuts[s], cuts[s+1], STEP);
          this.xCache.push(xs);
        }
      }

      initCurveCache() {
        var n = this.n;
        this.initXCache();
        this.curveCache = new Array(n);
        for (let ci = 0; ci != n; ci++) 
            this.updateCurveCache(ci);
      }

      // updates i'th curve Cache
      updateCurveCache(ci) {
        var seg;
        this.curveCache[ci] = new Array();
        for (let si = 0; si != this.xCache.length; si++) {
          seg = this.xCache[si].map(x => this.kernel(this.mu[ci], x));
          this.curveCache[ci].push(...seg);
        }
      }

      toggle_scramble() {
        this.active_ker = 1 - this.active_ker;
        this.initK();
        this.initCurveCache();
      }

      scrambled() {
        return this.active_ker == 1;
      }

      cut_size() {
        return CUT_SIZE;
      }

      resetAlpha() {
        this.alpha.fill(1);
      }

      set_sigma(log_sigma) {
        for (let k = 0; k != this.kernels.length; k++) {
          this.kernels[k].set_sigma(Math.pow(10, log_sigma));
        }
        for (let ci = 0; ci != this.n; ci++)
          this.updateCurveCache(ci);

        this.initK();
      }

      recenter_mu() {
        for (let i = 0; i != this.n; i++) {
          this.mu[i] = this.x[i];
        }
        this.initK();
        this.initInvK();
        this.initCurveCache();
      }

      get_sigma2() {
        return this.kernels[this.active_ker].get_sigma2();
      }

      populate() {
        var n = this.n;
        this.x = new Array(n);
        this.y = new Array(n);
        this.mu = new Array(n);
        this.alpha = new Array(n); 

        for (let i = 0; i != n; i++) {
          this.x[i] = this.ctx.unitToX(Math.random());
          this.mu[i] = this.x[i];
          this.alpha[i] = this.unitToAlpha(Math.random());
        }
        this.initK();
        this.initCurveCache();

        for (let i = 0; i != n; i++) 
          this.y[i] = this.solutionPoint(i);

        this.alpha.fill(1.0);
      }

      setDataPoint(i, u, v) {
        // update the value of the i'th data point
        this.x[i] = this.ctx.x(u);
        this.y[i] = this.ctx.y(v);
        this.initK();
        this.initInvK();
        this.updateCurveCache(i);
      }

      setMu(i, u) {
        this.mu[i] = this.ctx.x(u);
        this.initK();
        this.initInvK();
        this.updateCurveCache(i);
      }

      kernel(x1, x2) {
        return this.kernels[this.active_ker].call(x1, x2);
      }

      kernelInv0(y) {
        return this.kernels[this.active_ker].inv0(y);
      }

      jumps(x) {
        var k = this.kernels[this.active_ker];
        return k.cuts(x, this.ctx.xmin, this.ctx.xmax);
      }


      solutionAlpha() {
        var y = new Matrix([this.y]);
        var alpha = y.mmul(this.invK).flat();
        return alpha;

      }

      functionNorm() {
        var a = new Matrix([this.alpha]);
        var n = this.n, v;
        var tmp = Matrix.zeros(this.n, this.n);
        for (let i = 0; i != n; i++) {
          for (let j = 0; j != n; j++) {
            v = this.kernel(this.mu[i], this.mu[j]);
            tmp.set(i,j,v);
            tmp.set(j,i,v);
          }
        }
        var norm2 = a.mmul(tmp).mmul(a.transpose()).flat()[0];
        // console.log(norm);
        return Math.sqrt(norm2);
      }

      resize(w, h) {
        this.ctx.setWidth(w);
        this.ctx.setHeight(h);
        this.width = this.ctx.width;
        this.height = this.ctx.height;
      }

      updateContext(context) {
        this.ctx = context;
        this.height = this.ctx.height;
        this.width = this.ctx.width;
      }

      addPoint() {
        this.n++;
        this.populate();
      }

      delPoint() {
        if (this.n == 0) return;
        this.n--;
        this.populate();
      }

      updateAlpha(delta, index) {
        this.alpha[index] += delta;
      }

      makeLine(xs, ys) {
        const path = line()
          .x(d => this.ctx.u(d[0]))
          .y(d => this.ctx.v(d[1]))(zip(xs,ys));
        return path || '';
      }

      makeLines(ys) {
        var line = '';
        var off = 0, rng, len;
        for (let si = 0; si != this.xCache.length; si++) {
          rng = this.xCache[si];
          len = rng.length;
          line += this.makeLine(rng, ys.slice(off, off + len));
          off += len;
        }
        return line;
      }

      curve(ci) {
        var ys;
        var a = this.alpha[ci];
        var ys = this.curveCache[ci].map(y => a * y);
        return this.makeLines(ys);
      }

      solutionCurve() {
        if (this.n == 0) return '';
        var ys = new Array(this.curveCache[0].length).fill(0.0);

        for (let ci = 0; ci != this.n; ci++) {
          var a = this.alpha[ci];
          var cc = this.curveCache[ci];
          for (let xi = 0; xi != cc.length; xi++)
            ys[xi] += cc[xi] * a;
        }
        return this.makeLines(ys);
      }
      
      // return the u,v points for the i'th scaled curve
      points(i) {
        var a = this.alpha[i];
        var pts = range$3(this.n).map(j => [
          this.ctx.u(this.x[j]), 
          this.ctx.v(a * this.K.get(i,j))
        ]);
        return pts;
      }

      data() {
        return zip(this.x, this.y).map(([x,y]) => 
          [this.ctx.u(x), this.ctx.v(y)]
        );
      }

      getMuX() {
        return zip(this.mu, this.x).map(([mu,x]) => 
          [this.ctx.u(mu), this.ctx.u(x)]
        );
      }

      // return the y value for the solution at the i'th x location
      // unused currently
      solutionPoint(i) {
        var y = range$3(this.n).map(j => this.alpha[j] * this.K.get(i,j))
          .reduce((y1, y2) => y1 + y2, 0);
        return y;
      }


      u(x) {
        return this.ctx.u(x);
      }

      v(y) {
        return this.ctx.v(y);
      }


    }

    class Context {
      constructor(width, height, [xmin, xmax], [ymin, ymax]) {
        this.width = width;
        this.height = height;
        this.xmin = xmin;
        this.xmax = xmax;
        this.ymin = ymin;
        this.ymax = ymax;
        this.xToViewport = linear().domain([xmin, xmax]).range([0,width]);
        this.yToViewport = linear().domain([ymin, ymax]).range([height,0]);
        this.unitToX = linear().domain([0, 1]).range([xmin, xmax]);
        this.unitToY = linear().domain([0, 1]).range([ymin, ymax]);
        this.xToUnit = linear().domain([xmin, xmax]).range([0, 1]);
        // console.log(d3.scaleLinear);
      }

      setWidth(w) {
        this.width = w;
        this.xToViewport.range([0,w]);
      }

      setHeight(h) {
        this.height = h;
        this.yToViewport.range([h,0]);
      }

      x(u) {
        return this.xToViewport.invert(u);
      }

      y(v) {
        return this.yToViewport.invert(v);
      }

      u(x) {
        return this.xToViewport(x);
      }

      v(y) {
        return this.yToViewport(y);
      }

      xDomain() {
        return this.xToViewport.domain();
      }

      yDomain() {
        return this.yToViewport.domain();
      }
    }

    function make_sync(updater, sig, owner_component) {
      var ready = true;
      var source = owner_component;

      /* Synopsis: 
       * import { writable } from 'svelte/store';
       * let sig = writable(0);
       * 
       * $: respond($sig);
       * $: notify(obj);
       *
       */
      function respond(val) {
        console.log(`in ${source} respond(${val})`);
        if (val != source && ready) {
          ready = false;
          updater();
          ready = true;
        }
        // flag = true;
      }
      function notify(debug_msg) {
        if (! ready) return;
        /*
        if (flag) {
          flag = false;
          return;
        } 
        */
        if (debug_msg)
          console.log(`in ${source}'s notify: ${debug_msg}`);
        sig.update(() => source);
      }  return [respond, notify];
    }

    /* src/Curves.svelte generated by Svelte v3.40.2 */

    const { console: console_1$2 } = globals;
    const file$8 = "src/Curves.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i][0];
    	child_ctx[15] = list[i][1];
    	child_ctx[17] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i][0];
    	child_ctx[15] = list[i][1];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i][0];
    	child_ctx[23] = list[i][1];
    	child_ctx[17] = i;
    	return child_ctx;
    }

    // (114:7) {#each plot.getMuX() as [mu,x], i}
    function create_each_block_3(ctx) {
    	let use;
    	let use_x_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			use = svg_element("use");
    			attr_dev(use, "class", "marker draggable svelte-igsjpl");
    			attr_dev(use, "id", "mu" + /*i*/ ctx[17]);
    			attr_dev(use, "x", use_x_value = /*mu*/ ctx[22]);
    			attr_dev(use, "y", "0");
    			xlink_attr(use, "xlink:href", "#mu-select");
    			add_location(use, file$8, 114, 9, 1936);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, use, anchor);

    			if (!mounted) {
    				dispose = listen_dev(use, "mousedown", /*onMouseDown*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && use_x_value !== (use_x_value = /*mu*/ ctx[22])) {
    				attr_dev(use, "x", use_x_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(use);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(114:7) {#each plot.getMuX() as [mu,x], i}",
    		ctx
    	});

    	return block;
    }

    // (122:9) {#if cfg.show_scaled}
    function create_if_block_3(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "curve svelte-igsjpl");
    			attr_dev(path, "d", path_d_value = /*plot*/ ctx[1].curve(/*i*/ ctx[17]));
    			add_location(path, file$8, 122, 11, 2185);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && path_d_value !== (path_d_value = /*plot*/ ctx[1].curve(/*i*/ ctx[17]))) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(122:9) {#if cfg.show_scaled}",
    		ctx
    	});

    	return block;
    }

    // (126:9) {#if cfg.show_points}
    function create_if_block_2(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*plot*/ ctx[1].points(/*i*/ ctx[17]);
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot, range*/ 2) {
    				each_value_2 = /*plot*/ ctx[1].points(/*i*/ ctx[17]);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(126:9) {#if cfg.show_points}",
    		ctx
    	});

    	return block;
    }

    // (127:11) {#each plot.points(i) as [u,v]}
    function create_each_block_2(ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "point svelte-igsjpl");
    			attr_dev(circle, "cx", circle_cx_value = /*u*/ ctx[14]);
    			attr_dev(circle, "cy", circle_cy_value = /*v*/ ctx[15]);
    			attr_dev(circle, "r", "4");
    			add_location(circle, file$8, 127, 13, 2330);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && circle_cx_value !== (circle_cx_value = /*u*/ ctx[14])) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty & /*plot*/ 2 && circle_cy_value !== (circle_cy_value = /*v*/ ctx[15])) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(127:11) {#each plot.points(i) as [u,v]}",
    		ctx
    	});

    	return block;
    }

    // (121:7) {#each range(plot.n) as i}
    function create_each_block_1$2(ctx) {
    	let if_block0_anchor;
    	let if_block1_anchor;
    	let if_block0 = /*cfg*/ ctx[3].show_scaled && create_if_block_3(ctx);
    	let if_block1 = /*cfg*/ ctx[3].show_points && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, if_block0_anchor, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*cfg*/ ctx[3].show_scaled) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*cfg*/ ctx[3].show_points) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(if_block0_anchor);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(121:7) {#each range(plot.n) as i}",
    		ctx
    	});

    	return block;
    }

    // (133:7) {#if cfg.show_solution}
    function create_if_block_1(ctx) {
    	let path;
    	let path_d_value;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "solution-curve svelte-igsjpl");
    			attr_dev(path, "d", path_d_value = /*plot*/ ctx[1].solutionCurve());
    			add_location(path, file$8, 133, 9, 2468);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && path_d_value !== (path_d_value = /*plot*/ ctx[1].solutionCurve())) {
    				attr_dev(path, "d", path_d_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(133:7) {#if cfg.show_solution}",
    		ctx
    	});

    	return block;
    }

    // (137:7) {#if cfg.show_data}
    function create_if_block(ctx) {
    	let each_1_anchor;
    	let each_value = /*plot*/ ctx[1].data();
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot, onMouseDown*/ 18) {
    				each_value = /*plot*/ ctx[1].data();
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(137:7) {#if cfg.show_data}",
    		ctx
    	});

    	return block;
    }

    // (138:9) {#each plot.data() as [u,v], i}
    function create_each_block$4(ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "id", "xy" + /*i*/ ctx[17]);
    			attr_dev(circle, "class", "marker draggable svelte-igsjpl");
    			attr_dev(circle, "cx", circle_cx_value = /*u*/ ctx[14]);
    			attr_dev(circle, "cy", circle_cy_value = /*v*/ ctx[15]);
    			attr_dev(circle, "r", "5");
    			add_location(circle, file$8, 138, 11, 2619);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);

    			if (!mounted) {
    				dispose = listen_dev(circle, "mousedown", /*onMouseDown*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 2 && circle_cx_value !== (circle_cx_value = /*u*/ ctx[14])) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty & /*plot*/ 2 && circle_cy_value !== (circle_cy_value = /*v*/ ctx[15])) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(138:9) {#each plot.data() as [u,v], i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div;
    	let svg;
    	let defs;
    	let polygon;
    	let each0_anchor;
    	let each1_anchor;
    	let if_block0_anchor;
    	let div_resize_listener;
    	let mounted;
    	let dispose;
    	let each_value_3 = /*plot*/ ctx[1].getMuX();
    	validate_each_argument(each_value_3);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	let each_value_1 = range$3(/*plot*/ ctx[1].n);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	let if_block0 = /*cfg*/ ctx[3].show_solution && create_if_block_1(ctx);
    	let if_block1 = /*cfg*/ ctx[3].show_data && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			polygon = svg_element("polygon");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			each0_anchor = empty$3();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each1_anchor = empty$3();
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();
    			if (if_block1) if_block1.c();
    			attr_dev(polygon, "id", "mu-select");
    			attr_dev(polygon, "points", "-5,0 5,0 0,10");
    			add_location(polygon, file$8, 111, 5, 1823);
    			add_location(defs, file$8, 110, 5, 1811);
    			attr_dev(svg, "class", "inner-plot full svelte-igsjpl");
    			add_location(svg, file$8, 106, 2, 1704);
    			attr_dev(div, "class", "svg-wrap svelte-igsjpl");
    			add_render_callback(() => /*div_elementresize_handler*/ ctx[8].call(div));
    			add_location(div, file$8, 104, 0, 1623);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, defs);
    			append_dev(defs, polygon);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(svg, null);
    			}

    			append_dev(svg, each0_anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svg, null);
    			}

    			append_dev(svg, each1_anchor);
    			if (if_block0) if_block0.m(svg, null);
    			append_dev(svg, if_block0_anchor);
    			if (if_block1) if_block1.m(svg, null);
    			div_resize_listener = add_resize_listener(div, /*div_elementresize_handler*/ ctx[8].bind(div));

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "mousemove", /*onMouseMove*/ ctx[5], false, false, false),
    					listen_dev(svg, "mouseup", /*onMouseUp*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*plot, onMouseDown*/ 18) {
    				each_value_3 = /*plot*/ ctx[1].getMuX();
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_3(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(svg, each0_anchor);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_3.length;
    			}

    			if (dirty & /*plot, range, cfg*/ 10) {
    				each_value_1 = range$3(/*plot*/ ctx[1].n);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(svg, each1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*cfg*/ ctx[3].show_solution) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					if_block0.m(svg, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*cfg*/ ctx[3].show_data) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block(ctx);
    					if_block1.c();
    					if_block1.m(svg, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			div_resize_listener();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $sig,
    		$$unsubscribe_sig = noop$5,
    		$$subscribe_sig = () => ($$unsubscribe_sig(), $$unsubscribe_sig = subscribe(sig, $$value => $$invalidate(7, $sig = $$value)), sig);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_sig());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Curves', slots, []);
    	let { sig } = $$props, { box } = $$props, { cfg } = $$props, { plot } = $$props;
    	validate_store(sig, 'sig');
    	$$subscribe_sig();
    	let drag_point = null;

    	function update() {
    		$$invalidate(1, plot.touch++, plot);
    	}

    	var [respond, notify] = make_sync(update, sig, 'Curves');

    	function resize(width, height) {
    		console.log(`in resize with ${width} x ${height}`);
    		plot.resize(width, height);
    		update();
    	}

    	onMount(() => {
    		resize(box.w, box.h);
    	});

    	function onMouseDown(evt) {
    		drag_point = evt.target;
    	}

    	function onMouseMove(evt) {
    		if (drag_point == null) return;
    		var g = drag_point.id.match(/(?<code>\D+)(?<num>\d+)/).groups;
    		if (g.code == 'mu') plot.setMu(g.num, evt.offsetX); else if (g.code == 'xy') plot.setDataPoint(g.num, evt.offsetX, evt.offsetY); else console.log(`got drag_point id ${drag_point.id}`);
    		if (cfg.auto_solve) $$invalidate(1, plot.alpha = plot.solutionAlpha(), plot);
    		update();
    	}

    	function onMouseUp(evt) {
    		drag_point = null;
    	}

    	const writable_props = ['sig', 'box', 'cfg', 'plot'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<Curves> was created with unknown prop '${key}'`);
    	});

    	function div_elementresize_handler() {
    		box.w = this.clientWidth;
    		box.h = this.clientHeight;
    		$$invalidate(0, box);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(2, sig = $$props.sig));
    		if ('box' in $$props) $$invalidate(0, box = $$props.box);
    		if ('cfg' in $$props) $$invalidate(3, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    	};

    	$$self.$capture_state = () => ({
    		make_sync,
    		range: range$3,
    		onMount,
    		sig,
    		box,
    		cfg,
    		plot,
    		drag_point,
    		update,
    		respond,
    		notify,
    		resize,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp,
    		$sig
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(2, sig = $$props.sig));
    		if ('box' in $$props) $$invalidate(0, box = $$props.box);
    		if ('cfg' in $$props) $$invalidate(3, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    		if ('drag_point' in $$props) drag_point = $$props.drag_point;
    		if ('respond' in $$props) $$invalidate(11, respond = $$props.respond);
    		if ('notify' in $$props) $$invalidate(12, notify = $$props.notify);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*box*/ 1) {
    			resize(box.w, box.h);
    		}

    		if ($$self.$$.dirty & /*$sig*/ 128) {
    			respond($sig);
    		}

    		if ($$self.$$.dirty & /*plot*/ 2) {
    			notify(plot);
    		}
    	};

    	return [
    		box,
    		plot,
    		sig,
    		cfg,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp,
    		$sig,
    		div_elementresize_handler
    	];
    }

    class Curves extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$8, create_fragment$8, safe_not_equal, { sig: 2, box: 0, cfg: 3, plot: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Curves",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[2] === undefined && !('sig' in props)) {
    			console_1$2.warn("<Curves> was created without expected prop 'sig'");
    		}

    		if (/*box*/ ctx[0] === undefined && !('box' in props)) {
    			console_1$2.warn("<Curves> was created without expected prop 'box'");
    		}

    		if (/*cfg*/ ctx[3] === undefined && !('cfg' in props)) {
    			console_1$2.warn("<Curves> was created without expected prop 'cfg'");
    		}

    		if (/*plot*/ ctx[1] === undefined && !('plot' in props)) {
    			console_1$2.warn("<Curves> was created without expected prop 'plot'");
    		}
    	}

    	get sig() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get box() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set box(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cfg() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cfg(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<Curves>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<Curves>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function numberDisplay(n) {
      var ns = Math.abs(n) > 1000 ? n.toExponential(2) : n.toFixed(2);
      return ns;
    }

    /* src/LowPanelControls.svelte generated by Svelte v3.40.2 */
    const file$7 = "src/LowPanelControls.svelte";

    function create_fragment$7(ctx) {
    	let div13;
    	let div3;
    	let div0;
    	let button0;
    	let t1;
    	let div1;
    	let label0;
    	let t2;
    	let input0;
    	let t3;
    	let t4_value = Math.pow(10, /*l_log_sigma*/ ctx[3]).toFixed(3) + "";
    	let t4;
    	let t5;
    	let div2;
    	let d_math0;
    	let raw0_value = `\\|f\\| = ` + "";
    	let t6;

    	let t7_value = (/*plot*/ ctx[1].validInv
    	? numberDisplay(/*plot*/ ctx[1].functionNorm())
    	: 'Error: non-singular K') + "";

    	let t7;
    	let t8;
    	let div7;
    	let div4;
    	let button1;
    	let t10;
    	let div5;
    	let button2;
    	let t11;
    	let d_math1;
    	let raw1_value = `\\mu` + "";
    	let t12;
    	let t13;
    	let div6;
    	let button3;
    	let t14_value = (/*plot*/ ctx[1].scrambled() ? 'Unscramble' : 'Scramble') + "";
    	let t14;
    	let t15;
    	let div12;
    	let div8;
    	let label1;
    	let input1;
    	let t16;
    	let t17;
    	let div9;
    	let label2;
    	let input2;
    	let t18;
    	let t19;
    	let div10;
    	let label3;
    	let input3;
    	let t20;
    	let t21;
    	let div11;
    	let label4;
    	let input4;
    	let t22;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div13 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "New Data";
    			t1 = space();
    			div1 = element("div");
    			label0 = element("label");
    			t2 = text$1("Sigma: \n        ");
    			input0 = element("input");
    			t3 = space();
    			t4 = text$1(t4_value);
    			t5 = space();
    			div2 = element("div");
    			d_math0 = element("d-math");
    			t6 = space();
    			t7 = text$1(t7_value);
    			t8 = space();
    			div7 = element("div");
    			div4 = element("div");
    			button1 = element("button");
    			button1.textContent = "Solve";
    			t10 = space();
    			div5 = element("div");
    			button2 = element("button");
    			t11 = text$1("Recenter ");
    			d_math1 = element("d-math");
    			t12 = text$1("'s");
    			t13 = space();
    			div6 = element("div");
    			button3 = element("button");
    			t14 = text$1(t14_value);
    			t15 = space();
    			div12 = element("div");
    			div8 = element("div");
    			label1 = element("label");
    			input1 = element("input");
    			t16 = text$1("points");
    			t17 = space();
    			div9 = element("div");
    			label2 = element("label");
    			input2 = element("input");
    			t18 = text$1("curves");
    			t19 = space();
    			div10 = element("div");
    			label3 = element("label");
    			input3 = element("input");
    			t20 = text$1("solution");
    			t21 = space();
    			div11 = element("div");
    			label4 = element("label");
    			input4 = element("input");
    			t22 = text$1("auto solve");
    			attr_dev(button0, "id", "newdata");
    			add_location(button0, file$7, 102, 27, 1982);
    			attr_dev(div0, "class", "pad-small svelte-165jjul");
    			add_location(div0, file$7, 102, 4, 1959);
    			attr_dev(input0, "type", "range");
    			attr_dev(input0, "min", "-5");
    			attr_dev(input0, "max", "2");
    			attr_dev(input0, "step", "0.1");
    			add_location(input0, file$7, 105, 8, 2097);
    			add_location(label0, file$7, 104, 6, 2074);
    			attr_dev(div1, "class", "pad-small svelte-165jjul");
    			add_location(div1, file$7, 103, 4, 2044);
    			add_location(d_math0, file$7, 111, 6, 2295);
    			attr_dev(div2, "class", "pad-small svelte-165jjul");
    			add_location(div2, file$7, 110, 4, 2265);
    			set_style(div3, "flex-grow", "1");
    			add_location(div3, file$7, 101, 2, 1928);
    			attr_dev(button1, "id", "solve");
    			add_location(button1, file$7, 116, 27, 2495);
    			attr_dev(div4, "class", "pad-small svelte-165jjul");
    			add_location(div4, file$7, 116, 4, 2472);
    			add_location(d_math1, file$7, 117, 74, 2622);
    			attr_dev(button2, "id", "recenter_mu");
    			add_location(button2, file$7, 117, 27, 2575);
    			attr_dev(div5, "class", "pad-small svelte-165jjul");
    			add_location(div5, file$7, 117, 4, 2552);
    			attr_dev(button3, "id", "scramble");
    			add_location(button3, file$7, 118, 27, 2698);
    			attr_dev(div6, "class", "pad-small svelte-165jjul");
    			add_location(div6, file$7, 118, 4, 2675);
    			set_style(div7, "flex-grow", "1");
    			add_location(div7, file$7, 115, 2, 2441);
    			attr_dev(input1, "type", "checkbox");
    			add_location(input1, file$7, 124, 16, 2885);
    			add_location(label1, file$7, 124, 9, 2878);
    			add_location(div8, file$7, 124, 4, 2873);
    			attr_dev(input2, "type", "checkbox");
    			add_location(input2, file$7, 125, 16, 2978);
    			add_location(label2, file$7, 125, 9, 2971);
    			add_location(div9, file$7, 125, 4, 2966);
    			attr_dev(input3, "type", "checkbox");
    			add_location(input3, file$7, 126, 16, 3071);
    			add_location(label3, file$7, 126, 9, 3064);
    			add_location(div10, file$7, 126, 4, 3059);
    			attr_dev(input4, "type", "checkbox");
    			add_location(input4, file$7, 127, 16, 3168);
    			add_location(label4, file$7, 127, 9, 3161);
    			add_location(div11, file$7, 127, 4, 3156);
    			set_style(div12, "flex-grow", "1: align: right");
    			add_location(div12, file$7, 123, 2, 2827);
    			attr_dev(div13, "class", "row control pad svelte-165jjul");
    			add_location(div13, file$7, 100, 0, 1896);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div3);
    			append_dev(div3, div0);
    			append_dev(div0, button0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, label0);
    			append_dev(label0, t2);
    			append_dev(label0, input0);
    			set_input_value(input0, /*l_log_sigma*/ ctx[3]);
    			append_dev(label0, t3);
    			append_dev(label0, t4);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, d_math0);
    			d_math0.innerHTML = raw0_value;
    			append_dev(div2, t6);
    			append_dev(div2, t7);
    			append_dev(div13, t8);
    			append_dev(div13, div7);
    			append_dev(div7, div4);
    			append_dev(div4, button1);
    			append_dev(div7, t10);
    			append_dev(div7, div5);
    			append_dev(div5, button2);
    			append_dev(button2, t11);
    			append_dev(button2, d_math1);
    			d_math1.innerHTML = raw1_value;
    			append_dev(button2, t12);
    			append_dev(div7, t13);
    			append_dev(div7, div6);
    			append_dev(div6, button3);
    			append_dev(button3, t14);
    			append_dev(div13, t15);
    			append_dev(div13, div12);
    			append_dev(div12, div8);
    			append_dev(div8, label1);
    			append_dev(label1, input1);
    			input1.checked = /*cfg*/ ctx[0].show_points;
    			append_dev(label1, t16);
    			append_dev(div12, t17);
    			append_dev(div12, div9);
    			append_dev(div9, label2);
    			append_dev(label2, input2);
    			input2.checked = /*cfg*/ ctx[0].show_scaled;
    			append_dev(label2, t18);
    			append_dev(div12, t19);
    			append_dev(div12, div10);
    			append_dev(div10, label3);
    			append_dev(label3, input3);
    			input3.checked = /*cfg*/ ctx[0].show_solution;
    			append_dev(label3, t20);
    			append_dev(div12, t21);
    			append_dev(div12, div11);
    			append_dev(div11, label4);
    			append_dev(label4, input4);
    			input4.checked = /*cfg*/ ctx[0].auto_solve;
    			append_dev(label4, t22);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*h*/ ctx[4], false, false, false),
    					listen_dev(input0, "change", /*input0_change_input_handler*/ ctx[6]),
    					listen_dev(input0, "input", /*input0_change_input_handler*/ ctx[6]),
    					listen_dev(button1, "click", /*h*/ ctx[4], false, false, false),
    					listen_dev(button2, "click", /*h*/ ctx[4], false, false, false),
    					listen_dev(button3, "click", /*h*/ ctx[4], false, false, false),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[7]),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[8]),
    					listen_dev(input3, "change", /*input3_change_handler*/ ctx[9]),
    					listen_dev(input4, "change", /*input4_change_handler*/ ctx[10])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*l_log_sigma*/ 8) {
    				set_input_value(input0, /*l_log_sigma*/ ctx[3]);
    			}

    			if (dirty & /*l_log_sigma*/ 8 && t4_value !== (t4_value = Math.pow(10, /*l_log_sigma*/ ctx[3]).toFixed(3) + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*plot*/ 2 && t7_value !== (t7_value = (/*plot*/ ctx[1].validInv
    			? numberDisplay(/*plot*/ ctx[1].functionNorm())
    			: 'Error: non-singular K') + "")) set_data_dev(t7, t7_value);

    			if (dirty & /*plot*/ 2 && t14_value !== (t14_value = (/*plot*/ ctx[1].scrambled() ? 'Unscramble' : 'Scramble') + "")) set_data_dev(t14, t14_value);

    			if (dirty & /*cfg*/ 1) {
    				input1.checked = /*cfg*/ ctx[0].show_points;
    			}

    			if (dirty & /*cfg*/ 1) {
    				input2.checked = /*cfg*/ ctx[0].show_scaled;
    			}

    			if (dirty & /*cfg*/ 1) {
    				input3.checked = /*cfg*/ ctx[0].show_solution;
    			}

    			if (dirty & /*cfg*/ 1) {
    				input4.checked = /*cfg*/ ctx[0].auto_solve;
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div13);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const NSTEPS = 10;

    function instance$7($$self, $$props, $$invalidate) {
    	let $sig,
    		$$unsubscribe_sig = noop$5,
    		$$subscribe_sig = () => ($$unsubscribe_sig(), $$unsubscribe_sig = subscribe(sig, $$value => $$invalidate(5, $sig = $$value)), sig);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_sig());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LowPanelControls', slots, []);
    	let { sig } = $$props, { cfg } = $$props, { plot } = $$props;
    	validate_store(sig, 'sig');
    	$$subscribe_sig();
    	let l_log_sigma = 0;

    	function update() {
    		$$invalidate(1, plot.touch++, plot);
    	}

    	var [respond, notify] = make_sync(update, sig, 'LowPanelControls');

    	function h(e) {
    		var id = e.target.id;
    		if (id == 'solve') solve(true);
    		if (id == 'recenter_mu') recenter_mu();
    		if (id == 'scramble') toggle_scramble();

    		if (id == 'newdata') {
    			plot.populate();
    			notify();
    		}
    	}

    	function toggle_scramble() {
    		// console.log('in toggle_scramble');
    		plot.toggle_scramble();

    		solve(cfg.auto_solve);
    		notify();
    	}

    	function set_sigma(log_sigma) {
    		plot.set_sigma(log_sigma);
    		if (cfg.auto_solve) $$invalidate(1, plot.alpha = plot.solutionAlpha(), plot);
    		notify();
    	}

    	function recenter_mu() {
    		plot.recenter_mu();
    		notify('in recenter_mu');
    	}

    	function solve(do_solve, msg) {
    		// console.log(`in solve: ${msg}, do_solve=${do_solve}`);
    		if (!do_solve) return;

    		var start_alpha = plot.alpha;
    		var end_alpha = plot.solutionAlpha();

    		function transition(step, nsteps) {
    			var delta = step / nsteps;

    			for (let i = 0; i != plot.n; i++) {
    				$$invalidate(1, plot.alpha[i] = delta * end_alpha[i] + (1 - delta) * start_alpha[i], plot);
    			} // must call notify within the callback, since it is async

    			notify(`in transition step ${step}`);

    			if (step != nsteps) {
    				setTimeout(() => transition(step + 1, nsteps), 10);
    			}
    		}

    		transition(0, NSTEPS);
    	}

    	const writable_props = ['sig', 'cfg', 'plot'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LowPanelControls> was created with unknown prop '${key}'`);
    	});

    	function input0_change_input_handler() {
    		l_log_sigma = to_number(this.value);
    		$$invalidate(3, l_log_sigma);
    	}

    	function input1_change_handler() {
    		cfg.show_points = this.checked;
    		$$invalidate(0, cfg);
    	}

    	function input2_change_handler() {
    		cfg.show_scaled = this.checked;
    		$$invalidate(0, cfg);
    	}

    	function input3_change_handler() {
    		cfg.show_solution = this.checked;
    		$$invalidate(0, cfg);
    	}

    	function input4_change_handler() {
    		cfg.auto_solve = this.checked;
    		$$invalidate(0, cfg);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(2, sig = $$props.sig));
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    	};

    	$$self.$capture_state = () => ({
    		make_sync,
    		numberDisplay,
    		sig,
    		cfg,
    		plot,
    		l_log_sigma,
    		update,
    		respond,
    		notify,
    		NSTEPS,
    		h,
    		toggle_scramble,
    		set_sigma,
    		recenter_mu,
    		solve,
    		$sig
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(2, sig = $$props.sig));
    		if ('cfg' in $$props) $$invalidate(0, cfg = $$props.cfg);
    		if ('plot' in $$props) $$invalidate(1, plot = $$props.plot);
    		if ('l_log_sigma' in $$props) $$invalidate(3, l_log_sigma = $$props.l_log_sigma);
    		if ('respond' in $$props) $$invalidate(12, respond = $$props.respond);
    		if ('notify' in $$props) notify = $$props.notify;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*cfg*/ 1) {
    			solve(cfg.auto_solve);
    		}

    		if ($$self.$$.dirty & /*l_log_sigma*/ 8) {
    			set_sigma(l_log_sigma);
    		}

    		if ($$self.$$.dirty & /*$sig*/ 32) {
    			// necessary for function norm to update
    			respond($sig);
    		}
    	};

    	return [
    		cfg,
    		plot,
    		sig,
    		l_log_sigma,
    		h,
    		$sig,
    		input0_change_input_handler,
    		input1_change_handler,
    		input2_change_handler,
    		input3_change_handler,
    		input4_change_handler
    	];
    }

    class LowPanelControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$7, create_fragment$7, safe_not_equal, { sig: 2, cfg: 0, plot: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LowPanelControls",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[2] === undefined && !('sig' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'sig'");
    		}

    		if (/*cfg*/ ctx[0] === undefined && !('cfg' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'cfg'");
    		}

    		if (/*plot*/ ctx[1] === undefined && !('plot' in props)) {
    			console.warn("<LowPanelControls> was created without expected prop 'plot'");
    		}
    	}

    	get sig() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cfg() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cfg(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<LowPanelControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<LowPanelControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/SliderControls.svelte generated by Svelte v3.40.2 */
    const file$6 = "src/SliderControls.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[11] = list;
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (52:2) {#each plot.alpha as a, i}
    function create_each_block$3(ctx) {
    	let div;
    	let input;
    	let t0;
    	let code;
    	let t1_value = numberDisplay(/*a*/ ctx[10]) + "";
    	let t1;
    	let t2;
    	let mounted;
    	let dispose;

    	function input_change_input_handler() {
    		/*input_change_input_handler*/ ctx[7].call(input, /*each_value*/ ctx[11], /*i*/ ctx[12]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t0 = space();
    			code = element("code");
    			t1 = text$1(t1_value);
    			t2 = space();
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "-10");
    			attr_dev(input, "max", "10");
    			attr_dev(input, "step", "0.01");
    			add_location(input, file$6, 53, 6, 978);
    			attr_dev(code, "class", "alphas svelte-eznsce");
    			add_location(code, file$6, 54, 6, 1043);
    			attr_dev(div, "class", "row pad-small svelte-eznsce");
    			add_location(div, file$6, 52, 4, 944);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*a*/ ctx[10]);
    			append_dev(div, t0);
    			append_dev(div, code);
    			append_dev(code, t1);
    			append_dev(div, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", input_change_input_handler),
    					listen_dev(input, "input", input_change_input_handler)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*plot*/ 1) {
    				set_input_value(input, /*a*/ ctx[10]);
    			}

    			if (dirty & /*plot*/ 1 && t1_value !== (t1_value = numberDisplay(/*a*/ ctx[10]) + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(52:2) {#each plot.alpha as a, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div4;
    	let div0;
    	let button0;
    	let t1;
    	let div3;
    	let div1;
    	let button1;
    	let t3;
    	let div2;
    	let button2;
    	let t5;
    	let mounted;
    	let dispose;
    	let each_value = /*plot*/ ctx[0].alpha;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Reset Alpha";
    			t1 = space();
    			div3 = element("div");
    			div1 = element("div");
    			button1 = element("button");
    			button1.textContent = "Del Point";
    			t3 = space();
    			div2 = element("div");
    			button2 = element("button");
    			button2.textContent = "Add Point";
    			t5 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(button0, file$6, 45, 4, 583);
    			attr_dev(div0, "class", "pad-small svelte-eznsce");
    			add_location(div0, file$6, 44, 2, 555);
    			add_location(button1, file$6, 48, 27, 717);
    			attr_dev(div1, "class", "pad-small svelte-eznsce");
    			add_location(div1, file$6, 48, 4, 694);
    			add_location(button2, file$6, 49, 27, 823);
    			attr_dev(div2, "class", "pad-small svelte-eznsce");
    			add_location(div2, file$6, 49, 4, 800);
    			attr_dev(div3, "class", "row svelte-eznsce");
    			add_location(div3, file$6, 47, 2, 672);
    			attr_dev(div4, "class", "pad col svelte-eznsce");
    			add_location(div4, file$6, 43, 0, 531);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div0, button0);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, button1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, button2);
    			append_dev(div4, t5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div4, null);
    			}

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[5], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*numberDisplay, plot*/ 1) {
    				each_value = /*plot*/ ctx[0].alpha;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div4, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $sig,
    		$$unsubscribe_sig = noop$5,
    		$$subscribe_sig = () => ($$unsubscribe_sig(), $$unsubscribe_sig = subscribe(sig, $$value => $$invalidate(3, $sig = $$value)), sig);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_sig());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SliderControls', slots, []);
    	let { sig } = $$props, { plot } = $$props;
    	validate_store(sig, 'sig');
    	$$subscribe_sig();

    	function update() {
    		$$invalidate(0, plot.touch++, plot);
    	}

    	var [respond, notify] = make_sync(update, sig, 'SliderControls');
    	const writable_props = ['sig', 'plot'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SliderControls> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		plot.resetAlpha();
    		notify();
    	};

    	const click_handler_1 = () => {
    		plot.delPoint();
    		notify();
    	};

    	const click_handler_2 = () => {
    		plot.addPoint();
    		notify();
    	};

    	function input_change_input_handler(each_value, i) {
    		each_value[i] = to_number(this.value);
    		$$invalidate(0, plot);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(1, sig = $$props.sig));
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    	};

    	$$self.$capture_state = () => ({
    		make_sync,
    		numberDisplay,
    		sig,
    		plot,
    		update,
    		respond,
    		notify,
    		$sig
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(1, sig = $$props.sig));
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('respond' in $$props) $$invalidate(9, respond = $$props.respond);
    		if ('notify' in $$props) $$invalidate(2, notify = $$props.notify);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sig*/ 8) {
    			respond($sig);
    		}
    	};

    	return [
    		plot,
    		sig,
    		notify,
    		$sig,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		input_change_input_handler
    	];
    }

    class SliderControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$6, create_fragment$6, safe_not_equal, { sig: 1, plot: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliderControls",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[1] === undefined && !('sig' in props)) {
    			console.warn("<SliderControls> was created without expected prop 'sig'");
    		}

    		if (/*plot*/ ctx[0] === undefined && !('plot' in props)) {
    			console.warn("<SliderControls> was created without expected prop 'plot'");
    		}
    	}

    	get sig() {
    		throw new Error("<SliderControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<SliderControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<SliderControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<SliderControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var win;

    if (typeof window !== "undefined") {
        win = window;
    } else if (typeof commonjsGlobal !== "undefined") {
        win = commonjsGlobal;
    } else if (typeof self !== "undefined"){
        win = self;
    } else {
        win = {};
    }

    var window_1 = win;

    var isFunction_1 = isFunction;

    var toString = Object.prototype.toString;

    function isFunction (fn) {
      if (!fn) {
        return false
      }
      var string = toString.call(fn);
      return string === '[object Function]' ||
        (typeof fn === 'function' && string !== '[object RegExp]') ||
        (typeof window !== 'undefined' &&
         // IE8 and below
         (fn === window.setTimeout ||
          fn === window.alert ||
          fn === window.confirm ||
          fn === window.prompt))
    }

    var trim = function(string) {
      return string.replace(/^\s+|\s+$/g, '');
    }
      , isArray = function(arg) {
          return Object.prototype.toString.call(arg) === '[object Array]';
        };

    var parseHeaders = function (headers) {
      if (!headers)
        return {}

      var result = {};

      var headersArr = trim(headers).split('\n');

      for (var i = 0; i < headersArr.length; i++) {
        var row = headersArr[i];
        var index = row.indexOf(':')
        , key = trim(row.slice(0, index)).toLowerCase()
        , value = trim(row.slice(index + 1));

        if (typeof(result[key]) === 'undefined') {
          result[key] = value;
        } else if (isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [ result[key], value ];
        }
      }

      return result
    };

    var immutable = extend;

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function extend() {
        var target = {};

        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target
    }

    var xhr = createXHR;
    // Allow use of default import syntax in TypeScript
    var _default = createXHR;
    createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop;
    createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window_1.XDomainRequest;

    forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
        createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
            options = initParams(uri, options, callback);
            options.method = method.toUpperCase();
            return _createXHR(options)
        };
    });

    function forEachArray(array, iterator) {
        for (var i = 0; i < array.length; i++) {
            iterator(array[i]);
        }
    }

    function isEmpty(obj){
        for(var i in obj){
            if(obj.hasOwnProperty(i)) return false
        }
        return true
    }

    function initParams(uri, options, callback) {
        var params = uri;

        if (isFunction_1(options)) {
            callback = options;
            if (typeof uri === "string") {
                params = {uri:uri};
            }
        } else {
            params = immutable(options, {uri: uri});
        }

        params.callback = callback;
        return params
    }

    function createXHR(uri, options, callback) {
        options = initParams(uri, options, callback);
        return _createXHR(options)
    }

    function _createXHR(options) {
        if(typeof options.callback === "undefined"){
            throw new Error("callback argument missing")
        }

        var called = false;
        var callback = function cbOnce(err, response, body){
            if(!called){
                called = true;
                options.callback(err, response, body);
            }
        };

        function readystatechange() {
            if (xhr.readyState === 4) {
                setTimeout(loadFunc, 0);
            }
        }

        function getBody() {
            // Chrome with requestType=blob throws errors arround when even testing access to responseText
            var body = undefined;

            if (xhr.response) {
                body = xhr.response;
            } else {
                body = xhr.responseText || getXml(xhr);
            }

            if (isJson) {
                try {
                    body = JSON.parse(body);
                } catch (e) {}
            }

            return body
        }

        function errorFunc(evt) {
            clearTimeout(timeoutTimer);
            if(!(evt instanceof Error)){
                evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") );
            }
            evt.statusCode = 0;
            return callback(evt, failureResponse)
        }

        // will load the data & process the response in a special response object
        function loadFunc() {
            if (aborted) return
            var status;
            clearTimeout(timeoutTimer);
            if(options.useXDR && xhr.status===undefined) {
                //IE8 CORS GET successful response doesn't have a status field, but body is fine
                status = 200;
            } else {
                status = (xhr.status === 1223 ? 204 : xhr.status);
            }
            var response = failureResponse;
            var err = null;

            if (status !== 0){
                response = {
                    body: getBody(),
                    statusCode: status,
                    method: method,
                    headers: {},
                    url: uri,
                    rawRequest: xhr
                };
                if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                    response.headers = parseHeaders(xhr.getAllResponseHeaders());
                }
            } else {
                err = new Error("Internal XMLHttpRequest Error");
            }
            return callback(err, response, response.body)
        }

        var xhr = options.xhr || null;

        if (!xhr) {
            if (options.cors || options.useXDR) {
                xhr = new createXHR.XDomainRequest();
            }else {
                xhr = new createXHR.XMLHttpRequest();
            }
        }

        var key;
        var aborted;
        var uri = xhr.url = options.uri || options.url;
        var method = xhr.method = options.method || "GET";
        var body = options.body || options.data;
        var headers = xhr.headers = options.headers || {};
        var sync = !!options.sync;
        var isJson = false;
        var timeoutTimer;
        var failureResponse = {
            body: undefined,
            headers: {},
            statusCode: 0,
            method: method,
            url: uri,
            rawRequest: xhr
        };

        if ("json" in options && options.json !== false) {
            isJson = true;
            headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json"); //Don't override existing accept header declared by user
            if (method !== "GET" && method !== "HEAD") {
                headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"); //Don't override existing accept header declared by user
                body = JSON.stringify(options.json === true ? body : options.json);
            }
        }

        xhr.onreadystatechange = readystatechange;
        xhr.onload = loadFunc;
        xhr.onerror = errorFunc;
        // IE9 must have onprogress be set to a unique function.
        xhr.onprogress = function () {
            // IE must die
        };
        xhr.onabort = function(){
            aborted = true;
        };
        xhr.ontimeout = errorFunc;
        xhr.open(method, uri, !sync, options.username, options.password);
        //has to be after open
        if(!sync) {
            xhr.withCredentials = !!options.withCredentials;
        }
        // Cannot set timeout with sync request
        // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
        // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
        if (!sync && options.timeout > 0 ) {
            timeoutTimer = setTimeout(function(){
                if (aborted) return
                aborted = true;//IE9 may still call readystatechange
                xhr.abort("timeout");
                var e = new Error("XMLHttpRequest timeout");
                e.code = "ETIMEDOUT";
                errorFunc(e);
            }, options.timeout );
        }

        if (xhr.setRequestHeader) {
            for(key in headers){
                if(headers.hasOwnProperty(key)){
                    xhr.setRequestHeader(key, headers[key]);
                }
            }
        } else if (options.headers && !isEmpty(options.headers)) {
            throw new Error("Headers cannot be set on an XDomainRequest object")
        }

        if ("responseType" in options) {
            xhr.responseType = options.responseType;
        }

        if ("beforeSend" in options &&
            typeof options.beforeSend === "function"
        ) {
            options.beforeSend(xhr);
        }

        // Microsoft Edge browser sends "undefined" when send is called with undefined value.
        // XMLHttpRequest spec says to pass null as body to indicate no body
        // See https://github.com/naugtur/xhr/issues/100.
        xhr.send(body || null);

        return xhr


    }

    function getXml(xhr) {
        // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
        // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
        try {
            if (xhr.responseType === "document") {
                return xhr.responseXML
            }
            var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
            if (xhr.responseType === "" && !firefoxBugTakenEffect) {
                return xhr.responseXML
            }
        } catch (e) {}

        return null
    }

    function noop() {}
    xhr.default = _default;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };





    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();









































    var toConsumableArray = function (arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      } else {
        return Array.from(arr);
      }
    };

    var lastError = '';

    /**
     * Creates the HTLM for a failure message
     * @param {string} canvasContainerId id of container of th
     *        canvas.
     * @return {string} The html.
     */
    function makeFailHTML(msg) {
        return '\n<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>\n<td align="center">\n<div style="display: table-cell; vertical-align: middle;">\n<div style="">' + msg + '</div>\n</div>\n</td></tr></table>\n';
    }

    /**
     * Message for getting a webgl browser
     * @type {string}
     */
    var GET_A_WEBGL_BROWSER = '\n\tThis page requires a browser that supports WebGL.<br/>\n\t<a href="http://get.webgl.org">Click here to upgrade your browser.</a>\n';

    /**
     * Message for need better hardware
     * @type {string}
     */
    var OTHER_PROBLEM = '\n\tIt does not appear your computer can support WebGL.<br/>\n\t<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>\n';

    /**
     * Code to return in `onError` callback when the browser doesn't support webgl
     * @type {number}
     */
    var ERROR_BROWSER_SUPPORT = 1;

    /**
     * Code to return in `onError` callback there's any other problem related to webgl
     * @type {number}
     */
    var ERROR_OTHER = 2;

    /**
     * Creates a webgl context. If creation fails it will
     * change the contents of the container of the <canvas>
     * tag to an error message with the correct links for WebGL,
     * unless `onError` option is defined to a callback,
     * which allows for custom error handling..
     * @param {Element} canvas. The canvas element to create a
     *     context from.
     * @param {WebGLContextCreationAttributes} optAttribs Any
     *     creation attributes you want to pass in.
     * @return {WebGLRenderingContext} The created context.
     */
    function setupWebGL(canvas, optAttribs, onError) {
        function showLink(str) {
            var container = canvas.parentNode;
            if (container) {
                container.innerHTML = makeFailHTML(str);
            }
        }

        function handleError(errorCode, msg) {
            if (typeof onError === 'function') {
                onError(errorCode);
            } else {
                showLink(msg);
            }
        }

        if (!window.WebGLRenderingContext) {
            handleError(ERROR_BROWSER_SUPPORT, GET_A_WEBGL_BROWSER);
            return null;
        }

        var context = create3DContext(canvas, optAttribs);
        if (!context) {
            handleError(ERROR_OTHER, OTHER_PROBLEM);
        } else {
            context.getExtension('OES_standard_derivatives');
        }
        return context;
    }

    /**
     * Creates a webgl context.
     * @param {!Canvas} canvas The canvas tag to get context
     *     from. If one is not passed in one will be created.
     * @return {!WebGLContext} The created context.
     */
    function create3DContext(canvas, optAttribs) {
        var names = ['webgl', 'experimental-webgl'];
        var context = null;
        for (var ii = 0; ii < names.length; ++ii) {
            try {
                context = canvas.getContext(names[ii], optAttribs);
            } catch (e) {
                if (context) {
                    break;
                }
            }
        }
        return context;
    }

    /*
     *	Create a Vertex of a specific type (gl.VERTEX_SHADER/)
     */
    function createShader(main, source, type, offset) {
        var gl = main.gl;

        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

        if (!compiled) {
            // Something went wrong during compilation; get the error
            lastError = gl.getShaderInfoLog(shader);
            console.error('*** Error compiling shader ' + shader + ':' + lastError);
            main.trigger('error', {
                shader: shader,
                source: source,
                type: type,
                error: lastError,
                offset: offset || 0
            });
            gl.deleteShader(shader);
            return null;
        }

        return shader;
    }

    /**
     * Loads a shader.
     * @param {!WebGLContext} gl The WebGLContext to use.
     * @param {string} shaderSource The shader source.
     * @param {number} shaderType The type of shader.
     * @param {function(string): void) opt_errorCallback callback for errors.
     * @return {!WebGLShader} The created shader.
     */
    function createProgram(main, shaders, optAttribs, optLocations) {
        var gl = main.gl;

        var program = gl.createProgram();
        for (var ii = 0; ii < shaders.length; ++ii) {
            gl.attachShader(program, shaders[ii]);
        }
        if (optAttribs) {
            for (var _ii = 0; _ii < optAttribs.length; ++_ii) {
                gl.bindAttribLocation(program, optLocations ? optLocations[_ii] : _ii, optAttribs[_ii]);
            }
        }
        gl.linkProgram(program);

        // Check the link status
        var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!linked) {
            // something went wrong with the link
            lastError = gl.getProgramInfoLog(program);
            console.log('Error in program linking:' + lastError);
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    // By Brett Camber on
    // https://github.com/tangrams/tangram/blob/master/src/gl/glsl.js
    function parseUniforms(uniforms) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var parsed = [];

        for (var name in uniforms) {
            var uniform = uniforms[name];
            var u = void 0;

            if (prefix) {
                name = prefix + '.' + name;
            }

            // Single float
            if (typeof uniform === 'number') {
                parsed.push({
                    type: 'float',
                    method: '1f',
                    name: name,
                    value: uniform
                });
            }
            // Array: vector, array of floats, array of textures, or array of structs
            else if (Array.isArray(uniform)) {
                    // Numeric values
                    if (typeof uniform[0] === 'number') {
                        // float vectors (vec2, vec3, vec4)
                        if (uniform.length === 1) {
                            parsed.push({
                                type: 'float',
                                method: '1f',
                                name: name,
                                value: uniform
                            });
                        }
                        // float vectors (vec2, vec3, vec4)
                        else if (uniform.length >= 2 && uniform.length <= 4) {
                                parsed.push({
                                    type: 'vec' + uniform.length,
                                    method: uniform.length + 'fv',
                                    name: name,
                                    value: uniform
                                });
                            }
                            // float array
                            else if (uniform.length > 4) {
                                    parsed.push({
                                        type: 'float[]',
                                        method: '1fv',
                                        name: name + '[0]',
                                        value: uniform
                                    });
                                }
                        // TODO: assume matrix for (typeof == Float32Array && length == 16)?
                    }
                    // Array of textures
                    else if (typeof uniform[0] === 'string') {
                            parsed.push({
                                type: 'sampler2D',
                                method: '1i',
                                name: name,
                                value: uniform
                            });
                        }
                        // Array of arrays - but only arrays of vectors are allowed in this case
                        else if (Array.isArray(uniform[0]) && typeof uniform[0][0] === 'number') {
                                // float vectors (vec2, vec3, vec4)
                                if (uniform[0].length >= 2 && uniform[0].length <= 4) {
                                    // Set each vector in the array
                                    for (u = 0; u < uniform.length; u++) {
                                        parsed.push({
                                            type: 'vec' + uniform[0].length,
                                            method: uniform[u].length + 'fv',
                                            name: name + '[' + u + ']',
                                            value: uniform[u]
                                        });
                                    }
                                }
                                // else error?
                            }
                            // Array of structures
                            else if (_typeof(uniform[0]) === 'object') {
                                    for (u = 0; u < uniform.length; u++) {
                                        // Set each struct in the array
                                        parsed.push.apply(parsed, toConsumableArray(parseUniforms(uniform[u], name + '[' + u + ']')));
                                    }
                                }
                }
                // Boolean
                else if (typeof uniform === 'boolean') {
                        parsed.push({
                            type: 'bool',
                            method: '1i',
                            name: name,
                            value: uniform
                        });
                    }
                    // Texture
                    else if (typeof uniform === 'string') {
                            parsed.push({
                                type: 'sampler2D',
                                method: '1i',
                                name: name,
                                value: uniform
                            });
                        }
                        // Structure
                        else if ((typeof uniform === 'undefined' ? 'undefined' : _typeof(uniform)) === 'object') {
                                // Set each field in the struct
                                parsed.push.apply(parsed, toConsumableArray(parseUniforms(uniform, name)));
                            }
            // TODO: support other non-float types? (int, etc.)
        }
        return parsed;
    }

    function isCanvasVisible(canvas) {
        return canvas.getBoundingClientRect().top + canvas.height > 0 && canvas.getBoundingClientRect().top < (window.innerHeight || document.documentElement.clientHeight);
    }

    function isPowerOf2(value) {
        return (value & value - 1) === 0;
    }

    function isSafari() {
        return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        );
    }







    function isDiff(a, b) {
        if (a && b) {
            return a.toString() !== b.toString();
        }
        return false;
    }

    function subscribeMixin$1(target) {
        var listeners = new Set();

        return Object.assign(target, {
            on: function on(type, f) {
                var listener = {};
                listener[type] = f;
                listeners.add(listener);
            },
            off: function off(type, f) {
                if (f) {
                    var listener = {};
                    listener[type] = f;
                    listeners.delete(listener);
                } else {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var item = _step.value;
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = Object.keys(item)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var key = _step2.value;

                                    if (key === type) {
                                        listeners.delete(item);
                                        return;
                                    }
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                        _iterator2.return();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }
            },
            listSubscriptions: function listSubscriptions() {
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = listeners[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var item = _step3.value;

                        console.log(item);
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
            },
            subscribe: function subscribe(listener) {
                listeners.add(listener);
            },
            unsubscribe: function unsubscribe(listener) {
                listeners.delete(listener);
            },
            unsubscribeAll: function unsubscribeAll() {
                listeners.clear();
            },
            trigger: function trigger(event) {
                for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    data[_key - 1] = arguments[_key];
                }

                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = listeners[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var listener = _step4.value;

                        if (typeof listener[event] === 'function') {
                            listener[event].apply(listener, toConsumableArray(data));
                        }
                    }
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }
            }
        });
    }

    // Texture management
    var Texture = function () {
        function Texture(gl, name) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            classCallCheck(this, Texture);

            subscribeMixin$1(this);

            this.gl = gl;
            this.texture = gl.createTexture();
            if (this.texture) {
                this.valid = true;
            }
            this.bind();

            this.name = name;
            this.source = null;
            this.sourceType = null;
            this.loading = null; // a Promise object to track the loading state of this texture

            // Default to a 1-pixel black texture so we can safely render while we wait for an image to load
            // See: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
            this.setData(1, 1, new Uint8Array([0, 0, 0, 255]), { filtering: 'linear' });
            this.setFiltering(options.filtering);

            this.load(options);
        }

        // Destroy a single texture instance


        createClass(Texture, [{
            key: 'destroy',
            value: function destroy() {
                if (!this.valid) {
                    return;
                }
                this.gl.deleteTexture(this.texture);
                this.texture = null;
                delete this.data;
                this.data = null;
                this.valid = false;
            }
        }, {
            key: 'bind',
            value: function bind(unit) {
                if (!this.valid) {
                    return;
                }
                if (typeof unit === 'number') {
                    if (Texture.activeUnit !== unit) {
                        this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                        Texture.activeUnit = unit;
                    }
                }
                if (Texture.activeTexture !== this.texture) {
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                    Texture.activeTexture = this.texture;
                }
            }
        }, {
            key: 'load',
            value: function load() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                this.loading = null;

                if (typeof options.url === 'string') {
                    if (this.url === undefined || options.url !== this.url) {
                        this.setUrl(options.url, options);
                    }
                } else if (options.element) {
                    this.setElement(options.element, options);
                } else if (options.data && options.width && options.height) {
                    this.setData(options.width, options.height, options.data, options);
                }
            }

            // Sets texture from an url

        }, {
            key: 'setUrl',
            value: function setUrl(url) {
                var _this = this;

                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                if (!this.valid) {
                    return;
                }

                this.url = url; // save URL reference (will be overwritten when element is loaded below)
                this.source = this.url;
                this.sourceType = 'url';

                this.loading = new Promise(function (resolve, reject) {
                    var ext = url.split('.').pop().toLowerCase();
                    var isVideo = ext === 'ogv' || ext === 'webm' || ext === 'mp4';

                    var element = undefined;
                    if (isVideo) {
                        element = document.createElement('video');
                        element.autoplay = true;
                        options.filtering = 'nearest';
                        // element.preload = 'auto';
                        // element.style.display = 'none';
                        // document.body.appendChild(element);
                    } else {
                        element = new Image();
                    }

                    element.onload = function () {
                        try {
                            _this.setElement(element, options);
                        } catch (e) {
                            console.log('Texture \'' + _this.name + '\': failed to load url: \'' + _this.source + '\'', e, options);
                        }
                        resolve(_this);
                    };
                    element.onerror = function (e) {
                        // Warn and resolve on error
                        console.log('Texture \'' + _this.name + '\': failed to load url: \'' + _this.source + '\'', e, options);
                        resolve(_this);
                    };

                    // Safari has a bug loading data-URL elements with CORS enabled, so it must be disabled in that case
                    // https://bugs.webkit.org/show_bug.cgi?id=123978
                    if (!(isSafari() && _this.source.slice(0, 5) === 'data:')) {
                        element.crossOrigin = 'anonymous';
                    }

                    element.src = _this.source;
                    if (isVideo) {
                        _this.setElement(element, options);
                    }
                });
                return this.loading;
            }

            // Sets texture to a raw image buffer

        }, {
            key: 'setData',
            value: function setData(width, height, data) {
                var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

                this.width = width;
                this.height = height;

                this.source = data;
                this.sourceType = 'data';

                this.update(options);
                this.setFiltering(options);

                this.loading = Promise.resolve(this);
                return this.loading;
            }

            // Sets the texture to track a element (canvas/image)

        }, {
            key: 'setElement',
            value: function setElement(element, options) {
                var _this2 = this;

                var el = element;

                // a string element is interpeted as a CSS selector
                if (typeof element === 'string') {
                    element = document.querySelector(element);
                }

                if (element instanceof HTMLCanvasElement || element instanceof HTMLImageElement || element instanceof HTMLVideoElement) {
                    this.source = element;
                    this.sourceType = 'element';

                    if (element instanceof HTMLVideoElement) {
                        element.addEventListener('canplaythrough', function () {
                            _this2.intervalID = setInterval(function () {
                                _this2.update(options);
                            }, 15);
                        }, true);
                        element.addEventListener('ended', function () {
                            element.currentTime = 0;
                            element.play();
                        }, true);
                    } else {
                        this.update(options);
                    }
                    this.setFiltering(options);
                } else {
                    var msg = 'the \'element\' parameter (`element: ' + JSON.stringify(el) + '`) must be a CSS ';
                    msg += 'selector string, or a <canvas>, <image> or <video> object';
                    console.log('Texture \'' + this.name + '\': ' + msg, options);
                }

                this.loading = Promise.resolve(this);
                return this.loading;
            }

            // Uploads current image or buffer to the GPU (can be used to update animated textures on the fly)

        }, {
            key: 'update',
            value: function update() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (!this.valid) {
                    return;
                }

                this.bind();
                this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, options.UNPACK_FLIP_Y_WEBGL === false ? false : true);
                this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.UNPACK_PREMULTIPLY_ALPHA_WEBGL || false);

                // Image or Canvas element
                if (this.sourceType === 'element' && (this.source instanceof HTMLCanvasElement || this.source instanceof HTMLVideoElement || this.source instanceof HTMLImageElement && this.source.complete)) {
                    if (this.source instanceof HTMLVideoElement) {
                        this.width = this.source.videoWidth;
                        this.height = this.source.videoHeight;
                    } else {
                        this.width = this.source.width;
                        this.height = this.source.height;
                    }
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.source);
                }
                // Raw image buffer
                else if (this.sourceType === 'data') {
                        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.source);
                    }
                this.trigger('loaded', this);
            }

            // Determines appropriate filtering mode

        }, {
            key: 'setFiltering',
            value: function setFiltering() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                if (!this.valid) {
                    return;
                }

                this.powerOf2 = isPowerOf2(this.width) && isPowerOf2(this.height);
                var defualtFilter = this.powerOf2 ? 'mipmap' : 'linear';
                this.filtering = options.filtering || defualtFilter;

                var gl = this.gl;
                this.bind();

                // For power-of-2 textures, the following presets are available:
                // mipmap: linear blend from nearest mip
                // linear: linear blend from original image (no mips)
                // nearest: nearest pixel from original image (no mips, 'blocky' look)
                if (this.powerOf2) {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);

                    if (this.filtering === 'mipmap') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR); // TODO: use trilinear filtering by defualt instead?
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else if (this.filtering === 'linear') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    } else if (this.filtering === 'nearest') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    }
                } else {
                    // WebGL has strict requirements on non-power-of-2 textures:
                    // No mipmaps and must clamp to edge
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    if (this.filtering === 'mipmap') {
                        this.filtering = 'linear';
                    }

                    if (this.filtering === 'nearest') {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    } else {
                        // default to linear for non-power-of-2 textures
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    }
                }
            }
        }]);
        return Texture;
    }();

    // Report max texture size for a GL context


    Texture.getMaxTextureSize = function (gl) {
        return gl.getParameter(gl.MAX_TEXTURE_SIZE);
    };

    // Global set of textures, by name
    Texture.activeUnit = -1;

    /*
    The MIT License (MIT)

    Copyright (c) 2015 Patricio Gonzalez Vivo ( http://www.patriciogonzalezvivo.com )

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the 'Software'), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
    the Software, and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    */

    var GlslCanvas = function () {
        function GlslCanvas(canvas, contextOptions, options) {
            var _this = this;

            classCallCheck(this, GlslCanvas);

            subscribeMixin$1(this);

            contextOptions = contextOptions || {};
            options = options || {};

            this.width = canvas.clientWidth;
            this.height = canvas.clientHeight;

            this.canvas = canvas;
            this.gl = undefined;
            this.program = undefined;
            this.textures = {};
            this.buffers = {};
            this.uniforms = {};
            this.vbo = {};
            this.isValid = false;

            this.BUFFER_COUNT = 0;
            // this.TEXTURE_COUNT = 0;

            this.vertexString = contextOptions.vertexString || '\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nattribute vec2 a_position;\nattribute vec2 a_texcoord;\n\nvarying vec2 v_texcoord;\n\nvoid main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    v_texcoord = a_texcoord;\n}\n';
            this.fragmentString = contextOptions.fragmentString || '\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvarying vec2 v_texcoord;\n\nvoid main(){\n    gl_FragColor = vec4(0.0);\n}\n';

            // GL Context
            var gl = setupWebGL(canvas, contextOptions, options.onError);
            if (!gl) {
                return;
            }
            this.gl = gl;
            this.timeLoad = this.timePrev = performance.now();
            this.timeDelta = 0.0;
            this.forceRender = true;
            this.paused = false;
            this.realToCSSPixels = window.devicePixelRatio || 1;

            // Allow alpha
            canvas.style.backgroundColor = contextOptions.backgroundColor || 'rgba(1,1,1,0)';

            // Load shader
            if (canvas.hasAttribute('data-fragment')) {
                this.fragmentString = canvas.getAttribute('data-fragment');
            } else if (canvas.hasAttribute('data-fragment-url')) {
                var source = canvas.getAttribute('data-fragment-url');
                xhr.get(source, function (error, response, body) {
                    _this.load(body, _this.vertexString);
                });
            }

            // Load shader
            if (canvas.hasAttribute('data-vertex')) {
                this.vertexString = canvas.getAttribute('data-vertex');
            } else if (canvas.hasAttribute('data-vertex-url')) {
                var _source = canvas.getAttribute('data-vertex-url');
                xhr.get(_source, function (error, response, body) {
                    _this.load(_this.fragmentString, body);
                });
            }

            this.load();

            if (!this.program) {
                return;
            }

            // Define Vertex buffer
            var texCoordsLoc = gl.getAttribLocation(this.program, 'a_texcoord');
            this.vbo.texCoords = gl.createBuffer();
            this.gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.texCoords);
            this.gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
            this.gl.enableVertexAttribArray(texCoordsLoc);
            this.gl.vertexAttribPointer(texCoordsLoc, 2, gl.FLOAT, false, 0, 0);

            var verticesLoc = gl.getAttribLocation(this.program, 'a_position');
            this.vbo.vertices = gl.createBuffer();
            this.gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.vertices);
            this.gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]), gl.STATIC_DRAW);
            this.gl.enableVertexAttribArray(verticesLoc);
            this.gl.vertexAttribPointer(verticesLoc, 2, gl.FLOAT, false, 0, 0);

            // load TEXTURES
            if (canvas.hasAttribute('data-textures')) {
                var imgList = canvas.getAttribute('data-textures').split(',');
                for (var nImg in imgList) {
                    this.setUniform('u_tex' + nImg, imgList[nImg]);
                }
            }

            // ========================== EVENTS
            var mouse = {
                x: 0,
                y: 0
            };
            document.addEventListener('mousemove', function (e) {
                mouse.x = e.clientX || e.pageX;
                mouse.y = e.clientY || e.pageY;
            }, false);

            var sandbox = this;
            function RenderLoop() {
                if (sandbox.nMouse > 1) {
                    sandbox.setMouse(mouse);
                }

                if (sandbox.resize()) {
                    sandbox.forceRender = true;
                }

                sandbox.render();
                window.requestAnimationFrame(RenderLoop);
            }

            // Start
            this.setMouse({ x: 0, y: 0 });
            RenderLoop();
            return this;
        }

        createClass(GlslCanvas, [{
            key: 'destroy',
            value: function destroy() {
                this.animated = false;
                this.isValid = false;
                for (var tex in this.textures) {
                    if (tex.destroy) {
                        tex.destroy();
                    }
                }
                this.textures = {};
                for (var att in this.attribs) {
                    this.gl.deleteBuffer(this.attribs[att]);
                }
                this.gl.useProgram(null);
                this.gl.deleteProgram(this.program);
                for (var key in this.buffers) {
                    var buffer = this.buffers[key];
                    this.gl.deleteProgram(buffer.program);
                }
                this.program = null;
                this.gl = null;
            }
        }, {
            key: 'load',
            value: function load(fragString, vertString) {

                // Load vertex shader if there is one
                if (vertString) {
                    this.vertexString = vertString;
                }

                // Load fragment shader if there is one
                if (fragString) {
                    this.fragmentString = fragString;
                }

                this.animated = false;
                this.nDelta = (this.fragmentString.match(/u_delta/g) || []).length;
                this.nTime = (this.fragmentString.match(/u_time/g) || []).length;
                this.nDate = (this.fragmentString.match(/u_date/g) || []).length;
                this.nMouse = (this.fragmentString.match(/u_mouse/g) || []).length;
                this.animated = this.nDate > 1 || this.nTime > 1 || this.nMouse > 1;

                var nTextures = this.fragmentString.search(/sampler2D/g);
                if (nTextures) {
                    var lines = this.fragmentString.split('\n');
                    for (var i = 0; i < lines.length; i++) {
                        var match = lines[i].match(/uniform\s*sampler2D\s*([\w]*);\s*\/\/\s*([\w|\:\/\/|\.|\-|\_]*)/i);
                        if (match) {
                            var ext = match[2].split('.').pop().toLowerCase();
                            if (match[1] && match[2] && (ext === 'jpg' || ext === 'jpeg' || ext === 'png' || ext === 'ogv' || ext === 'webm' || ext === 'mp4')) {
                                this.setUniform(match[1], match[2]);
                            }
                        }
                        var main = lines[i].match(/\s*void\s*main\s*/g);
                        if (main) {
                            break;
                        }
                    }
                }

                var vertexShader = createShader(this, this.vertexString, this.gl.VERTEX_SHADER);
                var fragmentShader = createShader(this, this.fragmentString, this.gl.FRAGMENT_SHADER);

                // If Fragment shader fails load a empty one to sign the error
                if (!fragmentShader) {
                    fragmentShader = createShader(this, 'void main(){\n\tgl_FragColor = vec4(1.0);\n}', this.gl.FRAGMENT_SHADER);
                    this.isValid = false;
                } else {
                    this.isValid = true;
                }

                // Create and use program
                var program = createProgram(this, [vertexShader, fragmentShader]); //, [0,1],['a_texcoord','a_position']);
                this.gl.useProgram(program);

                // Delete shaders
                // this.gl.detachShader(program, vertexShader);
                // this.gl.detachShader(program, fragmentShader);
                this.gl.deleteShader(vertexShader);
                this.gl.deleteShader(fragmentShader);

                this.program = program;
                this.change = true;

                this.BUFFER_COUNT = 0;
                var buffers = this.getBuffers(this.fragmentString);
                if (Object.keys(buffers).length) {
                    this.loadPrograms(buffers);
                }
                this.buffers = buffers;
                this.texureIndex = this.BUFFER_COUNT;

                // Trigger event
                this.trigger('load', {});

                this.forceRender = true;
                this.render();
            }
        }, {
            key: 'test',
            value: function test(callback, fragString, vertString) {
                // Thanks to @thespite for the help here
                // https://www.khronos.org/registry/webgl/extensions/EXT_disjoint_timer_query/
                var pre_test_vert = this.vertexString;
                var pre_test_frag = this.fragmentString;
                var pre_test_paused = this.paused;

                var ext = this.gl.getExtension('EXT_disjoint_timer_query');
                var query = ext.createQueryEXT();
                var wasValid = this.isValid;

                if (fragString || vertString) {
                    this.load(fragString, vertString);
                    wasValid = this.isValid;
                    this.forceRender = true;
                    this.render();
                }

                this.paused = true;
                ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
                this.forceRender = true;
                this.render();
                ext.endQueryEXT(ext.TIME_ELAPSED_EXT);

                var sandbox = this;
                function finishTest() {
                    // Revert changes... go back to normal
                    sandbox.paused = pre_test_paused;
                    if (fragString || vertString) {
                        sandbox.load(pre_test_frag, pre_test_vert);
                    }
                }
                function waitForTest() {
                    sandbox.forceRender = true;
                    sandbox.render();
                    var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
                    var disjoint = sandbox.gl.getParameter(ext.GPU_DISJOINT_EXT);
                    if (available && !disjoint) {
                        var ret = {
                            wasValid: wasValid,
                            frag: fragString || sandbox.fragmentString,
                            vert: vertString || sandbox.vertexString,
                            timeElapsedMs: ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT) / 1000000.0
                        };
                        finishTest();
                        callback(ret);
                    } else {
                        window.requestAnimationFrame(waitForTest);
                    }
                }
                waitForTest();
            }
        }, {
            key: 'loadTexture',
            value: function loadTexture(name, urlElementOrData, options) {
                var _this2 = this;

                if (!options) {
                    options = {};
                }

                if (typeof urlElementOrData === 'string') {
                    options.url = urlElementOrData;
                } else if ((typeof urlElementOrData === 'undefined' ? 'undefined' : _typeof(urlElementOrData)) === 'object' && urlElementOrData.data && urlElementOrData.width && urlElementOrData.height) {
                    options.data = urlElementOrData.data;
                    options.width = urlElementOrData.width;
                    options.height = urlElementOrData.height;
                } else if ((typeof urlElementOrData === 'undefined' ? 'undefined' : _typeof(urlElementOrData)) === 'object') {
                    options.element = urlElementOrData;
                }

                if (this.textures[name]) {
                    if (this.textures[name]) {
                        this.textures[name].load(options);
                        this.textures[name].on('loaded', function (args) {
                            _this2.forceRender = true;
                        });
                    }
                } else {
                    this.textures[name] = new Texture(this.gl, name, options);
                    this.textures[name].on('loaded', function (args) {
                        _this2.forceRender = true;
                    });
                }
            }
        }, {
            key: 'refreshUniforms',
            value: function refreshUniforms() {
                this.uniforms = {};
            }
        }, {
            key: 'setUniform',
            value: function setUniform(name) {
                var u = {};

                for (var _len = arguments.length, value = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    value[_key - 1] = arguments[_key];
                }

                u[name] = value;
                this.setUniforms(u);
            }
        }, {
            key: 'setUniforms',
            value: function setUniforms(uniforms) {
                var parsed = parseUniforms(uniforms);
                // Set each uniform
                for (var u in parsed) {
                    if (parsed[u].type === 'sampler2D') {
                        // For textures, we need to track texture units, so we have a special setter
                        // this.uniformTexture(parsed[u].name, parsed[u].value[0]);
                        this.loadTexture(parsed[u].name, parsed[u].value[0]);
                    } else {
                        this.uniform(parsed[u].method, parsed[u].type, parsed[u].name, parsed[u].value);
                    }
                }
                this.forceRender = true;
            }
        }, {
            key: 'setMouse',
            value: function setMouse(mouse) {
                // set the mouse uniform
                var rect = this.canvas.getBoundingClientRect();
                if (mouse && mouse.x && mouse.x >= rect.left && mouse.x <= rect.right && mouse.y && mouse.y >= rect.top && mouse.y <= rect.bottom) {

                    var mouse_x = (mouse.x - rect.left) * this.realToCSSPixels;
                    var mouse_y = this.canvas.height - (mouse.y - rect.top) * this.realToCSSPixels;

                    this.uniform('2f', 'vec2', 'u_mouse', mouse_x, mouse_y);
                }
            }

            // ex: program.uniform('3f', 'position', x, y, z);

        }, {
            key: 'uniform',
            value: function uniform(method, type, name) {
                // 'value' is a method-appropriate arguments list
                this.uniforms[name] = this.uniforms[name] || {};
                var uniform = this.uniforms[name];

                for (var _len2 = arguments.length, value = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
                    value[_key2 - 3] = arguments[_key2];
                }

                var change = isDiff(uniform.value, value);

                // remember and keep track of uniforms location to save calls
                if (change || this.change || !uniform.location || !uniform.value) {
                    uniform.name = name;
                    uniform.type = type;
                    uniform.value = value;
                    uniform.method = 'uniform' + method;
                    this.gl.useProgram(this.program);
                    uniform.location = this.gl.getUniformLocation(this.program, name);
                    this.gl[uniform.method].apply(this.gl, [uniform.location].concat(uniform.value));
                    // If there is change update and there is buffer update manually one by one
                    for (var key in this.buffers) {
                        var buffer = this.buffers[key];
                        this.gl.useProgram(buffer.program);
                        var location = this.gl.getUniformLocation(buffer.program, name);
                        this.gl[uniform.method].apply(this.gl, [location].concat(uniform.value));
                    }
                }
            }
        }, {
            key: 'uniformTexture',
            value: function uniformTexture(name, texture, options) {
                if (this.textures[name] === undefined) {
                    this.loadTexture(name, texture, options);
                } else {
                    this.uniform('1i', 'sampler2D', name, this.texureIndex);

                    for (var key in this.buffers) {
                        var buffer = this.buffers[key];
                        this.gl.useProgram(buffer.program);
                        this.gl.activeTexture(this.gl.TEXTURE0 + this.texureIndex);
                        this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[name].texture);
                    }
                    this.gl.useProgram(this.program);
                    this.gl.activeTexture(this.gl.TEXTURE0 + this.texureIndex);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[name].texture);
                    this.uniform('2f', 'vec2', name + 'Resolution', this.textures[name].width, this.textures[name].height);
                }
            }
        }, {
            key: 'resize',
            value: function resize() {
                if (this.width !== this.canvas.clientWidth || this.height !== this.canvas.clientHeight) {
                    this.realToCSSPixels = window.devicePixelRatio || 1;

                    // Lookup the size the browser is displaying the canvas in CSS pixels
                    // and compute a size needed to make our drawingbuffer match it in
                    // device pixels.
                    var displayWidth = Math.floor(this.gl.canvas.clientWidth * this.realToCSSPixels);
                    var displayHeight = Math.floor(this.gl.canvas.clientHeight * this.realToCSSPixels);

                    // Check if the canvas is not the same size.
                    if (this.gl.canvas.width !== displayWidth || this.gl.canvas.height !== displayHeight) {
                        // Make the canvas the same size
                        this.gl.canvas.width = displayWidth;
                        this.gl.canvas.height = displayHeight;
                        // Set the viewport to match
                        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
                    }
                    this.width = this.canvas.clientWidth;
                    this.height = this.canvas.clientHeight;
                    this.resizeSwappableBuffers();
                    return true;
                } else {
                    return false;
                }
            }
        }, {
            key: 'render',
            value: function render() {
                this.visible = isCanvasVisible(this.canvas);
                if (this.forceRender || this.change || this.animated && this.visible && !this.paused) {

                    // Update Uniforms when are need
                    var date = new Date();
                    var now = performance.now();
                    this.timeDelta = (now - this.timePrev) / 1000.0;
                    this.timePrev = now;
                    if (this.nDelta > 1) {
                        // set the delta time uniform
                        this.uniform('1f', 'float', 'u_delta', this.timeDelta);
                    }

                    if (this.nTime > 1) {
                        // set the elapsed time uniform
                        this.uniform('1f', 'float', 'u_time', (now - this.timeLoad) / 1000.0);
                    }

                    if (this.nDate) {
                        // Set date uniform: year/month/day/time_in_sec
                        this.uniform('4f', 'float', 'u_date', date.getFullYear(), date.getMonth(), date.getDate(), date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds() + date.getMilliseconds() * 0.001);
                    }

                    // set the resolution uniform
                    this.uniform('2f', 'vec2', 'u_resolution', this.canvas.width, this.canvas.height);

                    for (var key in this.buffers) {
                        var buffer = this.buffers[key];
                        this.uniform('1i', 'sampler2D', buffer.name, buffer.bundle.input.index);
                    }

                    this.texureIndex = this.BUFFER_COUNT;
                    for (var tex in this.textures) {
                        this.uniformTexture(tex);
                        this.texureIndex++;
                    }

                    this.renderPrograms();

                    // Trigger event
                    this.trigger('render', {});
                    this.change = false;
                    this.forceRender = false;
                }
            }
        }, {
            key: 'pause',
            value: function pause() {
                this.paused = true;
            }
        }, {
            key: 'play',
            value: function play() {
                this.paused = false;
            }

            // render main and buffers programs

        }, {
            key: 'renderPrograms',
            value: function renderPrograms() {
                var gl = this.gl;
                var W = gl.canvas.width;
                var H = gl.canvas.height;

                gl.viewport(0, 0, W, H);

                for (var key in this.buffers) {
                    var buffer = this.buffers[key];
                    buffer.bundle.render(W, H, buffer.program, buffer.name);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }

                gl.useProgram(this.program);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            // parse input strings

        }, {
            key: 'getBuffers',
            value: function getBuffers(fragString) {
                var buffers = {};
                if (fragString) {
                    fragString.replace(/(?:^\s*)((?:#if|#elif)(?:\s*)(defined\s*\(\s*BUFFER_)(\d+)(?:\s*\))|(?:#ifdef)(?:\s*BUFFER_)(\d+)(?:\s*))/gm, function () {
                        var i = arguments[3] || arguments[4];
                        buffers['u_buffer' + i] = {
                            fragment: '#define BUFFER_' + i + '\n' + fragString
                        };
                    });
                }
                return buffers;
            }

            // load buffers programs

        }, {
            key: 'loadPrograms',
            value: function loadPrograms(buffers) {
                var glsl = this;
                var gl = this.gl;
                var vertex = createShader(glsl, glsl.vertexString, gl.VERTEX_SHADER);
                for (var key in buffers) {
                    var buffer = buffers[key];
                    var fragment = createShader(glsl, buffer.fragment, gl.FRAGMENT_SHADER, 1);
                    if (!fragment) {
                        fragment = createShader(glsl, 'void main(){\n\tgl_FragColor = vec4(1.0);\n}', gl.FRAGMENT_SHADER);
                        glsl.isValid = false;
                    } else {
                        glsl.isValid = true;
                    }
                    var program = createProgram(glsl, [vertex, fragment]);
                    buffer.name = key;
                    buffer.program = program;
                    buffer.bundle = glsl.createSwappableBuffer(glsl.canvas.width, glsl.canvas.height, program);
                    gl.deleteShader(fragment);
                }
                gl.deleteShader(vertex);
            }

            // create an input / output swappable buffer

        }, {
            key: 'createSwappableBuffer',
            value: function createSwappableBuffer(W, H, program) {
                var input = this.createBuffer(W, H, program);
                var output = this.createBuffer(W, H, program);
                var gl = this.gl;
                return {
                    input: input,
                    output: output,
                    swap: function swap() {
                        var temp = input;
                        input = output;
                        output = temp;
                        this.input = input;
                        this.output = output;
                    },
                    render: function render(W, H, program, name) {
                        gl.useProgram(program);
                        gl.viewport(0, 0, W, H);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, this.input.buffer);
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.output.texture, 0);
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        this.swap();
                    },
                    resize: function resize(W, H, program, name) {
                        gl.useProgram(program);
                        gl.viewport(0, 0, W, H);
                        this.input.resize(W, H);
                        this.output.resize(W, H);
                    }
                };
            }

            // create a buffers

        }, {
            key: 'createBuffer',
            value: function createBuffer(W, H, program) {
                var gl = this.gl;
                var index = this.BUFFER_COUNT;
                this.BUFFER_COUNT += 2;
                gl.getExtension('OES_texture_float');
                var texture = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0 + index);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.FLOAT, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                var buffer = gl.createFramebuffer();
                return {
                    index: index,
                    texture: texture,
                    buffer: buffer,
                    W: W,
                    H: H,
                    resize: function resize(W, H) {
                        gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
                        var minW = Math.min(W, this.W);
                        var minH = Math.min(H, this.H);
                        var pixels = new Float32Array(minW * minH * 4);
                        gl.readPixels(0, 0, minW, minH, gl.RGBA, gl.FLOAT, pixels);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                        var newIndex = index + 1;
                        var newTexture = gl.createTexture();
                        gl.activeTexture(gl.TEXTURE0 + newIndex);
                        gl.bindTexture(gl.TEXTURE_2D, newTexture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.FLOAT, null);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, minW, minH, gl.RGBA, gl.FLOAT, pixels);
                        var newBuffer = gl.createFramebuffer();
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                        gl.deleteTexture(texture);
                        gl.activeTexture(gl.TEXTURE0 + index);
                        gl.bindTexture(gl.TEXTURE_2D, newTexture);
                        index = this.index = index;
                        texture = this.texture = newTexture;
                        buffer = this.buffer = newBuffer;
                        this.W = W;
                        this.H = H;
                    }
                };
            }

            // resize buffers on canvas resize
            // consider applying a throttle of 50 ms on canvas resize
            // to avoid requestAnimationFrame and Gl violations

        }, {
            key: 'resizeSwappableBuffers',
            value: function resizeSwappableBuffers() {
                var gl = this.gl;
                var W = gl.canvas.width,
                    H = gl.canvas.height;
                gl.viewport(0, 0, W, H);
                for (var key in this.buffers) {
                    var buffer = this.buffers[key];
                    buffer.bundle.resize(W, H, buffer.program, buffer.name);
                }
                gl.useProgram(this.program);
            }
        }, {
            key: 'version',
            value: function version() {
                return '0.1.7';
            }
        }]);
        return GlslCanvas;
    }();

    function loadAllGlslCanvas() {
        var list = document.getElementsByClassName('glslCanvas');
        if (list.length > 0) {
            window.glslCanvases = [];
            for (var i = 0; i < list.length; i++) {
                var sandbox = new GlslCanvas(list[i]);
                if (sandbox.isValid) {
                    window.glslCanvases.push(sandbox);
                }
            }
        }
    }

    window.addEventListener('load', function () {
        loadAllGlslCanvas();
    });

    var kernel_frag = "precision mediump float;precision lowp int;\n#define GLSLIFY 1\nuniform vec2 u_resolution;uniform float u_sigma;uniform float cut_size;uniform bool u_do_scramble;uniform float u_xmin;uniform float u_xmax;const vec3 blue=vec3(0.0,0.0,1.0);const vec3 white=vec3(1.0,1.0,1.0);const float pi=3.1415926539;float slope=u_xmax-u_xmin;float intercept=u_xmin;float scramble(float x){float d=floor(x/cut_size);float r=x-d*cut_size;if(abs(mod(d,2.0))==1.0){x=x+cut_size-2.0*r;}return x;}float kernel(vec2 st){float fac=1.0/(u_sigma*sqrt(2.0*pi));return fac*exp(-0.5*pow((st.x-st.y)/u_sigma,2.0));}void main(){vec2 st=gl_FragCoord.xy/u_resolution;st=vec2(st.x,1.0-st.y)*slope+intercept;if(u_do_scramble){st=vec2(scramble(st.x),st.y);}float k=kernel(st)/kernel(vec2(0.0,0.0));vec3 color=k*blue+(1.0-k)*white;gl_FragColor=vec4(color,1.0);}"; // eslint-disable-line

    /* src/KernelHeatmap.svelte generated by Svelte v3.40.2 */

    const { console: console_1$1 } = globals;
    const file$5 = "src/KernelHeatmap.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    // (112:12) {#each plot.mu as mu}
    function create_each_block_1$1(ctx) {
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", circle_cx_value = /*xTou*/ ctx[3](/*x*/ ctx[13]));
    			attr_dev(circle, "cy", circle_cy_value = /*yTov*/ ctx[4](/*mu*/ ctx[16]));
    			attr_dev(circle, "r", "2");
    			attr_dev(circle, "fill", "rgba(255,0,0,1)");
    			add_location(circle, file$5, 112, 14, 2392);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*plot*/ 1 && circle_cx_value !== (circle_cx_value = /*xTou*/ ctx[3](/*x*/ ctx[13]))) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty & /*plot*/ 1 && circle_cy_value !== (circle_cy_value = /*yTov*/ ctx[4](/*mu*/ ctx[16]))) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(112:12) {#each plot.mu as mu}",
    		ctx
    	});

    	return block;
    }

    // (111:10) {#each plot.x as x}
    function create_each_block$2(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*plot*/ ctx[0].mu;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*xTou, plot, yTov*/ 25) {
    				each_value_1 = /*plot*/ ctx[0].mu;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(111:10) {#each plot.x as x}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div5;
    	let div4;
    	let div0;
    	let d_math0;
    	let raw0_value = `\\mu` + "";
    	let t0;
    	let div3;
    	let div1;
    	let canvas;
    	let t1;
    	let svg;
    	let div1_resize_listener;
    	let t2;
    	let div2;
    	let d_math1;
    	let raw1_value = `x` + "";
    	let t3;
    	let p;
    	let t4;
    	let d_math2;
    	let raw2_value = `\\mu` + "";
    	let each_value = /*plot*/ ctx[0].x;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			d_math0 = element("d-math");
    			t0 = space();
    			div3 = element("div");
    			div1 = element("div");
    			canvas = element("canvas");
    			t1 = space();
    			svg = svg_element("svg");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			div2 = element("div");
    			d_math1 = element("d-math");
    			t3 = space();
    			p = element("p");
    			t4 = text$1("Each row is the Gaussian at ");
    			d_math2 = element("d-math");
    			add_location(d_math0, file$5, 104, 6, 2060);
    			attr_dev(div0, "class", "col pad-small svelte-1bhz1t1");
    			add_location(div0, file$5, 103, 4, 2026);
    			attr_dev(canvas, "id", "glslCanvas");
    			attr_dev(canvas, "width", /*w*/ ctx[2]);
    			attr_dev(canvas, "height", /*w*/ ctx[2]);
    			add_location(canvas, file$5, 108, 8, 2199);
    			attr_dev(svg, "class", "overlay svelte-1bhz1t1");
    			attr_dev(svg, "width", /*w*/ ctx[2]);
    			attr_dev(svg, "height", /*w*/ ctx[2]);
    			add_location(svg, file$5, 109, 8, 2266);
    			attr_dev(div1, "class", "square inner-plot svelte-1bhz1t1");
    			add_render_callback(() => /*div1_elementresize_handler*/ ctx[6].call(div1));
    			add_location(div1, file$5, 107, 6, 2138);
    			add_location(d_math1, file$5, 118, 8, 2568);
    			attr_dev(div2, "class", "pad-small svelte-1bhz1t1");
    			add_location(div2, file$5, 117, 6, 2536);
    			add_location(d_math2, file$5, 120, 37, 2647);
    			add_location(p, file$5, 120, 6, 2616);
    			attr_dev(div3, "class", "col center svelte-1bhz1t1");
    			add_location(div3, file$5, 106, 4, 2107);
    			attr_dev(div4, "class", "row center svelte-1bhz1t1");
    			add_location(div4, file$5, 102, 2, 1997);
    			attr_dev(div5, "class", "pad col svelte-1bhz1t1");
    			add_location(div5, file$5, 101, 0, 1973);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div0, d_math0);
    			d_math0.innerHTML = raw0_value;
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, canvas);
    			append_dev(div1, t1);
    			append_dev(div1, svg);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svg, null);
    			}

    			div1_resize_listener = add_resize_listener(div1, /*div1_elementresize_handler*/ ctx[6].bind(div1));
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, d_math1);
    			d_math1.innerHTML = raw1_value;
    			append_dev(div3, t3);
    			append_dev(div3, p);
    			append_dev(p, t4);
    			append_dev(p, d_math2);
    			d_math2.innerHTML = raw2_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*w*/ 4) {
    				attr_dev(canvas, "width", /*w*/ ctx[2]);
    			}

    			if (dirty & /*w*/ 4) {
    				attr_dev(canvas, "height", /*w*/ ctx[2]);
    			}

    			if (dirty & /*plot, xTou, yTov*/ 25) {
    				each_value = /*plot*/ ctx[0].x;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(svg, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*w*/ 4) {
    				attr_dev(svg, "width", /*w*/ ctx[2]);
    			}

    			if (dirty & /*w*/ 4) {
    				attr_dev(svg, "height", /*w*/ ctx[2]);
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_each(each_blocks, detaching);
    			div1_resize_listener();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function webgl_supported() {
    	document.createElement('canvas');
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $sig,
    		$$unsubscribe_sig = noop$5,
    		$$subscribe_sig = () => ($$unsubscribe_sig(), $$unsubscribe_sig = subscribe(sig, $$value => $$invalidate(5, $sig = $$value)), sig);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_sig());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('KernelHeatmap', slots, []);
    	let { sig } = $$props, { plot } = $$props;
    	validate_store(sig, 'sig');
    	$$subscribe_sig();
    	let xmin, xmax;
    	let w, sandbox;

    	function xTou(x) {
    		return w * (x - xmin) / (xmax - xmin);
    	}

    	function yTov(y) {
    		return xTou(y);
    	}

    	function update() {
    		if (sandbox == null) return;
    		var sigma = Math.sqrt(plot.get_sigma2());
    		var do_scramble = plot.scrambled();
    		var cut_size = plot.cut_size();
    		[xmin, xmax] = plot.get_xrange();
    		sandbox.setUniform("u_sigma", sigma);
    		sandbox.setUniform("cut_size", cut_size);
    		sandbox.setUniform("u_do_scramble", do_scramble ? 1 : 0);
    		sandbox.setUniform("u_xmin", xmin);
    		sandbox.setUniform("u_xmax", xmax);
    		$$invalidate(0, plot.touch++, plot);
    	}

    	onMount(() => {
    		const canvas = document.getElementById('glslCanvas');
    		console.log('here in onMount');
    		var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    		console.log('gl is ', gl);

    		if (gl && gl instanceof WebGLRenderingContext) {
    			sandbox = new GlslCanvas(canvas);
    			sandbox.load(kernel_frag);
    		}

    		update();
    	});

    	var [respond, notify] = make_sync(update, sig, 'KernelHeatmap');
    	const writable_props = ['sig', 'plot'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<KernelHeatmap> was created with unknown prop '${key}'`);
    	});

    	function div1_elementresize_handler() {
    		w = this.clientWidth;
    		$$invalidate(2, w);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(1, sig = $$props.sig));
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		GlslCanvas,
    		RBFKernel,
    		RBFShuffleKernel,
    		kernel_frag,
    		make_sync,
    		d3,
    		sig,
    		plot,
    		xmin,
    		xmax,
    		w,
    		sandbox,
    		webgl_supported,
    		xTou,
    		yTov,
    		update,
    		respond,
    		notify,
    		$sig
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(1, sig = $$props.sig));
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('xmin' in $$props) xmin = $$props.xmin;
    		if ('xmax' in $$props) xmax = $$props.xmax;
    		if ('w' in $$props) $$invalidate(2, w = $$props.w);
    		if ('sandbox' in $$props) sandbox = $$props.sandbox;
    		if ('respond' in $$props) $$invalidate(11, respond = $$props.respond);
    		if ('notify' in $$props) notify = $$props.notify;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sig*/ 32) {
    			respond($sig);
    		}
    	};

    	return [plot, sig, w, xTou, yTov, $sig, div1_elementresize_handler];
    }

    class KernelHeatmap extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$5, create_fragment$5, safe_not_equal, { sig: 1, plot: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KernelHeatmap",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[1] === undefined && !('sig' in props)) {
    			console_1$1.warn("<KernelHeatmap> was created without expected prop 'sig'");
    		}

    		if (/*plot*/ ctx[0] === undefined && !('plot' in props)) {
    			console_1$1.warn("<KernelHeatmap> was created without expected prop 'plot'");
    		}
    	}

    	get sig() {
    		throw new Error("<KernelHeatmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<KernelHeatmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<KernelHeatmap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<KernelHeatmap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/KernelMatrix.svelte generated by Svelte v3.40.2 */

    const { console: console_1 } = globals;
    const file$4 = "src/KernelMatrix.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	return child_ctx;
    }

    // (82:10) {#each range(plot.n) as j}
    function create_each_block_1(ctx) {
    	let rect;
    	let rect_width_value;
    	let rect_height_value;
    	let rect_x_value;
    	let rect_y_value;

    	const block = {
    		c: function create() {
    			rect = svg_element("rect");
    			attr_dev(rect, "width", rect_width_value = /*rad*/ ctx[2] * 2);
    			attr_dev(rect, "height", rect_height_value = /*rad*/ ctx[2] * 2);
    			attr_dev(rect, "x", rect_x_value = /*corner*/ ctx[4](/*i*/ ctx[12]));
    			attr_dev(rect, "y", rect_y_value = /*corner*/ ctx[4](/*j*/ ctx[15]));
    			set_style(rect, "fill", color(/*plot*/ ctx[0].K[/*i*/ ctx[12]][/*j*/ ctx[15]]));
    			add_location(rect, file$4, 82, 12, 1255);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, rect, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rad*/ 4 && rect_width_value !== (rect_width_value = /*rad*/ ctx[2] * 2)) {
    				attr_dev(rect, "width", rect_width_value);
    			}

    			if (dirty & /*rad*/ 4 && rect_height_value !== (rect_height_value = /*rad*/ ctx[2] * 2)) {
    				attr_dev(rect, "height", rect_height_value);
    			}

    			if (dirty & /*plot*/ 1 && rect_x_value !== (rect_x_value = /*corner*/ ctx[4](/*i*/ ctx[12]))) {
    				attr_dev(rect, "x", rect_x_value);
    			}

    			if (dirty & /*plot*/ 1 && rect_y_value !== (rect_y_value = /*corner*/ ctx[4](/*j*/ ctx[15]))) {
    				attr_dev(rect, "y", rect_y_value);
    			}

    			if (dirty & /*plot*/ 1) {
    				set_style(rect, "fill", color(/*plot*/ ctx[0].K[/*i*/ ctx[12]][/*j*/ ctx[15]]));
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(rect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(82:10) {#each range(plot.n) as j}",
    		ctx
    	});

    	return block;
    }

    // (81:8) {#each range(plot.n) as i}
    function create_each_block$1(ctx) {
    	let each_1_anchor;
    	let each_value_1 = range(/*plot*/ ctx[0].n);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rad, corner, range, plot, color*/ 21) {
    				each_value_1 = range(/*plot*/ ctx[0].n);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(81:8) {#each range(plot.n) as i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let svg;
    	let div0_resize_listener;
    	let t0;
    	let div1;
    	let p;
    	let t1;
    	let d_math0;
    	let raw0_value = `i` + "";
    	let t2;
    	let d_math1;
    	let raw1_value = `(f_i(x_1), f_i(x_2), \\cdots, f_i(x_n))` + "";
    	let each_value = range(/*plot*/ ctx[0].n);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			svg = svg_element("svg");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			div1 = element("div");
    			p = element("p");
    			t1 = text$1("The ");
    			d_math0 = element("d-math");
    			t2 = text$1("'th row is the vector of evaluation \n      ");
    			d_math1 = element("d-math");
    			attr_dev(svg, "class", "inner-plot full svelte-8j35ro");
    			add_location(svg, file$4, 79, 6, 1141);
    			attr_dev(div0, "class", "square svelte-8j35ro");
    			add_render_callback(() => /*div0_elementresize_handler*/ ctx[7].call(div0));
    			add_location(div0, file$4, 78, 4, 1093);
    			add_location(d_math0, file$4, 90, 16, 1500);
    			add_location(d_math1, file$4, 91, 6, 1571);
    			add_location(p, file$4, 90, 9, 1493);
    			add_location(div1, file$4, 90, 4, 1488);
    			attr_dev(div2, "class", "col center svelte-8j35ro");
    			add_location(div2, file$4, 77, 2, 1064);
    			attr_dev(div3, "class", "pad svelte-8j35ro");
    			add_location(div3, file$4, 76, 0, 1044);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, svg);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svg, null);
    			}

    			div0_resize_listener = add_resize_listener(div0, /*div0_elementresize_handler*/ ctx[7].bind(div0));
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, p);
    			append_dev(p, t1);
    			append_dev(p, d_math0);
    			d_math0.innerHTML = raw0_value;
    			append_dev(p, t2);
    			append_dev(p, d_math1);
    			d_math1.innerHTML = raw1_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*range, plot, rad, corner, color*/ 21) {
    				each_value = range(/*plot*/ ctx[0].n);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(svg, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			div0_resize_listener();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function color(s) {
    	var i = 255 * s;
    	return `rgba(${255 - i}, ${255 - i}, 255)`;
    }

    function range(n) {
    	return [...Array(n).keys()];
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $sig,
    		$$unsubscribe_sig = noop$5,
    		$$subscribe_sig = () => ($$unsubscribe_sig(), $$unsubscribe_sig = subscribe(sig, $$value => $$invalidate(6, $sig = $$value)), sig);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_sig());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('KernelMatrix', slots, []);
    	let { sig } = $$props, { plot } = $$props;
    	validate_store(sig, 'sig');
    	$$subscribe_sig();
    	let { space = 10 } = $$props;
    	let rad, w;

    	// calculate the center coordinate
    	function corner(i) {
    		return (2 * rad + space) * i;
    	}

    	function center(i) {
    		return rad + (2 * rad + space) * i;
    	}

    	function update() {
    		$$invalidate(0, plot.touch++, plot);
    		$$invalidate(2, rad = (w - (plot.n - 1) * space) / plot.n / 2);
    	}

    	var [respond, notify] = make_sync(update, sig, 'KernelMatrix');

    	onMount(() => {
    		update();
    		console.log(`Matrix w=${w}`);
    	});

    	const writable_props = ['sig', 'plot', 'space'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<KernelMatrix> was created with unknown prop '${key}'`);
    	});

    	function div0_elementresize_handler() {
    		w = this.clientWidth;
    		$$invalidate(3, w);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(1, sig = $$props.sig));
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('space' in $$props) $$invalidate(5, space = $$props.space);
    	};

    	$$self.$capture_state = () => ({
    		make_sync,
    		numberDisplay,
    		onMount,
    		sig,
    		plot,
    		space,
    		rad,
    		w,
    		color,
    		corner,
    		center,
    		range,
    		update,
    		respond,
    		notify,
    		$sig
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(1, sig = $$props.sig));
    		if ('plot' in $$props) $$invalidate(0, plot = $$props.plot);
    		if ('space' in $$props) $$invalidate(5, space = $$props.space);
    		if ('rad' in $$props) $$invalidate(2, rad = $$props.rad);
    		if ('w' in $$props) $$invalidate(3, w = $$props.w);
    		if ('respond' in $$props) $$invalidate(10, respond = $$props.respond);
    		if ('notify' in $$props) notify = $$props.notify;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sig*/ 64) {
    			respond($sig);
    		}
    	};

    	return [plot, sig, rad, w, corner, space, $sig, div0_elementresize_handler];
    }

    class KernelMatrix extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$4, create_fragment$4, safe_not_equal, { sig: 1, plot: 0, space: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KernelMatrix",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[1] === undefined && !('sig' in props)) {
    			console_1.warn("<KernelMatrix> was created without expected prop 'sig'");
    		}

    		if (/*plot*/ ctx[0] === undefined && !('plot' in props)) {
    			console_1.warn("<KernelMatrix> was created without expected prop 'plot'");
    		}
    	}

    	get sig() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plot() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plot(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get space() {
    		throw new Error("<KernelMatrix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set space(value) {
    		throw new Error("<KernelMatrix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Figure1.svelte generated by Svelte v3.40.2 */
    const file$3 = "src/Figure1.svelte";

    function create_fragment$3(ctx) {
    	let div3;
    	let div1;
    	let div0;
    	let curves;
    	let t0;
    	let lowpanelcontrols;
    	let t1;
    	let slidercontrols;
    	let t2;
    	let div2;
    	let kernelheatmap;
    	let t3;
    	let kernelmatrix;
    	let current;

    	curves = new Curves({
    			props: {
    				sig: /*sig*/ ctx[3],
    				box: /*box*/ ctx[0],
    				cfg: /*cfg*/ ctx[1],
    				plot: /*plot*/ ctx[2]
    			},
    			$$inline: true
    		});

    	lowpanelcontrols = new LowPanelControls({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cfg: /*cfg*/ ctx[1],
    				plot: /*plot*/ ctx[2]
    			},
    			$$inline: true
    		});

    	slidercontrols = new SliderControls({
    			props: {
    				sig: /*sig*/ ctx[3],
    				plot: /*plot*/ ctx[2]
    			},
    			$$inline: true
    		});

    	kernelheatmap = new KernelHeatmap({
    			props: {
    				sig: /*sig*/ ctx[3],
    				plot: /*plot*/ ctx[2]
    			},
    			$$inline: true
    		});

    	kernelmatrix = new KernelMatrix({
    			props: {
    				sig: /*sig*/ ctx[3],
    				plot: /*plot*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(curves.$$.fragment);
    			t0 = space();
    			create_component(lowpanelcontrols.$$.fragment);
    			t1 = space();
    			create_component(slidercontrols.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			create_component(kernelheatmap.$$.fragment);
    			t3 = space();
    			create_component(kernelmatrix.$$.fragment);
    			attr_dev(div0, "class", "col full svelte-59d2b5");
    			add_location(div0, file$3, 47, 4, 920);
    			attr_dev(div1, "class", "row full svelte-59d2b5");
    			add_location(div1, file$3, 46, 2, 893);
    			attr_dev(div2, "class", "row full svelte-59d2b5");
    			add_location(div2, file$3, 53, 2, 1128);
    			attr_dev(div3, "class", "col full svelte-59d2b5");
    			add_location(div3, file$3, 45, 0, 868);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			mount_component(curves, div0, null);
    			append_dev(div0, t0);
    			mount_component(lowpanelcontrols, div0, null);
    			append_dev(div1, t1);
    			mount_component(slidercontrols, div1, null);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			mount_component(kernelheatmap, div2, null);
    			append_dev(div2, t3);
    			mount_component(kernelmatrix, div2, null);
    			current = true;
    		},
    		p: noop$5,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(curves.$$.fragment, local);
    			transition_in(lowpanelcontrols.$$.fragment, local);
    			transition_in(slidercontrols.$$.fragment, local);
    			transition_in(kernelheatmap.$$.fragment, local);
    			transition_in(kernelmatrix.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(curves.$$.fragment, local);
    			transition_out(lowpanelcontrols.$$.fragment, local);
    			transition_out(slidercontrols.$$.fragment, local);
    			transition_out(kernelheatmap.$$.fragment, local);
    			transition_out(kernelmatrix.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(curves);
    			destroy_component(lowpanelcontrols);
    			destroy_component(slidercontrols);
    			destroy_component(kernelheatmap);
    			destroy_component(kernelmatrix);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Figure1', slots, []);
    	let box = { w: 10, h: 10 };

    	let cfg = {
    		show_data: true,
    		show_scaled: true,
    		show_solution: true,
    		show_points: false,
    		auto_solve: false
    	};

    	let ctx = new Context(box.w, box.h, [-4, 4], [-4, 4]);
    	let plot = new Plot(ctx, 3);
    	let sig = writable(0);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Figure1> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		writable,
    		Plot,
    		Context,
    		Curves,
    		LowPanelControls,
    		SliderControls,
    		KernelHeatmap,
    		KernelMatrix,
    		box,
    		cfg,
    		ctx,
    		plot,
    		sig
    	});

    	$$self.$inject_state = $$props => {
    		if ('box' in $$props) $$invalidate(0, box = $$props.box);
    		if ('cfg' in $$props) $$invalidate(1, cfg = $$props.cfg);
    		if ('ctx' in $$props) ctx = $$props.ctx;
    		if ('plot' in $$props) $$invalidate(2, plot = $$props.plot);
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [box, cfg, plot, sig];
    }

    class Figure1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Figure1",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    const XMIN = -4;
    const XMAX = 4;

    function dotp(p, q) {
      return p[0] * q[0] + p[1] * q[1];
    }

    function norm2(p) {
      return dotp(p, p);
    }

    function scale(p, factor) {
      return [p[0] * factor, p[1] * factor];
    }

    // calculate the vector projection of arg to onto
    function proj(onto, arg) {
      return scale(onto, dotp(onto, arg) / norm2(onto));
    }


    class PhiSpace$1 {
      constructor(max_alpha) {
        this.basis = new Matrix([[1,0], [0,0]]);
        this.xTou = linear().domain([-max_alpha, max_alpha]);
        this.yTov = linear().domain([-max_alpha, max_alpha]);

        var ctx = new Context(10, 10, [XMIN, XMAX], [XMIN, XMAX]);
        this.plot = new Plot(ctx, 2);
        this.updateBasis();
        this.plot.initK();
        this.plot.initCurveCache();
      }

      toUV(val, i) {
        if (i == 0) return this.xTou(val);
        return this.yTov(val);
      }

      toXY(val, i) {
        if (i == 0) return this.xTou.invert(val);
        return this.yTov.invert(val);
      }

      resizePhi(w, h) {
        this.xTou.range([0, w]);
        this.yTov.range([h, 0]);
      }

      resizeCtx(w, h) {
        this.plot.resize(w, h);
      }

      // update the second basis vector, assuming the kernel with k(v, v) = 1 for
      // all v
      updateBasis() {
        var kv = this.plot.K[0][1];
        var ang = Math.acos(kv);
        this.basis[1][0] = Math.cos(ang);
        this.basis[1][1] = Math.sin(ang);
      }

      // update the current function f
      updateF(u, v) {
        var fx = this.toXY(u, 0);
        var fy = this.toXY(v, 1);
        var F = new Matrix([[fx, fy]]);
        this.plot.alpha = F.mmul(inverse(this.basis)).flat();
      }

      F(i) {
        var xy = this.alpha().mmul(this.basis).flat();
        return this.toUV(xy[i], i);
      }
      
      updateY(u, v) {
        var fhat = [this.toXY(u, 0), this.toXY(v, 1)];
        var y = new Matrix([fhat]).mmul(this.basis.transpose()).flat();
        this.plot.y = y;
      }

      _fHat() {
        var alpha_hat = new Matrix([this.plot.solutionAlpha()]);
        var f_hat = alpha_hat.mmul(this.basis).flat();
        return f_hat;
      }

      // c'th component of the solution vector
      fHat(c) {
        var f_hat = this._fHat();
        return this.toUV(f_hat[c], c);
      }

      fHatProj(b, c) {
        var fhp = proj(this.basis[b], this._fHat())[c];
        return this.toUV(fhp, c);
      }

      alpha() {
        return new Matrix([this.plot.alpha]);
      }

      // calculate the projection of F onto the j'th component of the i'th basis
      Fproj(b,c) {
        var dp = this.alpha().mmul(this.plot.K)[0][b];
        var proj = dp * this.basis[b][c];
        return this.toUV(proj, c);
      }


      // calculate c'th component of projection of y onto b'th basis.
      Yproj(b,c) {
        var dp = new Matrix([this.plot.y]).mmul(this.basis.transpose())[0][b];
        var proj = dp * this.basis[b][c];
        // console.log(b, c, dp);
        return this.toUV(proj, c);
      }

      scr(i,c) {
        return this.toUV(this.basis[i][c], c);
      }

    }

    var phi = /*#__PURE__*/Object.freeze({
        __proto__: null,
        PhiSpace: PhiSpace$1
    });

    /* src/PhiSpace.svelte generated by Svelte v3.40.2 */
    const file$2 = "src/PhiSpace.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    // (144:6) {#each [0, 1] as i}
    function create_each_block(ctx) {
    	let line0;
    	let line0_x__value;
    	let line0_y__value;
    	let line0_x__value_1;
    	let line0_y__value_1;
    	let line1;
    	let line1_x__value;
    	let line1_y__value;
    	let line1_x__value_1;
    	let line1_y__value_1;

    	const block = {
    		c: function create() {
    			line0 = svg_element("line");
    			line1 = svg_element("line");
    			attr_dev(line0, "class", "basis svelte-7fxcc2");
    			attr_dev(line0, "x1", line0_x__value = /*pp*/ ctx[0].xTou(0));
    			attr_dev(line0, "y1", line0_y__value = /*pp*/ ctx[0].yTov(0));
    			attr_dev(line0, "x2", line0_x__value_1 = /*pp*/ ctx[0].scr(/*i*/ ctx[16], 0));
    			attr_dev(line0, "y2", line0_y__value_1 = /*pp*/ ctx[0].scr(/*i*/ ctx[16], 1));
    			attr_dev(line0, "marker-end", "url(#basis-arrow)");
    			add_location(line0, file$2, 144, 8, 2679);
    			attr_dev(line1, "class", "perp svelte-7fxcc2");
    			attr_dev(line1, "x1", line1_x__value = /*pp*/ ctx[0].fHat(0));
    			attr_dev(line1, "y1", line1_y__value = /*pp*/ ctx[0].fHat(1));
    			attr_dev(line1, "x2", line1_x__value_1 = /*pp*/ ctx[0].fHatProj(/*i*/ ctx[16], 0));
    			attr_dev(line1, "y2", line1_y__value_1 = /*pp*/ ctx[0].fHatProj(/*i*/ ctx[16], 1));
    			attr_dev(line1, "stroke-dasharray", "4 4");
    			add_location(line1, file$2, 150, 8, 2930);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, line0, anchor);
    			insert_dev(target, line1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*pp*/ 1 && line0_x__value !== (line0_x__value = /*pp*/ ctx[0].xTou(0))) {
    				attr_dev(line0, "x1", line0_x__value);
    			}

    			if (dirty & /*pp*/ 1 && line0_y__value !== (line0_y__value = /*pp*/ ctx[0].yTov(0))) {
    				attr_dev(line0, "y1", line0_y__value);
    			}

    			if (dirty & /*pp*/ 1 && line0_x__value_1 !== (line0_x__value_1 = /*pp*/ ctx[0].scr(/*i*/ ctx[16], 0))) {
    				attr_dev(line0, "x2", line0_x__value_1);
    			}

    			if (dirty & /*pp*/ 1 && line0_y__value_1 !== (line0_y__value_1 = /*pp*/ ctx[0].scr(/*i*/ ctx[16], 1))) {
    				attr_dev(line0, "y2", line0_y__value_1);
    			}

    			if (dirty & /*pp*/ 1 && line1_x__value !== (line1_x__value = /*pp*/ ctx[0].fHat(0))) {
    				attr_dev(line1, "x1", line1_x__value);
    			}

    			if (dirty & /*pp*/ 1 && line1_y__value !== (line1_y__value = /*pp*/ ctx[0].fHat(1))) {
    				attr_dev(line1, "y1", line1_y__value);
    			}

    			if (dirty & /*pp*/ 1 && line1_x__value_1 !== (line1_x__value_1 = /*pp*/ ctx[0].fHatProj(/*i*/ ctx[16], 0))) {
    				attr_dev(line1, "x2", line1_x__value_1);
    			}

    			if (dirty & /*pp*/ 1 && line1_y__value_1 !== (line1_y__value_1 = /*pp*/ ctx[0].fHatProj(/*i*/ ctx[16], 1))) {
    				attr_dev(line1, "y2", line1_y__value_1);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(line0);
    			if (detaching) detach_dev(line1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(144:6) {#each [0, 1] as i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div2;
    	let div0;
    	let svg;
    	let defs;
    	let marker0;
    	let path0;
    	let marker1;
    	let path1;
    	let marker2;
    	let path2;
    	let circle;
    	let circle_cx_value;
    	let circle_cy_value;
    	let line;
    	let line_x__value;
    	let line_y__value;
    	let line_x__value_1;
    	let line_y__value_1;
    	let div0_resize_listener;
    	let t0;
    	let div1;
    	let p;
    	let t1;
    	let d_math0;
    	let raw0_value = `\\phi` + "";
    	let t2;
    	let t3_value = numberDisplay(/*pp*/ ctx[0].plot.x[0]) + "";
    	let t3;
    	let t4;
    	let d_math1;
    	let raw1_value = `\\sigma` + "";
    	let t5;
    	let t6_value = numberDisplay(Math.sqrt(/*pp*/ ctx[0].plot.get_sigma2())) + "";
    	let t6;
    	let t7;
    	let d_math2;
    	let raw2_value = `\\phi` + "";
    	let t8;
    	let t9_value = numberDisplay(/*pp*/ ctx[0].plot.x[1]) + "";
    	let t9;
    	let t10;
    	let d_math3;
    	let raw3_value = `\\sigma` + "";
    	let t11;
    	let t12_value = numberDisplay(Math.sqrt(/*pp*/ ctx[0].plot.get_sigma2())) + "";
    	let t12;
    	let t13;
    	let mounted;
    	let dispose;
    	let each_value = [0, 1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < 2; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			marker0 = svg_element("marker");
    			path0 = svg_element("path");
    			marker1 = svg_element("marker");
    			path1 = svg_element("path");
    			marker2 = svg_element("marker");
    			path2 = svg_element("path");

    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].c();
    			}

    			circle = svg_element("circle");
    			line = svg_element("line");
    			t0 = space();
    			div1 = element("div");
    			p = element("p");
    			t1 = text$1("Plane spanned by vectors \n    ");
    			d_math0 = element("d-math");
    			t2 = text$1("(");
    			t3 = text$1(t3_value);
    			t4 = text$1("; ");
    			d_math1 = element("d-math");
    			t5 = text$1("=");
    			t6 = text$1(t6_value);
    			t7 = text$1(") and\n    ");
    			d_math2 = element("d-math");
    			t8 = text$1("(");
    			t9 = text$1(t9_value);
    			t10 = text$1("; ");
    			d_math3 = element("d-math");
    			t11 = text$1("=");
    			t12 = text$1(t12_value);
    			t13 = text$1(")");
    			attr_dev(path0, "d", "M 0 0 L 10 5 L 0 10 z");
    			add_location(path0, file$2, 121, 10, 2056);
    			attr_dev(marker0, "id", "solution-arrow");
    			attr_dev(marker0, "class", "solution-arrow svelte-7fxcc2");
    			attr_dev(marker0, "viewBox", "0 0 10 10");
    			attr_dev(marker0, "refX", "10");
    			attr_dev(marker0, "refY", "5");
    			attr_dev(marker0, "markerWidth", "6");
    			attr_dev(marker0, "markerHeight", "6");
    			attr_dev(marker0, "orient", "auto-start-reverse");
    			add_location(marker0, file$2, 116, 8, 1853);
    			attr_dev(path1, "d", "M 0 0 L 10 5 L 0 10 z");
    			add_location(path1, file$2, 129, 10, 2314);
    			attr_dev(marker1, "id", "basis-arrow");
    			attr_dev(marker1, "class", "basis-arrow svelte-7fxcc2");
    			attr_dev(marker1, "viewBox", "0 0 10 10");
    			attr_dev(marker1, "refX", "10");
    			attr_dev(marker1, "refY", "5");
    			attr_dev(marker1, "markerWidth", "6");
    			attr_dev(marker1, "markerHeight", "6");
    			attr_dev(marker1, "orient", "auto-start-reverse");
    			add_location(marker1, file$2, 124, 8, 2118);
    			attr_dev(path2, "d", "M 3 0 L 6 0 L 6 10 L 3 10 z");
    			add_location(path2, file$2, 137, 10, 2569);
    			attr_dev(marker2, "id", "flat-head");
    			attr_dev(marker2, "class", "flat-head");
    			attr_dev(marker2, "viewBox", "0 0 10 10");
    			attr_dev(marker2, "refX", "5");
    			attr_dev(marker2, "refY", "5");
    			attr_dev(marker2, "markerWidth", "10");
    			attr_dev(marker2, "markerHeight", "10");
    			attr_dev(marker2, "orient", "auto-start-reverse");
    			add_location(marker2, file$2, 132, 8, 2376);
    			add_location(defs, file$2, 115, 6, 1838);
    			attr_dev(circle, "id", "fhat");
    			attr_dev(circle, "class", "perp-target draggable svelte-7fxcc2");
    			attr_dev(circle, "r", "6");
    			attr_dev(circle, "cx", circle_cx_value = /*pp*/ ctx[0].fHat(0));
    			attr_dev(circle, "cy", circle_cy_value = /*pp*/ ctx[0].fHat(1));
    			add_location(circle, file$2, 159, 6, 3202);
    			attr_dev(line, "class", "solution-curve draggable svelte-7fxcc2");
    			attr_dev(line, "x1", line_x__value = /*pp*/ ctx[0].xTou(0));
    			attr_dev(line, "y1", line_y__value = /*pp*/ ctx[0].yTov(0));
    			attr_dev(line, "x2", line_x__value_1 = /*pp*/ ctx[0].F(0));
    			attr_dev(line, "y2", line_y__value_1 = /*pp*/ ctx[0].F(1));
    			attr_dev(line, "marker-end", "url(#solution-arrow)");
    			add_location(line, file$2, 163, 6, 3436);
    			attr_dev(svg, "class", "inner-plot full svelte-7fxcc2");
    			add_location(svg, file$2, 112, 4, 1733);
    			attr_dev(div0, "class", "grow pad svelte-7fxcc2");
    			add_render_callback(() => /*div0_elementresize_handler*/ ctx[8].call(div0));
    			add_location(div0, file$2, 110, 2, 1639);
    			add_location(d_math0, file$2, 175, 4, 3755);
    			add_location(d_math1, file$2, 175, 68, 3819);
    			add_location(d_math2, file$2, 176, 4, 3912);
    			add_location(d_math3, file$2, 176, 68, 3976);
    			add_location(p, file$2, 174, 4, 3722);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$2, 173, 2, 3703);
    			attr_dev(div2, "class", "col full svelte-7fxcc2");
    			add_location(div2, file$2, 109, 0, 1614);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, svg);
    			append_dev(svg, defs);
    			append_dev(defs, marker0);
    			append_dev(marker0, path0);
    			append_dev(defs, marker1);
    			append_dev(marker1, path1);
    			append_dev(defs, marker2);
    			append_dev(marker2, path2);

    			for (let i = 0; i < 2; i += 1) {
    				each_blocks[i].m(svg, null);
    			}

    			append_dev(svg, circle);
    			append_dev(svg, line);
    			div0_resize_listener = add_resize_listener(div0, /*div0_elementresize_handler*/ ctx[8].bind(div0));
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, p);
    			append_dev(p, t1);
    			append_dev(p, d_math0);
    			d_math0.innerHTML = raw0_value;
    			append_dev(p, t2);
    			append_dev(p, t3);
    			append_dev(p, t4);
    			append_dev(p, d_math1);
    			d_math1.innerHTML = raw1_value;
    			append_dev(p, t5);
    			append_dev(p, t6);
    			append_dev(p, t7);
    			append_dev(p, d_math2);
    			d_math2.innerHTML = raw2_value;
    			append_dev(p, t8);
    			append_dev(p, t9);
    			append_dev(p, t10);
    			append_dev(p, d_math3);
    			d_math3.innerHTML = raw3_value;
    			append_dev(p, t11);
    			append_dev(p, t12);
    			append_dev(p, t13);

    			if (!mounted) {
    				dispose = [
    					listen_dev(circle, "mousedown", /*onMouseDown*/ ctx[4], false, false, false),
    					listen_dev(line, "mousedown", /*onMouseDown*/ ctx[4], false, false, false),
    					listen_dev(svg, "mousemove", /*onMouseMove*/ ctx[5], false, false, false),
    					listen_dev(svg, "mouseup", /*onMouseUp*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*pp*/ 1) {
    				each_value = [0, 1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < 2; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(svg, circle);
    					}
    				}

    				for (; i < 2; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}

    			if (dirty & /*pp*/ 1 && circle_cx_value !== (circle_cx_value = /*pp*/ ctx[0].fHat(0))) {
    				attr_dev(circle, "cx", circle_cx_value);
    			}

    			if (dirty & /*pp*/ 1 && circle_cy_value !== (circle_cy_value = /*pp*/ ctx[0].fHat(1))) {
    				attr_dev(circle, "cy", circle_cy_value);
    			}

    			if (dirty & /*pp*/ 1 && line_x__value !== (line_x__value = /*pp*/ ctx[0].xTou(0))) {
    				attr_dev(line, "x1", line_x__value);
    			}

    			if (dirty & /*pp*/ 1 && line_y__value !== (line_y__value = /*pp*/ ctx[0].yTov(0))) {
    				attr_dev(line, "y1", line_y__value);
    			}

    			if (dirty & /*pp*/ 1 && line_x__value_1 !== (line_x__value_1 = /*pp*/ ctx[0].F(0))) {
    				attr_dev(line, "x2", line_x__value_1);
    			}

    			if (dirty & /*pp*/ 1 && line_y__value_1 !== (line_y__value_1 = /*pp*/ ctx[0].F(1))) {
    				attr_dev(line, "y2", line_y__value_1);
    			}

    			if (dirty & /*pp*/ 1 && t3_value !== (t3_value = numberDisplay(/*pp*/ ctx[0].plot.x[0]) + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*pp*/ 1 && t6_value !== (t6_value = numberDisplay(Math.sqrt(/*pp*/ ctx[0].plot.get_sigma2())) + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*pp*/ 1 && t9_value !== (t9_value = numberDisplay(/*pp*/ ctx[0].plot.x[1]) + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*pp*/ 1 && t12_value !== (t12_value = numberDisplay(Math.sqrt(/*pp*/ ctx[0].plot.get_sigma2())) + "")) set_data_dev(t12, t12_value);
    		},
    		i: noop$5,
    		o: noop$5,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			div0_resize_listener();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $sig,
    		$$unsubscribe_sig = noop$5,
    		$$subscribe_sig = () => ($$unsubscribe_sig(), $$unsubscribe_sig = subscribe(sig, $$value => $$invalidate(7, $sig = $$value)), sig);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_sig());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PhiSpace', slots, []);
    	let { sig } = $$props, { pp } = $$props;
    	validate_store(sig, 'sig');
    	$$subscribe_sig();

    	function update() {
    		pp.updateBasis();
    		$$invalidate(0, pp.plot.touch++, pp);
    		$$invalidate(0, pp.touch++, pp);
    	}

    	var [respond, notify] = make_sync(update, sig, 'PhiSpace');
    	let phi_width, phi_height;
    	let vis_width, vis_height;
    	let drag_point = null;
    	let log_sigma = 0;

    	onMount(() => {
    		pp.resizePhi(phi_width, phi_height);
    		pp.resizeCtx(vis_width, vis_height);
    		update();
    	});

    	function onMouseDown(evt) {
    		drag_point = evt.target;
    	}

    	function onMouseMove(evt) {
    		if (drag_point == null) return;
    		if (drag_point.id == 'fhat') pp.updateY(evt.offsetX, evt.offsetY); else pp.updateF(evt.offsetX, evt.offsetY);
    		update();
    	}

    	function onMouseUp(evt) {
    		drag_point = null;
    	}

    	const writable_props = ['sig', 'pp'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PhiSpace> was created with unknown prop '${key}'`);
    	});

    	function div0_elementresize_handler() {
    		phi_width = this.clientWidth;
    		phi_height = this.clientHeight;
    		$$invalidate(2, phi_width);
    		$$invalidate(3, phi_height);
    	}

    	$$self.$$set = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(1, sig = $$props.sig));
    		if ('pp' in $$props) $$invalidate(0, pp = $$props.pp);
    	};

    	$$self.$capture_state = () => ({
    		make_sync,
    		numberDisplay,
    		d3,
    		onMount,
    		sig,
    		pp,
    		update,
    		respond,
    		notify,
    		phi_width,
    		phi_height,
    		vis_width,
    		vis_height,
    		drag_point,
    		log_sigma,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp,
    		$sig
    	});

    	$$self.$inject_state = $$props => {
    		if ('sig' in $$props) $$subscribe_sig($$invalidate(1, sig = $$props.sig));
    		if ('pp' in $$props) $$invalidate(0, pp = $$props.pp);
    		if ('respond' in $$props) $$invalidate(11, respond = $$props.respond);
    		if ('notify' in $$props) $$invalidate(12, notify = $$props.notify);
    		if ('phi_width' in $$props) $$invalidate(2, phi_width = $$props.phi_width);
    		if ('phi_height' in $$props) $$invalidate(3, phi_height = $$props.phi_height);
    		if ('vis_width' in $$props) vis_width = $$props.vis_width;
    		if ('vis_height' in $$props) vis_height = $$props.vis_height;
    		if ('drag_point' in $$props) drag_point = $$props.drag_point;
    		if ('log_sigma' in $$props) log_sigma = $$props.log_sigma;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sig*/ 128) {
    			respond($sig);
    		}

    		if ($$self.$$.dirty & /*pp*/ 1) {
    			notify(pp);
    		}
    	};

    	return [
    		pp,
    		sig,
    		phi_width,
    		phi_height,
    		onMouseDown,
    		onMouseMove,
    		onMouseUp,
    		$sig,
    		div0_elementresize_handler
    	];
    }

    class PhiSpace extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$2, create_fragment$2, safe_not_equal, { sig: 1, pp: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PhiSpace",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sig*/ ctx[1] === undefined && !('sig' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'sig'");
    		}

    		if (/*pp*/ ctx[0] === undefined && !('pp' in props)) {
    			console.warn("<PhiSpace> was created without expected prop 'pp'");
    		}
    	}

    	get sig() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sig(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pp() {
    		throw new Error("<PhiSpace>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pp(value) {
    		throw new Error("<PhiSpace>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Figure2.svelte generated by Svelte v3.40.2 */
    const file$1 = "src/Figure2.svelte";

    function create_fragment$1(ctx) {
    	let div1;
    	let div0;
    	let curves;
    	let t;
    	let lowpanelcontrols;
    	let current;

    	curves = new Curves({
    			props: {
    				sig: /*sig*/ ctx[3],
    				box: /*box*/ ctx[0],
    				cfg: /*cfg*/ ctx[1],
    				plot: /*pp*/ ctx[2].plot
    			},
    			$$inline: true
    		});

    	lowpanelcontrols = new LowPanelControls({
    			props: {
    				sig: /*sig*/ ctx[3],
    				cfg: /*cfg*/ ctx[1],
    				plot: /*pp*/ ctx[2].plot
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(curves.$$.fragment);
    			t = space();
    			create_component(lowpanelcontrols.$$.fragment);
    			attr_dev(div0, "class", "col full svelte-59d2b5");
    			add_location(div0, file$1, 46, 2, 765);
    			attr_dev(div1, "class", "row full svelte-59d2b5");
    			add_location(div1, file$1, 45, 0, 740);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(curves, div0, null);
    			append_dev(div0, t);
    			mount_component(lowpanelcontrols, div0, null);
    			current = true;
    		},
    		p: noop$5,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(curves.$$.fragment, local);
    			transition_in(lowpanelcontrols.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(curves.$$.fragment, local);
    			transition_out(lowpanelcontrols.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(curves);
    			destroy_component(lowpanelcontrols);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Figure2', slots, []);
    	let box = { w: 10, h: 10 };

    	let cfg = {
    		show_data: true,
    		show_scaled: true,
    		show_solution: true,
    		show_points: false,
    		auto_solve: true,
    		log_sigma: 0
    	};

    	var max_alpha = 4;
    	let pp = new PhiSpace$1(max_alpha);
    	let sig = writable(0);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Figure2> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		writable,
    		Plot,
    		Context,
    		phi,
    		Curves,
    		PhiSpace,
    		LowPanelControls,
    		box,
    		cfg,
    		max_alpha,
    		pp,
    		sig
    	});

    	$$self.$inject_state = $$props => {
    		if ('box' in $$props) $$invalidate(0, box = $$props.box);
    		if ('cfg' in $$props) $$invalidate(1, cfg = $$props.cfg);
    		if ('max_alpha' in $$props) max_alpha = $$props.max_alpha;
    		if ('pp' in $$props) $$invalidate(2, pp = $$props.pp);
    		if ('sig' in $$props) $$invalidate(3, sig = $$props.sig);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [box, cfg, pp, sig];
    }

    class Figure2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Figure2",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.40.2 */
    const file = "src/App.svelte";

    function create_fragment(ctx) {
    	let main;
    	let d_front_matter;
    	let script;
    	let t1;
    	let d_title;
    	let h1;
    	let t3;
    	let d_byline;
    	let t4;
    	let d_article;
    	let figure;
    	let figure2;
    	let t5;
    	let kernelmethods;
    	let t6;
    	let d_appendix;
    	let current;
    	figure2 = new Figure2({ $$inline: true });
    	kernelmethods = new Kernel_methods({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			d_front_matter = element("d-front-matter");
    			script = element("script");
    			script.textContent = "{\n        \"title\": \"Introduction to Kernel Regression\",\n      \"description\": \"A gentle introduction to Kernel Regression\",\n      \"authors\": [\n      {\n          \"author\": \"Henry Bigelow\"\n      }\n      ]\n      }";
    			t1 = space();
    			d_title = element("d-title");
    			h1 = element("h1");
    			h1.textContent = "Introduction to Kernel Regression";
    			t3 = space();
    			d_byline = element("d-byline");
    			t4 = space();
    			d_article = element("d-article");
    			figure = element("figure");
    			create_component(figure2.$$.fragment);
    			t5 = space();
    			create_component(kernelmethods.$$.fragment);
    			t6 = space();
    			d_appendix = element("d-appendix");
    			attr_dev(script, "type", "text/json");
    			add_location(script, file, 16, 4, 374);
    			add_location(d_front_matter, file, 15, 4, 353);
    			add_location(h1, file, 30, 8, 695);
    			set_style(d_title, "padding-bottom", "0");
    			add_location(d_title, file, 29, 4, 651);
    			add_location(d_byline, file, 33, 4, 758);
    			attr_dev(figure, "class", "l-page-outset");
    			set_style(figure, "height", "500px");
    			add_location(figure, file, 46, 8, 1013);
    			add_location(d_article, file, 36, 4, 786);
    			add_location(d_appendix, file, 54, 4, 1157);
    			add_location(main, file, 13, 0, 341);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, d_front_matter);
    			append_dev(d_front_matter, script);
    			append_dev(main, t1);
    			append_dev(main, d_title);
    			append_dev(d_title, h1);
    			append_dev(main, t3);
    			append_dev(main, d_byline);
    			append_dev(main, t4);
    			append_dev(main, d_article);
    			append_dev(d_article, figure);
    			mount_component(figure2, figure, null);
    			append_dev(d_article, t5);
    			mount_component(kernelmethods, d_article, null);
    			append_dev(main, t6);
    			append_dev(main, d_appendix);
    			current = true;
    		},
    		p: noop$5,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(figure2.$$.fragment, local);
    			transition_in(kernelmethods.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(figure2.$$.fragment, local);
    			transition_out(kernelmethods.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(figure2);
    			destroy_component(kernelmethods);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		KernelMethods: Kernel_methods,
    		Figure1,
    		Figure2,
    		KernelHeatmap
    	});

    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$1(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
